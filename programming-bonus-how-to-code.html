<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonus: How To Code - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
            --accent: #ff6b6b;
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: var(--bg2); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(255,255,255,0.05); color: var(--text); transform: translateX(4px); }
        .sidebar-link.active { background: rgba(255,255,255,0.1); color: var(--text); font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; background: linear-gradient(135deg, #fff 0%, var(--accent) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.25rem; font-weight: 600; margin: 2rem 0 1rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.2); box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0.75rem; }
        .info-box { background: var(--bg3); border-left: 3px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; }
        .info-box p { color: var(--text2); }
        .warning-box { background: rgba(255,107,107,0.05); border: 1px solid var(--border); border-left: 3px solid var(--accent); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre; }
        .inline-code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; }
        .metaphor-box { background: rgba(255,255,255,0.03); border-left: 4px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; }
        .metaphor-box::before { content: "üí°"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg2); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, var(--accent) 0%, var(--text) 100%); transition: width 0.1s; z-index: 1001; }
        .bonus-badge { display: inline-block; background: linear-gradient(135deg, var(--accent), #ff8787); padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.75rem; font-weight: 700; margin-left: 0.5rem; text-transform: uppercase; letter-spacing: 1px; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">‚ñº</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="index.html">Home</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#philosophy" class="sidebar-link">The Universal Philosophy of Code</a>
            <a href="#syntax" class="sidebar-link">Syntax Patterns Across Languages</a>
            <a href="#paradigms" class="sidebar-link">Programming Paradigms</a>
            <a href="#data-structures" class="sidebar-link">Universal Data Structures</a>
            <a href="#algorithms" class="sidebar-link">Core Algorithms</a>
            <a href="#python-deep" class="sidebar-link">Python Deep Dive</a>
            <a href="#javascript-deep" class="sidebar-link">JavaScript Deep Dive</a>
            <a href="#c-cpp-deep" class="sidebar-link">C/C++ Deep Dive</a>
            <a href="#java-deep" class="sidebar-link">Java Deep Dive</a>
            <a href="#go-deep" class="sidebar-link">Go Deep Dive</a>
            <a href="#rust-deep" class="sidebar-link">Rust Deep Dive</a>
            <a href="#design-patterns" class="sidebar-link">Design Patterns</a>
            <a href="#debugging-mastery" class="sidebar-link">Debugging Mastery</a>
            <a href="#testing-quality" class="sidebar-link">Testing & Quality</a>
            <a href="#mastery-path" class="sidebar-link">Path to Mastery</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="programming-ch06.html" class="sidebar-link">Next: Chapter 06 ‚Üí</a>
            <a href="programming-ch05.html" class="sidebar-link">‚Üê Previous: Chapter 05</a>
            <a href="roadmap-programming.html" class="sidebar-link">Back to Roadmap</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="chapter-label">
                Bonus Chapter
                <span class="bonus-badge">SPECIAL</span>
            </div>
            <h1 class="page-title">How To Code</h1>
            <p class="page-subtitle">The ultimate guide to understanding programming from first principles. Learn the patterns that transcend languages, master the fundamentals that make you language-agnostic, and become a true polyglot programmer who can pick up any language in days.</p>
        </div>

        <section class="section" id="philosophy">
            <h2 class="section-title">The Universal Philosophy of Code</h2>
            <p class="section-intro">Before diving into syntax and languages, let's understand what code truly is at its essence. Code is the bridge between human intention and machine execution‚Äîa way to express logical thinking in a form that computers can understand. Every programming language, despite surface differences, shares fundamental concepts because they all solve the same core problem: how to tell a computer what to do.</p>

            <h3>What IS Code?</h3>
            <p>At the most fundamental level, code is a set of instructions. Just like a recipe tells you how to make a cake, or assembly instructions tell you how to build furniture, code tells a computer how to process information and perform tasks. But here's what makes code special:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üéØ Precise</h4>
                    <p>Computers are literal machines. They do exactly what you tell them, nothing more, nothing less. There's no room for ambiguity.</p>
                </div>
                <div class="card">
                    <h4>üîÑ Reusable</h4>
                    <p>Write once, run millions of times. Code can be executed repeatedly without degradation, making it incredibly powerful.</p>
                </div>
                <div class="card">
                    <h4>üß© Composable</h4>
                    <p>Small pieces of code combine to create complex systems. Functions call functions, modules import modules, building up from simple to sophisticated.</p>
                </div>
            </div>

            <div class="metaphor-box">
                <h4>The Recipe Metaphor</h4>
                <p>Think of code like a recipe. A recipe has ingredients (variables/data), instructions (code statements), and produces a result (output). Just as you can write the same recipe in English or Spanish, you can write the same program in Python or JavaScript. The language changes, but the underlying logic‚Äîwhat you're trying to accomplish‚Äîremains the same.</p>
            </div>

            <h3>The Programmer's Mindset</h3>
            <p>Learning to code isn't just about memorizing syntax‚Äîit's about developing a new way of thinking. Programmers approach problems differently:</p>

            <ul>
                <li><strong>Decomposition:</strong> Breaking large problems into smaller, manageable pieces. Instead of "build a website," think "create a header, then navigation, then content sections..."</li>
                <li><strong>Pattern Recognition:</strong> Identifying similar problems you've solved before and adapting those solutions. "This is like that login form I built, but with validation."</li>
                <li><strong>Abstraction:</strong> Focusing on essential details while hiding complexity. You don't need to understand how <span class="inline-code">print()</span> works internally to use it.</li>
                <li><strong>Algorithm Design:</strong> Creating step-by-step procedures to solve problems efficiently. "To find the cheapest item: start with the first price, compare each subsequent price, keep track of the lowest."</li>
                <li><strong>Debugging Mindset:</strong> When code doesn't work (and it won't, at first), systematic investigation to find the source of the problem. Like being a detective.</li>
            </ul>

            <div class="info-box">
                <h4>üí° The Most Important Skill</h4>
                <p>The single most valuable programming skill isn't knowing every syntax rule‚Äîit's the ability to break down problems logically. Once you can describe a solution in plain English (or your native language) step-by-step, translating it to code becomes mechanical. Master the thinking, and the coding follows.</p>
            </div>

            <h3>How Computers Think vs. How Humans Think</h3>
            <p>Understanding the gap between human and computer cognition is crucial for effective programming:</p>

            <table>
                <thead>
                    <tr>
                        <th>Human Thinking</th>
                        <th>Computer Processing</th>
                        <th>Implication for Code</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Contextual - we understand implied meaning</td>
                        <td>Literal - only understands exact instructions</td>
                        <td>You must be explicit about every step</td>
                    </tr>
                    <tr>
                        <td>Intuitive - we make assumptions based on experience</td>
                        <td>Deterministic - same input always gives same output</td>
                        <td>Computers never "figure it out" - you must program all scenarios</td>
                    </tr>
                    <tr>
                        <td>Flexible - we adapt to ambiguity</td>
                        <td>Rule-based - follows syntax rules strictly</td>
                        <td>Missing a semicolon breaks the entire program (in some languages)</td>
                    </tr>
                    <tr>
                        <td>Emotional - we have preferences and feelings</td>
                        <td>Logical - pure calculation, no emotions</td>
                        <td>Code doesn't care about your intent, only your actual instructions</td>
                    </tr>
                    <tr>
                        <td>Parallel - we process multiple things subconsciously</td>
                        <td>Sequential* - executes instructions one by one</td>
                        <td>Order matters tremendously in code (*unless using concurrency)</td>
                    </tr>
                </tbody>
            </table>

            <div class="metaphor-box">
                <h4>The Robot Assistant Metaphor</h4>
                <p>Imagine you hire a super-fast, super-accurate robot assistant, but this robot has zero common sense. You ask it to "make coffee," and it stands there confused. You must tell it: 1) Walk to the kitchen, 2) Pick up the kettle, 3) Fill it with water, 4) Turn on the stove, 5) Wait for water to boil... Every. Single. Step. That's programming. The robot (computer) is incredibly powerful once instructed properly, but it needs complete, precise instructions.</p>
            </div>

            <h3>The Abstraction Ladder: From Silicon to High-Level Code</h3>
            <p>Computers don't actually understand Python or JavaScript‚Äîthey only understand electricity flowing through circuits (represented as 1s and 0s). Every programming language is an abstraction built on top of lower-level abstractions. Let's climb the ladder:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>Level 0: Hardware</h4>
                    <p><strong>What it is:</strong> Physical circuits, transistors, electricity</p>
                    <p><strong>Example:</strong> Voltage high = 1, voltage low = 0</p>
                    <p><strong>Human-readable?</strong> Not at all. Pure physics.</p>
                </div>
                <div class="card">
                    <h4>Level 1: Machine Code</h4>
                    <p><strong>What it is:</strong> Binary instructions the CPU executes directly</p>
                    <div class="code">01010101 01001000 10001001 11100101</div>
                    <p><strong>Human-readable?</strong> Barely. Programmers rarely write this directly.</p>
                </div>
                <div class="card">
                    <h4>Level 2: Assembly Language</h4>
                    <p><strong>What it is:</strong> Human-readable names for machine instructions</p>
                    <div class="code">MOV AX, 5
ADD AX, 3
RET</div>
                    <p><strong>Human-readable?</strong> Better, but still very low-level and CPU-specific.</p>
                </div>
                <div class="card">
                    <h4>Level 3: Low-Level Languages (C, C++)</h4>
                    <p><strong>What it is:</strong> More abstract, but still close to hardware. Direct memory control.</p>
                    <div class="code">int x = 5;
int y = 3;
int result = x + y;</div>
                    <p><strong>Human-readable?</strong> Yes! Getting much more readable and portable.</p>
                </div>
                <div class="card">
                    <h4>Level 4: High-Level Languages (Python, JavaScript)</h4>
                    <p><strong>What it is:</strong> Very abstract, handles memory automatically, focuses on logic</p>
                    <div class="code">x = 5
y = 3
result = x + y</div>
                    <p><strong>Human-readable?</strong> Extremely! Almost like natural language.</p>
                </div>
                <div class="card">
                    <h4>Level 5: Domain-Specific Languages (SQL, HTML)</h4>
                    <p><strong>What it is:</strong> Designed for specific tasks, not general programming</p>
                    <div class="code">SELECT name FROM users
WHERE age > 21;</div>
                    <p><strong>Human-readable?</strong> Very, for people in that domain.</p>
                </div>
            </div>

            <div class="info-box">
                <h4>üîç What Actually Happens</h4>
                <p>When you write Python code, here's the journey: You write <span class="inline-code">x = 5</span> ‚Üí Python interpreter translates it to bytecode ‚Üí Bytecode gets translated to machine code ‚Üí Machine code becomes electrical signals in the CPU ‚Üí The CPU executes them. All of this happens in milliseconds. Higher-level languages trade some performance (more translation steps) for massive gains in productivity (easier to write and read).</p>
            </div>

            <h3>Universal Concepts: The Core Four</h3>
            <p>Despite hundreds of programming languages, almost all of them share four fundamental concepts. Master these concepts, and picking up new languages becomes dramatically easier:</p>

            <h4>1. Variables: Storing Information</h4>
            <p>Every program needs to remember things. Variables are named storage locations for data. Think of them as labeled boxes where you put information.</p>

            <div class="code">// JavaScript
let playerName = "Alice";
let score = 100;
let isAlive = true;

# Python
player_name = "Alice"
score = 100
is_alive = True

// C
char* player_name = "Alice";
int score = 100;
bool is_alive = true;</div>

            <p>The concept is identical across languages: create a named container, put data in it, retrieve or modify that data later. Syntax differs, but the idea is universal.</p>

            <h4>2. Control Flow: Making Decisions and Repeating Actions</h4>
            <p>Programs need to make decisions (<span class="inline-code">if</span> this, then do that) and repeat actions (<span class="inline-code">do this 10 times</span>). This is control flow.</p>

            <div class="code">// Decision making (if/else) - JavaScript
if (score > 100) {
    console.log("High score!");
} else {
    console.log("Keep trying!");
}

# Repeating actions (loops) - Python
for i in range(5):
    print(f"Iteration {i}")

// C version
for (int i = 0; i < 5; i++) {
    printf("Iteration %d\n", i);
}</div>

            <p>Again, the concept is universal: evaluate conditions, branch execution, repeat code blocks. Every language has these mechanisms, just with different syntax.</p>

            <h4>3. Functions: Reusable Logic</h4>
            <p>Functions are named blocks of code that perform specific tasks. Write once, use many times. They're like recipes‚Äîgive them ingredients (inputs/parameters), they follow steps (code inside the function), and produce a result (return value).</p>

            <div class="code">// JavaScript
function calculateArea(width, height) {
    return width * height;
}

let area = calculateArea(5, 3);  // returns 15

# Python
def calculate_area(width, height):
    return width * height

area = calculate_area(5, 3)  # returns 15

// Java
public int calculateArea(int width, int height) {
    return width * height;
}

int area = calculateArea(5, 3);  // returns 15</div>

            <p>The pattern repeats: define function with parameters, write logic inside, return result, call the function with arguments. Universal across nearly all languages.</p>

            <h4>4. Data Structures: Organizing Information</h4>
            <p>Beyond simple variables, programs need to organize collections of data. Arrays/lists store multiple items in order. Objects/dictionaries store key-value pairs. These structures exist in every language.</p>

            <div class="code">// JavaScript - Array and Object
let scores = [95, 87, 92, 88];
let player = {
    name: "Alice",
    level: 5,
    inventory: ["sword", "shield"]
};

# Python - List and Dictionary
scores = [95, 87, 92, 88]
player = {
    "name": "Alice",
    "level": 5,
    "inventory": ["sword", "shield"]
}

// Java - Array and HashMap
int[] scores = {95, 87, 92, 88};
HashMap<String, Object> player = new HashMap<>();
player.put("name", "Alice");
player.put("level", 5);</div>

            <p>Data structures look different syntactically, but conceptually they're the same: ways to organize and access collections of related data efficiently.</p>

            <div class="warning-box">
                <h4>‚ö†Ô∏è The Syntax Trap</h4>
                <p>Beginners often get intimidated by syntax differences between languages. "Python uses colons and indentation, JavaScript uses curly braces, C requires semicolons..." These are superficial differences. It's like the difference between British English and American English‚Äîsame language, different spelling conventions. Focus on the underlying concepts (variables, loops, functions, data structures), and syntax becomes a minor detail you can look up.</p>
            </div>

            <h3>Why Languages Differ: Design Philosophy</h3>
            <p>If core concepts are universal, why do we have so many languages? Because different problems require different tools, and language designers make different trade-offs:</p>

            <ul>
                <li><strong>Performance vs. Ease of Use:</strong> C gives you raw speed but requires manual memory management. Python handles memory automatically but runs slower. It's a deliberate trade-off.</li>
                <li><strong>Static vs. Dynamic Typing:</strong> Java forces you to declare types (<span class="inline-code">int x = 5;</span>) catching errors early. Python lets you skip types (<span class="inline-code">x = 5</span>) for faster prototyping. Different philosophies.</li>
                <li><strong>General Purpose vs. Specialized:</strong> JavaScript was designed for web browsers. SQL was designed for databases. Python aims to be good at everything. Purpose shapes design.</li>
                <li><strong>Paradigm Focus:</strong> Haskell pushes functional programming. Java pushes object-oriented. Many modern languages (Python, JavaScript, Rust) are multi-paradigm, supporting multiple styles.</li>
            </ul>

            <div class="info-box">
                <h4>üéì The Polyglot Advantage</h4>
                <p>Once you deeply understand one language, learning others becomes exponentially easier. Your second language might take 50% less time to learn than your first. Your third, 75% less. Why? Because you're not relearning concepts‚Äîyou're just learning new syntax for concepts you already understand. Most professional programmers know 3-5 languages comfortably and can pick up new ones in weeks, not years.</p>
            </div>

            <h3>The Journey Ahead</h3>
            <p>This chapter will take you through programming from absolute foundations to advanced mastery. We'll explore:</p>

            <ul>
                <li>Syntax patterns across major languages‚Äîseeing the same concepts expressed differently</li>
                <li>Programming paradigms‚Äîdifferent approaches to structuring code</li>
                <li>Universal data structures and algorithms‚Äîthe building blocks of all software</li>
                <li>Deep dives into specific languages (Python, JavaScript, C/C++, Java, Go, Rust)‚Äîunderstanding what makes each unique</li>
                <li>Design patterns‚Äîproven solutions to common problems</li>
                <li>Debugging and testing‚Äîhow to write code that actually works</li>
                <li>The path to mastery‚Äîhow to continue learning and growing as a programmer</li>
            </ul>

            <div class="metaphor-box">
                <h4>Learning to Program is Like Learning to Drive</h4>
                <p>At first, everything is overwhelming‚Äîmirrors, pedals, steering, signals, other cars. But after practice, these become automatic. You don't think "press brake with 40% pressure"‚Äîyou just slow down naturally. Programming is the same. The syntax that seems foreign now will become second nature. The concepts that feel abstract will become intuitive. You'll start thinking in code. It just takes time and practice. Thousands of hours of practice shaped you into a natural walker, talker, and reader. Give programming that same patience, and you'll be amazed at what you can build.</p>
            </div>

            <p>Remember: every expert programmer was once exactly where you are now‚Äîconfused, frustrated, questioning if they could do this. They could. And so can you. Let's begin.</p>
        </section>

        <section class="section" id="syntax">
            <h2 class="section-title">Syntax Patterns Across Languages</h2>
            <p class="section-intro">Once you understand the universal concepts, the next step is seeing how different languages express those same ideas. Syntax is just the surface‚Äîthe grammar and punctuation rules of a programming language. While it looks different, the underlying logic remains the same. This section compares syntax across major languages so you can see the patterns and understand that learning a new language is mostly learning new notation for concepts you already know.</p>

            <h3>Variables: The Foundation of Data Storage</h3>
            <p>Every program needs to store information. Variables are named containers that hold data. Let's see how different languages declare and use variables:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>Python</h4>
                    <div class="code">x = 5
name = "Alice"
is_active = True
price = 19.99</div>
                    <p><strong>Philosophy:</strong> Dynamic typing, no type declaration needed. Variable type is inferred from the value assigned.</p>
                </div>
                <div class="card">
                    <h4>JavaScript</h4>
                    <div class="code">let x = 5;
const name = "Alice";
var isActive = true;
let price = 19.99;</div>
                    <p><strong>Philosophy:</strong> Dynamic typing. Use <span class="inline-code">let</span> for mutable, <span class="inline-code">const</span> for immutable values. <span class="inline-code">var</span> is legacy.</p>
                </div>
                <div class="card">
                    <h4>C</h4>
                    <div class="code">int x = 5;
char name[] = "Alice";
int is_active = 1;
float price = 19.99;</div>
                    <p><strong>Philosophy:</strong> Static typing. Must declare type explicitly. More verbose but catches type errors at compile time.</p>
                </div>
                <div class="card">
                    <h4>Java</h4>
                    <div class="code">int x = 5;
String name = "Alice";
boolean isActive = true;
double price = 19.99;</div>
                    <p><strong>Philosophy:</strong> Strongly typed, object-oriented. Everything (except primitives) is an object. Type safety is paramount.</p>
                </div>
                <div class="card">
                    <h4>Go</h4>
                    <div class="code">x := 5
name := "Alice"
isActive := true
price := 19.99</div>
                    <p><strong>Philosophy:</strong> Static typing with type inference. The <span class="inline-code">:=</span> operator declares and infers type. Clean and concise.</p>
                </div>
                <div class="card">
                    <h4>Rust</h4>
                    <div class="code">let x = 5;
let name = "Alice";
let is_active = true;
let price = 19.99;</div>
                    <p><strong>Philosophy:</strong> Static typing with inference. Immutable by default‚Äîuse <span class="inline-code">let mut</span> for mutable variables. Safety-focused.</p>
                </div>
            </div>

            <div class="info-box">
                <h4>üîç Static vs. Dynamic Typing</h4>
                <p><strong>Static (C, Java, Go, Rust):</strong> Variable types are checked at compile time. You declare types explicitly or the compiler infers them, but they're locked in. Catches type errors early.<br><br>
                <strong>Dynamic (Python, JavaScript):</strong> Variable types are checked at runtime. A variable can hold any type and change types. More flexible but can hide bugs until execution.</p>
            </div>

            <h3>Comprehensive Variable Declaration Comparison</h3>
            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Declaration</th>
                        <th>Type Declaration</th>
                        <th>Mutability</th>
                        <th>Semicolon</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td><span class="inline-code">x = 5</span></td>
                        <td>Implicit (inferred)</td>
                        <td>Always mutable</td>
                        <td>None</td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td><span class="inline-code">let x = 5;</span></td>
                        <td>Implicit (inferred)</td>
                        <td><span class="inline-code">let</span> mutable, <span class="inline-code">const</span> immutable</td>
                        <td>Optional but recommended</td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td><span class="inline-code">int x = 5;</span></td>
                        <td>Explicit required</td>
                        <td>Mutable (use <span class="inline-code">const</span> for immutable)</td>
                        <td>Required</td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td><span class="inline-code">int x = 5;</span></td>
                        <td>Explicit required</td>
                        <td>Mutable (use <span class="inline-code">final</span> for immutable)</td>
                        <td>Required</td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td><span class="inline-code">x := 5</span></td>
                        <td>Implicit with <span class="inline-code">:=</span></td>
                        <td>Always mutable</td>
                        <td>None</td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td><span class="inline-code">let x = 5;</span></td>
                        <td>Implicit (inferred)</td>
                        <td>Immutable by default, use <span class="inline-code">let mut</span></td>
                        <td>Required</td>
                    </tr>
                </tbody>
            </table>

            <h3>Data Types: Organizing Different Kinds of Information</h3>
            <p>All languages have similar fundamental data types: numbers, text, true/false values, and "nothing." The names and specifics vary:</p>

            <h4>Numbers</h4>
            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Integers</th>
                        <th>Floating Point</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td><span class="inline-code">int</span> (unlimited size)</td>
                        <td><span class="inline-code">float</span></td>
                        <td><span class="inline-code">x = 42</span>, <span class="inline-code">pi = 3.14</span></td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td>No distinction‚Äîall <span class="inline-code">number</span></td>
                        <td><span class="inline-code">number</span></td>
                        <td><span class="inline-code">let x = 42;</span>, <span class="inline-code">let pi = 3.14;</span></td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td><span class="inline-code">int</span>, <span class="inline-code">long</span>, <span class="inline-code">short</span></td>
                        <td><span class="inline-code">float</span>, <span class="inline-code">double</span></td>
                        <td><span class="inline-code">int x = 42;</span>, <span class="inline-code">double pi = 3.14;</span></td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td><span class="inline-code">int</span>, <span class="inline-code">long</span>, <span class="inline-code">byte</span>, <span class="inline-code">short</span></td>
                        <td><span class="inline-code">float</span>, <span class="inline-code">double</span></td>
                        <td><span class="inline-code">int x = 42;</span>, <span class="inline-code">double pi = 3.14;</span></td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td><span class="inline-code">int</span>, <span class="inline-code">int64</span>, <span class="inline-code">int32</span></td>
                        <td><span class="inline-code">float32</span>, <span class="inline-code">float64</span></td>
                        <td><span class="inline-code">x := 42</span>, <span class="inline-code">pi := 3.14</span></td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td><span class="inline-code">i32</span>, <span class="inline-code">i64</span>, <span class="inline-code">u32</span> (unsigned)</td>
                        <td><span class="inline-code">f32</span>, <span class="inline-code">f64</span></td>
                        <td><span class="inline-code">let x: i32 = 42;</span>, <span class="inline-code">let pi: f64 = 3.14;</span></td>
                    </tr>
                </tbody>
            </table>

            <h4>Strings (Text)</h4>
            <div class="code">// Python
name = "Alice"
message = 'Hello, World!'
multiline = """This is
a multiline
string"""

// JavaScript
const name = "Alice";
const message = 'Hello, World!';
const multiline = `This is
a multiline
string`;

// C
char name[] = "Alice";
char* message = "Hello, World!";

// Java
String name = "Alice";
String message = "Hello, World!";

// Go
name := "Alice"
message := `This is
a multiline
string`

// Rust
let name = "Alice";
let message = String::from("Hello, World!");</div>

            <p>Strings are sequences of characters. Most languages support both single and double quotes. Python and JavaScript have special syntax for multiline strings (<span class="inline-code">"""</span> and backticks respectively). C has no built-in string type‚Äîit uses character arrays. Rust distinguishes between string literals (<span class="inline-code">&str</span>) and owned strings (<span class="inline-code">String</span>).</p>

            <h4>Booleans and "Nothing"</h4>
            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>True</th>
                        <th>False</th>
                        <th>"Nothing" Value</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td><span class="inline-code">True</span></td>
                        <td><span class="inline-code">False</span></td>
                        <td><span class="inline-code">None</span></td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td><span class="inline-code">true</span></td>
                        <td><span class="inline-code">false</span></td>
                        <td><span class="inline-code">null</span> and <span class="inline-code">undefined</span></td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td><span class="inline-code">1</span> (or any non-zero)</td>
                        <td><span class="inline-code">0</span></td>
                        <td><span class="inline-code">NULL</span> (pointer)</td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td><span class="inline-code">true</span></td>
                        <td><span class="inline-code">false</span></td>
                        <td><span class="inline-code">null</span></td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td><span class="inline-code">true</span></td>
                        <td><span class="inline-code">false</span></td>
                        <td><span class="inline-code">nil</span></td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td><span class="inline-code">true</span></td>
                        <td><span class="inline-code">false</span></td>
                        <td><span class="inline-code">None</span> (in Option type)</td>
                    </tr>
                </tbody>
            </table>

            <div class="metaphor-box">
                <h4>Why So Many Number Types?</h4>
                <p>Think of number types like containers: a shot glass, a cup, a bucket, a swimming pool. You wouldn't use a swimming pool to hold a shot of espresso‚Äîwaste of space. Similarly, if you only need numbers 0-255, use a byte (1 byte) instead of an int (4 bytes). For most high-level work (Python, JavaScript), the language handles this automatically. For systems programming (C, Rust), you choose the right-sized container for efficiency.</p>
            </div>

            <h3>Control Flow: Making Decisions</h3>
            <p>Programs need to make decisions based on conditions. The <span class="inline-code">if</span>/<span class="inline-code">else</span> structure exists in every language:</p>

            <h4>If/Else Comparison</h4>
            <div class="card-grid">
                <div class="card">
                    <h4>Python</h4>
                    <div class="code">if score > 90:
    print("A grade")
elif score > 80:
    print("B grade")
else:
    print("C grade")</div>
                    <p>Uses colons and indentation. No parentheses around conditions. <span class="inline-code">elif</span> for "else if".</p>
                </div>
                <div class="card">
                    <h4>JavaScript</h4>
                    <div class="code">if (score > 90) {
    console.log("A grade");
} else if (score > 80) {
    console.log("B grade");
} else {
    console.log("C grade");
}</div>
                    <p>Parentheses around conditions, curly braces for blocks. <span class="inline-code">else if</span> spelled out.</p>
                </div>
                <div class="card">
                    <h4>C / Java</h4>
                    <div class="code">if (score > 90) {
    printf("A grade");
} else if (score > 80) {
    printf("B grade");
} else {
    printf("C grade");
}</div>
                    <p>Identical to JavaScript syntax. Semicolons after statements required.</p>
                </div>
                <div class="card">
                    <h4>Go</h4>
                    <div class="code">if score > 90 {
    fmt.Println("A grade")
} else if score > 80 {
    fmt.Println("B grade")
} else {
    fmt.Println("C grade")
}</div>
                    <p>No parentheses around conditions (optional), curly braces required.</p>
                </div>
                <div class="card">
                    <h4>Rust</h4>
                    <div class="code">if score > 90 {
    println!("A grade");
} else if score > 80 {
    println!("B grade");
} else {
    println!("C grade");
}</div>
                    <p>Similar to Go. Note: <span class="inline-code">if</span> is an expression in Rust, can return values.</p>
                </div>
            </div>

            <div class="info-box">
                <h4>üéØ The Pattern</h4>
                <p>Notice the pattern: <strong>if (condition) { code } else { code }</strong>. Python replaces braces with indentation and uses colons. Go/Rust drop parentheses. But the logic is identical: test a condition, execute one block if true, another if false. Same concept, different notation.</p>
            </div>

            <h3>Loops: Repeating Actions</h3>
            <p>Loops execute code multiple times. There are generally two types: "do this N times" (for loops) and "do this while condition is true" (while loops).</p>

            <h4>While Loops</h4>
            <div class="code">// Python
count = 0
while count < 5:
    print(count)
    count += 1

// JavaScript
let count = 0;
while (count < 5) {
    console.log(count);
    count++;
}

// C / Java
int count = 0;
while (count < 5) {
    printf("%d\n", count);
    count++;
}

// Go
count := 0
for count < 5 {
    fmt.Println(count)
    count++
}

// Rust
let mut count = 0;
while count < 5 {
    println!("{}", count);
    count += 1;
}</div>

            <p>Note: Go doesn't have a <span class="inline-code">while</span> keyword‚Äîit uses <span class="inline-code">for</span> with a condition. Same concept, different keyword.</p>

            <h4>For Loops</h4>
            <div class="code">// Python - range-based
for i in range(5):
    print(i)

// Python - iterate over list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

// JavaScript - C-style
for (let i = 0; i < 5; i++) {
    console.log(i);
}

// JavaScript - array iteration
const fruits = ["apple", "banana", "cherry"];
for (const fruit of fruits) {
    console.log(fruit);
}

// C - classic for loop
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
}

// Java - similar to C
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}

// Java - enhanced for loop
String[] fruits = {"apple", "banana", "cherry"};
for (String fruit : fruits) {
    System.out.println(fruit);
}

// Go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}

fruits := []string{"apple", "banana", "cherry"}
for _, fruit := range fruits {
    fmt.Println(fruit)
}

// Rust
for i in 0..5 {
    println!("{}", i);
}

let fruits = vec!["apple", "banana", "cherry"];
for fruit in &fruits {
    println!("{}", fruit);
}</div>

            <div class="info-box">
                <h4>üîÑ Loop Patterns</h4>
                <p><strong>Counted loops:</strong> Do something N times. C-style: <span class="inline-code">for (init; condition; increment)</span>. Python/Rust: <span class="inline-code">for i in range(N)</span>.<br><br>
                <strong>Collection iteration:</strong> Do something for each item in a collection. Python: <span class="inline-code">for item in collection</span>. JavaScript: <span class="inline-code">for (item of collection)</span>. Java: <span class="inline-code">for (Type item : collection)</span>. Syntax differs, concept identical.</p>
            </div>

            <h3>Functions: Defining Reusable Logic</h3>
            <p>Functions are named blocks of code that can be called with inputs (parameters) and return outputs (return values). Let's compare function syntax:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>Python</h4>
                    <div class="code">def add(a, b):
    return a + b

result = add(5, 3)  # 8</div>
                    <p><span class="inline-code">def</span> keyword, colon, indented body. No type annotations required (but supported).</p>
                </div>
                <div class="card">
                    <h4>JavaScript</h4>
                    <div class="code">function add(a, b) {
    return a + b;
}

// Arrow function
const add = (a, b) => a + b;

let result = add(5, 3);  // 8</div>
                    <p><span class="inline-code">function</span> keyword or arrow syntax. Multiple ways to define functions.</p>
                </div>
                <div class="card">
                    <h4>C</h4>
                    <div class="code">int add(int a, int b) {
    return a + b;
}

int result = add(5, 3);  // 8</div>
                    <p>Return type first, then name, typed parameters. Everything must be declared.</p>
                </div>
                <div class="card">
                    <h4>Java</h4>
                    <div class="code">public int add(int a, int b) {
    return a + b;
}

int result = add(5, 3);  // 8</div>
                    <p>Access modifier (public), return type, name, typed parameters. Very explicit.</p>
                </div>
                <div class="card">
                    <h4>Go</h4>
                    <div class="code">func add(a int, b int) int {
    return a + b
}

result := add(5, 3)  // 8</div>
                    <p><span class="inline-code">func</span> keyword, parameters with types after names, return type at end.</p>
                </div>
                <div class="card">
                    <h4>Rust</h4>
                    <div class="code">fn add(a: i32, b: i32) -> i32 {
    a + b  // implicit return
}

let result = add(5, 3);  // 8</div>
                    <p><span class="inline-code">fn</span> keyword, typed parameters, arrow <span class="inline-code">-></span> for return type. Last expression is returned.</p>
                </div>
            </div>

            <h4>Function Syntax Comparison Table</h4>
            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Keyword</th>
                        <th>Parameter Types</th>
                        <th>Return Type</th>
                        <th>Return Statement</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td><span class="inline-code">def</span></td>
                        <td>Optional type hints</td>
                        <td>Optional type hint</td>
                        <td><span class="inline-code">return</span> required</td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td><span class="inline-code">function</span> or arrow</td>
                        <td>No types</td>
                        <td>No declaration</td>
                        <td><span class="inline-code">return</span> required (or implicit in arrows)</td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td>Return type first</td>
                        <td>Required</td>
                        <td>Required (or <span class="inline-code">void</span>)</td>
                        <td><span class="inline-code">return</span> required</td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td>Return type + modifiers</td>
                        <td>Required</td>
                        <td>Required (or <span class="inline-code">void</span>)</td>
                        <td><span class="inline-code">return</span> required</td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td><span class="inline-code">func</span></td>
                        <td>Required (after name)</td>
                        <td>After parameters</td>
                        <td><span class="inline-code">return</span> required</td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td><span class="inline-code">fn</span></td>
                        <td>Required</td>
                        <td><span class="inline-code">-></span> syntax</td>
                        <td><span class="inline-code">return</span> or implicit last expression</td>
                    </tr>
                </tbody>
            </table>

            <div class="metaphor-box">
                <h4>Functions Are Like Vending Machines</h4>
                <p>You put in coins (arguments/parameters), press a button (call the function), internal mechanisms process your request (function body executes), and out comes your snack (return value). The vending machine can be called with different coins (different arguments) to get different results. You don't need to understand the internal mechanics‚Äîyou just use the interface. That's abstraction in action.</p>
            </div>

            <h3>Comments: Explaining Your Code</h3>
            <p>Comments are notes for humans that the computer ignores. Essential for explaining complex logic:</p>

            <div class="code">// Python
# This is a single-line comment
x = 5  # Inline comment

"""
This is a multi-line comment
(actually a multi-line string, but used as comment)
"""

// JavaScript
// Single-line comment
let x = 5;  // Inline comment

/*
Multi-line comment
Can span multiple lines
*/

// C / Java / Go / Rust
// Single-line comment
int x = 5;  // Inline comment

/*
Multi-line comment
Works in C, Java, Go, Rust
*/</div>

            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Single-Line</th>
                        <th>Multi-Line</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td><span class="inline-code">#</span></td>
                        <td><span class="inline-code">"""..."""</span> or <span class="inline-code">'''...'''</span></td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td><span class="inline-code">//</span></td>
                        <td><span class="inline-code">/* ... */</span></td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td><span class="inline-code">//</span></td>
                        <td><span class="inline-code">/* ... */</span></td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td><span class="inline-code">//</span></td>
                        <td><span class="inline-code">/* ... */</span> and <span class="inline-code">/** ... */</span> (JavaDoc)</td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td><span class="inline-code">//</span></td>
                        <td><span class="inline-code">/* ... */</span></td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td><span class="inline-code">//</span></td>
                        <td><span class="inline-code">/* ... */</span> and <span class="inline-code">/// ...</span> (doc comments)</td>
                    </tr>
                </tbody>
            </table>

            <h3>Statements vs. Expressions</h3>
            <p>A subtle but important distinction: statements do something (commands), expressions evaluate to a value.</p>

            <div class="info-box">
                <h4>üìù Statement vs Expression</h4>
                <p><strong>Statement:</strong> An instruction that performs an action but doesn't produce a value. Example: <span class="inline-code">x = 5</span> (assignment), <span class="inline-code">if (...) {...}</span> (control flow in most languages).<br><br>
                <strong>Expression:</strong> A piece of code that evaluates to a value. Example: <span class="inline-code">2 + 3</span> evaluates to 5, <span class="inline-code">x > 10</span> evaluates to true/false.<br><br>
                Some languages (like Rust) treat more things as expressions. In Rust, <span class="inline-code">if</span> is an expression that returns a value.</p>
            </div>

            <div class="code">// Rust - if as expression
let number = if x > 10 { "big" } else { "small" };

// JavaScript - ternary operator (expression)
const number = x > 10 ? "big" : "small";

// Python - conditional expression
number = "big" if x > 10 else "small"</div>

            <h3>Syntax Punctuation: Semicolons, Braces, Indentation</h3>
            <p>Different languages use different punctuation to delimit statements and blocks:</p>

            <h4>Semicolons</h4>
            <ul>
                <li><strong>Required (C, Java):</strong> Every statement must end with a semicolon. Missing one causes compilation errors.</li>
                <li><strong>Optional but recommended (JavaScript):</strong> Automatic Semicolon Insertion (ASI) adds them automatically, but can cause subtle bugs. Best practice: use them.</li>
                <li><strong>Never used (Python, Go):</strong> Statements end at the line break. No semicolons except when putting multiple statements on one line (rare).</li>
                <li><strong>Depends (Rust):</strong> Expressions don't need semicolons, statements do. Omitting a semicolon changes meaning (implicit return).</li>
            </ul>

            <h4>Block Delimiters</h4>
            <ul>
                <li><strong>Curly Braces <span class="inline-code">{}</span> (JavaScript, C, Java, Go, Rust):</strong> Define code blocks for functions, loops, conditionals.</li>
                <li><strong>Indentation (Python):</strong> Significant whitespace. Code blocks are defined by indentation level, not braces. Forces readable code.</li>
                <li><strong>Keywords (Ruby):</strong> Uses <span class="inline-code">end</span> keyword to close blocks (not covered deeply here).</li>
            </ul>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Don't Worry About Memorizing</h4>
                <p>You don't need to memorize every syntax rule for every language. Keep a reference handy, and with practice, muscle memory takes over. After a few weeks in a language, you'll instinctively know whether to use semicolons or not, braces or indentation. The key is understanding the <em>concepts</em>‚Äîthe syntax is just typing practice.</p>
            </div>

            <h3>The Big Picture: Syntax Is Just Surface</h3>
            <p>Here's the most important takeaway from this section: <strong>syntax differences are superficial</strong>. Once you know one language well, learning another is mostly about:</p>

            <ul>
                <li>Where to put parentheses and braces</li>
                <li>Whether types are explicit or inferred</li>
                <li>Which keywords the language uses (<span class="inline-code">def</span> vs <span class="inline-code">function</span> vs <span class="inline-code">fn</span>)</li>
                <li>How to run and install packages</li>
            </ul>

            <p>The hard parts‚Äîunderstanding variables, loops, functions, recursion, algorithms, design patterns‚Äîtransfer completely across languages. That's why experienced programmers can switch languages in days or weeks, not months or years.</p>

            <div class="metaphor-box">
                <h4>Languages Are Like Cars</h4>
                <p>If you learn to drive in a Toyota, switching to a Honda takes an hour or two to adjust to the layout. The fundamentals‚Äîsteering, braking, accelerating, parking‚Äîare identical. The pedals are in the same positions. The turn signal might be on the opposite side, but you adapt quickly. Programming languages are similar: different dashboards, same underlying mechanics. Learn one deeply, and the rest come much easier.</p>
            </div>

            <p>In the next section, we'll explore programming paradigms‚Äîdifferent philosophies for structuring and organizing code. These paradigms transcend syntax and represent truly different approaches to solving problems.</p>
        </section>

        <section class="section" id="paradigms">
            <h2 class="section-title">Programming Paradigms</h2>
            <p class="section-intro">If syntax is the grammar of programming languages, paradigms are the different styles of writing. A paradigm is a fundamental approach to structuring and organizing code. Just as you can write in different literary styles (poetry, prose, stream-of-consciousness), you can program in different paradigms. Most modern languages support multiple paradigms, making them multi-paradigm languages. Understanding these paradigms helps you choose the right tool for the job and appreciate why different languages exist.</p>

            <h3>What Is a Programming Paradigm?</h3>
            <p>A paradigm is a set of concepts, patterns, and practices that shape how you think about and solve problems in code. It answers questions like:</p>

            <ul>
                <li>How should I organize my code?</li>
                <li>How do I represent data and the operations on that data?</li>
                <li>How do I manage state (changing values over time)?</li>
                <li>What level of abstraction should I use?</li>
            </ul>

            <p>The three major paradigms are <strong>Procedural</strong>, <strong>Object-Oriented (OOP)</strong>, and <strong>Functional</strong>. Let's explore each in depth.</p>

            <h3>Procedural Programming: Step-by-Step Instructions</h3>
            <p>Procedural programming is the most intuitive paradigm for beginners because it mirrors how we give instructions in real life: a series of steps executed in order. The program is a sequence of procedures (functions) that operate on data.</p>

            <div class="metaphor-box">
                <h4>The Recipe Metaphor (Again)</h4>
                <p>Procedural programming is like following a recipe: Step 1, preheat oven. Step 2, mix ingredients. Step 3, pour into pan. Step 4, bake for 30 minutes. Each step modifies the state (ingredients become batter become cake). Functions are like sub-recipes: "make frosting" is its own procedure called within the main recipe.</p>
            </div>

            <h4>Characteristics of Procedural Programming</h4>
            <ul>
                <li><strong>Top-down approach:</strong> Break problems into smaller procedures/functions</li>
                <li><strong>Sequential execution:</strong> Code runs line by line, procedure by procedure</li>
                <li><strong>Shared state:</strong> Functions operate on shared global or passed data</li>
                <li><strong>Emphasis on functions:</strong> The program is organized around functions/procedures</li>
            </ul>

            <h4>Procedural Example: Calculate Area of Shapes</h4>
            <div class="code">// C - Procedural style
#include <stdio.h>
#include <math.h>

// Functions that perform calculations
double calculate_circle_area(double radius) {
    return M_PI * radius * radius;
}

double calculate_rectangle_area(double width, double height) {
    return width * height;
}

double calculate_triangle_area(double base, double height) {
    return 0.5 * base * height;
}

int main() {
    double circle_area = calculate_circle_area(5.0);
    double rectangle_area = calculate_rectangle_area(4.0, 6.0);
    double triangle_area = calculate_triangle_area(3.0, 7.0);
    
    printf("Circle: %.2f\n", circle_area);
    printf("Rectangle: %.2f\n", rectangle_area);
    printf("Triangle: %.2f\n", triangle_area);
    
    return 0;
}</div>

            <p>Notice: Functions are independent and operate on data passed to them. No classes, no objects‚Äîjust functions manipulating data. This is the essence of procedural programming.</p>

            <div class="info-box">
                <h4>üìå Procedural Languages</h4>
                <p><strong>Pure procedural:</strong> C, Pascal, Fortran<br>
                <strong>Support procedural style:</strong> Python, JavaScript, Go (multi-paradigm languages that can be used procedurally)</p>
            </div>

            <h3>Object-Oriented Programming (OOP): Modeling the World as Objects</h3>
            <p>Object-Oriented Programming organizes code around <strong>objects</strong>‚Äîbundles of data (properties/attributes) and the functions (methods) that operate on that data. Instead of separating data and functions, OOP combines them into cohesive units that model real-world entities.</p>

            <div class="metaphor-box">
                <h4>The Blueprint Metaphor</h4>
                <p>Think of a class as a blueprint for a house. The blueprint defines what rooms the house has, their sizes, and features (data). It also defines operations like "open door" or "turn on lights" (methods). Each house built from that blueprint is an object‚Äîa specific instance with its own state (lights on or off, door open or closed). You can have many houses (objects) from one blueprint (class), each with independent state.</p>
            </div>

            <h4>The Four Pillars of OOP</h4>
            <div class="card-grid">
                <div class="card">
                    <h4>1. Encapsulation</h4>
                    <p>Bundle data and methods together in a class. Hide internal details, expose only what's necessary. Like a car: you use the steering wheel and pedals (public interface) without understanding the engine internals (private implementation).</p>
                </div>
                <div class="card">
                    <h4>2. Inheritance</h4>
                    <p>Create new classes based on existing ones, inheriting their properties and methods. Like taxonomies: a Dog inherits from Mammal inherits from Animal. Promotes code reuse.</p>
                </div>
                <div class="card">
                    <h4>3. Polymorphism</h4>
                    <p>Different classes can be treated as instances of the same parent class. A function that works on Animal works on Dog, Cat, Bird. "Many forms" of the same interface.</p>
                </div>
                <div class="card">
                    <h4>4. Abstraction</h4>
                    <p>Focus on essential features, hide complex implementation. Define what an object does, not how it does it. Like using a smartphone: you tap icons without understanding the hardware/software underneath.</p>
                </div>
            </div>

            <h4>OOP Example: Shape Classes</h4>
            <div class="code">// Python - Object-Oriented Style
import math

class Shape:
    """Base class for all shapes"""
    def area(self):
        raise NotImplementedError("Subclass must implement area()")
    
    def describe(self):
        return f"{self.__class__.__name__} with area {self.area():.2f}"

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height

# Usage
shapes = [
    Circle(5),
    Rectangle(4, 6),
    Triangle(3, 7)
]

for shape in shapes:
    print(shape.describe())

# Output:
# Circle with area 78.54
# Rectangle with area 24.00
# Triangle with area 10.50</div>

            <p>Notice how each shape is an object with its own data (<span class="inline-code">radius</span>, <span class="inline-code">width</span>, etc.) and behavior (<span class="inline-code">area()</span> method). The shapes inherit from a base <span class="inline-code">Shape</span> class, demonstrating inheritance. The loop treats all shapes the same way (polymorphism), even though each calculates area differently.</p>

            <h4>OOP in Different Languages</h4>
            <div class="code">// JavaScript - Class-based (ES6+)
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks`);
    }
}

const dog = new Dog("Rex");
dog.speak();  // Rex barks

// Java - Classic OOP
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void speak() {
        System.out.println(name + " makes a sound");
    }
}

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    @Override
    public void speak() {
        System.out.println(getName() + " barks");
    }
}

// Usage
Dog dog = new Dog("Rex");
dog.speak();  // Rex barks</div>

            <div class="info-box">
                <h4>üìå OOP Languages</h4>
                <p><strong>Pure OOP:</strong> Smalltalk, Java (almost everything is an object)<br>
                <strong>OOP-friendly:</strong> Python, JavaScript, C++, C#, Ruby<br>
                <strong>OOP optional:</strong> Go (no classes, but has methods on structs)</p>
            </div>

            <h3>Functional Programming: Functions as First-Class Citizens</h3>
            <p>Functional programming treats computation as the evaluation of mathematical functions. It emphasizes <strong>immutability</strong> (data doesn't change), <strong>pure functions</strong> (same input always gives same output, no side effects), and <strong>higher-order functions</strong> (functions that take or return other functions).</p>

            <div class="metaphor-box">
                <h4>The Assembly Line Metaphor</h4>
                <p>Imagine an assembly line where each station transforms the input without modifying the original. Raw materials enter, Station 1 shapes them (doesn't destroy originals, creates new shapes), Station 2 paints them, Station 3 packages them. Each station is a pure function: given the same input, produces the same output, without side effects. The original materials never change‚Äîyou get a transformed copy at the end.</p>
            </div>

            <h4>Core Concepts of Functional Programming</h4>
            <ul>
                <li><strong>Pure Functions:</strong> No side effects (don't modify global state, don't do I/O), deterministic (same input ‚Üí same output always)</li>
                <li><strong>Immutability:</strong> Data never changes after creation. Instead of modifying data, create new data.</li>
                <li><strong>First-Class Functions:</strong> Functions are values‚Äîcan be assigned to variables, passed as arguments, returned from other functions.</li>
                <li><strong>Higher-Order Functions:</strong> Functions that take functions as arguments or return functions. Examples: <span class="inline-code">map</span>, <span class="inline-code">filter</span>, <span class="inline-code">reduce</span>.</li>
                <li><strong>Declarative Style:</strong> Describe <em>what</em> you want, not <em>how</em> to do it step-by-step.</li>
            </ul>

            <h4>Functional Example: Processing Data</h4>
            <div class="code">// JavaScript - Functional Style
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Imperative (procedural) way - step by step
const evenDoublesImperative = [];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
        evenDoublesImperative.push(numbers[i] * 2);
    }
}
// Result: [4, 8, 12, 16, 20]

// Functional way - declarative
const evenDoublesFunctional = numbers
    .filter(n => n % 2 === 0)  // Keep only even numbers
    .map(n => n * 2);           // Double each
// Result: [4, 8, 12, 16, 20]

// The functional version:
// - Doesn't mutate the original array
// - Reads like English: "filter evens, then map to doubles"
// - Chains pure functions together</div>

            <h4>Pure Functions vs. Impure Functions</h4>
            <div class="code">// Impure function - has side effects
let total = 0;
function addToTotal(value) {
    total += value;  // Modifies external state
    return total;
}

addToTotal(5);  // Returns 5
addToTotal(5);  // Returns 10 (different result with same input!)

// Pure function - no side effects
function add(a, b) {
    return a + b;  // Only depends on inputs, doesn't modify anything
}

add(5, 5);  // Returns 10
add(5, 5);  // Returns 10 (same input, same output always!)</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Functional Programming Trade-offs</h4>
                <p><strong>Pros:</strong> Easier to reason about, test, and parallelize. No hidden state changes. More predictable.<br><br>
                <strong>Cons:</strong> Can be less intuitive for beginners (requires different thinking). Sometimes less efficient (creating new data instead of modifying existing). Purely functional code is hard in languages not designed for it.</p>
            </div>

            <h4>Higher-Order Functions</h4>
            <div class="code">// Python - Higher-order functions
def apply_operation(numbers, operation):
    """Takes a function as an argument"""
    return [operation(n) for n in numbers]

def square(x):
    return x * x

def cube(x):
    return x * x * x

numbers = [1, 2, 3, 4, 5]
squares = apply_operation(numbers, square)    # [1, 4, 9, 16, 25]
cubes = apply_operation(numbers, cube)        # [1, 8, 27, 64, 125]

// JavaScript - Functions returning functions
function multiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15</div>

            <div class="info-box">
                <h4>üìå Functional Languages</h4>
                <p><strong>Pure functional:</strong> Haskell, Elm, Clojure<br>
                <strong>Functional-friendly:</strong> JavaScript, Python, Scala, Rust, F#<br>
                <strong>Support functional features:</strong> Most modern languages (even Java now has lambdas and streams)</p>
            </div>

            <h3>Comparing Paradigms: The Same Problem, Three Ways</h3>
            <p>Let's solve the same problem‚Äî"find the sum of squares of even numbers in a list"‚Äîusing all three paradigms:</p>

            <h4>Procedural Approach</h4>
            <div class="code">// C - Procedural
#include <stdio.h>

int sum_of_squares_of_evens(int numbers[], int length) {
    int sum = 0;
    for (int i = 0; i < length; i++) {
        if (numbers[i] % 2 == 0) {
            sum += numbers[i] * numbers[i];
        }
    }
    return sum;
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5, 6};
    int result = sum_of_squares_of_evens(numbers, 6);
    printf("%d\n", result);  // 56 (2¬≤ + 4¬≤ + 6¬≤ = 4 + 16 + 36)
    return 0;
}</div>

            <h4>Object-Oriented Approach</h4>
            <div class="code">// Java - OOP
import java.util.Arrays;
import java.util.List;

class NumberProcessor {
    private List<Integer> numbers;
    
    public NumberProcessor(List<Integer> numbers) {
        this.numbers = numbers;
    }
    
    public int sumOfSquaresOfEvens() {
        int sum = 0;
        for (int num : numbers) {
            if (num % 2 == 0) {
                sum += num * num;
            }
        }
        return sum;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
        NumberProcessor processor = new NumberProcessor(numbers);
        System.out.println(processor.sumOfSquaresOfEvens());  // 56
    }
}</div>

            <h4>Functional Approach</h4>
            <div class="code">// JavaScript - Functional
const numbers = [1, 2, 3, 4, 5, 6];

const result = numbers
    .filter(n => n % 2 === 0)      // [2, 4, 6]
    .map(n => n * n)                // [4, 16, 36]
    .reduce((sum, n) => sum + n, 0); // 56

console.log(result);  // 56

// Python - Even more concise
numbers = [1, 2, 3, 4, 5, 6]
result = sum(n*n for n in numbers if n % 2 == 0)
print(result)  // 56</div>

            <div class="card-grid">
                <div class="card">
                    <h4>Procedural Approach</h4>
                    <p><strong>Focus:</strong> Step-by-step instructions. Loop through, check condition, accumulate sum.</p>
                    <p><strong>Pros:</strong> Straightforward, easy to understand for beginners, efficient.</p>
                    <p><strong>Cons:</strong> More verbose, logic mixed with iteration mechanics.</p>
                </div>
                <div class="card">
                    <h4>OOP Approach</h4>
                    <p><strong>Focus:</strong> Encapsulating data (numbers) and behavior (summing) in an object.</p>
                    <p><strong>Pros:</strong> Organized, reusable, can add more methods to NumberProcessor.</p>
                    <p><strong>Cons:</strong> Overkill for this simple task, more boilerplate code.</p>
                </div>
                <div class="card">
                    <h4>Functional Approach</h4>
                    <p><strong>Focus:</strong> Composing transformations. Filter, map, reduce‚Äîdeclarative pipeline.</p>
                    <p><strong>Pros:</strong> Concise, readable, expressive. Each step is a pure function.</p>
                    <p><strong>Cons:</strong> Might be less intuitive for those unfamiliar with functional concepts.</p>
                </div>
            </div>

            <h3>Declarative vs. Imperative</h3>
            <p>Another way to categorize paradigms: <strong>imperative</strong> (how to do it) vs <strong>declarative</strong> (what to do).</p>

            <ul>
                <li><strong>Imperative:</strong> You tell the computer every step. Procedural and OOP are typically imperative. "Walk to the store, go to aisle 3, pick up milk, go to checkout..."</li>
                <li><strong>Declarative:</strong> You describe the desired result, not the steps. Functional programming, SQL, HTML/CSS are declarative. "Get me milk from the store" (don't care about the steps).</li>
            </ul>

            <div class="code">// Imperative - how to get uppercase names
const names = ["alice", "bob", "charlie"];
const upperNames = [];
for (let i = 0; i < names.length; i++) {
    upperNames.push(names[i].toUpperCase());
}

// Declarative - what we want (uppercase names)
const upperNames = names.map(name => name.toUpperCase());</div>

            <h3>Multi-Paradigm Languages</h3>
            <p>Most modern languages support multiple paradigms, giving you flexibility:</p>

            <table>
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Procedural</th>
                        <th>OOP</th>
                        <th>Functional</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Python</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>Supports all three well. Flexible and pragmatic.</td>
                    </tr>
                    <tr>
                        <td>JavaScript</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>Functional features very strong. Prototypal OOP.</td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td>‚úÖ</td>
                        <td>‚ùå</td>
                        <td>‚ùå</td>
                        <td>Purely procedural. No classes or first-class functions.</td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td>Partial</td>
                        <td>‚úÖ‚úÖ</td>
                        <td>‚úÖ (since Java 8)</td>
                        <td>Primarily OOP. Added functional features (lambdas, streams).</td>
                    </tr>
                    <tr>
                        <td>Go</td>
                        <td>‚úÖ</td>
                        <td>Partial</td>
                        <td>Partial</td>
                        <td>Procedural with struct methods. No inheritance. First-class functions.</td>
                    </tr>
                    <tr>
                        <td>Rust</td>
                        <td>‚úÖ</td>
                        <td>Partial</td>
                        <td>‚úÖ</td>
                        <td>Functional-leaning. Traits instead of classes. Strong functional features.</td>
                    </tr>
                    <tr>
                        <td>C++</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>Partial</td>
                        <td>Multi-paradigm powerhouse. Can do almost anything.</td>
                    </tr>
                </tbody>
            </table>

            <div class="info-box">
                <h4>üéì Which Paradigm Should You Use?</h4>
                <p>There's no single "best" paradigm. Each shines in different contexts:<br><br>
                <strong>Procedural:</strong> Scripts, simple tasks, performance-critical code, systems programming<br>
                <strong>OOP:</strong> Large applications, GUI programming, modeling real-world entities, teams working on big codebases<br>
                <strong>Functional:</strong> Data transformation pipelines, concurrent/parallel programming, mathematical computations<br><br>
                In practice, you'll often mix paradigms. Use OOP to structure your application, procedural code for algorithms, and functional style for data processing. Modern programming is pragmatic‚Äîuse what works best for the problem at hand.</p>
            </div>

            <h3>The Evolution of Paradigms</h3>
            <p>Paradigms have evolved over time as we learned better ways to manage complexity:</p>

            <ul>
                <li><strong>1950s-1960s:</strong> Procedural programming emerges (Fortran, C). Focus on breaking problems into procedures.</li>
                <li><strong>1970s-1980s:</strong> OOP gains traction (Smalltalk, C++). Encapsulation and inheritance help manage larger programs.</li>
                <li><strong>1990s-2000s:</strong> OOP dominates (Java, C#). "Everything is an object" philosophy.</li>
                <li><strong>2010s-Present:</strong> Functional programming renaissance. Languages add functional features (Java lambdas, C# LINQ, Python comprehensions). Recognition that immutability and pure functions help with concurrency and testing.</li>
            </ul>

            <p>The trend is toward multi-paradigm languages that let developers choose the right tool for each part of their program.</p>

            <div class="metaphor-box">
                <h4>Paradigms Are Tools in a Toolbox</h4>
                <p>Imagine you're building furniture. You wouldn't use only a hammer for everything‚Äîsometimes you need a saw, a screwdriver, or sandpaper. Similarly, don't force one paradigm everywhere. Need to model a user with properties and methods? OOP is great. Processing a list of data? Functional style is clean. Writing a quick script? Procedural is fine. Master all paradigms, then pick the right one for each task.</p>
            </div>

            <p>Understanding paradigms makes you a better programmer in any language. When you see why Rust emphasizes immutability, why Java is class-based, why functional languages avoid side effects‚Äîyou understand the design philosophy, not just the syntax. And that understanding transfers across languages and makes you a true polyglot programmer.</p>
        </section>

        <section class="section" id="data-structures">
            <h2 class="section-title">Universal Data Structures</h2>
            <p class="section-intro">Data structures are ways of organizing and storing data so it can be accessed and modified efficiently. Just as you organize physical objects in your home‚Äîbooks on shelves, clothes in drawers, dishes in cabinets‚Äîprograms organize data in structures optimized for different operations. The same fundamental data structures appear in every programming language, though syntax and implementation details vary. Mastering these structures is essential because they're the building blocks of all software.</p>

            <h3>Why Data Structures Matter</h3>
            <p>Choosing the right data structure dramatically affects your program's performance and elegance. Using an array when you need a hash map, or a list when you need a queue, can make your code slow, complicated, or buggy. Understanding data structures helps you:</p>

            <ul>
                <li>Write efficient code that scales to large datasets</li>
                <li>Choose the right tool for the job (the right structure for your use case)</li>
                <li>Understand how libraries and frameworks work internally</li>
                <li>Ace technical interviews (data structures are heavily tested)</li>
                <li>Reason about space and time complexity</li>
            </ul>

            <div class="metaphor-box">
                <h4>The Library Metaphor</h4>
                <p>Imagine organizing a library. You could:<br>
                ‚Ä¢ <strong>Pile all books on the floor</strong> (unstructured data): Easy to add books, impossible to find anything.<br>
                ‚Ä¢ <strong>Shelves in random order</strong> (unsorted array): Better, but still need to check every book to find one.<br>
                ‚Ä¢ <strong>Alphabetically organized</strong> (sorted array): Much faster to search, but adding new books requires moving many others.<br>
                ‚Ä¢ <strong>Card catalog with locations</strong> (hash map): Fast lookup by title, fast insertion, uses more space for the catalog.<br><br>
                Each organization method is a data structure with different trade-offs.</p>
            </div>

            <h3>Arrays and Lists: Sequential Storage</h3>
            <p>Arrays (and their dynamic counterparts, lists) are the simplest data structure: elements stored in contiguous memory locations, accessed by index.</p>

            <h4>Arrays: Fixed-Size</h4>
            <p>Arrays have a fixed size determined at creation. Elements are accessed by numeric index (0-based in most languages).</p>

            <div class="code">// C - Static array
int numbers[5] = {10, 20, 30, 40, 50};
printf("%d\n", numbers[0]);  // 10
printf("%d\n", numbers[2]);  // 30

// Java - Array
int[] numbers = {10, 20, 30, 40, 50};
System.out.println(numbers[0]);  // 10

// Go - Array
var numbers = [5]int{10, 20, 30, 40, 50}
fmt.Println(numbers[0])  // 10</div>

            <p><strong>Characteristics:</strong> Fixed size, fast random access (O(1)), stored contiguously in memory, efficient for iteration.</p>

            <h4>Lists: Dynamic Arrays</h4>
            <p>Lists (ArrayLists, Vectors, etc.) are dynamic‚Äîthey grow and shrink as needed, implemented as resizable arrays.</p>

            <div class="code">// Python - List (dynamic array)
numbers = [10, 20, 30]
numbers.append(40)  // Add element
numbers.append(50)
print(numbers[2])  // 30
print(len(numbers))  // 5

// JavaScript - Array (actually a dynamic list)
const numbers = [10, 20, 30];
numbers.push(40);
numbers.push(50);
console.log(numbers[2]);  // 30
console.log(numbers.length);  // 5

// Java - ArrayList
ArrayList<Integer> numbers = new ArrayList<>();
numbers.add(10);
numbers.add(20);
numbers.add(30);
System.out.println(numbers.get(2));  // 30

// Go - Slice (dynamic array)
numbers := []int{10, 20, 30}
numbers = append(numbers, 40)
numbers = append(numbers, 50)
fmt.Println(numbers[2])  // 30</div>

            <div class="info-box">
                <h4>‚öôÔ∏è Time Complexity: Arrays/Lists</h4>
                <p><strong>Access by index:</strong> O(1) ‚Äî instant, direct memory access<br>
                <strong>Search (unsorted):</strong> O(n) ‚Äî must check each element<br>
                <strong>Insert at end:</strong> O(1) amortized ‚Äî usually fast, occasionally slow when resizing<br>
                <strong>Insert at beginning/middle:</strong> O(n) ‚Äî must shift all subsequent elements<br>
                <strong>Delete:</strong> O(n) ‚Äî must shift elements to fill gap</p>
            </div>

            <h3>Hash Maps / Dictionaries / Objects: Key-Value Storage</h3>
            <p>Hash maps (also called dictionaries, hash tables, maps, or objects in JavaScript) store data as key-value pairs. They provide incredibly fast lookups, insertions, and deletions.</p>

            <div class="metaphor-box">
                <h4>The Phone Book Metaphor</h4>
                <p>A phone book is a hash map: you look up by name (key) to get a phone number (value). You don't need to know which page the name is on‚Äîyou just look it up directly. This is the power of hash maps: O(1) average lookup time regardless of how many entries there are.</p>
            </div>

            <h4>Hash Maps in Different Languages</h4>
            <div class="code">// Python - Dictionary
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}
print(person["name"])  // Alice
person["age"] = 31     // Update
person["job"] = "Engineer"  // Add new key

// JavaScript - Object
const person = {
    name: "Alice",
    age: 30,
    city: "New York"
};
console.log(person.name);  // Alice
person.age = 31;
person.job = "Engineer";

// JavaScript - Map (for non-string keys)
const scores = new Map();
scores.set("Alice", 95);
scores.set("Bob", 87);
console.log(scores.get("Alice"));  // 95

// Java - HashMap
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);
System.out.println(scores.get("Alice"));  // 95

// Go - Map
scores := map[string]int{
    "Alice": 95,
    "Bob":   87,
}
fmt.Println(scores["Alice"])  // 95
scores["Charlie"] = 92        // Add new entry

// Rust - HashMap
use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert("Alice", 95);
scores.insert("Bob", 87);
println!("{}", scores.get("Alice").unwrap());  // 95</div>

            <h4>How Hash Maps Work (Simplified)</h4>
            <p>Internally, a hash map uses a <strong>hash function</strong> to convert keys into array indices. When you insert <span class="inline-code">{"name": "Alice"}</span>, the hash function might convert <span class="inline-code">"name"</span> to index 42, and the value <span class="inline-code">"Alice"</span> is stored at that index in an underlying array. This allows O(1) lookup‚Äîthe hash function tells you exactly where to look.</p>

            <div class="info-box">
                <h4>‚öôÔ∏è Time Complexity: Hash Maps</h4>
                <p><strong>Lookup:</strong> O(1) average ‚Äî hash directly to the location<br>
                <strong>Insert:</strong> O(1) average ‚Äî hash and store<br>
                <strong>Delete:</strong> O(1) average ‚Äî hash and remove<br>
                <strong>Iteration:</strong> O(n) ‚Äî must visit all entries<br><br>
                <em>Note: "Average" because hash collisions can degrade to O(n) in worst case, but well-designed hash functions make this rare.</em></p>
            </div>

            <h3>Stacks: Last-In-First-Out (LIFO)</h3>
            <p>A stack is like a stack of plates: you add (push) plates to the top and remove (pop) plates from the top. The last plate you added is the first one you remove‚ÄîLast-In-First-Out (LIFO).</p>

            <div class="metaphor-box">
                <h4>The Plate Stack Metaphor</h4>
                <p>Washing dishes? You stack clean plates on top of each other. When you need a plate, you take from the top (most recent). You can't easily take the bottom plate without removing all the others. That's a stack.</p>
            </div>

            <h4>Stack Operations</h4>
            <ul>
                <li><strong>Push:</strong> Add element to top</li>
                <li><strong>Pop:</strong> Remove and return top element</li>
                <li><strong>Peek/Top:</strong> View top element without removing</li>
                <li><strong>isEmpty:</strong> Check if stack is empty</li>
            </ul>

            <h4>Stack Implementation and Usage</h4>
            <div class="code">// Python - Using list as stack
stack = []
stack.append(10)  // Push
stack.append(20)
stack.append(30)
print(stack.pop())  // 30 (top element)
print(stack.pop())  // 20
print(stack[-1])    // 10 (peek at top without removing)

// JavaScript - Using array as stack
const stack = [];
stack.push(10);
stack.push(20);
stack.push(30);
console.log(stack.pop());  // 30
console.log(stack.pop());  // 20
console.log(stack[stack.length - 1]);  // 10 (peek)

// Java - Stack class
Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.push(20);
stack.push(30);
System.out.println(stack.pop());  // 30
System.out.println(stack.peek()); // 20 (doesn't remove)

// Go - Using slice as stack
stack := []int{}
stack = append(stack, 10)  // Push
stack = append(stack, 20)
stack = append(stack, 30)
top := stack[len(stack)-1]  // Peek
stack = stack[:len(stack)-1]  // Pop
fmt.Println(top)  // 30</div>

            <h4>Real-World Stack Use Cases</h4>
            <ul>
                <li><strong>Function call stack:</strong> When you call a function, the return address is pushed onto the stack. When the function returns, it pops the return address. Nested function calls create a stack of frames.</li>
                <li><strong>Undo functionality:</strong> Each action pushes a state onto a stack. Undo pops the most recent state.</li>
                <li><strong>Expression evaluation:</strong> Parsing mathematical expressions like <span class="inline-code">(3 + 4) * 5</span> uses stacks.</li>
                <li><strong>Backtracking algorithms:</strong> DFS (Depth-First Search), maze solving, etc.</li>
            </ul>

            <div class="info-box">
                <h4>‚öôÔ∏è Time Complexity: Stack</h4>
                <p><strong>Push:</strong> O(1) ‚Äî add to top<br>
                <strong>Pop:</strong> O(1) ‚Äî remove from top<br>
                <strong>Peek:</strong> O(1) ‚Äî view top<br>
                <strong>Search:</strong> O(n) ‚Äî stacks aren't meant for searching</p>
            </div>

            <h3>Queues: First-In-First-Out (FIFO)</h3>
            <p>A queue is like a line at a store: first person to arrive is first to be served. First-In-First-Out (FIFO).</p>

            <div class="metaphor-box">
                <h4>The Line/Queue Metaphor</h4>
                <p>Standing in line for coffee? People join at the back (enqueue) and leave from the front (dequeue). Fair system: whoever arrived first gets served first. That's a queue.</p>
            </div>

            <h4>Queue Operations</h4>
            <ul>
                <li><strong>Enqueue:</strong> Add element to back</li>
                <li><strong>Dequeue:</strong> Remove and return front element</li>
                <li><strong>Front/Peek:</strong> View front element without removing</li>
                <li><strong>isEmpty:</strong> Check if queue is empty</li>
            </ul>

            <h4>Queue Implementation</h4>
            <div class="code">// Python - Using collections.deque
from collections import deque
queue = deque()
queue.append(10)  // Enqueue (add to back)
queue.append(20)
queue.append(30)
print(queue.popleft())  // 10 (dequeue from front)
print(queue.popleft())  // 20

// JavaScript - Using array (inefficient for large queues)
const queue = [];
queue.push(10);  // Enqueue
queue.push(20);
queue.push(30);
console.log(queue.shift());  // 10 (dequeue)
console.log(queue.shift());  // 20

// Java - Queue interface with LinkedList
Queue<Integer> queue = new LinkedList<>();
queue.offer(10);  // Enqueue
queue.offer(20);
queue.offer(30);
System.out.println(queue.poll());  // 10 (dequeue)
System.out.println(queue.peek());  // 20 (view front)

// Go - Using slice (basic implementation)
queue := []int{}
queue = append(queue, 10)  // Enqueue
queue = append(queue, 20)
queue = append(queue, 30)
front := queue[0]  // Peek
queue = queue[1:]  // Dequeue
fmt.Println(front)  // 10</div>

            <h4>Real-World Queue Use Cases</h4>
            <ul>
                <li><strong>Task scheduling:</strong> Print jobs, background processes‚Äîfirst submitted, first processed.</li>
                <li><strong>Breadth-First Search (BFS):</strong> Graph/tree traversal algorithm uses a queue.</li>
                <li><strong>Request handling:</strong> Web servers, message queues‚Äîprocess requests in order received.</li>
                <li><strong>Buffering:</strong> Streaming data (video, audio)‚Äîqueue buffers data to smooth playback.</li>
            </ul>

            <div class="info-box">
                <h4>‚öôÔ∏è Time Complexity: Queue</h4>
                <p><strong>Enqueue:</strong> O(1) ‚Äî add to back<br>
                <strong>Dequeue:</strong> O(1) ‚Äî remove from front (with proper implementation)<br>
                <strong>Peek:</strong> O(1) ‚Äî view front<br>
                <strong>Search:</strong> O(n) ‚Äî queues aren't meant for searching</p>
            </div>

            <h3>Linked Lists: Dynamic Sequential Storage</h3>
            <p>A linked list is a sequence of nodes where each node contains data and a pointer/reference to the next node. Unlike arrays, elements aren't stored contiguously in memory.</p>

            <div class="metaphor-box">
                <h4>The Treasure Hunt Metaphor</h4>
                <p>Imagine a treasure hunt where each clue tells you where the next clue is. You start at clue 1, which says "next clue is at the library." At the library, clue 2 says "next clue is under the oak tree." Each clue points to the next‚Äîthat's a linked list. You can't jump directly to clue 5; you must follow the chain.</p>
            </div>

            <h4>Types of Linked Lists</h4>
            <ul>
                <li><strong>Singly Linked List:</strong> Each node points to the next node. One-way traversal.</li>
                <li><strong>Doubly Linked List:</strong> Each node points to both next and previous nodes. Two-way traversal.</li>
                <li><strong>Circular Linked List:</strong> Last node points back to first node, forming a circle.</li>
            </ul>

            <h4>Linked List Implementation</h4>
            <div class="code">// Python - Singly Linked List
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

// Usage
ll = LinkedList()
ll.append(10)
ll.append(20)
ll.append(30)
ll.print_list()  // 10 -> 20 -> 30 -> None

// C - Singly Linked List
struct Node {
    int data;
    struct Node* next;
};

void append(struct Node** head_ref, int data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    struct Node* last = *head_ref;
    new_node->data = data;
    new_node->next = NULL;
    if (*head_ref == NULL) {
        *head_ref = new_node;
        return;
    }
    while (last->next != NULL)
        last = last->next;
    last->next = new_node;
}</div>

            <h4>Array vs. Linked List</h4>
            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Array</th>
                        <th>Linked List</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Access by index</td>
                        <td>O(1) ‚Äî direct memory access</td>
                        <td>O(n) ‚Äî must traverse from head</td>
                    </tr>
                    <tr>
                        <td>Insert at beginning</td>
                        <td>O(n) ‚Äî shift all elements</td>
                        <td>O(1) ‚Äî just update head pointer</td>
                    </tr>
                    <tr>
                        <td>Insert at end</td>
                        <td>O(1) amortized</td>
                        <td>O(n) ‚Äî traverse to end (O(1) if tail pointer)</td>
                    </tr>
                    <tr>
                        <td>Delete</td>
                        <td>O(n) ‚Äî shift elements</td>
                        <td>O(1) ‚Äî update pointers (if node reference known)</td>
                    </tr>
                    <tr>
                        <td>Memory</td>
                        <td>Contiguous, cache-friendly</td>
                        <td>Non-contiguous, extra space for pointers</td>
                    </tr>
                </tbody>
            </table>

            <p>Use arrays for fast random access. Use linked lists for frequent insertions/deletions, especially at the beginning.</p>

            <h3>Trees: Hierarchical Data</h3>
            <p>Trees are hierarchical structures with a root node and child nodes. Each node can have zero or more children. Trees are everywhere in computing: file systems, DOM in browsers, organization charts, decision trees.</p>

            <h4>Binary Trees</h4>
            <p>A binary tree is a tree where each node has at most two children: left and right.</p>

            <div class="code">// Python - Binary Tree Node
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

// Create a simple tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)</div>

            <h4>Binary Search Tree (BST)</h4>
            <p>A BST is a binary tree with a special property: for every node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater. This property enables fast searching.</p>

            <div class="code">// Python - BST Search
def search_bst(root, target):
    if root is None or root.data == target:
        return root
    if target < root.data:
        return search_bst(root.left, target)
    else:
        return search_bst(root.right, target)

// Time Complexity: O(log n) average, O(n) worst case (unbalanced tree)</div>

            <h4>Tree Traversal</h4>
            <p>Visiting all nodes in a tree. Three main depth-first methods:</p>

            <ul>
                <li><strong>Inorder (Left, Root, Right):</strong> For BST, visits nodes in sorted order</li>
                <li><strong>Preorder (Root, Left, Right):</strong> Used to copy tree structure</li>
                <li><strong>Postorder (Left, Right, Root):</strong> Used to delete tree</li>
            </ul>

            <div class="code">// Python - Tree Traversal
def inorder(node):
    if node:
        inorder(node.left)
        print(node.data, end=" ")
        inorder(node.right)

def preorder(node):
    if node:
        print(node.data, end=" ")
        preorder(node.left)
        preorder(node.right)

def postorder(node):
    if node:
        postorder(node.left)
        postorder(node.right)
        print(node.data, end=" ")</div>

            <h3>Graphs: Networks of Connections</h3>
            <p>Graphs are the most general data structure: a set of nodes (vertices) connected by edges. Trees are actually a special type of graph (connected, acyclic). Graphs model networks: social networks, road maps, computer networks, dependencies.</p>

            <h4>Graph Representation</h4>
            <p>Two common ways to represent graphs:</p>

            <div class="code">// Adjacency List - Most common for sparse graphs
// Python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

// JavaScript
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};

// Adjacency Matrix - Good for dense graphs, fast edge lookup
// Python
graph = [
    [0, 1, 1, 0, 0, 0],  // A connects to B, C
    [1, 0, 0, 1, 1, 0],  // B connects to A, D, E
    [1, 0, 0, 0, 0, 1],  // C connects to A, F
    [0, 1, 0, 0, 0, 0],  // D connects to B
    [0, 1, 0, 0, 0, 1],  // E connects to B, F
    [0, 0, 1, 0, 1, 0]   // F connects to C, E
]</div>

            <div class="info-box">
                <h4>üìä Data Structure Cheat Sheet</h4>
                <p><strong>Need fast random access?</strong> ‚Üí Array<br>
                <strong>Need fast lookup by key?</strong> ‚Üí Hash Map<br>
                <strong>Need LIFO (last in, first out)?</strong> ‚Üí Stack<br>
                <strong>Need FIFO (first in, first out)?</strong> ‚Üí Queue<br>
                <strong>Need frequent insertions at beginning?</strong> ‚Üí Linked List<br>
                <strong>Need hierarchical data?</strong> ‚Üí Tree<br>
                <strong>Need to model connections/networks?</strong> ‚Üí Graph</p>
            </div>

            <h3>Choosing the Right Data Structure</h3>
            <p>Selecting the appropriate data structure is a fundamental skill. Consider:</p>

            <ul>
                <li><strong>Access patterns:</strong> Do you need random access or sequential? Fast lookups or fast insertions?</li>
                <li><strong>Memory constraints:</strong> How much extra memory can you afford for metadata (pointers, hash tables)?</li>
                <li><strong>Performance requirements:</strong> What operations must be fast? What can be slow?</li>
                <li><strong>Data characteristics:</strong> Is data ordered? Are keys unique? How many elements?</li>
            </ul>

            <p>Every programming language provides built-in implementations of these structures (often in standard libraries). You rarely implement them from scratch in production code, but understanding how they work is crucial for using them effectively.</p>
        </section>

        <section class="section" id="algorithms">
            <h2 class="section-title">Core Algorithms</h2>
            <p class="section-intro">If data structures are nouns (the things), algorithms are verbs (the actions). An algorithm is a step-by-step procedure to solve a problem or perform a task. The same algorithms appear across languages and domains‚Äîsearching, sorting, graph traversal. Understanding algorithms helps you solve problems efficiently and gives you a vocabulary for discussing solutions. Whether you're in a coding interview or optimizing production code, algorithmic thinking is essential.</p>

            <h3>What Makes a Good Algorithm?</h3>
            <p>When evaluating algorithms, we consider:</p>

            <ul>
                <li><strong>Correctness:</strong> Does it always produce the right answer?</li>
                <li><strong>Efficiency:</strong> How fast does it run? (Time complexity)</li>
                <li><strong>Space usage:</strong> How much memory does it need? (Space complexity)</li>
                <li><strong>Clarity:</strong> Can other developers understand and maintain it?</li>
            </ul>

            <div class="info-box">
                <h4>üïí Big O Notation</h4>
                <p>Big O describes how an algorithm's runtime grows as input size increases. Common complexities from fastest to slowest:<br><br>
                <strong>O(1)</strong> ‚Äî Constant: Same time regardless of input size (array access)<br>
                <strong>O(log n)</strong> ‚Äî Logarithmic: Halves problem each step (binary search)<br>
                <strong>O(n)</strong> ‚Äî Linear: Time grows proportionally with input (linear search)<br>
                <strong>O(n log n)</strong> ‚Äî Linearithmic: Efficient sorts (merge sort, quick sort)<br>
                <strong>O(n¬≤)</strong> ‚Äî Quadratic: Nested loops (bubble sort, naive algorithms)<br>
                <strong>O(2‚Åø)</strong> ‚Äî Exponential: Doubles with each addition (brute force, some recursion)<br>
                <strong>O(n!)</strong> ‚Äî Factorial: Explodes rapidly (permutations, traveling salesman brute force)</p>
            </div>

            <h3>Searching Algorithms</h3>
            <p>Finding an element in a collection is one of the most common operations in programming.</p>

            <h4>Linear Search: Check Every Element</h4>
            <p>The simplest search: go through the list one by one until you find the target (or reach the end).</p>

            <div class="code">// Python - Linear Search
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Found at index i
    return -1  # Not found

numbers = [3, 7, 1, 9, 4, 8, 2]
print(linear_search(numbers, 9))  # 3
print(linear_search(numbers, 5))  # -1

// JavaScript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }
    }
    return -1;
}

// C
int linear_search(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}</div>

            <p><strong>Time Complexity:</strong> O(n) ‚Äî must potentially check every element<br>
            <strong>Space Complexity:</strong> O(1) ‚Äî no extra space needed<br>
            <strong>When to use:</strong> Unsorted or small datasets, or when simplicity matters more than speed</p>

            <h4>Binary Search: Divide and Conquer</h4>
            <p>Binary search only works on <strong>sorted</strong> arrays. It repeatedly divides the search space in half by comparing the target to the middle element.</p>

            <div class="metaphor-box">
                <h4>The Dictionary Metaphor</h4>
                <p>Looking up "python" in a dictionary? You don't start at "aardvark" and read every word. You open to the middle, see you're at "m," realize "p" comes after, so you look in the second half. Middle of that is "s"‚Äîtoo far, go back slightly. Keep halving until you find "python." That's binary search: each step eliminates half the possibilities.</p>
            </div>

            <div class="code">// Python - Binary Search
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid  # Found it!
        elif arr[mid] < target:
            left = mid + 1  // Target is in right half
        else:
            right = mid - 1  // Target is in left half
    
    return -1  // Not found

numbers = [1, 2, 3, 4, 7, 8, 9]  # Must be sorted!
print(binary_search(numbers, 7))  # 4
print(binary_search(numbers, 5))  # -1

// JavaScript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Recursive version - Python
def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)</div>

            <p><strong>Time Complexity:</strong> O(log n) ‚Äî halves search space each iteration<br>
            <strong>Space Complexity:</strong> O(1) iterative, O(log n) recursive (call stack)<br>
            <strong>Requirement:</strong> Array must be sorted<br>
            <strong>When to use:</strong> Large sorted datasets where speed matters</p>

            <h3>Sorting Algorithms</h3>
            <p>Putting data in order is fundamental. Sorted data enables binary search, makes finding min/max trivial, and often reveals patterns.</p>

            <h4>Bubble Sort: Simple but Slow</h4>
            <p>Repeatedly step through the list, compare adjacent elements, swap if they're in wrong order. "Bubbles" the largest element to the end each pass.</p>

            <div class="code">// Python - Bubble Sort
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Last i elements are already sorted
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # Swap
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

numbers = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(numbers))  # [11, 12, 22, 25, 34, 64, 90]

// JavaScript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}</div>

            <p><strong>Time Complexity:</strong> O(n¬≤) ‚Äî nested loops<br>
            <strong>Space Complexity:</strong> O(1) ‚Äî sorts in place<br>
            <strong>When to use:</strong> Small datasets, educational purposes. Not for production.</p>

            <h4>Merge Sort: Efficient and Reliable</h4>
            <p>Divide and conquer: split array in half recursively until you have single elements (which are trivially sorted), then merge sorted halves back together.</p>

            <div class="code">// Python - Merge Sort
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Conquer (merge)
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    # Merge two sorted arrays
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    return result

numbers = [64, 34, 25, 12, 22, 11, 90]
print(merge_sort(numbers))  # [11, 12, 22, 25, 34, 64, 90]

// JavaScript - Merge Sort
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}</div>

            <p><strong>Time Complexity:</strong> O(n log n) ‚Äî always, best and worst case<br>
            <strong>Space Complexity:</strong> O(n) ‚Äî needs extra space for merging<br>
            <strong>When to use:</strong> Large datasets, when consistent performance matters, linked lists (no random access needed)</p>

            <h4>Quick Sort: Fast in Practice</h4>
            <p>Choose a "pivot" element, partition array so elements smaller than pivot are on the left, larger on the right. Recursively sort left and right partitions.</p>

            <div class="code">// Python - Quick Sort
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

numbers = [64, 34, 25, 12, 22, 11, 90]
print(quick_sort(numbers))  # [11, 12, 22, 25, 34, 64, 90]

// JavaScript - Quick Sort
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSort(left), ...middle, ...quickSort(right)];
}</div>

            <p><strong>Time Complexity:</strong> O(n log n) average, O(n¬≤) worst case (bad pivot choices)<br>
            <strong>Space Complexity:</strong> O(log n) ‚Äî recursion depth<br>
            <strong>When to use:</strong> General-purpose sorting, often fastest in practice due to cache efficiency</p>

            <h4>Sorting Algorithm Comparison</h4>
            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best Case</th>
                        <th>Average Case</th>
                        <th>Worst Case</th>
                        <th>Space</th>
                        <th>Stable?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bubble Sort</td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Selection Sort</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Merge Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Quick Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(log n)</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Heap Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>No</td>
                    </tr>
                </tbody>
            </table>

            <p><em>Note: "Stable" means equal elements maintain their relative order after sorting. Important when sorting by multiple criteria.</em></p>

            <h3>Recursion: Functions Calling Themselves</h3>
            <p>Recursion is when a function calls itself. It's a powerful technique for solving problems that can be broken down into smaller, similar subproblems.</p>

            <div class="metaphor-box">
                <h4>The Russian Doll Metaphor</h4>
                <p>A Russian matryoshka doll contains a smaller doll, which contains a smaller doll, and so on until you reach the tiniest doll (base case). Opening the outermost doll requires opening the next one, which requires opening the next... That's recursion: solving a problem by solving a smaller version of the same problem, until you hit a base case that doesn't require further recursion.</p>
            </div>

            <h4>Anatomy of Recursion</h4>
            <p>Every recursive function needs:</p>

            <ul>
                <li><strong>Base case:</strong> The stopping condition. Without it, recursion never ends (stack overflow).</li>
                <li><strong>Recursive case:</strong> The function calls itself with a smaller/simpler problem.</li>
                <li><strong>Progress toward base case:</strong> Each recursive call must get closer to the base case.</li>
            </ul>

            <h4>Classic Example: Factorial</h4>
            <p>Factorial: n! = n √ó (n-1) √ó (n-2) √ó ... √ó 1. For example, 5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120.</p>

            <div class="code">// Python - Factorial
def factorial(n):
    # Base case
    if n == 0 or n == 1:
        return 1
    # Recursive case
    return n * factorial(n - 1)

print(factorial(5))  # 120

// How it works:
// factorial(5) = 5 * factorial(4)
//              = 5 * 4 * factorial(3)
//              = 5 * 4 * 3 * factorial(2)
//              = 5 * 4 * 3 * 2 * factorial(1)
//              = 5 * 4 * 3 * 2 * 1
//              = 120

// JavaScript
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// C
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}</div>

            <h4>Fibonacci Sequence</h4>
            <p>Fibonacci: each number is the sum of the previous two. 0, 1, 1, 2, 3, 5, 8, 13, 21...</p>

            <div class="code">// Python - Fibonacci (naive recursion)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(7))  # 13

// Problem: This is very slow! O(2^n) because it recalculates the same values many times.
// Solution: Dynamic Programming (memoization)

def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    return memo[n]

print(fib_memo(7))  # 13 (much faster!)

// JavaScript - With memoization
function fib(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Recursion Pitfalls</h4>
                <p><strong>Stack overflow:</strong> Too many recursive calls can exceed the call stack limit. Solution: Use iteration or tail recursion optimization (if your language supports it).<br><br>
                <strong>Inefficiency:</strong> Naive recursion (like Fibonacci) can be exponentially slow. Solution: Memoization or dynamic programming.<br><br>
                <strong>Readability:</strong> For simple problems, iteration might be clearer. Use recursion when the problem is naturally recursive (trees, graphs, divide-and-conquer).</p>
            </div>

            <h3>Graph Traversal: BFS and DFS</h3>
            <p>Graphs require special traversal algorithms to visit all nodes systematically.</p>

            <h4>Breadth-First Search (BFS): Level by Level</h4>
            <p>BFS explores all neighbors at the current depth before moving to nodes at the next depth. Uses a queue. Think of it as exploring in waves radiating outward.</p>

            <div class="code">// Python - BFS
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        print(node, end=" ")
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

bfs(graph, 'A')  # A B C D E F

// JavaScript - BFS
function bfs(graph, start) {
    const visited = new Set();
    const queue = [start];
    visited.add(start);
    
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node);
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
}</div>

            <p><strong>Use cases:</strong> Shortest path in unweighted graphs, level-order tree traversal, web crawlers, social network "degrees of separation"</p>

            <h4>Depth-First Search (DFS): Go Deep First</h4>
            <p>DFS explores as far as possible along each branch before backtracking. Uses a stack (or recursion, which uses the call stack implicitly).</p>

            <div class="code">// Python - DFS (recursive)
def dfs(graph, node, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(node)
    print(node, end=" ")
    
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

dfs(graph, 'A')  # A B D E F C

// Python - DFS (iterative with stack)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=" ")
            visited.add(node)
            # Add neighbors in reverse to maintain left-to-right order
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

// JavaScript - DFS (recursive)
function dfs(graph, node, visited = new Set()) {
    visited.add(node);
    console.log(node);
    
    for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
            dfs(graph, neighbor, visited);
        }
    }
}</div>

            <p><strong>Use cases:</strong> Cycle detection, topological sorting, maze solving, path finding, connected components</p>

            <h3>Dynamic Programming: Optimizing with Memory</h3>
            <p>Dynamic Programming (DP) solves complex problems by breaking them into simpler subproblems and storing solutions to avoid redundant calculations. Two approaches:</p>

            <ul>
                <li><strong>Memoization (Top-Down):</strong> Recursion + caching results</li>
                <li><strong>Tabulation (Bottom-Up):</strong> Build table iteratively from base cases up</li>
            </ul>

            <h4>Example: Climbing Stairs</h4>
            <p>Problem: You can climb 1 or 2 steps at a time. How many ways to reach step n?</p>

            <div class="code">// Python - Memoization (top-down)
def climb_stairs(n, memo={}):
    if n <= 2:
        return n
    if n in memo:
        return memo[n]
    memo[n] = climb_stairs(n - 1, memo) + climb_stairs(n - 2, memo)
    return memo[n]

print(climb_stairs(5))  # 8

// Python - Tabulation (bottom-up)
def climb_stairs_tab(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

print(climb_stairs_tab(5))  # 8</div>

            <p>DP turns exponential problems into polynomial ones by avoiding redundant computation.</p>

            <h3>The Big Picture: Algorithm Design Paradigms</h3>
            <p>Most algorithms fall into these design categories:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>Brute Force</h4>
                    <p>Try all possibilities. Simple but often slow. Example: checking all passwords until one works.</p>
                </div>
                <div class="card">
                    <h4>Divide and Conquer</h4>
                    <p>Break problem into smaller subproblems, solve recursively, combine results. Examples: merge sort, quick sort, binary search.</p>
                </div>
                <div class="card">
                    <h4>Greedy</h4>
                    <p>Make locally optimal choice at each step, hoping it leads to global optimum. Examples: Dijkstra's shortest path, Huffman coding.</p>
                </div>
                <div class="card">
                    <h4>Dynamic Programming</h4>
                    <p>Solve subproblems once, store results, reuse them. Examples: Fibonacci, shortest paths, knapsack problem.</p>
                </div>
                <div class="card">
                    <h4>Backtracking</h4>
                    <p>Try solutions, backtrack when you hit a dead end. Examples: Sudoku solver, N-queens, maze solving.</p>
                </div>
            </div>

            <p>Understanding these paradigms helps you recognize patterns and apply proven strategies to new problems. Algorithms aren't about memorizing code‚Äîthey're about developing a toolkit of problem-solving techniques that transcend any single language.</p>
        </section>

        <section class="section" id="python-deep">
            <h2 class="section-title">Python Deep Dive</h2>
            <p class="section-intro">Python has become one of the world's most popular programming languages, and for good reason. Its philosophy of readability and simplicity ("There should be one‚Äîand preferably only one‚Äîobvious way to do it") makes it excellent for beginners, while its powerful features and vast ecosystem make it a favorite among professionals. From web development to data science, machine learning to automation, Python does it all. Let's dive deep into what makes Python special and how to master it.</p>

            <h3>Why Python Is Powerful</h3>
            <p>Python's strength comes from several key factors that set it apart:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üéØ Readable Syntax</h4>
                    <p>Python reads almost like English. <span class="inline-code">if user.is_authenticated:</span> is self-documenting. The forced indentation creates visually clean code.</p>
                </div>
                <div class="card">
                    <h4>üîã Batteries Included</h4>
                    <p>Massive standard library covers everything from file I/O to web servers to data structures. Third-party ecosystem (PyPI) has 400,000+ packages.</p>
                </div>
                <div class="card">
                    <h4>üöÄ Rapid Development</h4>
                    <p>Dynamic typing, no compilation step, and concise syntax mean you can prototype and iterate incredibly fast. Perfect for MVPs and experimentation.</p>
                </div>
                <div class="card">
                    <h4>üåê Versatile</h4>
                    <p>Web backends (Django, Flask), data science (pandas, NumPy), ML (TensorFlow, PyTorch), automation, scripting, game development‚ÄîPython does it all.</p>
                </div>
            </div>

            <h3>Python Syntax Mastery</h3>
            <p>Let's cover Python-specific syntax features that make it unique and powerful:</p>

            <h4>List Comprehensions: Elegant Data Transformation</h4>
            <p>List comprehensions are a Pythonic way to create lists based on existing lists or iterables. They're more concise and often faster than traditional loops.</p>

            <div class="code"># Traditional loop
squares = []
for i in range(10):
    squares.append(i ** 2)

# List comprehension - more Pythonic
squares = [i ** 2 for i in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# With condition
even_squares = [i ** 2 for i in range(10) if i % 2 == 0]
# [0, 4, 16, 36, 64]

# Nested comprehensions
matrix = [[i * j for j in range(3)] for i in range(3)]
# [[0, 0, 0], [0, 1, 2], [0, 2, 4]]

# Dictionary comprehension
squared_dict = {i: i ** 2 for i in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Set comprehension
unique_lengths = {len(word) for word in ['hello', 'world', 'python', 'code']}
# {4, 5, 6}</div>

            <h4>Generators: Memory-Efficient Iteration</h4>
            <p>Generators produce values lazily (on-demand) rather than storing them all in memory. Crucial for working with large datasets.</p>

            <div class="code"># Regular function returns list (all values in memory)
def get_numbers(n):
    numbers = []
    for i in range(n):
        numbers.append(i ** 2)
    return numbers

# Generator function yields values one at a time
def get_numbers_gen(n):
    for i in range(n):
        yield i ** 2

# Usage
for num in get_numbers_gen(1000000):  # No memory spike!
    if num > 1000:
        break

# Generator expression (like list comprehension but lazy)
gen = (i ** 2 for i in range(1000000))  # Note: parentheses, not brackets
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 4</div>

            <div class="metaphor-box">
                <h4>Generators Are Like Streaming Video</h4>
                <p>A list is like downloading the entire movie before watching‚Äîtakes time and space. A generator is like streaming‚Äîyou get frames as you need them, no need to store the whole movie in memory. Perfect for large datasets or infinite sequences.</p>
            </div>

            <h4>Decorators: Modifying Function Behavior</h4>
            <p>Decorators are functions that wrap other functions, adding functionality before or after the original function runs. They use the <span class="inline-code">@decorator_name</span> syntax.</p>

            <div class="code">import time

# Simple decorator
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    return "Done"

slow_function()  # Prints: slow_function took 2.0001 seconds

# Decorator with arguments
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # Prints "Hello, Alice!" three times

# Common built-in decorators
class MyClass:
    @staticmethod
    def static_method():
        print("No self or cls parameter")
    
    @classmethod
    def class_method(cls):
        print(f"Class method of {cls}")
    
    @property
    def my_property(self):
        return self._value
    
    @my_property.setter
    def my_property(self, value):
        self._value = value</div>

            <h4>Context Managers: Resource Management</h4>
            <p>Context managers ensure proper resource acquisition and release, even if exceptions occur. The <span class="inline-code">with</span> statement is the key.</p>

            <div class="code"># Without context manager - dangerous!
file = open('data.txt', 'r')
data = file.read()
file.close()  # What if an exception occurs before this?

# With context manager - safe!
with open('data.txt', 'r') as file:
    data = file.read()
# File automatically closed, even if exception occurs

# Creating custom context managers
class DatabaseConnection:
    def __enter__(self):
        print("Opening database connection")
        self.conn = "Connected"
        return self.conn
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing database connection")
        self.conn = None
        return False  # Don't suppress exceptions

with DatabaseConnection() as conn:
    print(f"Using connection: {conn}")
# Output:
# Opening database connection
# Using connection: Connected
# Closing database connection

# Using contextlib for simple cases
from contextlib import contextmanager

@contextmanager
def temporary_value(var, temp_val):
    original = var.copy()
    var.update(temp_val)
    try:
        yield var
    finally:
        var.clear()
        var.update(original)</div>

            <h3>Python's Object Model</h3>
            <p>Everything in Python is an object‚Äîeven functions, classes, and modules. Understanding this is key to mastering Python.</p>

            <h4>Classes and Objects</h4>
            <div class="code">class Dog:
    # Class variable (shared by all instances)
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        # Instance variables (unique to each instance)
        self.name = name
        self.age = age
    
    def bark(self):
        return f"{self.name} says Woof!"
    
    def __str__(self):
        return f"{self.name} is {self.age} years old"
    
    def __repr__(self):
        return f"Dog(name='{self.name}', age={self.age})"

# Creating instances
dog1 = Dog("Rex", 5)
dog2 = Dog("Buddy", 3)

print(dog1.bark())  # Rex says Woof!
print(dog1)  # Rex is 5 years old
print(repr(dog1))  # Dog(name='Rex', age=5)

# Inheritance
class GoldenRetriever(Dog):
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def fetch(self):
        return f"{self.name} fetches the ball!"

golden = GoldenRetriever("Buddy", 3, "golden")
print(golden.bark())  # Buddy says Woof! (inherited)
print(golden.fetch())  # Buddy fetches the ball!</div>

            <h4>Magic Methods (Dunder Methods)</h4>
            <p>Python's "magic methods" (double underscore methods) let you define how objects behave with built-in operations.</p>

            <div class="code">class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __len__(self):
        return int((self.x ** 2 + self.y ** 2) ** 0.5)
    
    def __getitem__(self, index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        else:
            raise IndexError("Vector index out of range")

v1 = Vector(2, 3)
v2 = Vector(4, 5)

print(v1 + v2)  # Vector(6, 8)
print(v1 * 3)  # Vector(6, 9)
print(len(v1))  # 3 (approximately)
print(v1[0])  # 2</div>

            <h3>Standard Library Essentials</h3>
            <p>Python's standard library is massive. Here are the most important modules:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>os & pathlib</h4>
                    <div class="code">import os
from pathlib import Path

# Get current directory
print(os.getcwd())

# List files
for file in os.listdir('.'):
    print(file)

# Modern path handling
path = Path('data/file.txt')
if path.exists():
    content = path.read_text()</div>
                </div>
                <div class="card">
                    <h4>collections</h4>
                    <div class="code">from collections import (
    Counter, defaultdict, 
    deque, namedtuple
)

# Count occurrences
counter = Counter(['a','b','a','c','b','a'])
print(counter.most_common(2))

# Dict with default values
d = defaultdict(list)
d['key'].append('value')  # No KeyError!

# Named tuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)</div>
                </div>
                <div class="card">
                    <h4>itertools</h4>
                    <div class="code">from itertools import (
    chain, combinations,
    permutations, product
)

# Chain iterables
combined = chain([1,2], [3,4])

# Combinations
combos = combinations([1,2,3], 2)
# [(1,2), (1,3), (2,3)]

# Cartesian product
prod = product([1,2], ['a','b'])
# [(1,'a'), (1,'b'), (2,'a'), (2,'b')]</div>
                </div>
                <div class="card">
                    <h4>json & pickle</h4>
                    <div class="code">import json
import pickle

# JSON for interoperability
data = {'name': 'Alice', 'age': 30}
json_str = json.dumps(data)
parsed = json.loads(json_str)

# Pickle for Python objects
with open('data.pkl', 'wb') as f:
    pickle.dump(data, f)

with open('data.pkl', 'rb') as f:
    loaded = pickle.load(f)</div>
                </div>
            </div>

            <h3>Virtual Environments and Package Management</h3>
            <p>Python projects should use virtual environments to isolate dependencies and avoid conflicts.</p>

            <div class="code"># Create virtual environment
python -m venv myenv

# Activate (Windows)
myenv\Scripts\activate

# Activate (Unix/Mac)
source myenv/bin/activate

# Install packages
pip install requests pandas numpy

# Save dependencies
pip freeze > requirements.txt

# Install from requirements
pip install -r requirements.txt

# Deactivate
deactivate</div>

            <div class="info-box">
                <h4>üîß Modern Python Tools</h4>
                <p><strong>pip:</strong> Default package installer<br>
                <strong>virtualenv/venv:</strong> Virtual environments<br>
                <strong>pipenv:</strong> Combines pip and venv, manages Pipfile<br>
                <strong>poetry:</strong> Modern dependency management and packaging<br>
                <strong>conda:</strong> Environment and package manager (especially for data science)</p>
            </div>

            <h3>Type Hints: Optional Static Typing</h3>
            <p>Python 3.5+ supports optional type hints. They don't enforce types at runtime but enable better IDE support and type checking with tools like mypy.</p>

            <div class="code">from typing import List, Dict, Optional, Union, Tuple

def greet(name: str) -> str:
    return f"Hello, {name}!"

def process_items(items: List[int]) -> int:
    return sum(items)

def find_user(user_id: int) -> Optional[Dict[str, str]]:
    # Returns user dict or None
    if user_id == 1:
        return {"name": "Alice", "email": "alice@example.com"}
    return None

def parse_value(value: Union[int, str]) -> int:
    if isinstance(value, int):
        return value
    return int(value)

# Complex types
def get_coordinates() -> Tuple[float, float]:
    return (40.7128, -74.0060)

# Generic types
from typing import TypeVar, Generic

T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self) -> None:
        self.items: List[T] = []
    
    def push(self, item: T) -> None:
        self.items.append(item)
    
    def pop(self) -> T:
        return self.items.pop()</div>

            <h3>Async/Await: Asynchronous Programming</h3>
            <p>Python's <span class="inline-code">async</span>/<span class="inline-code">await</span> syntax enables efficient concurrent I/O operations.</p>

            <div class="code">import asyncio

# Synchronous - slow
def fetch_data(url):
    time.sleep(2)  # Simulating network request
    return f"Data from {url}"

# Asynchronous - fast!
async def fetch_data_async(url):
    await asyncio.sleep(2)  # Non-blocking sleep
    return f"Data from {url}"

async def main():
    # Run multiple requests concurrently
    tasks = [
        fetch_data_async("url1"),
        fetch_data_async("url2"),
        fetch_data_async("url3")
    ]
    results = await asyncio.gather(*tasks)
    # All 3 complete in ~2 seconds total, not 6!
    print(results)

# Run the async function
asyncio.run(main())</div>

            <h3>Common Python Patterns and Idioms</h3>
            <p>Writing Pythonic code means following community conventions:</p>

            <div class="code"># Swapping variables
a, b = b, a

# Multiple assignment
x, y, z = 1, 2, 3

# Unpacking
first, *rest, last = [1, 2, 3, 4, 5]
# first=1, rest=[2,3,4], last=5

# Enumerate instead of range(len())
for i, item in enumerate(['a', 'b', 'c']):
    print(f"{i}: {item}")

# Zip for parallel iteration
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
for name, age in zip(names, ages):
    print(f"{name} is {age}")

# Dictionary get with default
value = my_dict.get('key', 'default')

# Checking if list is empty (Pythonic)
if my_list:  # Not: if len(my_list) > 0
    print("List has items")

# String joining
words = ['Python', 'is', 'awesome']
sentence = ' '.join(words)  # Not: string concatenation in loop

# List slicing
numbers = [0, 1, 2, 3, 4, 5]
print(numbers[2:5])  # [2, 3, 4]
print(numbers[::2])  # [0, 2, 4] (every 2nd)
print(numbers[::-1])  # [5, 4, 3, 2, 1, 0] (reversed)</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Common Python Pitfalls</h4>
                <p><strong>Mutable default arguments:</strong> Don't use <span class="inline-code">def func(items=[]):</span> ‚Äî the list is shared across calls!<br><br>
                <strong>Late binding in closures:</strong> Loop variables in lambdas bind at execution, not definition.<br><br>
                <strong>Shallow vs deep copy:</strong> <span class="inline-code">list2 = list1</span> doesn't copy‚Äîuse <span class="inline-code">list2 = list1.copy()</span> or <span class="inline-code">copy.deepcopy()</span> for nested structures.</p>
            </div>

            <h3>When to Use Python</h3>
            <ul>
                <li><strong>‚úÖ Great for:</strong> Web backends (Django, Flask), data science/ML, automation, scripting, prototyping, APIs</li>
                <li><strong>‚ùå Not ideal for:</strong> Mobile apps (limited support), high-performance computing (use C/Rust with Python bindings), desktop GUIs (though PyQt exists)</li>
            </ul>

            <p>Python's philosophy‚Äî"simple is better than complex," "readability counts"‚Äîmakes it an excellent first language and a powerful tool for professionals. Its vast ecosystem means there's a library for almost anything you want to build. Master Python, and you'll have a versatile tool that opens doors across many domains of programming.</p>
        </section>

        <section class="section" id="javascript-deep">
            <h2 class="section-title">JavaScript Deep Dive</h2>
            <p class="section-intro">JavaScript started as a simple scripting language for web browsers and has evolved into one of the most versatile languages in existence. It now powers frontends (React, Vue, Angular), backends (Node.js), mobile apps (React Native), desktop apps (Electron), and more. Understanding JavaScript deeply‚Äîespecially its quirks and async nature‚Äîis essential for modern web development. Let's explore what makes JavaScript unique and powerful.</p>

            <h3>JavaScript Fundamentals</h3>
            <p>JavaScript has some unique characteristics that differentiate it from other languages:</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üåê Runs Everywhere</h4>
                    <p>Every browser has a JavaScript engine. Node.js brings it to servers. It's the only language that runs natively in browsers, making it indispensable for web development.</p>
                </div>
                <div class="card">
                    <h4>‚ö° Event-Driven</h4>
                    <p>Built around events and callbacks. Perfect for handling user interactions, network requests, and other asynchronous operations without blocking.</p>
                </div>
                <div class="card">
                    <h4>üîÑ Dynamic & Flexible</h4>
                    <p>Dynamically typed, first-class functions, prototypal inheritance. You can modify objects at runtime, add properties dynamically, and treat functions as data.</p>
                </div>
                <div class="card">
                    <h4>üì¶ Huge Ecosystem</h4>
                    <p>NPM (Node Package Manager) has over 2 million packages. Whatever you need to build, there's probably a library for it.</p>
                </div>
            </div>

            <h3>The Event Loop and Async Programming</h3>
            <p>JavaScript is single-threaded but handles asynchronous operations elegantly through the event loop. This is critical to understand for writing efficient JavaScript.</p>

            <div class="metaphor-box">
                <h4>The Restaurant Waiter Metaphor</h4>
                <p>Imagine a restaurant with one waiter (single thread). The waiter takes Order 1, sends it to the kitchen, then takes Order 2 (doesn't wait for kitchen). When kitchen finishes Order 1, they ring a bell (event), and the waiter delivers it. The waiter never stops‚Äîalways taking orders or delivering food‚Äînever blocked waiting. That's the event loop: non-blocking I/O through callbacks.</p>
            </div>

            <h4>Call Stack, Web APIs, and Event Loop</h4>
            <div class="code">console.log('Start');

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise callback');
});

console.log('End');

// Output:
// Start
// End
// Promise callback
// Timeout callback

// Why this order?
// 1. Synchronous code runs first (Start, End)
// 2. Promises (microtasks) run before setTimeout (macrotasks)
// 3. Event loop processes callback queue</div>

            <div class="info-box">
                <h4>üîÑ Event Loop Components</h4>
                <p><strong>Call Stack:</strong> Where function calls are executed<br>
                <strong>Web APIs:</strong> Browser features (setTimeout, fetch, DOM events)<br>
                <strong>Callback Queue:</strong> Where callbacks wait to be executed<br>
                <strong>Microtask Queue:</strong> Priority queue for Promises<br>
                <strong>Event Loop:</strong> Continuously checks if call stack is empty, then pushes callbacks from queue</p>
            </div>

            <h3>Promises: Taming Async Code</h3>
            <p>Promises represent the eventual result of an asynchronous operation. They solve "callback hell" and make async code more readable.</p>

            <div class="code">// Callback hell (bad)
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                console.log('Finally done!');
            });
        });
    });
});

// Promises (better)
getData()
    .then(a => getMoreData(a))
    .then(b => getMoreData(b))
    .then(c => getMoreData(c))
    .then(d => console.log('Done!'))
    .catch(error => console.error(error));

// Creating Promises
const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        const success = true;
        if (success) {
            resolve('Operation successful!');
        } else {
            reject('Operation failed!');
        }
    }, 1000);
});

myPromise
    .then(result => console.log(result))
    .catch(error => console.error(error));

// Promise methods
Promise.all([promise1, promise2, promise3])
    .then(results => console.log(results));  // All must succeed

Promise.race([promise1, promise2, promise3])
    .then(result => console.log(result));  // First to complete wins

Promise.allSettled([promise1, promise2, promise3])
    .then(results => console.log(results));  // Wait for all, even failures</div>

            <h3>Async/Await: Synchronous-Looking Async Code</h3>
            <p>Async/await is syntactic sugar over Promises, making asynchronous code look synchronous and easier to read.</p>

            <div class="code">// With Promises
function fetchUserData() {
    return fetch('/api/user')
        .then(response => response.json())
        .then(user => {
            return fetch(`/api/posts/${user.id}`);
        })
        .then(response => response.json())
        .then(posts => {
            console.log(posts);
        })
        .catch(error => console.error(error));
}

// With async/await (much cleaner!)
async function fetchUserData() {
    try {
        const userResponse = await fetch('/api/user');
        const user = await userResponse.json();
        
        const postsResponse = await fetch(`/api/posts/${user.id}`);
        const posts = await postsResponse.json();
        
        console.log(posts);
    } catch (error) {
        console.error(error);
    }
}

// Parallel execution with async/await
async function fetchMultiple() {
    // Sequential (slow - 6 seconds total)
    const user1 = await fetchUser(1);  // 2 seconds
    const user2 = await fetchUser(2);  // 2 seconds
    const user3 = await fetchUser(3);  // 2 seconds
    
    // Parallel (fast - 2 seconds total)
    const [user1, user2, user3] = await Promise.all([
        fetchUser(1),
        fetchUser(2),
        fetchUser(3)
    ]);
}

// Error handling
async function riskyOperation() {
    try {
        const result = await mightFail();
        return result;
    } catch (error) {
        console.error('Operation failed:', error);
        throw error;  // Re-throw if needed
    } finally {
        console.log('Cleanup happens here');
    }
}</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Async/Await Gotchas</h4>
                <p><strong>Forgot await:</strong> Without <span class="inline-code">await</span>, you get a Promise, not the value!<br><br>
                <strong>Sequential when should be parallel:</strong> Don't await inside a loop if operations can run concurrently‚Äîuse <span class="inline-code">Promise.all()</span>.<br><br>
                <strong>Error handling:</strong> Always use try/catch with await, or unhandled rejections will crash Node.js.</p>
            </div>

            <h3>Closures and Scope</h3>
            <p>Closures are one of JavaScript's most powerful and misunderstood features. A closure is a function that has access to variables from its outer (enclosing) scope, even after that outer function has returned.</p>

            <div class="code">// Basic closure
function outer() {
    const outerVar = 'I am outside';
    
    function inner() {
        console.log(outerVar);  // Can access outerVar
    }
    
    return inner;
}

const closureFunc = outer();
closureFunc();  // Logs: "I am outside"
// outer() has returned, but inner() still has access to outerVar!

// Practical example: Private variables
function createCounter() {
    let count = 0;  // Private variable
    
    return {
        increment() {
            count++;
            return count;
        },
        decrement() {
            count--;
            return count;
        },
        getCount() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getCount());   // 2
// No way to access 'count' directly - it's private!

// Common closure pitfall with loops
for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100);
}
// Logs: 5 5 5 5 5 (not 0 1 2 3 4!)
// Why? 'var' is function-scoped, not block-scoped

// Solution 1: Use 'let' (block-scoped)
for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 100);
}
// Logs: 0 1 2 3 4 (correct!)

// Solution 2: IIFE to create closure
for (var i = 0; i < 5; i++) {
    ((j) => {
        setTimeout(() => console.log(j), 100);
    })(i);
}
// Logs: 0 1 2 3 4</div>

            <h4>Scope Types in JavaScript</h4>
            <ul>
                <li><strong>Global Scope:</strong> Variables accessible everywhere</li>
                <li><strong>Function Scope:</strong> Variables declared with <span class="inline-code">var</span> inside a function</li>
                <li><strong>Block Scope:</strong> Variables declared with <span class="inline-code">let</span>/<span class="inline-code">const</span> inside <span class="inline-code">{}</span></li>
                <li><strong>Lexical Scope:</strong> Inner functions have access to outer function variables</li>
            </ul>

            <h3>Prototypes vs Classes</h3>
            <p>JavaScript uses prototypal inheritance, not classical inheritance. ES6 introduced <span class="inline-code">class</span> syntax, but it's syntactic sugar over prototypes.</p>

            <h4>Prototypes (Traditional)</h4>
            <div class="code">// Constructor function
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Methods on prototype (shared by all instances)
Person.prototype.greet = function() {
    return `Hello, I'm ${this.name}`;
};

const alice = new Person('Alice', 30);
console.log(alice.greet());  // Hello, I'm Alice

// Prototype chain
console.log(alice.__proto__ === Person.prototype);  // true
console.log(Person.prototype.__proto__ === Object.prototype);  // true

// Inheritance with prototypes
function Employee(name, age, job) {
    Person.call(this, name, age);  // Call parent constructor
    this.job = job;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

Employee.prototype.work = function() {
    return `${this.name} is working as a ${this.job}`;
};

const bob = new Employee('Bob', 25, 'Developer');
console.log(bob.greet());  // Hello, I'm Bob (inherited)
console.log(bob.work());   // Bob is working as a Developer</div>

            <h4>Classes (Modern ES6+)</h4>
            <div class="code">// Class syntax (much cleaner!)
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // Static method
    static species() {
        return 'Homo sapiens';
    }
}

class Employee extends Person {
    constructor(name, age, job) {
        super(name, age);  // Call parent constructor
        this.job = job;
    }
    
    work() {
        return `${this.name} is working as a ${this.job}`;
    }
    
    // Method overriding
    greet() {
        return `${super.greet()}, and I'm a ${this.job}`;
    }
}

const employee = new Employee('Alice', 30, 'Engineer');
console.log(employee.greet());  // Hello, I'm Alice, and I'm an Engineer
console.log(employee.work());   // Alice is working as an Engineer
console.log(Person.species());  // Homo sapiens

// Under the hood, classes are still prototype-based!
console.log(typeof Person);  // function
console.log(employee instanceof Person);  // true</div>

            <h3>Modern ES6+ Features</h3>
            <p>ES6 (ES2015) and later versions added powerful features that make JavaScript more expressive:</p>

            <div class="code">// Destructuring
const person = { name: 'Alice', age: 30, city: 'NYC' };
const { name, age } = person;
const { name: personName, age: personAge } = person;  // Rename

const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;

// Spread operator
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];  // [1,2,3,4,5,6]

const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, ...obj1 };  // {c: 3, a: 1, b: 2}

// Rest parameters
function sum(...numbers) {
    return numbers.reduce((total, n) => total + n, 0);
}
console.log(sum(1, 2, 3, 4));  // 10

// Arrow functions
const double = (x) => x * 2;
const add = (a, b) => a + b;
const greet = name => `Hello, ${name}`;

// Arrow functions don't have their own 'this'
const obj = {
    value: 42,
    regularFunc: function() {
        console.log(this.value);  // 42
    },
    arrowFunc: () => {
        console.log(this.value);  // undefined (lexical 'this')
    }
};

// Template literals
const name = 'Alice';
const age = 30;
const message = `Hello, ${name}! You are ${age} years old.`;
const multiline = `
    This is
    a multiline
    string
`;

// Optional chaining
const user = { profile: { name: 'Alice' } };
console.log(user?.profile?.name);  // Alice
console.log(user?.settings?.theme);  // undefined (no error!)

// Nullish coalescing
const value = null ?? 'default';  // 'default'
const value2 = 0 ?? 'default';    // 0 (not 'default' - only null/undefined trigger ??)

// Default parameters
function greet(name = 'Guest', greeting = 'Hello') {
    return `${greeting}, ${name}!`;
}

// Object shorthand
const x = 10, y = 20;
const point = { x, y };  // Same as { x: x, y: y }

// Computed property names
const key = 'dynamicKey';
const obj = { [key]: 'value' };  // { dynamicKey: 'value' }</div>

            <h3>DOM Manipulation</h3>
            <p>JavaScript's original purpose: manipulating the Document Object Model (DOM) in web browsers.</p>

            <div class="code">// Selecting elements
const element = document.getElementById('myId');
const elements = document.getElementsByClassName('myClass');
const element = document.querySelector('.myClass');  // First match
const elements = document.querySelectorAll('.myClass');  // All matches

// Creating and modifying elements
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello, World!';
newDiv.className = 'my-class';
newDiv.style.color = 'blue';

document.body.appendChild(newDiv);

// Event listeners
button.addEventListener('click', function(event) {
    console.log('Button clicked!');
    event.preventDefault();  // Prevent default behavior
});

// Modern event delegation
document.body.addEventListener('click', function(event) {
    if (event.target.matches('.my-button')) {
        console.log('Button clicked!');
    }
});

// Modifying styles
element.style.backgroundColor = 'red';
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');

// Getting/setting attributes
const value = element.getAttribute('data-value');
element.setAttribute('data-value', 'new-value');

// Removing elements
element.remove();  // Modern
parent.removeChild(element);  // Old way</div>

            <h3>Node.js Basics</h3>
            <p>Node.js brings JavaScript to the server, enabling full-stack JavaScript development.</p>

            <div class="code">// Simple HTTP server
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Hello, World!');
});

server.listen(3000, () => {
    console.log('Server running on port 3000');
});

// File system operations
const fs = require('fs').promises;

async function readFile() {
    const content = await fs.readFile('file.txt', 'utf8');
    console.log(content);
}

async function writeFile() {
    await fs.writeFile('output.txt', 'Hello, World!');
}

// Module exports (CommonJS)
// math.js
module.exports = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
};

// app.js
const math = require('./math');
console.log(math.add(5, 3));

// ES Modules (modern)
// math.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// app.js
import { add, subtract } from './math.js';
console.log(add(5, 3));</div>

            <h3>NPM: Node Package Manager</h3>
            <div class="code"># Initialize project
npm init -y

# Install dependencies
npm install express
npm install --save-dev jest

# Install globally
npm install -g nodemon

# Run scripts (defined in package.json)
npm start
npm test
npm run build

# package.json scripts example
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  }
}</div>

            <h3>When to Use JavaScript</h3>
            <ul>
                <li><strong>‚úÖ Mandatory for:</strong> Frontend web development, browser-based applications</li>
                <li><strong>‚úÖ Great for:</strong> Full-stack web apps (MERN/MEAN stack), real-time applications, SPAs, APIs, serverless functions</li>
                <li><strong>‚ùå Not ideal for:</strong> CPU-intensive tasks (use WebAssembly or other languages), systems programming</li>
            </ul>

            <p>JavaScript's evolution from simple browser scripts to a full-featured language powering both frontend and backend is remarkable. Its async capabilities, vast ecosystem, and ubiquity make it an essential language for any developer. Master JavaScript‚Äîespecially closures, promises, and the event loop‚Äîand you'll be able to build virtually any web application.</p>
        </section>

        <section class="section" id="c-cpp-deep">
            <h2 class="section-title">C/C++ Deep Dive</h2>
            <p class="section-intro">C and C++ are the languages of systems programming‚Äîoperating systems, game engines, databases, embedded systems, and performance-critical applications are built with these languages. They give you direct control over hardware and memory, which is both powerful and dangerous. Understanding C/C++ teaches you how computers actually work at a low level, making you a better programmer in any language. Let's explore pointers, memory management, and why these languages are still essential decades after their creation.</p>

            <h3>Why C and C++ Matter</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>‚ö° Maximum Performance</h4>
                    <p>No garbage collector, minimal runtime overhead. You control every byte of memory and every CPU cycle. Used when speed is critical: games, operating systems, real-time systems.</p>
                </div>
                <div class="card">
                    <h4>üîß Low-Level Control</h4>
                    <p>Direct memory access via pointers. Inline assembly if needed. Perfect for embedded systems, device drivers, and hardware interaction.</p>
                </div>
                <div class="card">
                    <h4>üìö Legacy and Ubiquity</h4>
                    <p>Linux kernel, Windows, Python interpreter, game engines (Unreal, Unity), databases (MySQL, PostgreSQL)‚Äîall written in C/C++. Understanding them unlocks understanding of foundational software.</p>
                </div>
                <div class="card">
                    <h4>üéì Educational Value</h4>
                    <p>Forces you to understand memory, pointers, compilation, linking. Makes you appreciate higher-level languages and understand their performance tradeoffs.</p>
                </div>
            </div>

            <h3>Memory Management: Stack vs Heap</h3>
            <p>In C/C++, memory is divided into two main areas: the stack and the heap. Understanding this is fundamental.</p>

            <div class="metaphor-box">
                <h4>Stack vs Heap: The Office Metaphor</h4>
                <p><strong>Stack:</strong> Your desk. Fast, organized, automatic cleanup. Local variables live here. When function ends, desk is cleared (memory freed automatically). Limited space‚Äîstack overflow if too much.<br><br>
                <strong>Heap:</strong> The warehouse. Large space for long-term storage. You manually allocate and must remember to free. Slower access than desk. Memory leaks if you forget to clean up.</p>
            </div>

            <div class="code">// Stack allocation (automatic)
void function() {
    int x = 10;           // On stack
    char buffer[100];     // On stack
    // When function returns, x and buffer are automatically destroyed
}

// Heap allocation (manual - C)
void function() {
    int* ptr = (int*)malloc(sizeof(int) * 100);  // Allocate 100 ints on heap
    if (ptr == NULL) {
        // Allocation failed!
        return;
    }
    
    ptr[0] = 42;
    // Use the memory...
    
    free(ptr);  // MUST free manually or memory leak!
}

// Heap allocation (C++)
void function() {
    int* ptr = new int[100];  // Allocate 100 ints
    ptr[0] = 42;
    delete[] ptr;  // MUST delete or memory leak!
    
    // Single object
    int* single = new int(42);
    delete single;
}</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Common Memory Errors</h4>
                <p><strong>Memory leak:</strong> Allocating memory and never freeing it. Program uses more and more memory until crash.<br><br>
                <strong>Dangling pointer:</strong> Using a pointer after its memory has been freed. Undefined behavior, often segfault.<br><br>
                <strong>Double free:</strong> Freeing the same memory twice. Corrupts heap, crashes program.<br><br>
                <strong>Buffer overflow:</strong> Writing beyond allocated memory. Can overwrite other data, security vulnerability.</p>
            </div>

            <h3>Pointers: The Power and The Danger</h3>
            <p>Pointers are variables that store memory addresses. They're powerful but error-prone.</p>

            <div class="code">// Pointer basics
int x = 42;
int* ptr = &x;   // ptr stores the address of x
int value = *ptr;  // Dereference: get the value at the address (42)

*ptr = 100;  // Modify x through the pointer
// x is now 100

// Pointer arithmetic
int arr[5] = {10, 20, 30, 40, 50};
int* p = arr;  // Array name decays to pointer to first element

printf("%d\n", *p);      // 10 (first element)
printf("%d\n", *(p+1));  // 20 (second element)
printf("%d\n", p[2]);    // 30 (same as *(p+2))

// Pointers and functions (pass by reference)
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int x = 5, y = 10;
swap(&x, &y);  // Pass addresses
// x is now 10, y is 5

// NULL pointer
int* ptr = NULL;  // Pointer to nowhere
if (ptr != NULL) {
    *ptr = 42;  // Safe to dereference
}

// Common pointer errors
int* danglingPointer() {
    int x = 42;
    return &x;  // BAD! x is on stack, destroyed when function returns
}

int* ptr;
*ptr = 42;  // BAD! ptr is uninitialized, points to random memory</div>

            <h3>References (C++ Only)</h3>
            <p>C++ introduces references: aliases for existing variables. Safer than pointers but less flexible.</p>

            <div class="code">// Reference basics
int x = 42;
int& ref = x;  // ref is an alias for x

ref = 100;  // Modifies x
// x is now 100

// References in functions (cleaner than pointers)
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int x = 5, y = 10;
swap(x, y);  // No & needed when calling!
// x is now 10, y is 5

// Differences: Pointers vs References
// Pointers can be reassigned, references cannot
int* ptr = &x;
ptr = &y;  // OK, now points to y

int& ref = x;
ref = y;  // Does NOT make ref refer to y, it assigns y's value to x!

// Pointers can be NULL, references must always refer to something
int* ptr = nullptr;  // OK
int& ref;  // ERROR: must be initialized</div>

            <h3>The Compilation Process</h3>
            <p>Unlike interpreted languages, C/C++ code goes through multiple stages before becoming an executable:</p>

            <div class="info-box">
                <h4>üîß Compilation Stages</h4>
                <p><strong>1. Preprocessing:</strong> Handles #include, #define, etc. Expands macros and includes headers.<br>
                <strong>2. Compilation:</strong> Translates C/C++ code to assembly, then to object files (.o or .obj).<br>
                <strong>3. Linking:</strong> Combines object files and libraries into final executable.<br>
                <strong>4. Execution:</strong> Operating system loads executable into memory and runs it.</p>
            </div>

            <div class="code"># Compile and link in one step
gcc main.c -o program
g++ main.cpp -o program

# Separate compilation and linking
gcc -c file1.c  # Creates file1.o
gcc -c file2.c  # Creates file2.o
gcc file1.o file2.o -o program  # Link

# With optimizations
gcc -O2 main.c -o program  # -O2 for moderate optimization
gcc -O3 main.c -o program  # -O3 for aggressive optimization

# With debugging info
gcc -g main.c -o program  # Include debug symbols for gdb</div>

            <h3>Header Files and Includes</h3>
            <div class="code">// math_utils.h (header file - declarations)
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);
int multiply(int a, int b);

#endif

// math_utils.c (implementation file - definitions)
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

// main.c (using the header)
#include <stdio.h>
#include "math_utils.h"

int main() {
    int result = add(5, 3);
    printf("Result: %d\n", result);
    return 0;
}</div>

            <h3>C++ Classes and OOP</h3>
            <p>C++ adds object-oriented programming to C, with classes, inheritance, polymorphism, and more.</p>

            <div class="code">// Simple class
class Rectangle {
private:
    int width, height;
    
public:
    // Constructor
    Rectangle(int w, int h) : width(w), height(h) {}
    
    // Member functions
    int area() const {
        return width * height;
    }
    
    void resize(int w, int h) {
        width = w;
        height = h;
    }
    
    // Destructor
    ~Rectangle() {
        // Cleanup code here
    }
};

// Usage
Rectangle rect(10, 5);
int a = rect.area();  // 50
rect.resize(20, 10);

// Inheritance
class Square : public Rectangle {
public:
    Square(int size) : Rectangle(size, size) {}
};

// Polymorphism
class Shape {
public:
    virtual double area() const = 0;  // Pure virtual (abstract)
    virtual ~Shape() {}
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
};

// Using polymorphism
Shape* shape = new Circle(5.0);
double a = shape->area();  // Calls Circle::area()
delete shape;</div>

            <h3>RAII: Resource Acquisition Is Initialization</h3>
            <p>A core C++ idiom: tie resource lifetime to object lifetime. When object is destroyed, resource is automatically freed.</p>

            <div class="code">// Manual memory management (bad)
void badExample() {
    int* data = new int[100];
    
    // ... code that might throw exception or return early ...
    
    delete[] data;  // Might not be reached!
}

// RAII with smart pointers (good)
#include <memory>

void goodExample() {
    std::unique_ptr<int[]> data(new int[100]);
    
    // ... code that might throw exception or return early ...
    
    // data is automatically deleted when it goes out of scope!
}

// Smart pointer types
std::unique_ptr<int> ptr1(new int(42));  // Unique ownership, can't be copied
std::shared_ptr<int> ptr2 = std::make_shared<int>(42);  // Shared ownership, reference counted
std::weak_ptr<int> ptr3 = ptr2;  // Non-owning reference (prevents cycles)

// File RAII
class FileHandler {
private:
    FILE* file;
public:
    FileHandler(const char* filename) {
        file = fopen(filename, "r");
    }
    
    ~FileHandler() {
        if (file) fclose(file);  // Always closes, even on exception
    }
    
    // Delete copy constructor (prevent copying)
    FileHandler(const FileHandler&) = delete;
};</div>

            <h3>Templates: Generic Programming</h3>
            <p>Templates allow you to write generic, type-independent code‚Äîthe foundation of the C++ Standard Library.</p>

            <div class="code">// Function template
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int x = max(5, 10);        // T is int
double y = max(3.5, 2.1);  // T is double

// Class template
template<typename T>
class Stack {
private:
    T* data;
    int top;
    int capacity;
    
public:
    Stack(int size) : top(-1), capacity(size) {
        data = new T[size];
    }
    
    ~Stack() {
        delete[] data;
    }
    
    void push(const T& item) {
        if (top < capacity - 1) {
            data[++top] = item;
        }
    }
    
    T pop() {
        if (top >= 0) {
            return data[top--];
        }
        throw std::runtime_error("Stack underflow");
    }
};

// Usage
Stack<int> intStack(100);
intStack.push(42);
int value = intStack.pop();

Stack<std::string> stringStack(50);
stringStack.push("Hello");
std::string str = stringStack.pop();</div>

            <h3>The Standard Template Library (STL)</h3>
            <p>The STL provides generic containers, algorithms, and iterators‚Äîessential for modern C++.</p>

            <div class="code">#include <vector>
#include <map>
#include <algorithm>
#include <string>

// Vector (dynamic array)
std::vector<int> vec;
vec.push_back(10);
vec.push_back(20);
int first = vec[0];
int size = vec.size();

// Iterating
for (int num : vec) {
    std::cout << num << std::endl;
}

// Map (hash map / dictionary)
std::map<std::string, int> ages;
ages["Alice"] = 30;
ages["Bob"] = 25;
int aliceAge = ages["Alice"];

// Algorithms
std::vector<int> numbers = {5, 2, 8, 1, 9};
std::sort(numbers.begin(), numbers.end());  // Sort in-place
auto it = std::find(numbers.begin(), numbers.end(), 8);  // Find element
int count = std::count_if(numbers.begin(), numbers.end(), 
                          [](int n) { return n > 5; });  // Count with lambda</div>

            <h3>When to Use C/C++</h3>
            <ul>
                <li><strong>‚úÖ Essential for:</strong> Operating systems, device drivers, embedded systems, game engines, performance-critical code</li>
                <li><strong>‚úÖ Great for:</strong> High-performance applications, real-time systems, systems programming, learning computer fundamentals</li>
                <li><strong>‚ùå Not ideal for:</strong> Rapid prototyping (too verbose), web backends (better options exist), beginner projects (steep learning curve)</li>
            </ul>

            <p>C and C++ are unforgiving but rewarding. They teach you how computers work at a fundamental level‚Äîmemory, pointers, compilation, linking. Modern C++ (C++11 and beyond) has become much more pleasant with smart pointers, RAII, lambdas, and the STL. If you want to truly understand software performance and build the fastest possible programs, C/C++ are essential tools in your arsenal.</p>
        </section>

        <section class="section" id="java-deep">
            <h2 class="section-title">Java Deep Dive</h2>
            <p class="section-intro">Java's motto "Write Once, Run Anywhere" revolutionized software distribution. The Java Virtual Machine (JVM) compiles Java code to bytecode that runs on any platform with a JVM. Java powers Android apps, enterprise backends, big data systems (Hadoop, Spark), and more. Its strong typing, extensive standard library, and mature ecosystem make it a solid choice for large-scale applications. Let's explore what makes Java unique and why it's still dominant in enterprise environments.</p>

            <div class="card-grid">
                <div class="card">
                    <h4>‚òï Platform Independence</h4>
                    <p>Compile once to bytecode, run on Windows, Linux, Mac‚Äîany system with a JVM. No recompilation needed for different platforms.</p>
                </div>
                <div class="card">
                    <h4>üè¢ Enterprise Standard</h4>
                    <p>Spring Framework, massive ecosystem, battle-tested for decades. Banks, governments, and large corporations rely on Java for mission-critical systems.</p>
                </div>
                <div class="card">
                    <h4>üîí Type Safety</h4>
                    <p>Strong static typing catches errors at compile time. Generics, interfaces, and inheritance provide structure and prevent bugs.</p>
                </div>
                <div class="card">
                    <h4>üóëÔ∏è Automatic Memory Management</h4>
                    <p>Garbage collector handles memory deallocation. No manual memory management like C/C++, reducing memory leaks and crashes.</p>
                </div>
            </div>

            <h3>The JVM: How Java Runs</h3>
            <div class="info-box">
                <h4>üîß JVM Execution Flow</h4>
                <p><strong>1. Write:</strong> Java source code (.java files)<br>
                <strong>2. Compile:</strong> <span class="inline-code">javac</span> compiles to bytecode (.class files)<br>
                <strong>3. Run:</strong> JVM interprets/JIT-compiles bytecode to native machine code<br>
                <strong>4. Execute:</strong> Code runs on any platform with a JVM<br><br>
                This architecture allows "write once, run anywhere" portability.</p>
            </div>

            <h3>Object-Oriented Java</h3>
            <p>Java is purely object-oriented (except primitives). Everything is a class, and classes define objects.</p>

            <div class="code">// Basic class
public class Person {
    // Fields (instance variables)
    private String name;
    private int age;
    
    // Constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Methods (instance methods)
    public String greet() {
        return "Hello, I'm " + name;
    }
    
    // Getters/Setters (encapsulation)
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    // Static method
    public static String species() {
        return "Homo sapiens";
    }
}

// Usage
Person person = new Person("Alice", 30);
System.out.println(person.greet());
System.out.println(Person.species());</div>

            <h3>Interfaces vs Abstract Classes</h3>
            <div class="code">// Interface (contract - what to do)
interface Drawable {
    void draw();  // No implementation
    default void display() {  // Default method (Java 8+)
        System.out.println("Displaying...");
    }
}

// Abstract class (partial implementation - how to do it)
abstract class Shape {
    abstract double area();  // Must be implemented by subclass
    
    void describe() {  // Concrete method
        System.out.println("I am a shape");
    }
}

// Implementing interface and extending abstract class
class Circle extends Shape implements Drawable {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing circle");
    }
}

// Multiple interfaces allowed, only one abstract class
class Rectangle implements Drawable, Comparable<Rectangle> {
    // ...
}</div>

            <h3>Generics: Type-Safe Collections</h3>
            <p>Generics allow you to write type-safe code that works with different types without casting.</p>

            <div class="code">// Without generics (old way - not type-safe)
List list = new ArrayList();
list.add("Hello");
list.add(42);
String str = (String) list.get(1);  // Runtime error! 42 is not a String

// With generics (type-safe)
List<String> strings = new ArrayList<>();
strings.add("Hello");
// strings.add(42);  // Compile error!
String str = strings.get(0);  // No cast needed

// Generic class
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

Box<Integer> intBox = new Box<>();
intBox.set(42);
int value = intBox.get();

Box<String> strBox = new Box<>();
strBox.set("Hello");
String str = strBox.get();

// Generic methods
public static <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}

// Bounded type parameters
public class NumberBox<T extends Number> {
    private T number;
    
    public double doubleValue() {
        return number.doubleValue();  // Can call Number methods
    }
}</div>

            <h3>Collections Framework</h3>
            <div class="code">import java.util.*;

// List (ordered, allows duplicates)
List<String> list = new ArrayList<>();
list.add("apple");
list.add("banana");
String first = list.get(0);

List<String> linkedList = new LinkedList<>();  // Better for insertions/deletions

// Set (no duplicates)
Set<Integer> set = new HashSet<>();
set.add(1);
set.add(2);
set.add(1);  // Ignored - already exists
System.out.println(set.size());  // 2

// Map (key-value pairs)
Map<String, Integer> map = new HashMap<>();
map.put("Alice", 30);
map.put("Bob", 25);
int age = map.get("Alice");  // 30

// Iterating
for (String name : map.keySet()) {
    System.out.println(name + ": " + map.get(name));
}

// Sorting
List<Integer> numbers = Arrays.asList(5, 2, 8, 1);
Collections.sort(numbers);
Collections.reverse(numbers);

// Streams (Java 8+)
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .filter(n -> n % 2 == 0)
                 .map(n -> n * 2)
                 .reduce(0, Integer::sum);  // Sum of doubled evens</div>

            <h3>Exception Handling</h3>
            <div class="code">// Checked exceptions (must handle or declare)
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);  // May throw IOException
    // ...
}

// Try-catch
try {
    int result = divide(10, 0);
} catch (ArithmeticException e) {
    System.err.println("Cannot divide by zero: " + e.getMessage());
} finally {
    System.out.println("Always executes");
}

// Try-with-resources (automatic resource management)
try (FileReader reader = new FileReader("file.txt")) {
    // Use reader...
}  // Automatically closed, even if exception occurs

// Custom exception
public class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}</div>

            <h3>Threads and Concurrency</h3>
            <div class="code">// Creating threads
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}

MyThread thread = new MyThread();
thread.start();

// Using Runnable (better - composition over inheritance)
Runnable task = () -> {
    System.out.println("Task running");
};

Thread thread = new Thread(task);
thread.start();

// ExecutorService (thread pool)
ExecutorService executor = Executors.newFixedThreadPool(4);

for (int i = 0; i < 10; i++) {
    executor.submit(() -> {
        System.out.println("Task executed by " + Thread.currentThread().getName());
    });
}

executor.shutdown();

// Synchronized (thread-safe)
public class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}</div>

            <h3>When to Use Java</h3>
            <ul>
                <li><strong>‚úÖ Perfect for:</strong> Enterprise applications, Android development, large-scale systems, microservices</li>
                <li><strong>‚úÖ Great for:</strong> Backend services, big data (Hadoop, Spark), web APIs (Spring Boot), long-term maintainability</li>
                <li><strong>‚ùå Not ideal for:</strong> Systems programming (too high-level), quick scripts (too verbose), performance-critical low-level code</li>
            </ul>

            <p>Java's "write once, run anywhere" promise, combined with its strong typing, garbage collection, and massive ecosystem, makes it a reliable choice for enterprise software. While it may be more verbose than modern languages, its maturity and tooling ecosystem ensure that Java remains a dominant force in software development.</p>
        </section>

        <section class="section" id="go-deep">
            <h2 class="section-title">Go Deep Dive</h2>
            <p class="section-intro">Go (Golang) was created by Google to address shortcomings in existing languages: slow compilation, complex dependency management, and difficult concurrency. Go is simple, fast to compile, and has built-in concurrency primitives (goroutines and channels). It's become the language of choice for cloud infrastructure, microservices, CLIs, and DevOps tools (Docker, Kubernetes, Terraform). Let's explore what makes Go special and why it's growing so rapidly.</p>

            <div class="card-grid">
                <div class="card">
                    <h4>‚ö° Fast Compilation</h4>
                    <p>Go compiles to native binaries incredibly fast. Large projects compile in seconds, not minutes. No JVM or interpreter‚Äîjust a single executable.</p>
                </div>
                <div class="card">
                    <h4>üöÄ Built-in Concurrency</h4>
                    <p>Goroutines are lightweight threads, and channels enable safe communication between them. Concurrency is simple and idiomatic in Go.</p>
                </div>
                <div class="card">
                    <h4>üéØ Simplicity</h4>
                    <p>Go intentionally lacks features like generics (until recently), inheritance, and operator overloading. Fewer ways to do things means more readable, maintainable code.</p>
                </div>
                <div class="card">
                    <h4>üì¶ Excellent Tooling</h4>
                    <p><span class="inline-code">go fmt</span> standardizes formatting, <span class="inline-code">go test</span> for testing, <span class="inline-code">go mod</span> for dependencies. Tooling is built-in and opinionated.</p>
                </div>
            </div>

            <h3>Goroutines: Lightweight Concurrency</h3>
            <p>Goroutines are functions that run concurrently. They're lightweight (start with ~2KB stack) and managed by the Go runtime, not the OS.</p>

            <div class="code">package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    // Start a goroutine with 'go' keyword
    go sayHello()
    
    // Main function continues immediately
    fmt.Println("Hello from main!")
    
    // Wait for goroutine to finish
    time.Sleep(time.Second)
}

// Multiple goroutines
func main() {
    for i := 0; i < 5; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d\\n", id)
        }(i)
    }
    
    time.Sleep(time.Second)  // Wait for all to finish
}</div>

            <h3>Channels: Communication Between Goroutines</h3>
            <p>Channels allow goroutines to communicate safely without explicit locks. "Don't communicate by sharing memory; share memory by communicating."</p>

            <div class="code">// Creating and using channels
func main() {
    ch := make(chan int)  // Create channel
    
    // Send to channel in a goroutine
    go func() {
        ch <- 42  // Send value
    }()
    
    value := <-ch  // Receive value
    fmt.Println(value)  // 42
}

// Buffered channels
ch := make(chan int, 3)  // Buffer of 3
ch <- 1
ch <- 2
ch <- 3
// ch <- 4  // Would block until someone receives

// Closing channels
func producer(ch chan int) {
    for i := 0; i < 5; i++ {
        ch <- i
    }
    close(ch)  // Signal no more values
}

func main() {
    ch := make(chan int)
    go producer(ch)
    
    // Receive until channel closed
    for value := range ch {
        fmt.Println(value)
    }
}

// Select: multiplexing channels
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()
    
    // Wait for either channel
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println(msg1)
        case msg2 := <-ch2:
            fmt.Println(msg2)
        }
    }
}</div>

            <h3>Interfaces and Composition</h3>
            <p>Go doesn't have classes or inheritance. Instead, it uses interfaces and composition.</p>

            <div class="code">// Interface (implicit satisfaction)
type Speaker interface {
    Speak() string
}

// Structs
type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct {
    Name string
}

func (c Cat) Speak() string {
    return "Meow!"
}

// Dog and Cat satisfy Speaker interface automatically!
func makeSound(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    dog := Dog{Name: "Buddy"}
    cat := Cat{Name: "Whiskers"}
    
    makeSound(dog)  // Woof!
    makeSound(cat)  // Meow!
}

// Composition (embedding)
type Animal struct {
    Name string
}

func (a Animal) Info() string {
    return "Name: " + a.Name
}

type Dog struct {
    Animal  // Embed Animal
    Breed string
}

func main() {
    dog := Dog{
        Animal: Animal{Name: "Buddy"},
        Breed:  "Golden Retriever",
    }
    
    fmt.Println(dog.Info())  // Can call Animal's method
    fmt.Println(dog.Name)    // Can access Animal's field
}</div>

            <h3>Error Handling: Explicit and Clear</h3>
            <p>Go doesn't have exceptions. Instead, functions return errors that must be explicitly checked.</p>

            <div class="code">import (
    "errors"
    "fmt"
)

// Functions return (result, error)
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}

// Custom errors
type ValidationError struct {
    Field string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

// Wrapping errors (Go 1.13+)
import "fmt"

func readConfig() error {
    err := readFile("config.json")
    if err != nil {
        return fmt.Errorf("failed to read config: %w", err)
    }
    return nil
}</div>

            <h3>Standard Library Power</h3>
            <div class="code">// HTTP server (just standard library!)
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}

// JSON encoding/decoding
import "encoding/json"

type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}

// Marshal (Go -> JSON)
person := Person{Name: "Alice", Age: 30}
jsonData, err := json.Marshal(person)
fmt.Println(string(jsonData))  // {"name":"Alice","age":30}

// Unmarshal (JSON -> Go)
jsonStr := `{"name":"Bob","age":25}`
var person Person
json.Unmarshal([]byte(jsonStr), &person)
fmt.Println(person.Name)  // Bob

// File I/O
import "os"

data, err := os.ReadFile("file.txt")
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println(string(data))

err = os.WriteFile("output.txt", []byte("Hello"), 0644)
if err != nil {
    fmt.Println("Error:", err)
}</div>

            <h3>Go Modules: Dependency Management</h3>
            <div class="code"># Initialize module
go mod init myproject

# Add dependency
go get github.com/gorilla/mux

# Update dependencies
go mod tidy

# go.mod file example:
module myproject

go 1.21

require (
    github.com/gorilla/mux v1.8.0
)</div>

            <h3>When to Use Go</h3>
            <ul>
                <li><strong>‚úÖ Perfect for:</strong> Microservices, cloud infrastructure, DevOps tools, CLIs, network services, APIs</li>
                <li><strong>‚úÖ Great for:</strong> Concurrent systems, web servers, distributed systems, container orchestration</li>
                <li><strong>‚ùå Not ideal for:</strong> GUIs (limited libraries), data science (Python dominates), highly dynamic code (strict typing)</li>
            </ul>

            <p>Go's simplicity, fast compilation, built-in concurrency, and excellent standard library make it the language of modern cloud infrastructure. Its philosophy of "less is more" leads to readable, maintainable code. If you're building microservices, CLIs, or infrastructure tools, Go should be high on your list.</p>
        </section>

        <section class="section" id="rust-deep">
            <h2 class="section-title">Rust Deep Dive</h2>
            <p class="section-intro">Rust is the new systems programming language that challenges C/C++'s dominance. It guarantees memory safety without garbage collection through its ownership system‚Äîpreventing segfaults, data races, and undefined behavior at compile time. Rust is fast (as fast as C/C++), safe (no memory bugs), and has a growing ecosystem. It's used in browsers (Firefox), operating systems (Linux kernel drivers), game engines, blockchain, and more. Let's explore Rust's unique features and why it's called "the future of systems programming."</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üîí Memory Safety</h4>
                    <p>No null pointers, no dangling pointers, no data races. The compiler catches memory errors before you run the program. Safety without runtime overhead.</p>
                </div>
                <div class="card">
                    <h4>‚ö° Zero-Cost Abstractions</h4>
                    <p>High-level features (iterators, pattern matching) compile to the same efficient code as hand-written C. Performance without sacrificing ergonomics.</p>
                </div>
                <div class="card">
                    <h4>üßµ Fearless Concurrency</h4>
                    <p>Ownership rules prevent data races at compile time. Write concurrent code without fear of race conditions‚Äîthe compiler won't let you.</p>
                </div>
                <div class="card">
                    <h4>üì¶ Modern Tooling</h4>
                    <p>Cargo handles builds, dependencies, testing, documentation. <span class="inline-code">rustfmt</span> and <span class="inline-code">clippy</span> keep code clean. Tooling rivals Go's excellence.</p>
                </div>
            </div>

            <h3>Ownership: Rust's Big Innovation</h3>
            <p>Ownership is Rust's most unique feature. It enables memory safety without garbage collection.</p>

            <div class="info-box">
                <h4>üîë Ownership Rules</h4>
                <p><strong>1.</strong> Each value has one owner<br>
                <strong>2.</strong> When the owner goes out of scope, the value is dropped (freed)<br>
                <strong>3.</strong> Ownership can be transferred (moved)<br><br>
                These rules eliminate memory leaks and double-frees at compile time!</p>
            </div>

            <div class="code">// Ownership basics
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // Ownership moved to s2
    
    // println!("{}", s1);  // ERROR! s1 no longer owns the data
    println!("{}", s2);  // OK
}

// Ownership and functions
fn takes_ownership(s: String) {
    println!("{}", s);
}  // s is dropped here

fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    // println!("{}", s);  // ERROR! Ownership was moved
}

// Returning ownership
fn gives_ownership() -> String {
    String::from("hello")  // Ownership transferred to caller
}

fn main() {
    let s = gives_ownership();
    println!("{}", s);  // OK
}</div>

            <h3>Borrowing: References Without Ownership</h3>
            <p>Borrowing allows you to use data without taking ownership. Rust's borrow checker enforces safety rules at compile time.</p>

            <div class="code">// Immutable borrowing
fn calculate_length(s: &String) -> usize {
    s.len()  // Can read, but not modify
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // Borrow s
    println!("{}: {}", s, len);  // Still can use s!
}

// Mutable borrowing
fn append_world(s: &mut String) {
    s.push_str(", world!");
}

fn main() {
    let mut s = String::from("hello");
    append_world(&mut s);
    println!("{}", s);  // "hello, world!"
}

// Borrowing rules
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;  // OK: immutable borrow
    let r2 = &s;  // OK: multiple immutable borrows allowed
    println!("{} {}", r1, r2);
    
    // let r3 = &mut s;  // ERROR! Can't have mutable borrow while immutable borrows exist
    
    let r3 = &mut s;  // OK now: r1 and r2 are no longer used
    println!("{}", r3);
}</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Borrow Checker Rules</h4>
                <p><strong>1.</strong> You can have EITHER:<br>
                - One mutable reference (&mut T)<br>
                - Any number of immutable references (&T)<br><br>
                <strong>2.</strong> References must always be valid (no dangling references)<br><br>
                These rules prevent data races at compile time!</p>
            </div>

            <h3>Lifetimes: Ensuring Reference Validity</h3>
            <p>Lifetimes tell the compiler how long references are valid, preventing dangling references.</p>

            <div class="code">// Compiler infers lifetimes in simple cases
fn first_word(s: &str) -> &str {
    &s[..5]
}

// Explicit lifetime annotations when needed
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = String::from("hello");
    let s2 = String::from("world!");
    let result = longest(&s1, &s2);
    println!("{}", result);
}

// Lifetimes in structs
struct Book<'a> {
    title: &'a str,  // title references data that outlives Book
}

fn main() {
    let title = String::from("Rust Programming");
    let book = Book { title: &title };
    println!("{}", book.title);
}</div>

            <h3>Pattern Matching and Enums</h3>
            <p>Rust's enums are powerful, and pattern matching makes working with them elegant.</p>

            <div class="code">// Enums
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// Pattern matching
fn process_message(msg: Message) {
    match msg {
        Message::Quit => println!("Quit"),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(text) => println!("Write: {}", text),
        Message::ChangeColor(r, g, b) => println!("Color: ({}, {}, {})", r, g, b),
    }
}

// Option<T> - Rust's answer to null
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Some(result) => println!("Result: {}", result),
        None => println!("Cannot divide by zero"),
    }
    
    // Or use if let
    if let Some(result) = divide(10, 2) {
        println!("Result: {}", result);
    }
}</div>

            <h3>Result<T, E>: Rust's Error Handling</h3>
            <div class="code">use std::fs::File;
use std::io::{self, Read};

// Function that can fail
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;  // ? propagates error
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file("config.txt") {
        Ok(contents) => println!("{}", contents),
        Err(e) => println!("Error: {}", e),
    }
}

// Custom Result type
type MyResult<T> = Result<T, MyError>;

// Chaining with combinators
fn process() -> Result<i32, String> {
    read_number()
        .map(|n| n * 2)
        .and_then(|n| validate(n))
}

// Unwrap (use sparingly - panics on error)
let value = divide(10, 2).unwrap();  // OK
let value = divide(10, 0).unwrap();  // PANIC!</div>

            <h3>Traits: Rust's Interfaces</h3>
            <div class="code">// Define trait
trait Speak {
    fn speak(&self) -> String;
}

// Implement trait
struct Dog {
    name: String,
}

impl Speak for Dog {
    fn speak(&self) -> String {
        format!("{} says Woof!", self.name)
    }
}

struct Cat {
    name: String,
}

impl Speak for Cat {
    fn speak(&self) -> String {
        format!("{} says Meow!", self.name)
    }
}

// Generic function with trait bounds
fn make_speak<T: Speak>(animal: &T) {
    println!("{}", animal.speak());
}

fn main() {
    let dog = Dog { name: String::from("Buddy") };
    let cat = Cat { name: String::from("Whiskers") };
    
    make_speak(&dog);
    make_speak(&cat);
}

// Trait with default implementation
trait Greet {
    fn greet(&self) -> String {
        String::from("Hello!")
    }
}

// Associated types
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}</div>

            <h3>Cargo: Rust's Build System</h3>
            <div class="code"># Create new project
cargo new myproject
cd myproject

# Build
cargo build
cargo build --release  # Optimized

# Run
cargo run

# Test
cargo test

# Check (faster than build - no binary)
cargo check

# Format code
cargo fmt

# Lint
cargo clippy

# Cargo.toml (dependencies)
[dependencies]
serde = "1.0"
tokio = { version = "1", features = ["full"] }</div>

            <h3>When to Use Rust</h3>
            <ul>
                <li><strong>‚úÖ Perfect for:</strong> Systems programming, embedded systems, game engines, browser engines, operating systems, high-performance services</li>
                <li><strong>‚úÖ Great for:</strong> CLI tools, WebAssembly, blockchain, networking, parsers, compilers</li>
                <li><strong>‚ùå Not ideal for:</strong> Rapid prototyping (steep learning curve), simple scripts (overkill), domains where Python/JS excel</li>
            </ul>

            <p>Rust is the future of systems programming. Its ownership system eliminates entire classes of bugs at compile time, making it safer than C/C++ without sacrificing performance. The learning curve is steep‚Äîthe borrow checker will frustrate you initially‚Äîbut once you internalize the rules, you'll write fast, safe code with confidence. If you want to build the next generation of performance-critical, memory-safe software, learn Rust.</p>
        </section>

        <section class="section" id="design-patterns">
            <h2 class="section-title">Design Patterns</h2>
            <p class="section-intro">Design patterns are proven solutions to common programming problems. They're not code you copy-paste, but rather templates for structuring your code. Patterns emerged from decades of experience‚Äîthey represent best practices for building maintainable, flexible software. Understanding patterns helps you communicate with other developers ("we need a factory here") and recognize good architecture. Let's explore the most important design patterns across creational, structural, and behavioral categories.</p>

            <h3>Creational Patterns: Object Creation</h3>
            <p>These patterns abstract the instantiation process, making your system independent of how objects are created, composed, and represented.</p>

            <h4>Singleton: One Instance Only</h4>
            <p>Ensures a class has only one instance and provides global access to it. Use for logging, configuration, database connections.</p>

            <div class="code">// Python
class Database:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connection = "Connected to DB"
        return cls._instance

db1 = Database()
db2 = Database()
print(db1 is db2)  # True - same instance

// JavaScript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        Singleton.instance = this;
        this.data = "Single instance";
    }
}

const s1 = new Singleton();
const s2 = new Singleton();
console.log(s1 === s2);  // true</div>

            <h4>Factory: Object Creation Logic</h4>
            <p>Defines an interface for creating objects but lets subclasses decide which class to instantiate. Encapsulates object creation.</p>

            <div class="code">// Python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("Unknown animal type")

animal = AnimalFactory.create_animal("dog")
print(animal.speak())  # Woof!

// Java
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing Square");
    }
}

class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type) {
            case "circle": return new Circle();
            case "square": return new Square();
            default: throw new IllegalArgumentException("Unknown shape");
        }
    }
}

Shape shape = ShapeFactory.createShape("circle");
shape.draw();</div>

            <h4>Builder: Step-by-Step Construction</h4>
            <p>Separates construction of complex objects from their representation. Build objects step-by-step with a fluent interface.</p>

            <div class="code">// Java
class Pizza {
    private String dough;
    private String sauce;
    private String topping;
    
    private Pizza(Builder builder) {
        this.dough = builder.dough;
        this.sauce = builder.sauce;
        this.topping = builder.topping;
    }
    
    static class Builder {
        private String dough;
        private String sauce;
        private String topping;
        
        Builder setDough(String dough) {
            this.dough = dough;
            return this;
        }
        
        Builder setSauce(String sauce) {
            this.sauce = sauce;
            return this;
        }
        
        Builder setTopping(String topping) {
            this.topping = topping;
            return this;
        }
        
        Pizza build() {
            return new Pizza(this);
        }
    }
}

Pizza pizza = new Pizza.Builder()
    .setDough("thin crust")
    .setSauce("tomato")
    .setTopping("pepperoni")
    .build();</div>

            <h3>Structural Patterns: Object Composition</h3>
            <p>These patterns deal with how classes and objects are composed to form larger structures.</p>

            <h4>Adapter: Interface Conversion</h4>
            <p>Converts the interface of a class into another interface clients expect. Makes incompatible interfaces work together.</p>

            <div class="code">// Python
class EuropeanSocket:
    def plug_in_european(self):
        return "220V European socket"

class AmericanSocket:
    def plug_in_american(self):
        return "110V American socket"

class SocketAdapter:
    def __init__(self, socket):
        self.socket = socket
    
    def plug_in(self):
        if hasattr(self.socket, 'plug_in_european'):
            return self.socket.plug_in_european()
        elif hasattr(self.socket, 'plug_in_american'):
            return self.socket.plug_in_american()

euro = EuropeanSocket()
adapter = SocketAdapter(euro)
print(adapter.plug_in())  # Works with unified interface</div>

            <h4>Decorator: Add Functionality</h4>
            <p>Attaches additional responsibilities to an object dynamically. Flexible alternative to subclassing.</p>

            <div class="code">// Python decorators
def uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

@uppercase_decorator
def greet(name):
    return f"hello, {name}"

print(greet("alice"))  # HELLO, ALICE

// JavaScript
class Coffee {
    cost() {
        return 5;
    }
}

class MilkDecorator {
    constructor(coffee) {
        this.coffee = coffee;
    }
    
    cost() {
        return this.coffee.cost() + 2;
    }
}

class SugarDecorator {
    constructor(coffee) {
        this.coffee = coffee;
    }
    
    cost() {
        return this.coffee.cost() + 1;
    }
}

let coffee = new Coffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
console.log(coffee.cost());  // 8</div>

            <h4>Facade: Simplified Interface</h4>
            <p>Provides a unified, simplified interface to a complex subsystem. Hides complexity behind a clean API.</p>

            <div class="code">// Python
class CPU:
    def freeze(self): pass
    def jump(self, position): pass
    def execute(self): pass

class Memory:
    def load(self, position, data): pass

class HardDrive:
    def read(self, lba, size): pass

class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hdd = HardDrive()
    
    def start(self):
        self.cpu.freeze()
        self.memory.load(0, self.hdd.read(0, 1024))
        self.cpu.jump(0)
        self.cpu.execute()

# Simple interface for complex operation
computer = ComputerFacade()
computer.start()  # Hides all the complexity</div>

            <h3>Behavioral Patterns: Object Interaction</h3>
            <p>These patterns focus on communication between objects and assignment of responsibilities.</p>

            <h4>Observer: Event Subscription</h4>
            <p>Defines a one-to-many dependency. When one object changes state, all dependents are notified automatically.</p>

            <div class="code">// Python
class Subject:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        self._observers.append(observer)
    
    def notify(self, message):
        for observer in self._observers:
            observer.update(message)

class Observer:
    def __init__(self, name):
        self.name = name
    
    def update(self, message):
        print(f"{self.name} received: {message}")

subject = Subject()
observer1 = Observer("Observer1")
observer2 = Observer("Observer2")

subject.attach(observer1)
subject.attach(observer2)
subject.notify("Event occurred!")
# Observer1 received: Event occurred!
# Observer2 received: Event occurred!

// JavaScript (Event Emitter pattern)
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }
    
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(data));
        }
    }
}

const emitter = new EventEmitter();
emitter.on('data', (data) => console.log('Received:', data));
emitter.emit('data', 'Hello World!');</div>

            <h4>Strategy: Interchangeable Algorithms</h4>
            <p>Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Algorithm varies independently from clients.</p>

            <div class="code">// Python
class PaymentStrategy:
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with credit card"

class PayPalPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with PayPal"

class BitcoinPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with Bitcoin"

class ShoppingCart:
    def __init__(self, payment_strategy):
        self.payment_strategy = payment_strategy
    
    def checkout(self, amount):
        return self.payment_strategy.pay(amount)

cart = ShoppingCart(CreditCardPayment())
print(cart.checkout(100))  # Paid $100 with credit card

cart = ShoppingCart(PayPalPayment())
print(cart.checkout(50))  # Paid $50 with PayPal</div>

            <h4>Command: Encapsulate Requests</h4>
            <p>Encapsulates a request as an object, allowing parameterization and queuing of requests. Supports undo/redo.</p>

            <div class="code">// Java
interface Command {
    void execute();
    void undo();
}

class Light {
    void on() {
        System.out.println("Light is ON");
    }
    
    void off() {
        System.out.println("Light is OFF");
    }
}

class LightOnCommand implements Command {
    private Light light;
    
    LightOnCommand(Light light) {
        this.light = light;
    }
    
    public void execute() {
        light.on();
    }
    
    public void undo() {
        light.off();
    }
}

class RemoteControl {
    private Command command;
    
    void setCommand(Command command) {
        this.command = command;
    }
    
    void pressButton() {
        command.execute();
    }
    
    void pressUndo() {
        command.undo();
    }
}

Light light = new Light();
Command lightOn = new LightOnCommand(light);
RemoteControl remote = new RemoteControl();
remote.setCommand(lightOn);
remote.pressButton();  // Light is ON
remote.pressUndo();    // Light is OFF</div>

            <h3>Anti-Patterns: What to Avoid</h3>
            <div class="warning-box">
                <h4>‚ö†Ô∏è Common Anti-Patterns</h4>
                <p><strong>God Object:</strong> One class that does everything. Break it into smaller, focused classes.<br><br>
                <strong>Spaghetti Code:</strong> Tangled, unstructured code with no clear flow. Use proper architecture and separation of concerns.<br><br>
                <strong>Copy-Paste Programming:</strong> Duplicating code instead of abstracting it. Use functions, classes, or inheritance.<br><br>
                <strong>Premature Optimization:</strong> Optimizing before you know where the bottleneck is. Measure first, then optimize.</p>
            </div>

            <p>Design patterns are tools, not rules. Don't force a pattern where it doesn't fit. The goal is clear, maintainable code‚Äîpatterns help you get there. As you gain experience, you'll recognize when patterns apply naturally. Study them, but use them judiciously.</p>
        </section>

        <section class="section" id="debugging-mastery">
            <h2 class="section-title">Debugging Mastery</h2>
            <p class="section-intro">Debugging is an essential skill‚Äîyou'll spend more time debugging than writing new code. Great debuggers think systematically, form hypotheses, and test them methodically. Debugging isn't guessing; it's the scientific method applied to code. Let's explore debugging mindsets, tools, and techniques that will make you efficient at finding and fixing bugs.</p>

            <h3>The Debugging Mindset</h3>
            <div class="metaphor-box">
                <h4>Debugging Is Detective Work</h4>
                <p>You're a detective investigating a crime scene (your buggy code). Gather evidence (logs, stack traces), form hypotheses (what could cause this?), test them (add prints, breakpoints), eliminate suspects (what it's NOT), and find the culprit. Like a detective, stay calm and methodical‚Äîpanicking leads to more bugs.</p>
            </div>

            <div class="card-grid">
                <div class="card">
                    <h4>üî¨ Scientific Method</h4>
                    <p>Observe the bug. Form a hypothesis about the cause. Test the hypothesis (add logs, change code). If wrong, form a new hypothesis. Iterate until fixed.</p>
                </div>
                <div class="card">
                    <h4>üß© Reproduce First</h4>
                    <p>If you can't reliably reproduce the bug, you can't fix it. Find the minimal steps to trigger the bug every time.</p>
                </div>
                <div class="card">
                    <h4>üéØ Isolate the Problem</h4>
                    <p>Narrow down where the bug occurs. Binary search: comment out half the code, see if bug persists. Repeat until you find the exact line.</p>
                </div>
                <div class="card">
                    <h4>üìù Keep Notes</h4>
                    <p>Write down what you've tried and what you've learned. Prevents repeating failed approaches and helps you spot patterns.</p>
                </div>
            </div>

            <h3>Print Debugging</h3>
            <p>The simplest debugging tool: insert print statements to see variable values and program flow.</p>

            <div class="code"># Python
def calculate_total(prices):
    print(f"Prices received: {prices}")  # What we got
    total = 0
    for price in prices:
        print(f"Adding price: {price}, current total: {total}")  # Each iteration
        total += price
    print(f"Final total: {total}")  # Result
    return total

// JavaScript
function findMax(numbers) {
    console.log('Input:', numbers);
    let max = numbers[0];
    console.log('Initial max:', max);
    
    for (let i = 1; i < numbers.length; i++) {
        console.log(`Comparing ${max} vs ${numbers[i]}`);
        if (numbers[i] > max) {
            max = numbers[i];
            console.log(`New max: ${max}`);
        }
    }
    
    console.log('Final max:', max);
    return max;
}</div>

            <div class="info-box">
                <h4>üí° Print Debugging Tips</h4>
                <p><strong>Label your prints:</strong> <span class="inline-code">print("DEBUG: value =", value)</span><br>
                <strong>Print state before/after:</strong> See how code changes variables<br>
                <strong>Print types:</strong> <span class="inline-code">print(type(variable))</span> catches type errors<br>
                <strong>Remove after fixing:</strong> Don't leave debug prints in production code</p>
            </div>

            <h3>Reading Stack Traces</h3>
            <p>Stack traces show you the call stack when an error occurs‚Äîwhere the error happened and how you got there.</p>

            <h4>Python Traceback</h4>
            <div class="code">Traceback (most recent call last):
  File "main.py", line 10, in <module>
    result = calculate()
  File "main.py", line 6, in calculate
    return divide(10, 0)
  File "main.py", line 2, in divide
    return a / b
ZeroDivisionError: division by zero

# Read from bottom up:
# 1. Error type: ZeroDivisionError
# 2. Where: line 2 in divide function
# 3. Called from: line 6 in calculate
# 4. Called from: line 10 in main module</div>

            <h4>JavaScript Stack Trace</h4>
            <div class="code">TypeError: Cannot read property 'name' of undefined
    at getUsername (app.js:15:25)
    at processUser (app.js:22:18)
    at main (app.js:30:5)
    at <anonymous>:1:1

# Read bottom-up:
# 1. Started at top level
# 2. Called main() at line 30
# 3. Called processUser() at line 22
# 4. Error in getUsername() at line 15</div>

            <h3>Debugger Tools</h3>
            <p>Debuggers let you pause execution, inspect variables, and step through code line-by-line.</p>

            <h4>Python: pdb</h4>
            <div class="code">import pdb

def buggy_function(x, y):
    result = x + y
    pdb.set_trace()  # Execution pauses here
    result = result * 2
    return result

# Debugger commands:
# n (next): Execute next line
# s (step): Step into function
# c (continue): Continue until next breakpoint
# p variable: Print variable value
# l (list): Show current code context
# q (quit): Exit debugger</div>

            <h4>JavaScript: Chrome DevTools</h4>
            <p>Open DevTools (F12), go to Sources tab, set breakpoints by clicking line numbers. When code hits breakpoint, you can:</p>
            <ul>
                <li>Inspect variables in Scope panel</li>
                <li>Step over (F10), step into (F11), step out (Shift+F11)</li>
                <li>Watch expressions (track specific variables)</li>
                <li>View call stack (how you got here)</li>
            </ul>

            <h4>C/C++: gdb</h4>
            <div class="code"># Compile with debug symbols
gcc -g program.c -o program

# Run with gdb
gdb ./program

# gdb commands:
(gdb) break main          # Set breakpoint at main
(gdb) run                 # Start program
(gdb) next                # Execute next line
(gdb) print variable      # Print variable
(gdb) backtrace           # Show call stack
(gdb) continue            # Continue execution</div>

            <h3>Binary Search Debugging</h3>
            <p>When the bug is somewhere in a large codebase, narrow it down by eliminating half the possibilities at a time.</p>

            <div class="code"># 1000 lines of code, bug somewhere
# Comment out lines 500-1000, test
# Bug still present? It's in lines 1-500
# Comment out lines 250-500, test
# Bug still present? It's in lines 1-250
# Comment out lines 125-250, test
# Bug gone? It's in lines 125-250
# Repeat until you find the exact lines</div>

            <h3>Rubber Duck Debugging</h3>
            <div class="metaphor-box">
                <h4>Explain Your Code to a Rubber Duck</h4>
                <p>Place a rubber duck on your desk. Explain your code, line by line, to the duck. "This function takes a list, then loops through it, then... wait, I'm not checking if the list is empty!" Often, articulating the problem helps you see the solution. The duck doesn't need to be a duck‚Äîa colleague, a pet, or even yourself works.</p>
            </div>

            <h3>Common Bug Types</h3>
            <div class="warning-box">
                <h4>‚ö†Ô∏è Frequent Bugs</h4>
                <p><strong>Off-by-one errors:</strong> Loop one too many or too few times. Check loop conditions.<br><br>
                <strong>Null/undefined:</strong> Accessing property of null. Check existence before accessing.<br><br>
                <strong>Type errors:</strong> String vs number, int vs float. Print types to verify.<br><br>
                <strong>Scope issues:</strong> Variable not accessible where you think. Check where it's defined.<br><br>
                <strong>Mutability bugs:</strong> Modifying shared data unexpectedly. Use immutable data or copy before modifying.</p>
            </div>

            <p>Debugging is a skill that improves with practice. The more bugs you fix, the faster you'll recognize patterns. Stay calm, be systematic, and remember: every bug teaches you something. Embrace debugging as part of the craft‚Äîit's where you learn how things really work.</p>
        </section>

        <section class="section" id="testing-quality">
            <h2 class="section-title">Testing & Code Quality</h2>
            <p class="section-intro">Testing isn't just about finding bugs‚Äîit's about building confidence that your code works as intended. Automated tests catch regressions, document expected behavior, and enable refactoring without fear. Writing testable code forces you to write better code: modular, loosely coupled, and with clear responsibilities. Let's explore testing fundamentals, test-driven development, and how to build software that's reliable and maintainable.</p>

            <h3>Why Test?</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>üêõ Catch Bugs Early</h4>
                    <p>Tests catch bugs before they reach production. Fixing a bug in development is 10-100x cheaper than fixing in production.</p>
                </div>
                <div class="card">
                    <h4>üîí Prevent Regressions</h4>
                    <p>Tests ensure that fixing one bug doesn't create new bugs. Refactor confidently knowing tests will catch breaks.</p>
                </div>
                <div class="card">
                    <h4>üìö Living Documentation</h4>
                    <p>Tests show how code is meant to be used. Better than comments because tests must stay up-to-date or they fail.</p>
                </div>
                <div class="card">
                    <h4>üèóÔ∏è Better Design</h4>
                    <p>Testable code is modular code. Writing tests forces you to decouple components and think about interfaces.</p>
                </div>
            </div>

            <h3>Unit Testing: Test Individual Functions</h3>
            <p>Unit tests verify that a single function or method works correctly in isolation.</p>

            <h4>Python: pytest</h4>
            <div class="code"># calculator.py
def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

# test_calculator.py
import pytest
from calculator import add, divide

def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
    assert add(0, 0) == 0

def test_divide():
    assert divide(10, 2) == 5
    assert divide(9, 3) == 3

def test_divide_by_zero():
    with pytest.raises(ValueError):
        divide(10, 0)

# Run tests: pytest test_calculator.py</div>

            <h4>JavaScript: Jest</h4>
            <div class="code">// math.js
function multiply(a, b) {
    return a * b;
}

function factorial(n) {
    if (n === 0 || n === 1) return 1;
    return n * factorial(n - 1);
}

module.exports = { multiply, factorial };

// math.test.js
const { multiply, factorial } = require('./math');

test('multiply two numbers', () => {
    expect(multiply(2, 3)).toBe(6);
    expect(multiply(-2, 3)).toBe(-6);
});

test('factorial of 5', () => {
    expect(factorial(5)).toBe(120);
});

test('factorial of 0', () => {
    expect(factorial(0)).toBe(1);
});

// Run: npm test</div>

            <h4>Java: JUnit</h4>
            <div class="code">import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    @Test
    void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));
        assertEquals(0, calc.add(-1, 1));
    }
    
    @Test
    void testDivide() {
        Calculator calc = new Calculator();
        assertEquals(5.0, calc.divide(10, 2), 0.001);
    }
    
    @Test
    void testDivideByZero() {
        Calculator calc = new Calculator();
        assertThrows(ArithmeticException.class, () -> {
            calc.divide(10, 0);
        });
    }
}</div>

            <h3>Test-Driven Development (TDD)</h3>
            <p>TDD flips the script: write tests before writing code. The cycle is Red-Green-Refactor.</p>

            <div class="info-box">
                <h4>üîÑ TDD Cycle</h4>
                <p><strong>Red:</strong> Write a failing test for the feature you want to implement<br>
                <strong>Green:</strong> Write the simplest code to make the test pass<br>
                <strong>Refactor:</strong> Clean up the code while keeping tests green<br><br>
                Repeat for each new feature. Tests guide your implementation.</p>
            </div>

            <div class="code"># Example: Building a shopping cart with TDD

# Step 1: Red - Write failing test
def test_empty_cart():
    cart = ShoppingCart()
    assert cart.total() == 0  # FAILS - ShoppingCart doesn't exist

# Step 2: Green - Make it pass
class ShoppingCart:
    def total(self):
        return 0  # Simplest implementation

# Test passes! Now refactor if needed, then move to next feature

# Step 3: Red - Test adding items
def test_add_item():
    cart = ShoppingCart()
    cart.add_item(10)
    assert cart.total() == 10  # FAILS - add_item doesn't exist

# Step 4: Green - Implement add_item
class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def add_item(self, price):
        self.items.append(price)
    
    def total(self):
        return sum(self.items)

# Continue this cycle for each feature</div>

            <h3>Test Coverage</h3>
            <p>Code coverage measures what percentage of your code is executed by tests. Aim for 70-90%.</p>

            <div class="code"># Python: coverage.py
pip install coverage
coverage run -m pytest
coverage report
coverage html  # Generates HTML report

# Output:
Name                Stmts   Miss  Cover
---------------------------------------
calculator.py          10      1    90%
user.py                25      8    68%
---------------------------------------
TOTAL                  35      9    74%</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Coverage ‚â† Quality</h4>
                <p>100% coverage doesn't mean bug-free code. You can execute every line without testing edge cases. Focus on meaningful tests, not just high coverage numbers. Test behavior, not implementation.</p>
            </div>

            <h3>Testing Best Practices</h3>
            <h4>AAA Pattern: Arrange-Act-Assert</h4>
            <div class="code">def test_user_creation():
    # Arrange: Set up test data
    username = "alice"
    email = "alice@example.com"
    
    # Act: Execute the code being tested
    user = create_user(username, email)
    
    # Assert: Verify the result
    assert user.username == username
    assert user.email == email
    assert user.is_active == True</div>

            <h4>Test Independence</h4>
            <p>Each test should be independent‚Äîorder shouldn't matter. Tests should not rely on shared state.</p>

            <div class="code"># Bad: Tests depend on order
users = []

def test_create_user():
    user = User("alice")
    users.append(user)  # Modifies shared state
    assert len(users) == 1

def test_find_user():
    # Assumes test_create_user ran first!
    assert len(users) == 1  # Brittle

# Good: Each test is independent
def test_create_user():
    users = []
    user = User("alice")
    users.append(user)
    assert len(users) == 1

def test_find_user():
    users = [User("alice")]  # Set up own state
    found = find_user(users, "alice")
    assert found.name == "alice"</div>

            <h4>Test Naming</h4>
            <p>Test names should describe what they test and what the expected outcome is.</p>

            <div class="code"># Bad
def test_1(): ...
def test_user(): ...

# Good
def test_divide_by_zero_raises_error(): ...
def test_empty_cart_total_is_zero(): ...
def test_user_with_invalid_email_fails_validation(): ...</div>

            <h3>Mocking: Isolating Units</h3>
            <p>Mocking replaces real dependencies with fake ones, letting you test in isolation.</p>

            <div class="code"># Python: unittest.mock
from unittest.mock import Mock

# Mock an API call
def test_fetch_user():
    api = Mock()
    api.get_user.return_value = {"name": "Alice", "age": 30}
    
    result = fetch_user(api, 123)
    
    assert result["name"] == "Alice"
    api.get_user.assert_called_once_with(123)

# JavaScript: jest.fn()
test('callback is called', () => {
    const mockCallback = jest.fn();
    
    processData([1, 2, 3], mockCallback);
    
    expect(mockCallback).toHaveBeenCalledTimes(3);
    expect(mockCallback).toHaveBeenCalledWith(1);
});</div>

            <h3>Integration and End-to-End Testing</h3>
            <p>Unit tests test individual pieces. Integration tests test how pieces work together. E2E tests test the entire system.</p>

            <ul>
                <li><strong>Unit:</strong> Test a single function</li>
                <li><strong>Integration:</strong> Test database + API layer together</li>
                <li><strong>E2E:</strong> Test the full user flow (click button, data saves, UI updates)</li>
            </ul>

            <p>Testing is an investment. It takes time upfront but saves time in the long run by preventing bugs and enabling confident refactoring. Write tests for critical paths first, then expand coverage. Good tests are fast, independent, repeatable, and self-validating. Make testing a habit, and your code quality will skyrocket.</p>
        </section>

        <section class="section" id="mastery-path">
            <h2 class="section-title">The Path to Mastery</h2>
            <p class="section-intro">You've learned syntax, paradigms, data structures, algorithms, language-specific features, design patterns, debugging, and testing. That's a foundation‚Äîbut mastery comes from deliberate practice, building real projects, and continuous learning. Programming is a lifelong journey. Let's explore strategies for accelerating your growth, staying current, and building a career as a developer.</p>

            <h3>How to Learn New Languages Fast</h3>
            <p>Once you master one language deeply, learning others becomes faster. You're learning syntax, not concepts.</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üìö Concepts Transfer</h4>
                    <p>Variables, loops, functions, OOP‚Äîthese are universal. Focus on what's different: syntax, idioms, ecosystem.</p>
                </div>
                <div class="card">
                    <h4>üîç Compare and Contrast</h4>
                    <p>How does this language handle X compared to what I know? Map new syntax to familiar concepts.</p>
                </div>
                <div class="card">
                    <h4>üèóÔ∏è Build Something</h4>
                    <p>Don't just read tutorials. Build a project you've built before in another language. You'll learn by doing.</p>
                </div>
                <div class="card">
                    <h4>üìñ Read Documentation</h4>
                    <p>Official docs are your friend. Learn to navigate them efficiently‚Äîthey're authoritative and comprehensive.</p>
                </div>
            </div>

            <h3>Learning Strategy: Build Projects</h3>
            <p>The fastest way to learn is by building. Projects force you to solve real problems and integrate multiple concepts.</p>

            <h4>Project Ideas by Level</h4>
            <div class="code"># Beginner Projects
- To-Do List (CRUD operations)
- Calculator (UI + logic)
- Weather App (API calls)
- Personal Website (HTML/CSS/JS)

# Intermediate Projects
- Blog with Database (full CRUD, authentication)
- Chat Application (websockets, real-time)
- E-commerce Site (cart, payments, database)
- REST API (endpoints, authentication, database)

# Advanced Projects
- Social Media Platform (scalability, complex features)
- Distributed System (microservices, message queues)
- Game Engine (graphics, physics, optimization)
- Compiler/Interpreter (parsing, code generation)</div>

            <h3>Deliberate Practice</h3>
            <p>Not all practice is equal. Deliberate practice means working just beyond your comfort zone, getting feedback, and reflecting.</p>

            <div class="info-box">
                <h4>üéØ Principles of Deliberate Practice</h4>
                <p><strong>Challenging:</strong> Work on problems slightly harder than you can comfortably solve<br>
                <strong>Focused:</strong> Eliminate distractions, concentrate fully<br>
                <strong>Feedback:</strong> Get code reviews, automated tests, or compare to expert solutions<br>
                <strong>Reflection:</strong> After solving, ask: How could I do this better? What did I learn?</p>
            </div>

            <h4>Coding Challenges</h4>
            <p>Platforms like LeetCode, HackerRank, and Codewars offer structured practice.</p>
            <ul>
                <li><strong>LeetCode:</strong> Interview prep, algorithms, data structures</li>
                <li><strong>HackerRank:</strong> Broad topics, certification tracks</li>
                <li><strong>Codewars:</strong> Gamified, community solutions to learn from</li>
                <li><strong>Advent of Code:</strong> Fun December challenge, algorithmic puzzles</li>
            </ul>

            <h3>Contributing to Open Source</h3>
            <p>Open source teaches you to read others' code, collaborate, and contribute to real projects used by thousands.</p>

            <div class="code"># Getting Started
1. Find a project you use and like (libraries, tools, frameworks)
2. Look for issues labeled "good first issue" or "beginner-friendly"
3. Fork the repo, clone locally
4. Make your change (fix bug, add docs, improve tests)
5. Submit a pull request with clear description
6. Respond to feedback, iterate

# Benefits
- Learn professional workflows (Git, code reviews, CI/CD)
- Build portfolio (GitHub contributions visible to employers)
- Network with experienced developers
- Give back to projects you benefit from</div>

            <h3>Reading Code</h3>
            <p>Great writers read widely. Great programmers read code widely.</p>

            <ul>
                <li><strong>Read standard libraries:</strong> See how experts structure code</li>
                <li><strong>Read popular open source:</strong> Django, React, Linux kernel‚Äîlearn from the best</li>
                <li><strong>Read your own old code:</strong> Cringe at it, then refactor. That's growth.</li>
            </ul>

            <h3>Staying Current</h3>
            <p>Technology evolves fast. Stay current without burning out.</p>

            <div class="card-grid">
                <div class="card">
                    <h4>üì∞ Follow Blogs</h4>
                    <p>Hacker News, dev.to, Medium, specific language blogs. Skim daily, read deeply weekly.</p>
                </div>
                <div class="card">
                    <h4>üé• Watch Talks</h4>
                    <p>Conference talks on YouTube (PyCon, JSConf, RustConf). Learn from experts in 30 minutes.</p>
                </div>
                <div class="card">
                    <h4>üë• Join Communities</h4>
                    <p>Reddit (r/programming, r/learnprogramming), Discord servers, local meetups. Ask questions, help others.</p>
                </div>
                <div class="card">
                    <h4>üìö Read Books</h4>
                    <p>Classics like Clean Code, Design Patterns, SICP. Deep knowledge that doesn't go out of date.</p>
                </div>
            </div>

            <h3>Career Paths</h3>
            <p>Programming opens many doors. Choose a path that excites you.</p>

            <ul>
                <li><strong>Web Development:</strong> Frontend (React, Vue), backend (Node, Django), full-stack</li>
                <li><strong>Mobile Development:</strong> iOS (Swift), Android (Kotlin), cross-platform (React Native, Flutter)</li>
                <li><strong>Data Engineering/Science:</strong> Python, SQL, big data tools (Spark, Airflow), machine learning</li>
                <li><strong>DevOps/SRE:</strong> Infrastructure, CI/CD, Kubernetes, monitoring, automation</li>
                <li><strong>Systems Programming:</strong> Operating systems, databases, compilers, low-level performance</li>
                <li><strong>Game Development:</strong> Unity (C#), Unreal (C++), indie games</li>
                <li><strong>Security:</strong> Penetration testing, secure coding, cryptography</li>
            </ul>

            <h3>The 10,000 Hour "Rule"</h3>
            <p>Malcolm Gladwell popularized the idea that mastery takes 10,000 hours. But it's not just time‚Äîit's deliberate practice.</p>

            <div class="metaphor-box">
                <h4>Quality Over Quantity</h4>
                <p>10,000 hours of mindless repetition won't make you an expert. 1,000 hours of deliberate practice‚Äîworking on challenging problems, getting feedback, reflecting‚Äîwill make you far better. Focus on quality practice, not just logging hours.</p>
            </div>

            <h3>Embrace the Journey</h3>
            <p>Programming is frustrating, exhilarating, creative, and logical all at once. You'll feel stupid often‚Äîthat's good, it means you're learning. Embrace the struggle. Every bug you fix, every concept you grasp, every project you complete makes you better.</p>

            <div class="info-box">
                <h4>üöÄ Final Advice</h4>
                <p><strong>Build things:</strong> Projects teach more than tutorials<br>
                <strong>Read code:</strong> Learn from others' solutions<br>
                <strong>Ask questions:</strong> No question is too basic<br>
                <strong>Help others:</strong> Teaching solidifies your understanding<br>
                <strong>Never stop learning:</strong> Technology evolves, so must you<br>
                <strong>Enjoy the process:</strong> Programming is a craft‚Äîtake pride in your work</p>
            </div>

            <p>You now have a comprehensive foundation in programming‚Äîfrom philosophy to syntax, paradigms to patterns, debugging to testing, and strategies for mastery. The rest is practice. Go build something amazing. The world needs the software only you can create. Happy coding!</p>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (scrollY >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });

            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>