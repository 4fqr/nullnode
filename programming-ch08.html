<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 08: Full-Stack Integration - Part I - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: var(--bg2); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(255,255,255,0.05); color: var(--text); transform: translateX(4px); }
        .sidebar-link.active { background: rgba(255,255,255,0.1); color: var(--text); font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: var(--text3); margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.2); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: var(--bg3); border-left: 3px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-left: 3px solid #ff6b6b; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #ff6b6b; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; white-space: nowrap; }
        .metaphor-box { background: rgba(255,255,255,0.03); border-left: 4px solid var(--text); padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "üí°"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg2); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, var(--text) 0%, var(--text2) 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">‚ñº</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#what-is-fullstack" class="sidebar-link">What is Full-Stack?</a>
            <a href="#frontend-basics" class="sidebar-link">Frontend: HTML, CSS, JS</a>
            <a href="#backend-basics" class="sidebar-link">Backend: Servers & APIs</a>
            <a href="#connecting-pieces" class="sidebar-link">Connecting Frontend & Backend</a>
            <a href="#modern-frameworks" class="sidebar-link">Why Modern Frameworks?</a>
            <a href="#react-from-scratch" class="sidebar-link">React from Absolute Scratch</a>
            <a href="#vue-from-scratch" class="sidebar-link">Vue from Absolute Scratch</a>
            <a href="#state-explained" class="sidebar-link">What is State?</a>
            <a href="#apis-explained" class="sidebar-link">What are APIs?</a>
            <a href="#building-first-app" class="sidebar-link">Building Your First Full-Stack App</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="programming-bonus-reading-code.html" class="sidebar-link">‚Üê Previous: Reading Code</a>
            <a href="programming-ch07.html" class="sidebar-link">Chapter 07: Databases</a>
            <a href="programming-bonus-how-to-code.html" class="sidebar-link">Bonus B1: How To Code</a>
            <a href="programming-ch09.html" class="sidebar-link">Next: Professional Practices ‚Üí</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="chapter-label">Chapter 08</div>
            <h1 class="page-title">Full-Stack Integration - Part I</h1>
            <p class="page-subtitle">Start from absolute zero. Learn what full-stack means, how websites actually work, why we need frameworks, and build your first complete application that connects a beautiful frontend to a powerful backend. No prior knowledge needed - we explain EVERYTHING.</p>
        </div>

        <!-- SECTION 1: What Even IS Full-Stack? -->
        <section id="what-is-fullstack" class="section">
            <h2 class="section-title">What Even IS Full-Stack?</h2>
            <p class="section-intro">Welcome! If you're reading this, you might have heard terms like "full-stack developer," "React," "frontend," "backend," and felt completely lost. That's okay! We're starting from ABSOLUTE ZERO. Imagine you know nothing about web development - we'll build up from there, step by step, with tons of analogies and examples.</p>

            <h3>Part 1: What Even IS a Website?</h3>
            
            <h4>The Big Picture: Computers Talking to Each Other</h4>
            <p>Before we dive into fancy terms, let's start with the absolute basics. When you open a website like Facebook, YouTube, or Amazon, what's actually happening?</p>

            <div class="metaphor-box">
                <h4>The Restaurant Metaphor</h4>
                <p>Think of a website like a restaurant:<br><br>
                <strong>You (the customer)</strong> = Your web browser (Chrome, Firefox, Safari)<br>
                <strong>The dining area</strong> = The website you see on your screen<br>
                <strong>The kitchen</strong> = The server (a powerful computer somewhere in the world)<br>
                <strong>The waiter</strong> = The internet<br><br>
                When you click a link, it's like ordering food. Your browser sends a request through the internet (the waiter) to a server (the kitchen). The server prepares your order (fetches data from databases, processes it) and sends it back through the internet to your browser, which displays it beautifully on your screen.</p>
            </div>

            <p>Let's break that down even further. A website is made of THREE main technologies working together:</p>

            <h4>1. HTML - The Skeleton/Structure</h4>
            <p>HTML stands for HyperText Markup Language. Big scary name, simple concept: HTML defines WHAT is on the page. It's like the skeleton of a body or the frame of a house.</p>

            <div class="code">&lt;!-- This is HTML --&gt;
&lt;h1&gt;Welcome to My Website&lt;/h1&gt;
&lt;p&gt;This is a paragraph of text.&lt;/p&gt;
&lt;button&gt;Click Me&lt;/button&gt;
&lt;img src="cat.jpg" alt="A cute cat"&gt;</div>

            <p>Each of those things in angle brackets (<span class="inline-code">&lt;&gt;</span>) is called an <strong>element</strong> or <strong>tag</strong>. They tell the browser: "Put a heading here," "Put a paragraph here," "Put a button here."</p>

            <div class="info-box">
                <h4>HTML Elements Explained</h4>
                <p><span class="inline-code">&lt;h1&gt;</span> = Heading (big title text)<br>
                <span class="inline-code">&lt;p&gt;</span> = Paragraph (normal text)<br>
                <span class="inline-code">&lt;button&gt;</span> = A clickable button<br>
                <span class="inline-code">&lt;img&gt;</span> = An image<br>
                <span class="inline-code">&lt;div&gt;</span> = A container (holds other elements)<br>
                <span class="inline-code">&lt;a&gt;</span> = A link to another page<br><br>
                Notice: Most tags come in pairs: <span class="inline-code">&lt;p&gt;text&lt;/p&gt;</span><br>
                Some are self-closing: <span class="inline-code">&lt;img /&gt;</span><br><br>
                That's it! HTML is just telling the browser what content to display.</p>
            </div>

            <h4>2. CSS - The Styling/Makeup</h4>
            <p>CSS stands for Cascading Style Sheets. It makes your website look pretty. If HTML is the skeleton, CSS is the skin, hair, clothes, and makeup.</p>

            <div class="code">/* This is CSS */
h1 {
  color: blue;
  font-size: 48px;
  text-align: center;
}

button {
  background-color: green;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
}</div>

            <p>CSS says: "Take that heading and make it blue, 48 pixels big, and centered." "Take that button and make it green with white text and rounded corners."</p>

            <div class="metaphor-box">
                <h4>The Blueprint Metaphor</h4>
                <p>HTML is like a blueprint that says "put a door here, a window there."<br><br>
                CSS is like the interior designer who says "paint the door red, put curtains on the window, add a fancy doorknob."<br><br>
                Same structure, but now it looks beautiful!</p>
            </div>

            <h4>3. JavaScript - The Behavior/Brain</h4>
            <p>JavaScript makes your website DO stuff. It's the brain that makes things interactive.</p>

            <div class="code">// This is JavaScript
const button = document.querySelector('button');

button.addEventListener('click', function() {
  alert('Button was clicked!');
  console.log('User clicked the button');
});</div>

            <p>This code says: "Find the button on the page. When someone clicks it, show a popup message and log something to the console."</p>

            <div class="info-box">
                <h4>Putting It All Together</h4>
                <p><strong>HTML:</strong> "There's a button on the page."<br>
                <strong>CSS:</strong> "The button is green and rounded."<br>
                <strong>JavaScript:</strong> "When you click the button, something happens!"<br><br>
                Every website you've ever visited uses these three technologies. Facebook, Google, YouTube - they all use HTML for structure, CSS for styling, and JavaScript for interactivity.</p>
            </div>

            <h4>A Complete Mini Example</h4>
            <p>Let's see all three working together in a simple counter:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Counter&lt;/title&gt;
  &lt;style&gt;
    /* CSS - Make it pretty */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 50px;
    }
    
    h1 {
      color: #333;
    }
    
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    
    button:hover {
      background: #0056b3;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- HTML - Structure --&gt;
  &lt;h1&gt;Simple Counter&lt;/h1&gt;
  &lt;p&gt;Count: &lt;span id="count"&gt;0&lt;/span&gt;&lt;/p&gt;
  &lt;button id="increment"&gt;Add 1&lt;/button&gt;
  &lt;button id="reset"&gt;Reset&lt;/button&gt;
  
  &lt;script&gt;
    // JavaScript - Make it work
    let count = 0;
    
    const countDisplay = document.getElementById('count');
    const incrementBtn = document.getElementById('increment');
    const resetBtn = document.getElementById('reset');
    
    incrementBtn.addEventListener('click', function() {
      count = count + 1;
      countDisplay.textContent = count;
    });
    
    resetBtn.addEventListener('click', function() {
      count = 0;
      countDisplay.textContent = count;
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <p>Save this as <span class="inline-code">counter.html</span>, open it in a browser, and you have a working counter! You can click the button and watch the number go up.</p>

            <h3>Part 2: What is "Frontend" vs "Backend"?</h3>

            <h4>The Restaurant Metaphor (Again, Because It's Perfect)</h4>
            <p>Remember our restaurant analogy? Let's expand on it:</p>

            <div class="metaphor-box">
                <h4>Frontend = What Customers See</h4>
                <p><strong>The Frontend</strong> is everything in the dining area:<br>
                ‚Ä¢ The menu (layout and design)<br>
                ‚Ä¢ The tables and chairs (UI elements like buttons and forms)<br>
                ‚Ä¢ The decorations (colors, fonts, animations)<br>
                ‚Ä¢ The waiter taking your order (handling user interactions)<br><br>
                It's everything you SEE and INTERACT with. In web terms, this is the HTML, CSS, and JavaScript that runs IN YOUR BROWSER on YOUR COMPUTER.</p>
            </div>

            <div class="metaphor-box">
                <h4>Backend = What Customers Don't See</h4>
                <p><strong>The Backend</strong> is everything in the kitchen:<br>
                ‚Ä¢ The chefs cooking food (processing data)<br>
                ‚Ä¢ The pantry storing ingredients (databases)<br>
                ‚Ä¢ The recipes (business logic)<br>
                ‚Ä¢ The dishwashers and food prep (background tasks)<br><br>
                It's everything that happens BEHIND THE SCENES. In web terms, this is code running on a SERVER (a computer somewhere else), working with databases, processing payments, sending emails, etc.</p>
            </div>

            <h4>A Real Example: Logging Into Facebook</h4>
            <p>Let's trace what happens when you log into Facebook to see frontend and backend working together:</p>

            <ol>
                <li><strong>Frontend:</strong> You see a login page (HTML/CSS) with two text boxes and a button.</li>
                <li><strong>Frontend:</strong> You type your email and password. JavaScript captures what you typed.</li>
                <li><strong>Frontend:</strong> You click "Log In." JavaScript sends your credentials to Facebook's server.</li>
                <li><strong>Backend:</strong> Facebook's server receives your email/password.</li>
                <li><strong>Backend:</strong> It checks the database: "Does this email exist? Does the password match?"</li>
                <li><strong>Backend:</strong> If yes, it creates a session token (like a temporary ticket) and sends it back.</li>
                <li><strong>Frontend:</strong> Your browser receives the token and stores it.</li>
                <li><strong>Frontend:</strong> JavaScript updates the page to show your feed instead of the login screen.</li>
            </ol>

            <div class="info-box">
                <h4>Why Have a Backend?</h4>
                <p><strong>Security:</strong> You can't check passwords in the frontend - anyone could read your JavaScript code! The backend keeps sensitive operations hidden.<br><br>
                <strong>Data Storage:</strong> Browsers can't store millions of user posts. The backend has databases for that.<br><br>
                <strong>Shared Data:</strong> Your friends see YOUR posts because the backend stores them in one place everyone can access.<br><br>
                <strong>Processing Power:</strong> Heavy computations (like video encoding) happen on powerful servers, not your phone.</p>
            </div>

            <h4>What is "Full-Stack"?</h4>
            <p>Now we can finally answer the original question! A <strong>full-stack developer</strong> is someone who can work on BOTH the frontend (the dining area) AND the backend (the kitchen).</p>

            <div class="code">// Full-Stack Developer Can Do:

FRONTEND (Browser):
- Build beautiful UIs with HTML/CSS
- Make interactive pages with JavaScript
- Use frameworks like React or Vue
- Handle user interactions

BACKEND (Server):
- Write server code (Node.js, Python, etc.)
- Design databases
- Create APIs (ways for frontend to talk to backend)
- Handle authentication, payments, emails</div>

            <p>Think of it like being both a chef AND a waiter. You understand the whole restaurant, not just one part.</p>

            <h3>Part 3: Why Regular JavaScript Gets Messy</h3>

            <h4>Let's Build Something Simple (The Wrong Way First)</h4>
            <p>Remember that counter we built? Let's look at it again and understand the problems:</p>

            <div class="code">&lt;!-- Your HTML --&gt;
&lt;div id="counter-app"&gt;
  &lt;h1&gt;Click Counter&lt;/h1&gt;
  &lt;p&gt;You clicked &lt;span id="count"&gt;0&lt;/span&gt; times&lt;/p&gt;
  &lt;button id="increment-btn"&gt;Click Me!&lt;/button&gt;
  &lt;button id="reset-btn"&gt;Reset&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
// Your JavaScript
let count = 0;  // Store the count

// Step 1: Find HTML elements
const countDisplay = document.getElementById('count');
const incrementBtn = document.getElementById('increment-btn');
const resetBtn = document.getElementById('reset-btn');

// Step 2: Add event listeners
incrementBtn.addEventListener('click', function() {
  count = count + 1;
  countDisplay.textContent = count;  // Step 3: Update display
});

resetBtn.addEventListener('click', function() {
  count = 0;
  countDisplay.textContent = count;  // Step 3: Update display
});
&lt;/script&gt;</div>

            <p>This works for a simple counter. But notice the problems:</p>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Problems with Vanilla JavaScript</h4>
                <p><strong>1. Manual DOM manipulation:</strong> You have to manually find every element with <span class="inline-code">getElementById</span>. What if you have 100 elements?<br><br>
                <strong>2. Manual updates:</strong> Every time <span class="inline-code">count</span> changes, YOU must remember to update <span class="inline-code">countDisplay.textContent</span>. Forget once = bug.<br><br>
                <strong>3. Scattered logic:</strong> Your data (<span class="inline-code">count</span>) is separate from your HTML. They can get out of sync.<br><br>
                <strong>4. No reusability:</strong> Want another counter? Copy-paste all this code and change IDs. Want 10 counters? Good luck.<br><br>
                <strong>5. Hard to maintain:</strong> As your app grows, you have spaghetti code everywhere.</p>
            </div>

            <h4>What Happens When Your App Grows?</h4>
            <p>Let's imagine you're building a TODO list app. Not with frameworks - just vanilla JavaScript. Here's what you'd need:</p>

            <div class="code">// Imagine all this in vanilla JavaScript:

1. Create todo HTML
   - Find the input field
   - Get the text user typed
   - Create a new &lt;li&gt; element
   - Set its text
   - Create a delete button
   - Add it to the list
   - Clear the input field

2. Delete a todo
   - Find which todo was clicked
   - Remove it from the DOM
   - Update the count display

3. Mark todo as complete
   - Find the checkbox
   - Add event listener
   - Update the styling
   - Move it to "completed" section
   - Update the count

4. Filter todos (all, active, completed)
   - Loop through ALL todos
   - Hide/show based on filter
   - Update which filter button is active

5. Save to localStorage
   - Convert todos to JSON
   - Save when anything changes
   - Load when page refreshes
   - Parse JSON back to todos

// That's HUNDREDS of lines of:
// - document.getElementById()
// - element.addEventListener()
// - element.textContent = ...
// - element.style.something = ...
// And you have to remember to update EVERYTHING
// when ANYTHING changes!</div>

            <p>Every interaction requires you to:</p>
            <ol>
                <li>Update your data (JavaScript variables)</li>
                <li>Find the right HTML elements</li>
                <li>Update those elements to match your data</li>
                <li>Make sure you didn't forget to update something</li>
            </ol>

            <div class="metaphor-box">
                <h4>The Spreadsheet Metaphor</h4>
                <p>Imagine a spreadsheet where formulas DON'T auto-calculate.<br><br>
                <strong>Without frameworks (manual):</strong> You have a column showing prices, a column showing quantities, and a total. When you change a price, you have to MANUALLY recalculate the total. Change 10 prices? Recalculate 10 times. Miss one? Your total is wrong.<br><br>
                <strong>With frameworks (automatic):</strong> Excel automatically updates the total when anything changes. You change a price - boom, total updates instantly. You never think about HOW it updates, it just DOES.<br><br>
                Frameworks are like Excel formulas for your website!</p>
            </div>

            <h4>The DOM: What You're Actually Manipulating</h4>
            <p>Before we go further, let's understand what the "DOM" is, because frameworks help you NOT have to work with it directly.</p>

            <div class="info-box">
                <h4>What is the DOM?</h4>
                <p>DOM stands for <strong>Document Object Model</strong>. Scary name, simple concept:<br><br>
                When your browser loads HTML, it converts it into a JavaScript object structure - a tree of elements that JavaScript can manipulate.<br><br>
                Your HTML is like a family tree:<br>
                <span class="inline-code">&lt;html&gt;</span> is the grandparent<br>
                <span class="inline-code">&lt;body&gt;</span> is a parent<br>
                <span class="inline-code">&lt;div&gt;</span> is a child<br>
                <span class="inline-code">&lt;p&gt;</span> inside <span class="inline-code">&lt;div&gt;</span> is a grandchild<br><br>
                The DOM lets JavaScript say "find the second child of the third div" or "change the text of this paragraph."</p>
            </div>

            <p>Working with the DOM directly is SLOW and TEDIOUS:</p>

            <div class="code">// All these DOM operations are SLOW:
const element = document.getElementById('my-div');
element.textContent = 'New text';
element.style.color = 'blue';
element.classList.add('active');

// Create new element
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello';
newDiv.className = 'card';
document.body.appendChild(newDiv);

// Remove element
const oldElement = document.getElementById('old-div');
oldElement.parentNode.removeChild(oldElement);

// Update a list of 100 items?
// Loop 100 times, update each one manually...
// SLOW and PAINFUL!</div>

            <h3>Part 4: Enter Frameworks - The Solution</h3>

            <h4>What Frameworks Actually Do</h4>
            <p>A framework (or library - we'll explain the difference soon) like React or Vue solves all these problems. Here's what they do:</p>

            <div class="info-box">
                <h4>What Frameworks Give You</h4>
                <p><strong>1. Automatic Updates:</strong> Change your data, and the UI updates automatically. No manual DOM manipulation.<br><br>
                <strong>2. Components:</strong> Build reusable pieces. Create a Button component once, use it 1000 times.<br><br>
                <strong>3. State Management:</strong> A smart way to store data that automatically triggers UI updates when it changes.<br><br>
                <strong>4. Declarative Code:</strong> You describe WHAT the UI should look like, not HOW to build it step-by-step.<br><br>
                <strong>5. Ecosystem:</strong> Thousands of pre-built components and tools you can use.<br><br>
                <strong>6. Performance:</strong> Frameworks are SMART about updating only what changed, not redrawing everything.</p>
            </div>

            <h4>The Declarative vs Imperative Mindset</h4>
            <p>This is THE most important mental shift when learning frameworks:</p>

            <div class="metaphor-box">
                <h4>Ordering at a Restaurant (Again!)</h4>
                <p><strong>Imperative (Vanilla JS):</strong><br>
                "Go to the kitchen. Open the fridge. Take out 3 eggs. Get a bowl from the cabinet. Crack each egg into the bowl. Whisk for 30 seconds. Get a pan from the drawer. Put it on the stove. Turn heat to medium. Wait 1 minute. Add butter. Wait for it to melt. Pour in eggs. Stir constantly with a spatula. After 2 minutes, add salt and pepper. Stir 30 more seconds. Transfer to a plate. Bring it to table 5."<br><br>
                You tell the chef EVERY SINGLE STEP. That's imperative programming.<br><br>
                <strong>Declarative (React/Vue):</strong><br>
                "I'd like scrambled eggs, please."<br><br>
                You describe WHAT you want. The chef figures out HOW to make it. That's declarative programming!</p>
            </div>

            <p>In code terms:</p>

            <div class="code">// IMPERATIVE (Vanilla JS):
// Tell the computer HOW to do everything
let count = 0;
const display = document.getElementById('count');

function increment() {
  count = count + 1;              // Step 1: Update data
  display.textContent = count;    // Step 2: Find element and update it
  
  if (count > 10) {               // Step 3: Check condition
    display.style.color = 'red';  // Step 4: Update styling
  } else {
    display.style.color = 'black';
  }
}

// DECLARATIVE (React):
// Describe WHAT you want the UI to look like
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p style={{ color: count &gt; 10 ? 'red' : 'black' }}&gt;
        Count: {count}
      &lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
// React figures out WHEN and HOW to update the DOM!</div>

            <p>See the difference? In React, you just say "when count is over 10, make it red." React handles the rest!</p>

            <h4>Why This Matters So Much</h4>
            <p>Let's compare building a shopping cart in vanilla JS vs React:</p>

            <div class="code">// VANILLA JS - YOU MUST DO EVERYTHING:
let cart = [];
const cartDisplay = document.getElementById('cart');
const totalDisplay = document.getElementById('total');
const countDisplay = document.getElementById('cart-count');

function addToCart(item) {
  // Step 1: Update data
  cart.push(item);
  
  // Step 2: Update cart display
  const li = document.createElement('li');
  li.textContent = item.name;
  cartDisplay.appendChild(li);
  
  // Step 3: Update total
  const total = cart.reduce((sum, i) => sum + i.price, 0);
  totalDisplay.textContent = '$' + total;
  
  // Step 4: Update count badge
  countDisplay.textContent = cart.length;
  
  // Step 5: Update localStorage
  localStorage.setItem('cart', JSON.stringify(cart));
  
  // Did you forget something? That's a bug!
}

// REACT - DESCRIBE WHAT YOU WANT:
function ShoppingCart() {
  const [cart, setCart] = useState([]);
  
  const addToCart = (item) => {
    setCart([...cart, item]);
    // That's IT! React updates EVERYTHING automatically:
    // - The cart list
    // - The total
    // - The count badge
    // No manual DOM manipulation!
  };
  
  const total = cart.reduce((sum, item) => sum + item.price, 0);
  
  return (
    &lt;div&gt;
      &lt;div&gt;Items: {cart.length}&lt;/div&gt;
      &lt;ul&gt;
        {cart.map(item => &lt;li&gt;{item.name}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;div&gt;Total: ${total}&lt;/div&gt;
    &lt;/div&gt;
  );
}
// React sees cart changed and re-renders EVERYTHING that uses it!</div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è The Mental Shift</h4>
                <p>The hardest part of learning React/Vue isn't the syntax - it's changing how you THINK about code.<br><br>
                <strong>Stop thinking:</strong> "When this button is clicked, find this element and change its text, then find that element and update its style, then..."<br><br>
                <strong>Start thinking:</strong> "Here's what my data looks like. Here's what my UI should look like for that data. When data changes, React figures out what to update."<br><br>
                Once this clicks, everything becomes easier!</p>
            </div>

            <h4>Component-Based Architecture</h4>
            <p>Frameworks let you build your UI from small, reusable pieces called <strong>components</strong>. This is HUGE for organization:</p>

            <div class="metaphor-box">
                <h4>LEGO Blocks Metaphor</h4>
                <p>Think of components like LEGO blocks:<br><br>
                <strong>Without components (vanilla JS):</strong> You're carving one giant sculpture from a single block of marble. Want to change the left arm? You have to carefully chisel, hoping you don't break the leg.<br><br>
                <strong>With components (React/Vue):</strong> You're building with LEGO. Create an Arm component. Use it for both arms! Need to change it? Rebuild just that block. Everything else stays intact. Want to build a whole LEGO person? Combine Head + Torso + 2 Arms + 2 Legs. Each piece is independent!</p>
            </div>

            <p>Here's how you might break down a website into components:</p>

            <div class="code">// A typical website structure:

App
‚îú‚îÄ‚îÄ Header
‚îÇ   ‚îú‚îÄ‚îÄ Logo
‚îÇ   ‚îú‚îÄ‚îÄ Navigation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavLink
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavLink
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NavLink
‚îÇ   ‚îî‚îÄ‚îÄ UserMenu
‚îÇ       ‚îú‚îÄ‚îÄ Avatar
‚îÇ       ‚îî‚îÄ‚îÄ Dropdown
‚îú‚îÄ‚îÄ Main
‚îÇ   ‚îú‚îÄ‚îÄ Sidebar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SearchBox
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FilterList
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FilterOption
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ FilterOption
‚îÇ   ‚îî‚îÄ‚îÄ Content
‚îÇ       ‚îú‚îÄ‚îÄ ProductCard
‚îÇ       ‚îú‚îÄ‚îÄ ProductCard
‚îÇ       ‚îî‚îÄ‚îÄ ProductCard
‚îÇ           ‚îú‚îÄ‚îÄ Image
‚îÇ           ‚îú‚îÄ‚îÄ Title
‚îÇ           ‚îú‚îÄ‚îÄ Price
‚îÇ           ‚îî‚îÄ‚îÄ AddToCartButton
‚îî‚îÄ‚îÄ Footer
    ‚îú‚îÄ‚îÄ SocialLinks
    ‚îî‚îÄ‚îÄ Copyright

// Each of these is a COMPONENT - a reusable piece!
// Build ProductCard once, use it 1000 times for 1000 products!</div>

            <h4>Why Components Are a Game-Changer</h4>

            <div class="info-box">
                <h4>The Power of Components</h4>
                <p><strong>Reusability:</strong> Build a Button component with all your styling and logic. Use it everywhere. Change it once, it updates everywhere.<br><br>
                <strong>Maintainability:</strong> Bug in the header? You know exactly where to look - the Header component. Not searching through 5000 lines of HTML.<br><br>
                <strong>Testability:</strong> Test each component individually. Button works? Great! Header works? Perfect! Combine them with confidence.<br><br>
                <strong>Team Work:</strong> Person A builds the header, Person B builds the footer. They work in separate files and merge easily.<br><br>
                <strong>Mental Model:</strong> Think about one small piece at a time, not the entire application at once.</p>
            </div>

            <h3>Part 5: React and Vue - What's the Difference?</h3>

            <h4>Library vs Framework (Again)</h4>
            <p>You'll hear React called a "library" and Vue called a "framework" (though Vue calls itself "progressive framework"). What's the difference?</p>

            <div class="metaphor-box">
                <h4>The Toolbox vs Construction Kit Metaphor</h4>
                <p><strong>React (Library):</strong> Like a toolbox. Here are some great tools (components, hooks, JSX). YOU decide how to structure your app. Want routing? Pick a library (React Router). Want global state? Pick one (Redux, MobX, Zustand). You're the architect.<br><br>
                <strong>Vue (Framework):</strong> Like a construction kit with instructions. Vue gives you tools AND tells you the "Vue way" of doing things. It includes routing (Vue Router), state management (Pinia/Vuex), and opinions on how to structure code. Still flexible, but more guided.<br><br>
                <strong>Angular (Full Framework):</strong> Like building with a pre-designed kit. Everything is included and there's ONE way to do things. Very opinionated.</p>
            </div>

            <p>In practice, for beginners, this distinction doesn't matter much! Both React and Vue solve the same problems:</p>

            <div class="code">// What React and Vue BOTH do:
‚úÖ Component-based architecture
‚úÖ Reactive state management (data changes = UI updates)
‚úÖ Virtual DOM for performance
‚úÖ Rich ecosystem of tools and libraries
‚úÖ Large communities with tons of tutorials
‚úÖ Can build anything from simple pages to huge apps

// Differences:
React:
- Uses JSX (HTML-in-JavaScript)
- More JavaScript-heavy
- More flexible (pick your own tools)
- Bigger job market

Vue:
- Uses templates (HTML-like)
- Easier for beginners
- More batteries-included
- Growing rapidly in popularity</div>

            <h4>Which One Should You Learn?</h4>
            <p>Honest answer: EITHER! They're both excellent. Learning one makes learning the other easy because the CONCEPTS are the same.</p>

            <div class="info-box">
                <h4>Pick Based On</h4>
                <p><strong>Choose React if:</strong><br>
                ‚Ä¢ You want maximum job opportunities (React is more common in job listings)<br>
                ‚Ä¢ You like JavaScript-heavy syntax<br>
                ‚Ä¢ You want to learn the most popular library<br>
                ‚Ä¢ You're okay piecing together your own toolset<br><br>
                <strong>Choose Vue if:</strong><br>
                ‚Ä¢ You're a complete beginner (Vue is often considered easier to start with)<br>
                ‚Ä¢ You prefer HTML-like templates<br>
                ‚Ä¢ You want more built-in features<br>
                ‚Ä¢ You like clear, official documentation<br><br>
                <strong>Best advice:</strong> Flip a coin! You can't go wrong. Learn one well, then learn the other later - it'll take you a weekend because you already understand the concepts.</p>
            </div>

            <h3>Part 6: State - The Most Important Concept</h3>

            <h4>What Even IS "State"?</h4>
            <p>You'll hear "state" mentioned constantly in framework tutorials. Let's break it down to the simplest possible explanation:</p>

            <div class="info-box">
                <h4>State in Plain English</h4>
                <p><strong>State</strong> = Data that can change over time.<br><br>
                That's it! Seriously!<br><br>
                Examples of state:<br>
                ‚Ä¢ A counter value (starts at 0, changes when you click)<br>
                ‚Ä¢ Whether a user is logged in (true or false)<br>
                ‚Ä¢ Items in a shopping cart (an array that grows/shrinks)<br>
                ‚Ä¢ The current page you're on<br>
                ‚Ä¢ Form input values<br>
                ‚Ä¢ Whether a modal is open or closed<br><br>
                State is just variables that, when they change, should update what the user sees.</p>
            </div>

            <div class="metaphor-box">
                <h4>The Light Switch Metaphor</h4>
                <p>Think of state like a light switch:<br><br>
                <strong>State value:</strong> ON or OFF (true or false)<br>
                <strong>UI:</strong> The light bulb (bright or dark)<br>
                <strong>State change:</strong> Flipping the switch<br><br>
                When you flip the switch (change state), the light automatically updates. You don't manually turn the bulb on - it's CONNECTED to the switch. That's how state works! Change state, UI automatically updates.</p>
            </div>

            <h4>State vs Regular Variables</h4>
            <p>Why not just use regular variables? Great question!</p>

            <div class="code">// Regular variable (doesn't work in React/Vue):
function Counter() {
  let count = 0;  // Regular variable
  
  function increment() {
    count = count + 1;
    console.log(count);  // This works! Logs 1, 2, 3...
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Problem: The UI shows "Count: 0" FOREVER
// Even though count IS changing, React doesn't know to re-render!</div>

            <p>React doesn't automatically watch all your variables. It would be too slow! Instead, you explicitly tell React "this variable is special - when it changes, update the UI":</p>

            <div class="code">// State variable (works!):
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);  // Special state variable
  
  function increment() {
    setCount(count + 1);
    // React sees count changed and automatically re-renders the component!
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Now it works! UI updates when count changes!</div>

            <h4>Breaking Down useState</h4>
            <p>Let's understand that weird syntax:</p>

            <div class="code">const [count, setCount] = useState(0);
//     ^       ^          ^         ^
//     |       |          |         |
//     |       |          |         Initial value (count starts at 0)
//     |       |          A React function that creates state
//     |       Function to UPDATE the state
//     The STATE VALUE itself</div>

            <div class="info-box">
                <h4>Understanding Array Destructuring</h4>
                <p><span class="inline-code">useState(0)</span> returns an array with TWO things: <span class="inline-code">[value, setterFunction]</span><br><br>
                We use <strong>array destructuring</strong> to unpack them:<br><br>
                <span class="inline-code">const [count, setCount] = useState(0);</span><br><br>
                Is the same as:<br><br>
                <span class="inline-code">const stateArray = useState(0);</span><br>
                <span class="inline-code">const count = stateArray[0];  // The value</span><br>
                <span class="inline-code">const setCount = stateArray[1];  // The setter</span><br><br>
                Destructuring is just shorter! You can name them whatever you want:<br>
                <span class="inline-code">const [user, setUser] = useState(null);</span><br>
                <span class="inline-code">const [isOpen, setIsOpen] = useState(false);</span><br>
                <span class="inline-code">const [items, setItems] = useState([]);</span></p>
            </div>

            <h4>Multiple State Variables</h4>
            <p>You can have as many state variables as you want:</p>

            <div class="code">function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  
  // Each one updates independently!
  
  return (
    &lt;form&gt;
      &lt;input 
        value={email} 
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input 
        type="password"
        value={password} 
        onChange={(e) =&gt; setPassword(e.target.value)}
      /&gt;
      &lt;input 
        type="checkbox"
        checked={rememberMe}
        onChange={(e) =&gt; setRememberMe(e.target.checked)}
      /&gt;
      {error && &lt;p&gt;{error}&lt;/p&gt;}
      {loading && &lt;p&gt;Loading...&lt;/p&gt;}
      &lt;button type="submit"&gt;Log In&lt;/button&gt;
    &lt;/form&gt;
  );
}</div>

            <h3>Part 7: Recap - Where We Are Now</h3>

            <h4>What You Now Understand</h4>
            <p>Let's recap this journey from absolute zero:</p>

            <div class="info-box">
                <h4>Your Mental Model So Far</h4>
                <p><strong>1. Websites are made of three things:</strong><br>
                ‚Ä¢ HTML (structure) - what's on the page<br>
                ‚Ä¢ CSS (styling) - how it looks<br>
                ‚Ä¢ JavaScript (behavior) - what it does<br><br>
                <strong>2. Frontend vs Backend:</strong><br>
                ‚Ä¢ Frontend = what users see and interact with (runs in browser)<br>
                ‚Ä¢ Backend = hidden server code that processes data (runs on server)<br>
                ‚Ä¢ Full-stack = both!<br><br>
                <strong>3. The problem with vanilla JavaScript:</strong><br>
                ‚Ä¢ You manually manipulate the DOM (slow and tedious)<br>
                ‚Ä¢ You must remember to update the UI when data changes<br>
                ‚Ä¢ Code becomes messy as apps grow<br><br>
                <strong>4. Frameworks solve this:</strong><br>
                ‚Ä¢ Declarative (describe what, not how)<br>
                ‚Ä¢ Components (reusable pieces)<br>
                ‚Ä¢ Automatic UI updates when state changes<br>
                ‚Ä¢ Much cleaner, more maintainable code<br><br>
                <strong>5. State is the key concept:</strong><br>
                ‚Ä¢ State = data that changes<br>
                ‚Ä¢ When state changes, UI updates automatically<br>
                ‚Ä¢ React uses useState() to create state<br>
                ‚Ä¢ Vue has ref() and reactive()<br><br>
                <strong>6. React and Vue both:</strong><br>
                ‚Ä¢ Use components<br>
                ‚Ä¢ Have reactive state<br>
                ‚Ä¢ Make building UIs much easier<br>
                ‚Ä¢ Are excellent choices for beginners</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Restaurant Metaphor</h4>
                <p>Let's bring it all together with our restaurant analogy:<br><br>
                <strong>HTML:</strong> The blueprint of the restaurant (where things are)<br>
                <strong>CSS:</strong> The interior design (how it looks)<br>
                <strong>JavaScript:</strong> The staff and operations (what happens)<br>
                <strong>Frontend:</strong> The dining area (what customers experience)<br>
                <strong>Backend:</strong> The kitchen (where the real work happens)<br>
                <strong>API:</strong> The waiter (carries requests and responses between dining area and kitchen)<br>
                <strong>State:</strong> The current situation (how many tables are occupied, what's cooking, who's waiting for food)<br>
                <strong>React/Vue:</strong> An automated system that updates menus, bills, and displays automatically when orders change - instead of staff manually rewriting everything!<br><br>
                Full-stack = understanding and being able to work in EVERY part of the restaurant!</p>
            </div>

            <h4>What's Next?</h4>
            <p>Now that you understand the foundations, the rest of this chapter will teach you:</p>

            <ul>
                <li><strong>Section 2:</strong> Building actual React apps from scratch (not just theory anymore!)</li>
                <li><strong>Section 3:</strong> Building actual Vue apps from scratch</li>
                <li><strong>Section 4:</strong> Connecting frontend to backend (full-stack!)</li>
                <li><strong>Section 5:</strong> Deploying your app so the world can see it</li>
            </ul>

            <div class="warning-box">
                <h4>üéØ Your Learning Strategy</h4>
                <p><strong>Don't rush!</strong> Seriously. These concepts take time to sink in.<br><br>
                <strong>Build as you learn:</strong> Type out every code example. Change things. Break things. Fix them.<br><br>
                <strong>Expect confusion:</strong> It's NORMAL to feel lost at first. Your brain is building new neural pathways. Keep going!<br><br>
                <strong>Focus on concepts, not syntax:</strong> The syntax of React vs Vue is different, but the CONCEPTS (components, state, props) are the same. Master concepts first.<br><br>
                <strong>One thing at a time:</strong> Don't try to learn React + TypeScript + Next.js + Redux all at once. Start simple!<br><br>
                <strong>Build tiny projects:</strong> A counter. A todo list. A weather app. Each one teaches you more than reading 100 tutorials.<br><br>
                Ready? Let's build something real!</p>
            </div>
        </section>
            <p>What happens if you add a third button that doubles the count? You'd need to add another event listener. What if you want to show the count in multiple places? You'd need to update multiple elements. What if you want to add a feature that changes the button text when count is high? More code, more places to update, more chances for bugs.</p>

            <div class="metaphor-box">
                <h4>The Recipe Metaphor</h4>
                <p>Think about cooking without a recipe versus following one:<br><br>
                <strong>Without a recipe (Vanilla JS):</strong> "Go to the stove. Turn the heat to medium. Get a pan. Add oil. Wait 30 seconds. Crack eggs. Stir constantly. After 2 minutes, add salt..." You have to remember every step, in order, and do each one manually.<br><br>
                <strong>With a recipe (React):</strong> "I want scrambled eggs with salt." The recipe handles the steps. You just describe the end result you want.<br><br>
                React lets you describe WHAT you want, not HOW to create it. This is called "declarative programming."</p>
            </div>

            <h3>Part 2: What Even IS React?</h3>

            <h4>The Absolute Basics (No Jargon)</h4>
            <p>React is a JavaScript library that solves the exact problem we just saw. Instead of you manually updating the page every time data changes, React does it for you automatically. Let me break that down:</p>

            <div class="info-box">
                <h4>React in Simple Terms</h4>
                <p><strong>What it is:</strong> A tool that helps you build websites where things change and update automatically.<br><br>
                <strong>What it does:</strong> You tell React what the page should look like based on your data, and React handles all the complicated DOM manipulation for you.<br><br>
                <strong>Why it's useful:</strong> Instead of writing "when this button is clicked, find this element and change it," you write "here's what the page looks like when count is 0, here's what it looks like when count is 5." React figures out how to update everything.</p>
            </div>

            <h4>Library vs Framework - What's the Difference?</h4>
            <p>You'll hear React called both a "library" and a "framework." Here's the difference (and why it matters):</p>

            <div class="metaphor-box">
                <h4>Library vs Framework</h4>
                <p><strong>A Library (like React):</strong> It's like a toolbox. You pick which tools you want to use, when you want to use them, and how. React gives you tools for building UIs, but YOU decide the structure of your app. Want to add routing? Pick a library. Want to manage global state? Pick another library. You're in control.<br><br>
                <strong>A Framework (like Angular):</strong> It's like building with a construction kit that comes with instructions. The framework decides the structure, the rules, and how everything fits together. You work within its system.<br><br>
                Think of it this way: A library is a cookbook - you choose recipes. A framework is a meal kit - everything is pre-planned, you just follow steps.</p>
            </div>

            <p>React technically calls itself a "library," but many people casually call it a "framework." For our purposes, it doesn't matter much - what matters is understanding what React DOES.</p>

            <h4>The Big Concept: Components</h4>
            <p>Everything in React is built from <strong>components</strong>. But what's a component? Let's build up to it:</p>

            <p>Remember functions from Chapter 2? A function is a reusable piece of code:</p>

            <div class="code">// A simple function
function greet(name) {
  return "Hello, " + name + "!";
}

// Use it multiple times
console.log(greet("Alice"));  // "Hello, Alice!"
console.log(greet("Bob"));    // "Hello, Bob!"

            <p>A React component is just like that, but instead of returning text, it returns HTML!</p>

            <div class="code">// A React component (we'll explain the syntax soon)
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// Use it multiple times in your page
&lt;Greeting name="Alice" /&gt;   // Shows: Hello, Alice!
&lt;Greeting name="Bob" /&gt;     // Shows: Hello, Bob!</div>

            <p>That's it! A component is a function that returns HTML. You can use it like a custom HTML tag.</p>

            <div class="info-box">
                <h4>Why Components Are Awesome</h4>
                <p><strong>Reusability:</strong> Write once, use everywhere. Like a button component you use 100 times.<br><br>
                <strong>Organization:</strong> Instead of one giant 5000-line HTML file, you have small, focused pieces.<br><br>
                <strong>Maintainability:</strong> If you need to fix a bug in your button, you fix it in ONE place.<br><br>
                <strong>Thinking in pieces:</strong> Your brain can focus on one small thing at a time instead of the whole app.</p>
            </div>

            <h4>Declarative vs Imperative (The React Way of Thinking)</h4>
            <p>This is THE most important concept to understand about React. Let's use an analogy:</p>

            <div class="metaphor-box">
                <h4>Ordering at a Restaurant</h4>
                <p><strong>Imperative (Vanilla JS):</strong> "Go to the kitchen. Get a pan. Turn on the stove to medium heat. Get 3 eggs from the fridge. Crack them into a bowl. Whisk them. Pour into pan. Stir for 2 minutes. Add salt. Serve on a plate."<br><br>
                You tell the chef every single step, in order, exactly how to do it.<br><br>
                <strong>Declarative (React):</strong> "I'd like scrambled eggs, please."<br><br>
                You describe WHAT you want, not HOW to make it. The chef (React) handles all the steps.</p>
            </div>

            <p>In code terms:</p>

            <div class="code">// IMPERATIVE (Vanilla JS) - Tell HOW to do everything
let count = 0;
const display = document.getElementById('count');

function increment() {
  count = count + 1;           // Step 1: Change the data
  display.textContent = count; // Step 2: Update the display
}

// DECLARATIVE (React) - Tell WHAT you want
function Counter() {
  const [count, setCount] = useState(0);
  
  // Just describe what the UI looks like for the current count
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
// React figures out HOW to update the display!

            <p>See the difference? In React, you just describe what the UI should look like. When <span class="inline-code">count</span> changes, React automatically updates the display. You don't tell it HOW - it figures that out.</p>

            <h4>Setting Up React (Two Ways)</h4>
            <p>Before we write React code, we need to set it up. There are two main ways beginners can start:</p>

            <h4>Method 1: Create React App (The Traditional Way)</h4>
            <p>Create React App is a tool that sets up everything you need with one command. It's like getting a fully furnished apartment - everything works out of the box.</p>

            <div class="code">// In your terminal (you need Node.js installed - see Chapter 4)
npx create-react-app my-first-app

// This creates a folder with:
// - React installed
// - A development server
// - Build tools configured
// - Sample code to get started

// Go into the folder
cd my-first-app

// Start the development server
npm start

// Your browser opens to http://localhost:3000
// You'll see a spinning React logo!</div>

            <div class="info-box">
                <h4>What Just Happened?</h4>
                <p><span class="inline-code">npx</span> is a tool that comes with Node.js. It runs <span class="inline-code">create-react-app</span> which:<br><br>
                ‚Ä¢ Downloads React and related tools<br>
                ‚Ä¢ Sets up a project structure<br>
                ‚Ä¢ Configures a development server with hot reloading (your changes appear instantly)<br>
                ‚Ä¢ Sets up build tools (Webpack, Babel) that convert your React code to regular JavaScript browsers understand</p>
            </div>

            <h4>Method 2: Vite (The Modern, Faster Way)</h4>
            <p>Vite (pronounced "veet" - French for "fast") is a newer tool that's becoming more popular because it's MUCH faster than Create React App.</p>

            <div class="code">// In your terminal
npm create vite@latest my-first-app

// It asks what framework: Choose "React"
// It asks variant: Choose "JavaScript" (not TypeScript yet)

// Go into the folder
cd my-first-app

// Install dependencies
npm install

// Start the development server
npm run dev

// Your browser opens and you see the Vite + React demo!

            <div class="warning-box">
                <h4>Which One Should I Use?</h4>
                <p>For learning: Either is fine! Both work great.<br><br>
                <strong>Create React App:</strong> More established, tons of tutorials online use it.<br>
                <strong>Vite:</strong> Faster, more modern, becoming the standard for new projects.<br><br>
                If you're just starting, go with Vite. It's faster and you'll see changes instantly.</p>
            </div>

            <h3>Part 3: Your First React Component (Let's Actually Code!)</h3>

            <h4>The Absolute Simplest Component</h4>
            <p>Let's start with literally the simplest React component possible. Open your project (either Create React App or Vite) and look for a file called <span class="inline-code">App.jsx</span> or <span class="inline-code">App.js</span>. Clear everything in it and type:</p>

            <div class="code">function App() {
  return &lt;h1&gt;Hello World&lt;/h1&gt;;
}

export default App;</div>

            <p>That's it! Save the file. If your dev server is running (<span class="inline-code">npm start</span> or <span class="inline-code">npm run dev</span>), your browser will instantly show "Hello World" in big letters.</p>

            <h4>Breaking Down Every Single Piece</h4>
            <p>Let's analyze this code line by line, assuming you know NOTHING:</p>

            <div class="code">function App() {      // 1. A function named "App"
                             //    Component names MUST start with capital letter!
  
  return &lt;h1&gt;Hello World&lt;/h1&gt;;  // 2. Return some HTML
                                      //    This looks like HTML but it's JSX
}

export default App;  // 3. Make this component available to other files

            <div class="info-box">
                <h4>Why Capital Letters Matter</h4>
                <p>React treats lowercase components as regular HTML tags. So <span class="inline-code">&lt;div&gt;</span> is HTML, but <span class="inline-code">&lt;App&gt;</span> is a component.<br><br>
                <span class="inline-code">&lt;button&gt;</span> = HTML button<br>
                <span class="inline-code">&lt;Button&gt;</span> = Your custom Button component<br><br>
                Always name components with PascalCase (capital first letter)!</p>
            </div>

            <h4>What is JSX?</h4>
            <p>That <span class="inline-code">&lt;h1&gt;Hello World&lt;/h1&gt;</span> looks like HTML, but it's in a JavaScript file! This is JSX - JavaScript XML. It's a special syntax that lets you write HTML-looking code in JavaScript.</p>

            <div class="code">// This is JSX:
return &lt;h1&gt;Hello World&lt;/h1&gt;;

// Behind the scenes, it gets converted to regular JavaScript:
return React.createElement('h1', null, 'Hello World');

// JSX is just EASIER TO READ than the converted version!</div>

            <h4>Putting JavaScript Inside JSX</h4>
            <p>The power of JSX is that you can mix JavaScript right into your HTML using curly braces <span class="inline-code">{ }</span>:</p>

            <div class="code">function App() {
  const name = "Alice";
  const age = 25;
  const hobbies = ["coding", "gaming", "reading"];
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
      &lt;p&gt;You are {age} years old&lt;/p&gt;
      &lt;p&gt;Next year you'll be {age + 1}&lt;/p&gt;
      &lt;p&gt;2 + 2 = {2 + 2}&lt;/p&gt;
      &lt;p&gt;Random number: {Math.random()}&lt;/p&gt;
      &lt;p&gt;Your hobbies: {hobbies.join(", ")}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default App;</div>

            <p>Anything inside <span class="inline-code">{ }</span> is regular JavaScript! You can do math, call functions, access variables, anything.</p>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Common Beginner Mistakes with JSX</h4>
                <p><strong>1. Use className not class:</strong> Because "class" is a reserved word in JavaScript, React uses <span class="inline-code">className</span> for CSS classes.<br><br>
                <strong>Wrong:</strong> <span class="inline-code">&lt;div class="container"&gt;</span><br>
                <strong>Right:</strong> <span class="inline-code">&lt;div className="container"&gt;</span><br><br>
                <strong>2. Close all tags:</strong> HTML lets you write <span class="inline-code">&lt;img&gt;</span> or <span class="inline-code">&lt;br&gt;</span>, but JSX requires <span class="inline-code">&lt;img /&gt;</span> and <span class="inline-code">&lt;br /&gt;</span>.<br><br>
                <strong>3. Return ONE root element:</strong> You can't return multiple elements directly. Wrap them in a <span class="inline-code">&lt;div&gt;</span> or use a Fragment <span class="inline-code">&lt;&gt;&lt;/&gt;</span>.</p>
            </div>

            <div class="code">// ‚ùå WRONG - Multiple root elements
function App() {
  return (
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Paragraph&lt;/p&gt;
  );
}

// ‚úÖ RIGHT - Wrapped in div
function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Title&lt;/h1&gt;
      &lt;p&gt;Paragraph&lt;/p&gt;
    &lt;/div&gt;
  );
}

// ‚úÖ ALSO RIGHT - Using Fragment (doesn't add extra HTML)
function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;Title&lt;/h1&gt;
      &lt;p&gt;Paragraph&lt;/p&gt;
    &lt;/&gt;
  );
}

            <h4>Complete Working Example</h4>
            <p>Here's a real, complete component that demonstrates everything we've learned so far:</p>

            <div class="code">function App() {
  // JavaScript variables
  const userName = "Alice";
  const userAge = 25;
  const isLoggedIn = true;
  const skills = ["JavaScript", "React", "CSS"];
  
  return (
    &lt;div className="app-container"&gt;
      {/* This is a comment in JSX - must be in curly braces! */}
      
      &lt;h1&gt;Welcome to My App&lt;/h1&gt;
      
      {/* Using variables in JSX */}
      &lt;p&gt;Hello, {userName}!&lt;/p&gt;
      &lt;p&gt;Age: {userAge}&lt;/p&gt;
      
      {/* Conditional rendering - shows different content based on condition */}
      {isLoggedIn ? (
        &lt;p&gt;You are logged in! ‚úÖ&lt;/p&gt;
      ) : (
        &lt;p&gt;Please log in&lt;/p&gt;
      )}
      
      {/* Rendering a list */}
      &lt;h2&gt;My Skills:&lt;/h2&gt;
      &lt;ul&gt;
        {skills.map((skill) =&gt; (
          &lt;li key={skill}&gt;{skill}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      
      {/* Self-closing tags */}
      &lt;img src="/avatar.jpg" alt="Avatar" /&gt;
      &lt;br /&gt;
      
      {/* camelCase for event handlers */}
      &lt;button onClick={() =&gt; alert('Button clicked!')}&gt;
        Click Me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;</div>

            <h3>Hooks Mastery</h3>
            <p>Hooks are functions that let you "hook into" React features from functional components. They revolutionized React development by making functional components as powerful as class components.</p>

            <h4>useState - State Management</h4>
            <p>The most commonly used hook for managing component state.</p>

            <div class="code">import { useState } from 'react';

// Basic usage
function Example() {
  const [count, setCount] = useState(0);
  
  return <button onClick={() => setCount(count + 1)}>
    Clicked {count} times
  </button>;
}

// Functional updates (when new state depends on old state)
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    // BAD - can cause bugs with multiple updates
    setCount(count + 1);
    
    // GOOD - uses previous state
    setCount(prev => prev + 1);
  };
  
  const incrementMultiple = () => {
    // This works correctly because of functional updates
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };
  
  return <button onClick={incrementMultiple}>+3</button>;
}

// Lazy initialization (expensive computation)
function ExpensiveComponent() {
  // BAD - runs every render
  const [state, setState] = useState(expensiveFunction());
  
  // GOOD - runs only on initial render
  const [state, setState] = useState(() => expensiveFunction());
  
  return <div>{state}</div>;
}

// Multiple state variables
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [errors, setErrors] = useState({});
  
  // OR use a single state object
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  return null;
}</div>

            <h4>useEffect - Side Effects</h4>
            <p>useEffect handles side effects like data fetching, subscriptions, and manual DOM manipulation.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Basic usage - runs after every render
function Example() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `Count: ${count}`;
  });
  
  return <button onClick={() => setCount(count + 1)}>
    Increment
  </button>;
}

// With dependency array - runs only when dependencies change
function User({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    setLoading(true);
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        console.error(err);
        setLoading(false);
      });
  }, [userId]); // Re-run when userId changes
  
  if (loading) return <div>Loading...</div>;
  return <div>{user?.name}</div>;
}

// Cleanup function - prevents memory leaks
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // Cleanup function runs before component unmounts
    // and before the effect runs again
    return () => {
      clearInterval(interval);
      console.log('Timer cleaned up');
    };
  }, []); // Empty array = run once on mount
  
  return <div>Seconds: {seconds}</div>;
}

// Real-world example - WebSocket connection
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://api.com/rooms/${roomId}`);
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    // Cleanup: close connection when component unmounts
    // or when roomId changes
    return () => {
      ws.close();
    };
  }, [roomId]);
  
  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useEffect Pitfalls</h4>
                <p><strong>Missing dependencies:</strong> Always include all values from component scope that are used in effect.<br><br>
                <strong>Infinite loops:</strong> Be careful with dependency arrays - updating state that's in dependencies causes loops.<br><br>
                <strong>Async functions:</strong> Can't make useEffect callback async directly. Create async function inside instead.<br><br>
                <strong>Cleanup is crucial:</strong> Always cleanup subscriptions, timers, and listeners to prevent memory leaks.</p>
            </div>

            <h4>useContext - Global State</h4>
            <p>useContext provides a way to pass data through the component tree without passing props down manually at every level.</p>

            <div class="code">import { createContext, useContext, useState } from 'react';

// 1. Create a context
const ThemeContext = createContext();

// 2. Create a provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create a custom hook for easy access
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 4. Use in components
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={`header-${theme}`}>
      <h1>My App</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}

// Real-world example - Auth context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('token');
    if (token) {
      fetch('/api/auth/me', {
        headers: { Authorization: `Bearer ${token}` }
      })
        .then(res => res.json())
        .then(data => {
          setUser(data);
          setLoading(false);
        })
        .catch(() => {
          localStorage.removeItem('token');
          setLoading(false);
        });
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    const data = await res.json();
    localStorage.setItem('token', data.token);
    setUser(data.user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}</div>

            <h4>useRef - Persistent Values & DOM Access</h4>
            <p>useRef creates a mutable reference that persists across renders without causing re-renders when changed.</p>

            <div class="code">import { useRef, useEffect } from 'react';

// Accessing DOM elements
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  useEffect(() => {
    // Auto-focus on mount
    inputRef.current.focus();
  }, []);
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

// Storing previous values
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();
  
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  const prevCount = prevCountRef.current;
  
  return (
    <div>
      <h2>Current: {count}</h2>
      <h3>Previous: {prevCount}</h3>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// Storing interval/timeout IDs
function StopWatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  
  const start = () => {
    setIsRunning(true);
    intervalRef.current = setInterval(() => {
      setTime(t => t + 1);
    }, 1000);
  };
  
  const stop = () => {
    setIsRunning(false);
    clearInterval(intervalRef.current);
  };
  
  const reset = () => {
    stop();
    setTime(0);
  };
  
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <div>
      <h2>Time: {time}s</h2>
      {!isRunning ? (
        <button onClick={start}>Start</button>
      ) : (
        <button onClick={stop}>Stop</button>
      )}
      <button onClick={reset}>Reset</button>
    </div>
  );
}

// Preventing unnecessary API calls
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const abortControllerRef = useRef(null);
  
  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }
    
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // Create new abort controller
    abortControllerRef.current = new AbortController();
    
    fetch(`/api/search?q=${query}`, {
      signal: abortControllerRef.current.signal
    })
      .then(res => res.json())
      .then(data => setResults(data))
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      });
  }, [query]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}</div>

            <h4>useMemo - Expensive Computations</h4>
            <p>useMemo memoizes computed values, recalculating only when dependencies change.</p>

            <div class="code">import { useMemo, useState } from 'react';

function ProductList({ products, searchTerm, sortBy }) {
  // Expensive filtering and sorting
  const processedProducts = useMemo(() => {
    console.log('Processing products...');
    
    let result = products.filter(product =>
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    result.sort((a, b) => {
      if (sortBy === 'price') {
        return a.price - b.price;
      }
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      return 0;
    });
    
    return result;
  }, [products, searchTerm, sortBy]);
  // Only recalculate when these change
  
  return (
    <div>
      {processedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// When NOT to use useMemo
function SimpleComponent({ a, b }) {
  // BAD - premature optimization
  const sum = useMemo(() => a + b, [a, b]);
  
  // GOOD - simple calculation, no memoization needed
  const sum = a + b;
  
  return <div>Sum: {sum}</div>;
}

// Memoizing object creation for dependencies
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  // WITHOUT useMemo - creates new object every render
  // causes useEffect to run every time
  const requestOptions = {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  };
  
  // WITH useMemo - stable reference
  const requestOptions = useMemo(() => ({
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  }), [token]);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`, requestOptions)
      .then(res => res.json())
      .then(setUser);
  }, [userId, requestOptions]); // Now only runs when actually needed
  
  return <div>{user?.name}</div>;
}</div>

            <h4>useCallback - Memoized Functions</h4>
            <p>useCallback memoizes function definitions, preventing unnecessary re-creations.</p>

            <div class="code">import { useCallback, useState, memo } from 'react';

// Child component - expensive to render
const ExpensiveChild = memo(({ onClick, data }) => {
  console.log('ExpensiveChild rendered');
  return (
    <button onClick={onClick}>
      Click me - {data}
    </button>
  );
});

function Parent() {
  const [count, setCount] = useState(0);
  const [other, setOther] = useState(0);
  
  // WITHOUT useCallback - new function every render
  // ExpensiveChild re-renders unnecessarily
  const handleClick = () => {
    setCount(c => c + 1);
  };
  
  // WITH useCallback - stable function reference
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []); // No dependencies - function never changes
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => setOther(other + 1)}>
        Other: {other}
      </button>
      <ExpensiveChild onClick={handleClick} data={count} />
    </div>
  );
}

// Real-world example - event handlers with parameters
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  // Memoize the remove function
  const removeTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []); // No dependencies because we use functional update
  
  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  }, []);
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onRemove={removeTodo}
          onToggle={toggleTodo}
        />
      ))}
    </div>
  );
}

// useCallback with dependencies
function SearchBox({ onSearch, filters }) {
  const [query, setQuery] = useState('');
  
  const handleSearch = useCallback(() => {
    // Function recreated when filters change
    onSearch(query, filters);
  }, [query, filters, onSearch]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useMemo vs useCallback</h4>
                <p><strong>useMemo:</strong> Memoizes the RESULT of a function - <span class="inline-code">useMemo(() => value, deps)</span><br><br>
                <strong>useCallback:</strong> Memoizes the FUNCTION itself - <span class="inline-code">useCallback(fn, deps)</span><br><br>
                <strong>Remember:</strong> <span class="inline-code">useCallback(fn, deps)</span> is equivalent to <span class="inline-code">useMemo(() => fn, deps)</span><br><br>
                <strong>Don't overuse:</strong> These optimizations have a cost. Only use when profiling shows a performance issue.</p>
            </div>

            <h4>Custom Hooks - Reusable Logic</h4>
            <p>Custom hooks let you extract component logic into reusable functions. They're just JavaScript functions that use React hooks.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Custom hook for fetching data
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
          setData(null);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url, JSON.stringify(options)]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(
    `/api/users/${userId}`
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
}

// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function
        ? value(storedValue)
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}

// Custom hook for window dimensions
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Custom hook for debounced value
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage - search with debounce
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  const { data: results } = useFetch(
    `/api/search?q=${debouncedSearchTerm}`
  );
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {results && results.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}</div>

            <h3>Advanced Component Patterns</h3>

            <h4>Higher-Order Components (HOCs)</h4>
            <p>A higher-order component is a function that takes a component and returns a new component with additional props or behavior.</p>

            <div class="code">// Basic HOC pattern
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...props} />;
  };
}

// Usage
const UserListWithLoading = withLoading(UserList);

// With authentication
function withAuth(Component) {
  return function WithAuthComponent(props) {
    const { user, loading } = useAuth();
    
    if (loading) {
      return <div>Checking authentication...</div>;
    }
    
    if (!user) {
      return <Navigate to="/login" />;
    }
    
    return <Component {...props} user={user} />;
  };
}

// Usage
const ProtectedDashboard = withAuth(Dashboard);

// With data fetching
function withData(url) {
  return function (Component) {
    return function WithDataComponent(props) {
      const { data, loading, error } = useFetch(url);
      
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error}</div>;
      
      return <Component {...props} data={data} />;
    };
  };
}

// Usage
const UserListWithData = withData('/api/users')(UserList);

// Composing multiple HOCs
const EnhancedComponent = withAuth(
  withLoading(
    withData('/api/users')(UserList)
  )
);</div>

            <div class="info-box">
                <h4>HOC Best Practices</h4>
                <p><strong>Don't mutate:</strong> Create new components, don't modify the original.<br><br>
                <strong>Pass through props:</strong> Forward all props that aren't consumed by the HOC.<br><br>
                <strong>Display name:</strong> Set displayName for better debugging.<br><br>
                <strong>Static methods:</strong> Copy static methods from wrapped component.<br><br>
                <strong>Refs:</strong> Use React.forwardRef to forward refs through HOCs.</p>
            </div>

            <h4>Render Props Pattern</h4>
            <p>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</p>

            <div class="code">// Mouse tracker with render props
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return render(position);
}

// Usage
function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <div>
          Mouse position: {x}, {y}
        </div>
      )}
    />
  );
}

// Using children as a function (common pattern)
function DataProvider({ url, children }) {
  const { data, loading, error } = useFetch(url);
  
  return children({ data, loading, error });
}

// Usage
function App() {
  return (
    <DataProvider url="/api/users">
      {({ data, loading, error }) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error}</div>;
        return (
          <ul>
            {data.map(user => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>
        );
      }}
    </DataProvider>
  );
}

// Toggle component with render props
function Toggle({ initial = false, children }) {
  const [on, setOn] = useState(initial);
  
  const toggle = () => setOn(prev => !prev);
  const setOff = () => setOn(false);
  const setOn = () => setOn(true);
  
  return children({
    on,
    toggle,
    setOff,
    setOn
  });
}

// Usage
<Toggle initial={false}>
  {({ on, toggle }) => (
    <div>
      <button onClick={toggle}>
        {on ? 'ON' : 'OFF'}
      </button>
      {on && <div>Content visible!</div>}
    </div>
  )}
</Toggle></div>

            <h4>Compound Components Pattern</h4>
            <p>Compound components work together to form a complete UI. They share implicit state without prop drilling.</p>

            <div class="code">// Tabs compound component
const TabsContext = createContext();

function Tabs({ children, defaultValue }) {
  const [activeTab, setActiveTab] = useState(defaultValue);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === value;
  
  return (
    <button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== value) return null;
  
  return <div className="tab-panel">{children}</div>;
}

// Attach sub-components
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage - beautiful API!
function App() {
  return (
    <Tabs defaultValue="profile">
      <Tabs.List>
        <Tabs.Tab value="profile">Profile</Tabs.Tab>
        <Tabs.Tab value="settings">Settings</Tabs.Tab>
        <Tabs.Tab value="notifications">Notifications</Tabs.Tab>
      </Tabs.List>
      
      <Tabs.Panel value="profile">
        <h2>Profile Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="settings">
        <h2>Settings Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="notifications">
        <h2>Notifications Content</h2>
      </Tabs.Panel>
    </Tabs>
  );
}</div>

            <h3>Performance Optimization</h3>

            <h4>React.memo - Component Memoization</h4>
            <p>React.memo prevents unnecessary re-renders by memoizing component output.</p>

            <div class="code">import { memo } from 'react';

// Without memo - re-renders every time parent renders
function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  // Expensive computation
  return <div>{data}</div>;
}

// With memo - only re-renders when props change
const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  return <div>{data}</div>;
});

// Custom comparison function
const ExpensiveComponent = memo(
  function ExpensiveComponent({ user, settings }) {
    return (
      <div>
        <h2>{user.name}</h2>
        <p>{settings.theme}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    // Return false if props changed (re-render)
    return (
      prevProps.user.id === nextProps.user.id &&
      prevProps.settings.theme === nextProps.settings.theme
    );
  }
);

// Real-world example
const ProductCard = memo(function ProductCard({ product, onAddToCart }) {
  console.log(`Rendering product: ${product.name}`);
  
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => onAddToCart(product.id)}>
        Add to Cart
      </button>
    </div>
  );
});

function ProductList({ products }) {
  const [cart, setCart] = useState([]);
  
  // Memoize callback to prevent ProductCard re-renders
  const handleAddToCart = useCallback((productId) => {
    setCart(prev => [...prev, productId]);
  }, []);
  
  return (
    <div className="product-list">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
}</div>

            <h4>Code Splitting & Lazy Loading</h4>
            <p>Split your code into smaller chunks that load on demand, reducing initial bundle size.</p>

            <div class="code">import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Dashboard />
      </Suspense>
    </div>
  );
}

// With React Router
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Custom loading component
function LoadingSpinner() {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  );
}

// Error boundary for lazy loading
class LazyLoadErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Failed to load component</h2>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage with error boundary
<LazyLoadErrorBoundary>
  <Suspense fallback={<LoadingSpinner />}>
    <Dashboard />
  </Suspense>
</LazyLoadErrorBoundary></div>

            <div class="info-box">
                <h4>Performance Tips</h4>
                <p><strong>List virtualization:</strong> Use libraries like react-window for long lists.<br><br>
                <strong>Debounce expensive operations:</strong> Delay API calls and computations.<br><br>
                <strong>Avoid inline functions:</strong> Extract to useCallback when passing to memoized components.<br><br>
                <strong>Profile before optimizing:</strong> Use React DevTools Profiler to find real bottlenecks.<br><br>
                <strong>Bundle analysis:</strong> Use webpack-bundle-analyzer to find large dependencies.</p>
            </div>

            <h3>Error Boundaries</h3>
            <p>Error boundaries catch JavaScript errors anywhere in the component tree and display a fallback UI.</p>

            <div class="code">import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error to error reporting service
    console.error('Error caught by boundary:', error, errorInfo);
    
    // You can also log to external services
    // logErrorToService(error, errorInfo);
    
    this.setState({
      error,
      errorInfo
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <ErrorBoundary>
        <Sidebar />
      </ErrorBoundary>
      <ErrorBoundary>
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}

// Component that might error
function BuggyComponent() {
  const [count, setCount] = useState(0);
  
  if (count === 5) {
    // Simulate an error
    throw new Error('Crashed at count 5!');
  }
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}</div>

            <div class="warning-box">
                <h4>Error Boundary Limitations</h4>
                <p>Error boundaries do NOT catch errors in:<br><br>
                ‚Ä¢ Event handlers (use try-catch instead)<br>
                ‚Ä¢ Asynchronous code (setTimeout, fetch)<br>
                ‚Ä¢ Server-side rendering<br>
                ‚Ä¢ Errors thrown in the error boundary itself<br><br>
                For event handlers, wrap in try-catch and update state to show error UI.</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered React!</h4>
                <p>Congratulations! You now understand React from the ground up - from the Virtual DOM to advanced patterns, performance optimization, and error handling. You're equipped to build production-ready React applications with confidence. Remember: the best way to solidify this knowledge is to build real projects. Start small, iterate, and gradually tackle more complex challenges.</p>
            </div>
        </section>

        <!-- SECTION 2: Vue Mastery -->
        <section id="vue-mastery" class="section">
            <h2 class="section-title">Vue Mastery</h2>
            <p class="section-intro">Vue.js is the approachable, versatile, and performant framework that makes building web interfaces a joy. In this comprehensive section, we'll explore Vue from the ground up - from understanding its reactive philosophy to mastering advanced patterns with Composition API, Pinia state management, and sophisticated routing. Whether you're coming from React or starting fresh, you'll discover why Vue has become one of the most loved frameworks in the JavaScript ecosystem.</p>

            <h3>1. Introduction to Vue: The Progressive Framework</h3>
            
            <p>Vue (pronounced "view") is often described as the "progressive framework" - but what does that actually mean? Unlike all-or-nothing frameworks, Vue is designed to be incrementally adoptable. You can use as little or as much Vue as you need, from enhancing a single section of an existing page to building full-scale single-page applications.</p>

            <div class="metaphor-box">
                <h4>The Swiss Army Knife of Frameworks</h4>
                <p>Think of Vue like a Swiss Army knife. React is like a specialized chef's knife - exceptional at one thing but requires additional tools for a complete toolkit. Angular is like a professional kitchen - everything included but overwhelming if you just want to make a sandwich. Vue gives you the essential tools in one elegant package, and you can add more specialized tools as needed.</p>
            </div>

            <h4>Why Vue? The Philosophy</h4>
            
            <p>Vue was created by Evan You after working with Angular at Google. He wanted to extract the parts he really liked about Angular and build something lighter and more flexible. The result is a framework that prioritizes:</p>

            <ul>
                <li><strong>Approachability:</strong> Gentle learning curve, especially if you know HTML, CSS, and basic JavaScript</li>
                <li><strong>Versatility:</strong> Works for projects of any size, from progressive enhancement to full SPAs</li>
                <li><strong>Performance:</strong> Fast virtual DOM implementation with automatic optimization</li>
                <li><strong>Developer Experience:</strong> Excellent tooling, clear error messages, and comprehensive documentation</li>
            </ul>

            <h4>Vue vs React: Key Differences</h4>

            <p>If you're familiar with React, here are the main philosophical differences:</p>

            <div class="code">// REACT: JavaScript-centric, JSX everywhere
function Counter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

// VUE: Template-based, HTML-centric approach
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
    &lt;button @click="count++"&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
const count = ref(0);
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Template vs JSX</h4>
                <p><strong>Vue templates</strong> are easier to read and write for most developers, especially those with HTML/CSS backgrounds. <strong>React JSX</strong> offers more JavaScript flexibility but has a steeper learning curve. Vue supports both approaches - you can use templates OR JSX render functions.</p>
            </div>

            <h3>2. Vue Fundamentals: Template Syntax & Directives</h3>

            <p>Vue's template syntax extends HTML with powerful directives that make building dynamic interfaces intuitive. Let's master each directive with practical examples.</p>

            <h4>Text Interpolation & Expressions</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Basic interpolation --&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  
  &lt;!-- JavaScript expressions work! --&gt;
  &lt;p&gt;{{ message.toUpperCase() }}&lt;/p&gt;
  &lt;p&gt;{{ number + 1 }}&lt;/p&gt;
  &lt;p&gt;{{ isActive ? 'Yes' : 'No' }}&lt;/p&gt;
  
  &lt;!-- Ternary operators, method calls --&gt;
  &lt;p&gt;{{ reversedMessage() }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, computed } from 'vue';

const message = ref('Hello Vue!');
const number = ref(41);
const isActive = ref(true);

function reversedMessage() {
  return message.value.split('').reverse().join('');
}
&lt;/script&gt;</div>

            <h4>v-bind: Dynamic Attributes</h4>

            <p>The <span class="inline-code">v-bind</span> directive dynamically binds attributes to expressions. The shorthand <span class="inline-code">:</span> is commonly used.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;img v-bind:src="imageSrc" v-bind:alt="imageAlt"&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;img :src="imageSrc" :alt="imageAlt"&gt;
  
  &lt;!-- Binding classes --&gt;
  &lt;div :class="{ active: isActive, 'text-danger': hasError }"&gt;&lt;/div&gt;
  &lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;
  
  &lt;!-- Binding styles --&gt;
  &lt;div :style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
  
  &lt;!-- Binding multiple attributes --&gt;
  &lt;div v-bind="objectOfAttrs"&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const imageSrc = ref('https://vuejs.org/logo.svg');
const imageAlt = ref('Vue Logo');
const isActive = ref(true);
const hasError = ref(false);
const activeColor = ref('#42b883');
const fontSize = ref(16);
const objectOfAttrs = ref({
  id: 'container',
  class: 'wrapper'
});
&lt;/script&gt;</div>

            <h4>v-on: Event Handling</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;button v-on:click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Method handler --&gt;
  &lt;button @click="handleClick"&gt;Click Me&lt;/button&gt;
  
  &lt;!-- Inline handler with parameters --&gt;
  &lt;button @click="say('hello')"&gt;Say Hello&lt;/button&gt;
  
  &lt;!-- Event modifiers --&gt;
  &lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;
  &lt;button @click.stop="doThis"&gt;&lt;/button&gt;
  &lt;button @click.once="doThisOnce"&gt;&lt;/button&gt;
  
  &lt;!-- Key modifiers --&gt;
  &lt;input @keyup.enter="submit"&gt;
  &lt;input @keyup.esc="clearInput"&gt;
&lt;/template&gt;

&lt;script setup&gt;
const count = ref(0);

function handleClick(event) {
  console.log('Button clicked!', event);
}

function say(message) {
  alert(message);
}
&lt;/script&gt;</div>

            <h4>v-model: Two-Way Binding</h4>

            <p>The <span class="inline-code">v-model</span> directive creates two-way data binding on form inputs, perfect for handling user input.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Text input --&gt;
  &lt;input v-model="text" placeholder="Type something"&gt;
  &lt;p&gt;You typed: {{ text }}&lt;/p&gt;
  
  &lt;!-- Textarea --&gt;
  &lt;textarea v-model="message"&gt;&lt;/textarea&gt;
  
  &lt;!-- Checkbox --&gt;
  &lt;input type="checkbox" v-model="checked" id="checkbox"&gt;
  &lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;
  
  &lt;!-- Multiple checkboxes --&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Alice"&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Bob"&gt;
  &lt;p&gt;Checked: {{ checkedNames }}&lt;/p&gt;
  
  &lt;!-- Radio buttons --&gt;
  &lt;input type="radio" v-model="picked" value="One"&gt;
  &lt;input type="radio" v-model="picked" value="Two"&gt;
  
  &lt;!-- Select --&gt;
  &lt;select v-model="selected"&gt;
    &lt;option disabled value=""&gt;Choose one&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  
  &lt;!-- v-model modifiers --&gt;
  &lt;input v-model.lazy="msg"&gt;        &lt;!-- Update on change, not input --&gt;
  &lt;input v-model.number="age"&gt;      &lt;!-- Auto-typecast to number --&gt;
  &lt;input v-model.trim="username"&gt;   &lt;!-- Auto-trim whitespace --&gt;
&lt;/template&gt;

&lt;script setup&gt;
const text = ref('');
const message = ref('');
const checked = ref(false);
const checkedNames = ref([]);
const picked = ref('');
const selected = ref('');
const msg = ref('');
const age = ref(0);
const username = ref('');
&lt;/script&gt;</div>

            <h4>v-if, v-else-if, v-else: Conditional Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;div v-if="type === 'A'"&gt;
    Type A content
  &lt;/div&gt;
  &lt;div v-else-if="type === 'B'"&gt;
    Type B content
  &lt;/div&gt;
  &lt;div v-else&gt;
    Not A or B
  &lt;/div&gt;
  
  &lt;!-- Using template for grouping --&gt;
  &lt;template v-if="loginStatus === 'loggedIn'"&gt;
    &lt;h1&gt;Welcome back!&lt;/h1&gt;
    &lt;p&gt;Your dashboard&lt;/p&gt;
  &lt;/template&gt;
&lt;/template&gt;</div>

            <div class="warning-box">
                <h4>v-if vs v-show</h4>
                <p><strong>v-if:</strong> Conditionally renders the element (truly removes/adds to DOM). Higher toggle cost, lazy rendering.<br><br>
                <strong>v-show:</strong> Always renders but toggles CSS display. Lower toggle cost, immediate rendering.<br><br>
                <strong>Use v-if</strong> when the condition rarely changes. <strong>Use v-show</strong> for frequent toggling.</p>
            </div>

            <h4>v-for: List Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Array iteration --&gt;
  &lt;ul&gt;
    &lt;li v-for="(item, index) in items" :key="item.id"&gt;
      {{ index }}: {{ item.text }}
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;!-- Object iteration --&gt;
  &lt;div v-for="(value, key, index) in userObject" :key="key"&gt;
    {{ index }}. {{ key }}: {{ value }}
  &lt;/div&gt;
  
  &lt;!-- Range --&gt;
  &lt;span v-for="n in 10" :key="n"&gt;{{ n }}&lt;/span&gt;
  
  &lt;!-- v-for with v-if (not recommended on same element) --&gt;
  &lt;template v-for="item in items" :key="item.id"&gt;
    &lt;li v-if="!item.hidden"&gt;{{ item.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/template&gt;

&lt;script setup&gt;
const items = ref([
  { id: 1, text: 'Learn Vue', hidden: false },
  { id: 2, text: 'Build App', hidden: false },
  { id: 3, text: 'Deploy', hidden: true }
]);

const userObject = ref({
  name: 'Alice',
  age: 28,
  email: 'alice@example.com'
});
&lt;/script&gt;</div>

            <div class="warning-box">
                <h4>Always Use :key with v-for</h4>
                <p>Vue needs keys to track each node's identity for efficient DOM updates. Without keys, Vue uses an "in-place patch" strategy that can cause issues with stateful components or animations. Always provide unique, stable keys!</p>
            </div>

            <h3>3. Composition API Deep Dive</h3>

            <p>The Composition API is Vue 3's revolutionary approach to organizing component logic. It provides better code reusability, type inference, and logical organization compared to the Options API.</p>

            <h4>Why Composition API?</h4>

            <div class="metaphor-box">
                <h4>Organization by Concern</h4>
                <p>The Options API organizes code by option type (data, methods, computed, etc.) - like organizing books by size. The Composition API organizes by logical concern - like organizing books by topic. When you need to understand the "user authentication" feature, all related code is together rather than scattered across multiple options.</p>
            </div>

            <h4>setup() and &lt;script setup&gt;</h4>

            <div class="code">&lt;!-- Traditional setup() function --&gt;
&lt;script&gt;
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const double = computed(() =&gt; count.value * 2);
    
    function increment() {
      count.value++;
    }
    
    // Must return everything you want to expose to template
    return {
      count,
      double,
      increment
    };
  }
};
&lt;/script&gt;

&lt;!-- Modern &lt;script setup&gt; (preferred!) --&gt;
&lt;script setup&gt;
import { ref, computed } from 'vue';

// Everything defined here is automatically exposed to template
const count = ref(0);
const double = computed(() =&gt; count.value * 2);

function increment() {
  count.value++;
}
// No need to return anything!
&lt;/script&gt;</div>

            <h4>ref() vs reactive()</h4>

            <p>Understanding the difference between <span class="inline-code">ref</span> and <span class="inline-code">reactive</span> is crucial for mastering Vue's reactivity system.</p>

            <div class="code">&lt;script setup&gt;
import { ref, reactive } from 'vue';

// ref: For primitives and single values
const count = ref(0);
const message = ref('Hello');
const user = ref({ name: 'Alice' });

// Access via .value in script, automatic unwrap in template
count.value++;                    // In script: need .value
console.log(user.value.name);     // In script: need .value

// reactive: For objects only
const state = reactive({
  count: 0,
  message: 'Hello',
  nested: {
    value: 42
  }
});

// Direct access, no .value needed
state.count++;
state.nested.value = 100;

// GOTCHA: Destructuring loses reactivity with reactive()
const { count, message } = state;  // ‚ùå NOT reactive anymore!

// Use toRefs() to maintain reactivity
import { toRefs } from 'vue';
const { count, message } = toRefs(state);  // ‚úÖ Still reactive!
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>When to Use ref vs reactive</h4>
                <p><strong>Use ref():</strong> For primitive values, single objects, or when you need to replace the entire object reference.<br><br>
                <strong>Use reactive():</strong> For complex objects with many properties that you'll mutate in place.<br><br>
                <strong>Common pattern:</strong> Many developers use <span class="inline-code">ref()</span> for everything for consistency, even for objects.</p>
            </div>

            <h4>computed(): Derived State</h4>

            <div class="code">&lt;script setup&gt;
import { ref, computed } from 'vue';

const firstName = ref('John');
const lastName = ref('Doe');

// Read-only computed
const fullName = computed(() =&gt; {
  return `${firstName.value} ${lastName.value}`;
});

// Writable computed (getter + setter)
const fullNameWritable = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ');
  }
});

// Computed with complex logic
const items = ref([
  { id: 1, name: 'Apple', price: 1.5, quantity: 3 },
  { id: 2, name: 'Banana', price: 0.8, quantity: 5 }
]);

const totalPrice = computed(() =&gt; {
  return items.value.reduce((total, item) =&gt; {
    return total + (item.price * item.quantity);
  }, 0).toFixed(2);
});

const expensiveItems = computed(() =&gt; {
  return items.value.filter(item =&gt; item.price &gt; 1);
});
&lt;/script&gt;</div>

            <h4>watch() and watchEffect()</h4>

            <p>Vue provides two ways to react to reactive state changes: <span class="inline-code">watch()</span> and <span class="inline-code">watchEffect()</span>.</p>

            <div class="code">&lt;script setup&gt;
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);
const user = ref({ name: 'Alice', age: 25 });

// watch: Explicit source, access old and new values
watch(count, (newValue, oldValue) =&gt; {
  console.log(`Count changed from ${oldValue} to ${newValue}`);
});

// watch multiple sources
watch([count, user], ([newCount, newUser], [oldCount, oldUser]) =&gt; {
  console.log('Count or user changed');
});

// watch with options
watch(user, (newUser) =&gt; {
  console.log('User changed:', newUser);
}, {
  deep: true,       // Watch nested properties
  immediate: true   // Run immediately on mount
});

// watchEffect: Automatic dependency tracking
watchEffect(() =&gt; {
  // Automatically tracks count and user.name as dependencies
  console.log(`${user.value.name} has count: ${count.value}`);
});

// watchEffect with cleanup
watchEffect((onCleanup) =&gt; {
  const timer = setTimeout(() =&gt; {
    console.log('Delayed log:', count.value);
  }, 1000);
  
  // Cleanup function runs before next execution and on unmount
  onCleanup(() =&gt; {
    clearTimeout(timer);
  });
});
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>watch vs watchEffect</h4>
                <p><strong>Use watch()</strong> when you need to access previous values, watch specific sources, or perform side effects only when certain dependencies change.<br><br>
                <strong>Use watchEffect()</strong> for simpler cases where you want automatic dependency tracking and don't need old values.</p>
            </div>

            <h3>4. Component Communication</h3>

            <h4>Props: Parent to Child</h4>

            <div class="code">&lt;!-- Child Component: UserCard.vue --&gt;
&lt;template&gt;
  &lt;div class="user-card"&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
    &lt;p&gt;Role: {{ role }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define props with TypeScript-style type annotation
const props = defineProps({
  user: {
    type: Object,
    required: true
  },
  role: {
    type: String,
    default: 'Guest'
  },
  age: {
    type: Number,
    validator: (value) =&gt; value &gt;= 0
  }
});

// Access props
console.log(props.user.name);
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;UserCard :user="currentUser" role="Admin" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import UserCard from './UserCard.vue';
const currentUser = ref({ name: 'Alice', age: 28 });
&lt;/script&gt;</div>

            <h4>Emits: Child to Parent</h4>

            <div class="code">&lt;!-- Child Component: CustomButton.vue --&gt;
&lt;template&gt;
  &lt;button @click="handleClick"&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define emits
const emit = defineEmits(['click', 'custom-event']);

function handleClick(event) {
  // Emit with data
  emit('click', { timestamp: Date.now(), event });
  emit('custom-event', 'some data');
}
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;CustomButton @click="onButtonClick" @custom-event="onCustom"&gt;
    Click Me
  &lt;/CustomButton&gt;
&lt;/template&gt;

&lt;script setup&gt;
function onButtonClick(data) {
  console.log('Button clicked at:', data.timestamp);
}

function onCustom(data) {
  console.log('Custom event:', data);
}
&lt;/script&gt;</div>

            <h4>provide/inject: Deep Component Communication</h4>

            <div class="code">&lt;!-- Grandparent Component --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue';

const theme = ref('dark');
const user = ref({ name: 'Alice', role: 'admin' });

// Provide to all descendants
provide('theme', theme);
provide('user', user);

// Provide with read-only access
import { readonly } from 'vue';
provide('config', readonly({
  apiUrl: 'https://api.example.com'
}));
&lt;/script&gt;

&lt;!-- Deep Child Component (any level deep) --&gt;
&lt;script setup&gt;
import { inject } from 'vue';

// Inject provided values
const theme = inject('theme');
const user = inject('user');

// Inject with default value
const config = inject('config', { apiUrl: 'fallback' });

// Now you can use theme, user, config
console.log(theme.value);  // 'dark'
&lt;/script&gt;</div>

            <h4>Slots: Content Distribution</h4>

            <div class="code">&lt;!-- Card Component with Slots --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;div class="card-header"&gt;
      &lt;slot name="header"&gt;Default Header&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-body"&gt;
      &lt;slot&gt;Default Content&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-footer"&gt;
      &lt;slot name="footer" :data="footerData"&gt;
        Default Footer
      &lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const footerData = ref({ timestamp: new Date() });
&lt;/script&gt;

&lt;!-- Using the Card --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;template #header&gt;
      &lt;h2&gt;My Custom Header&lt;/h2&gt;
    &lt;/template&gt;
    
    &lt;!-- Default slot --&gt;
    &lt;p&gt;This is the main content&lt;/p&gt;
    
    &lt;!-- Scoped slot receiving data --&gt;
    &lt;template #footer="{ data }"&gt;
      &lt;small&gt;Last updated: {{ data.timestamp }}&lt;/small&gt;
    &lt;/template&gt;
  &lt;/Card&gt;
&lt;/template&gt;</div>

            <h3>5. Pinia State Management</h3>

            <p>Pinia is the official state management solution for Vue 3, replacing Vuex. It offers a simpler API, better TypeScript support, and modular design.</p>

            <h4>Creating a Store</h4>

            <div class="code">// stores/counter.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

// Composition API style (recommended)
export const useCounterStore = defineStore('counter', () =&gt; {
  // State
  const count = ref(0);
  const name = ref('Counter Store');
  
  // Getters (computed)
  const doubleCount = computed(() =&gt; count.value * 2);
  const isEven = computed(() =&gt; count.value % 2 === 0);
  
  // Actions (functions)
  function increment() {
    count.value++;
  }
  
  function incrementBy(amount) {
    count.value += amount;
  }
  
  async function fetchCount() {
    const response = await fetch('/api/count');
    const data = await response.json();
    count.value = data.count;
  }
  
  return {
    count,
    name,
    doubleCount,
    isEven,
    increment,
    incrementBy,
    fetchCount
  };
});

// Options API style (alternative)
export const useCounterStore = defineStore('counter', {
  state: () =&gt; ({
    count: 0,
    name: 'Counter Store'
  }),
  getters: {
    doubleCount: (state) =&gt; state.count * 2,
    isEven: (state) =&gt; state.count % 2 === 0
  },
  actions: {
    increment() {
      this.count++;
    },
    incrementBy(amount) {
      this.count += amount;
    }
  }
});</div>

            <h4>Using Stores in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ counter.count }}&lt;/p&gt;
    &lt;p&gt;Double: {{ counter.doubleCount }}&lt;/p&gt;
    &lt;p&gt;Is Even: {{ counter.isEven }}&lt;/p&gt;
    &lt;button @click="counter.increment"&gt;Increment&lt;/button&gt;
    &lt;button @click="counter.incrementBy(5)"&gt;Add 5&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useCounterStore } from '@/stores/counter';

// Get store instance
const counter = useCounterStore();

// Destructure with reactivity (use storeToRefs!)
import { storeToRefs } from 'pinia';
const { count, doubleCount, isEven } = storeToRefs(counter);
const { increment, incrementBy } = counter;  // Actions don't need storeToRefs

// Watch store state
watch(() =&gt; counter.count, (newCount) =&gt; {
  console.log('Count changed:', newCount);
});
&lt;/script&gt;</div>

            <h4>Complex Store Example: User Authentication</h4>

            <div class="code">// stores/auth.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () =&gt; {
  // State
  const user = ref(null);
  const token = ref(localStorage.getItem('token') || null);
  const loading = ref(false);
  const error = ref(null);
  
  // Getters
  const isAuthenticated = computed(() =&gt; !!token.value);
  const userRole = computed(() =&gt; user.value?.role || 'guest');
  const isAdmin = computed(() =&gt; userRole.value === 'admin');
  
  // Actions
  async function login(email, password) {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      token.value = data.token;
      user.value = data.user;
      
      localStorage.setItem('token', data.token);
      
      return true;
    } catch (err) {
      error.value = err.message;
      return false;
    } finally {
      loading.value = false;
    }
  }
  
  function logout() {
    user.value = null;
    token.value = null;
    localStorage.removeItem('token');
  }
  
  async function fetchUser() {
    if (!token.value) return;
    
    try {
      const response = await fetch('/api/user', {
        headers: { Authorization: `Bearer ${token.value}` }
      });
      
      const data = await response.json();
      user.value = data;
    } catch (err) {
      // Token invalid, logout
      logout();
    }
  }
  
  return {
    user,
    token,
    loading,
    error,
    isAuthenticated,
    userRole,
    isAdmin,
    login,
    logout,
    fetchUser
  };
});</div>

            <h3>6. Vue Router Deep Dive</h3>

            <h4>Router Setup</h4>

            <div class="code">// router/index.js
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

const routes = [
  {
    path: '/',
    name: 'home',
    component: Home
  },
  {
    path: '/about',
    name: 'about',
    component: About
  },
  {
    path: '/user/:id',
    name: 'user',
    component: () =&gt; import('@/views/User.vue'),  // Lazy loading
    props: true  // Pass route params as props
  },
  {
    path: '/dashboard',
    component: () =&gt; import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: '',
        name: 'dashboard-home',
        component: () =&gt; import('@/views/DashboardHome.vue')
      },
      {
        path: 'profile',
        name: 'profile',
        component: () =&gt; import('@/views/Profile.vue')
      }
    ]
  },
  {
    // Catch all 404
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () =&gt; import('@/views/NotFound.vue')
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;</div>

            <h4>Navigation Guards</h4>

            <div class="code">// Global navigation guard
router.beforeEach(async (to, from) =&gt; {
  const authStore = useAuthStore();
  
  // Check authentication
  if (to.meta.requiresAuth &amp;&amp; !authStore.isAuthenticated) {
    return { name: 'login' };
  }
  
  // Check admin access
  if (to.meta.requiresAdmin &amp;&amp; !authStore.isAdmin) {
    return { name: 'forbidden' };
  }
  
  // Allow navigation
  return true;
});

// Per-route guard
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from) =&gt; {
      if (!isAdmin()) {
        return { name: 'home' };
      }
    }
  }
];</div>

            <h4>Using Router in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- Declarative navigation --&gt;
    &lt;router-link to="/"&gt;Home&lt;/router-link&gt;
    &lt;router-link :to="{ name: 'user', params: { id: 123 } }"&gt;
      User 123
    &lt;/router-link&gt;
    
    &lt;!-- Router view --&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRouter, useRoute } from 'vue-router';

const router = useRouter();
const route = useRoute();

// Programmatic navigation
function goToUser(id) {
  router.push({ name: 'user', params: { id } });
}

function goBack() {
  router.go(-1);
}

// Access route params/query
const userId = computed(() =&gt; route.params.id);
const searchQuery = computed(() =&gt; route.query.search);

// Watch route changes
watch(() =&gt; route.params.id, (newId) =&gt; {
  console.log('User ID changed:', newId);
});
&lt;/script&gt;</div>

            <h3>7. Composables: Reusable Logic</h3>

            <p>Composables are the Vue equivalent of React hooks - reusable functions that encapsulate stateful logic.</p>

            <div class="code">// composables/useFetch.js
import { ref } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);
  const loading = ref(false);
  
  async function fetchData() {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  }
  
  fetchData();
  
  return { data, error, loading, refetch: fetchData };
}

// Usage in component
&lt;script setup&gt;
import { useFetch } from '@/composables/useFetch';

const { data: users, loading, error } = useFetch('/api/users');
&lt;/script&gt;

// composables/useLocalStorage.js
import { ref, watch } from 'vue';

export function useLocalStorage(key, defaultValue) {
  const storedValue = localStorage.getItem(key);
  const data = ref(storedValue ? JSON.parse(storedValue) : defaultValue);
  
  watch(data, (newValue) =&gt; {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return data;
}

// Usage
const user = useLocalStorage('user', { name: 'Guest' });

// composables/useMousePosition.js
export function useMousePosition() {
  const x = ref(0);
  const y = ref(0);
  
  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }
  
  onMounted(() =&gt; {
    window.addEventListener('mousemove', update);
  });
  
  onUnmounted(() =&gt; {
    window.removeEventListener('mousemove', update);
  });
  
  return { x, y };
}</div>

            <h3>8. Lifecycle Hooks</h3>

            <div class="code">&lt;script setup&gt;
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted
} from 'vue';

// Before component is mounted to DOM
onBeforeMount(() =&gt; {
  console.log('Before mount');
});

// After component is mounted (DOM available)
onMounted(() =&gt; {
  console.log('Mounted - DOM ready');
  // Perfect for:
  // - API calls
  // - DOM manipulation
  // - Setting up listeners
});

// Before reactive data changes trigger re-render
onBeforeUpdate(() =&gt; {
  console.log('Before update');
});

// After reactive data changes and DOM updates
onUpdated(() =&gt; {
  console.log('Updated - DOM has changed');
});

// Before component is unmounted
onBeforeUnmount(() =&gt; {
  console.log('Before unmount');
  // Cleanup here
});

// After component is unmounted
onUnmounted(() =&gt; {
  console.log('Unmounted');
  // Final cleanup
});
&lt;/script&gt;</div>

            <h3>9. Form Handling & Validation</h3>

            <h4>Advanced v-model</h4>

            <div class="code">&lt;!-- Custom component with v-model --&gt;
&lt;!-- CustomInput.vue --&gt;
&lt;template&gt;
  &lt;input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  &gt;
&lt;/template&gt;

&lt;script setup&gt;
defineProps(['modelValue']);
defineEmits(['update:modelValue']);
&lt;/script&gt;

&lt;!-- Usage --&gt;
&lt;CustomInput v-model="text" /&gt;

&lt;!-- Multiple v-models --&gt;
&lt;UserForm
  v-model:firstName="firstName"
  v-model:lastName="lastName"
/&gt;</div>

            <h4>Form Validation with Vuelidate</h4>

            <div class="code">&lt;script setup&gt;
import { useVuelidate } from '@vuelidate/core';
import { required, email, minLength } from '@vuelidate/validators';

const formData = reactive({
  email: '',
  password: '',
  confirmPassword: ''
});

const rules = {
  email: { required, email },
  password: { required, minLength: minLength(8) },
  confirmPassword: {
    required,
    sameAs: (value) =&gt; value === formData.password
  }
};

const v$ = useVuelidate(rules, formData);

async function submitForm() {
  const isValid = await v$.value.$validate();
  
  if (!isValid) {
    console.log('Validation errors:', v$.value.$errors);
    return;
  }
  
  // Submit form
  console.log('Form valid, submitting...');
}
&lt;/script&gt;

&lt;template&gt;
  &lt;form @submit.prevent="submitForm"&gt;
    &lt;div&gt;
      &lt;input v-model="formData.email" placeholder="Email"&gt;
      &lt;span v-if="v$.email.$error"&gt;
        {{ v$.email.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;input v-model="formData.password" type="password"&gt;
      &lt;span v-if="v$.password.$error"&gt;
        {{ v$.password.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;</div>

            <h3>10. Performance Optimization</h3>

            <div class="code">&lt;template&gt;
  &lt;!-- v-once: Render once, never update --&gt;
  &lt;p v-once&gt;{{ staticContent }}&lt;/p&gt;
  
  &lt;!-- v-memo: Skip re-render if dependencies unchanged --&gt;
  &lt;div v-memo="[user.id, user.name]"&gt;
    &lt;UserCard :user="user" /&gt;
  &lt;/div&gt;
  
  &lt;!-- Lazy load components --&gt;
  &lt;component :is="AsyncComponent" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue';

// Lazy load heavy component
const AsyncComponent = defineAsyncComponent(() =&gt;
  import('./HeavyComponent.vue')
);

// Computed caching (automatically memoized)
const expensiveComputation = computed(() =&gt; {
  return items.value.reduce((sum, item) =&gt; sum + item.price, 0);
});

// Use shallowRef for large objects you rarely mutate
import { shallowRef } from 'vue';
const bigDataset = shallowRef({ /* thousands of items */ });
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Vue Performance Tips</h4>
                <p>
                ‚Ä¢ Use <span class="inline-code">v-show</span> for frequently toggled elements<br>
                ‚Ä¢ Use <span class="inline-code">v-if</span> for rarely changed conditions<br>
                ‚Ä¢ Always provide keys for v-for<br>
                ‚Ä¢ Lazy load route components<br>
                ‚Ä¢ Use computed for expensive calculations<br>
                ‚Ä¢ Use shallowRef/shallowReactive for large data structures<br>
                ‚Ä¢ Implement virtual scrolling for large lists (vue-virtual-scroller)<br>
                ‚Ä¢ Debounce expensive operations (user input, API calls)
                </p>
            </div>

            <div class="metaphor-box">
                <h4>Vue's Philosophy: Progressive Simplicity</h4>
                <p>Vue is designed to be incrementally adoptable - you start simple and add complexity only when needed. It's like learning to drive: you start with the basics (turning, braking), then gradually add advanced skills (parallel parking, highway merging). You don't need to know everything to be productive, but the advanced features are there when you're ready.</p>
            </div>

        <!-- SECTION 3: State Management (Redux, Zustand, Recoil, Context) -->
        <section id="state-management" class="section">
            <h2 class="section-title">State Management</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 4: API Integration -->
        <section id="api-integration" class="section">
            <h2 class="section-title">API Integration</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 5: Real-Time Features -->
        <section id="realtime-features" class="section">
            <h2 class="section-title">Real-Time Features</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 6: Authentication -->
        <section id="authentication" class="section">
            <h2 class="section-title">Authentication & Authorization</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 7: File Uploads -->
        <section id="file-uploads" class="section">
            <h2 class="section-title">File Uploads & Media</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 8: PWA Features -->
        <section id="pwa-features" class="section">
            <h2 class="section-title">Progressive Web Apps</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 9: Testing Integration -->
        <section id="testing-integration" class="section">
            <h2 class="section-title">Testing Full-Stack Apps</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 10: Deployment & Scaling -->
        <section id="deployment-scaling" class="section">
            <h2 class="section-title">Deployment & Scaling</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>

