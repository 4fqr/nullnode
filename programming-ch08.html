<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 08: Full-Stack Integration - Part I - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: var(--bg2); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(255,255,255,0.05); color: var(--text); transform: translateX(4px); }
        .sidebar-link.active { background: rgba(255,255,255,0.1); color: var(--text); font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: var(--text3); margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.2); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: var(--bg3); border-left: 3px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-left: 3px solid #ff6b6b; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #ff6b6b; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; white-space: nowrap; }
        .metaphor-box { background: rgba(255,255,255,0.03); border-left: 4px solid var(--text); padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "ğŸ’¡"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg2); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, var(--text) 0%, var(--text2) 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">â–¼</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#what-is-fullstack" class="sidebar-link">1. What Even IS Full-Stack?</a>
            <a href="#first-react-app" class="sidebar-link">2. Building Your First React App</a>
            <a href="#first-vue-app" class="sidebar-link">3. Building Your First Vue App</a>
            <a href="#understanding-state" class="sidebar-link">4. Understanding State</a>
            <a href="#state-management" class="sidebar-link">5. State Management</a>
            <a href="#api-integration" class="sidebar-link">6. API Integration</a>
            <a href="#realtime-features" class="sidebar-link">7. Real-Time Features</a>
            <a href="#authentication" class="sidebar-link">8. Authentication & Authorization</a>
            <a href="#file-uploads" class="sidebar-link">9. File Uploads & Media</a>
            <a href="#pwa-features" class="sidebar-link">10. Progressive Web Apps</a>
            <a href="#testing-integration" class="sidebar-link">11. Testing Full-Stack Apps</a>
            <a href="#deployment-scaling" class="sidebar-link">12. Deployment & Scaling</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="programming-ch07.html" class="sidebar-link">â† Previous: Ch07 Databases</a>
            <a href="programming-ch09.html" class="sidebar-link">Next: Ch09 Professional Practices â†’</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="chapter-label">Chapter 08</div>
            <h1 class="page-title">Full-Stack Integration - Part I</h1>
            <p class="page-subtitle">Start from absolute zero. Learn what full-stack means, how websites actually work, why we need frameworks, and build your first complete application that connects a beautiful frontend to a powerful backend. No prior knowledge needed - we explain EVERYTHING.</p>
        </div>

        <!-- SECTION 1: What Even IS Full-Stack? -->
        <section id="what-is-fullstack" class="section">
            <h2 class="section-title">What Even IS Full-Stack?</h2>
            <p class="section-intro">Welcome! If you're reading this, you might have heard terms like "full-stack developer," "React," "frontend," "backend," and felt completely lost. That's okay! We're starting from ABSOLUTE ZERO. Imagine you know nothing about web development - we'll build up from there, step by step, with tons of analogies and examples.</p>

            <h3>Part 1: What Even IS a Website?</h3>
            
            <h4>The Big Picture: Computers Talking to Each Other</h4>
            <p>Before we dive into fancy terms, let's start with the absolute basics. When you open a website like Facebook, YouTube, or Amazon, what's actually happening?</p>

            <div class="metaphor-box">
                <h4>The Restaurant Metaphor</h4>
                <p>Think of a website like a restaurant:<br><br>
                <strong>You (the customer)</strong> = Your web browser (Chrome, Firefox, Safari)<br>
                <strong>The dining area</strong> = The website you see on your screen<br>
                <strong>The kitchen</strong> = The server (a powerful computer somewhere in the world)<br>
                <strong>The waiter</strong> = The internet<br><br>
                When you click a link, it's like ordering food. Your browser sends a request through the internet (the waiter) to a server (the kitchen). The server prepares your order (fetches data from databases, processes it) and sends it back through the internet to your browser, which displays it beautifully on your screen.</p>
            </div>

            <p>Let's break that down even further. A website is made of THREE main technologies working together:</p>

            <h4>1. HTML - The Skeleton/Structure</h4>
            <p>HTML stands for HyperText Markup Language. Big scary name, simple concept: HTML defines WHAT is on the page. It's like the skeleton of a body or the frame of a house.</p>

            <div class="code">&lt;!-- This is HTML --&gt;
&lt;h1&gt;Welcome to My Website&lt;/h1&gt;
&lt;p&gt;This is a paragraph of text.&lt;/p&gt;
&lt;button&gt;Click Me&lt;/button&gt;
&lt;img src="cat.jpg" alt="A cute cat"&gt;</div>

            <p>Each of those things in angle brackets (<span class="inline-code">&lt;&gt;</span>) is called an <strong>element</strong> or <strong>tag</strong>. They tell the browser: "Put a heading here," "Put a paragraph here," "Put a button here."</p>

            <div class="info-box">
                <h4>HTML Elements Explained</h4>
                <p><span class="inline-code">&lt;h1&gt;</span> = Heading (big title text)<br>
                <span class="inline-code">&lt;p&gt;</span> = Paragraph (normal text)<br>
                <span class="inline-code">&lt;button&gt;</span> = A clickable button<br>
                <span class="inline-code">&lt;img&gt;</span> = An image<br>
                <span class="inline-code">&lt;div&gt;</span> = A container (holds other elements)<br>
                <span class="inline-code">&lt;a&gt;</span> = A link to another page<br><br>
                Notice: Most tags come in pairs: <span class="inline-code">&lt;p&gt;text&lt;/p&gt;</span><br>
                Some are self-closing: <span class="inline-code">&lt;img /&gt;</span><br><br>
                That's it! HTML is just telling the browser what content to display.</p>
            </div>

            <h4>2. CSS - The Styling/Makeup</h4>
            <p>CSS stands for Cascading Style Sheets. It makes your website look pretty. If HTML is the skeleton, CSS is the skin, hair, clothes, and makeup.</p>

            <div class="code">/* This is CSS */
h1 {
  color: blue;
  font-size: 48px;
  text-align: center;
}

button {
  background-color: green;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
}</div>

            <p>CSS says: "Take that heading and make it blue, 48 pixels big, and centered." "Take that button and make it green with white text and rounded corners."</p>

            <div class="metaphor-box">
                <h4>The Blueprint Metaphor</h4>
                <p>HTML is like a blueprint that says "put a door here, a window there."<br><br>
                CSS is like the interior designer who says "paint the door red, put curtains on the window, add a fancy doorknob."<br><br>
                Same structure, but now it looks beautiful!</p>
            </div>

            <h4>3. JavaScript - The Behavior/Brain</h4>
            <p>JavaScript makes your website DO stuff. It's the brain that makes things interactive.</p>

            <div class="code">// This is JavaScript
const button = document.querySelector('button');

button.addEventListener('click', function() {
  alert('Button was clicked!');
  console.log('User clicked the button');
});</div>

            <p>This code says: "Find the button on the page. When someone clicks it, show a popup message and log something to the console."</p>

            <div class="info-box">
                <h4>Putting It All Together</h4>
                <p><strong>HTML:</strong> "There's a button on the page."<br>
                <strong>CSS:</strong> "The button is green and rounded."<br>
                <strong>JavaScript:</strong> "When you click the button, something happens!"<br><br>
                Every website you've ever visited uses these three technologies. Facebook, Google, YouTube - they all use HTML for structure, CSS for styling, and JavaScript for interactivity.</p>
            </div>

            <h4>A Complete Mini Example</h4>
            <p>Let's see all three working together in a simple counter:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Counter&lt;/title&gt;
  &lt;style&gt;
    /* CSS - Make it pretty */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 50px;
    }
    
    h1 {
      color: #333;
    }
    
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    
    button:hover {
      background: #0056b3;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- HTML - Structure --&gt;
  &lt;h1&gt;Simple Counter&lt;/h1&gt;
  &lt;p&gt;Count: &lt;span id="count"&gt;0&lt;/span&gt;&lt;/p&gt;
  &lt;button id="increment"&gt;Add 1&lt;/button&gt;
  &lt;button id="reset"&gt;Reset&lt;/button&gt;
  
  &lt;script&gt;
    // JavaScript - Make it work
    let count = 0;
    
    const countDisplay = document.getElementById('count');
    const incrementBtn = document.getElementById('increment');
    const resetBtn = document.getElementById('reset');
    
    incrementBtn.addEventListener('click', function() {
      count = count + 1;
      countDisplay.textContent = count;
    });
    
    resetBtn.addEventListener('click', function() {
      count = 0;
      countDisplay.textContent = count;
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <p>Save this as <span class="inline-code">counter.html</span>, open it in a browser, and you have a working counter! You can click the button and watch the number go up.</p>

            <h3>Part 2: What is "Frontend" vs "Backend"?</h3>

            <h4>The Restaurant Metaphor (Again, Because It's Perfect)</h4>
            <p>Remember our restaurant analogy? Let's expand on it:</p>

            <div class="metaphor-box">
                <h4>Frontend = What Customers See</h4>
                <p><strong>The Frontend</strong> is everything in the dining area:<br>
                â€¢ The menu (layout and design)<br>
                â€¢ The tables and chairs (UI elements like buttons and forms)<br>
                â€¢ The decorations (colors, fonts, animations)<br>
                â€¢ The waiter taking your order (handling user interactions)<br><br>
                It's everything you SEE and INTERACT with. In web terms, this is the HTML, CSS, and JavaScript that runs IN YOUR BROWSER on YOUR COMPUTER.</p>
            </div>

            <div class="metaphor-box">
                <h4>Backend = What Customers Don't See</h4>
                <p><strong>The Backend</strong> is everything in the kitchen:<br>
                â€¢ The chefs cooking food (processing data)<br>
                â€¢ The pantry storing ingredients (databases)<br>
                â€¢ The recipes (business logic)<br>
                â€¢ The dishwashers and food prep (background tasks)<br><br>
                It's everything that happens BEHIND THE SCENES. In web terms, this is code running on a SERVER (a computer somewhere else), working with databases, processing payments, sending emails, etc.</p>
            </div>

            <h4>A Real Example: Logging Into Facebook</h4>
            <p>Let's trace what happens when you log into Facebook to see frontend and backend working together:</p>

            <ol>
                <li><strong>Frontend:</strong> You see a login page (HTML/CSS) with two text boxes and a button.</li>
                <li><strong>Frontend:</strong> You type your email and password. JavaScript captures what you typed.</li>
                <li><strong>Frontend:</strong> You click "Log In." JavaScript sends your credentials to Facebook's server.</li>
                <li><strong>Backend:</strong> Facebook's server receives your email/password.</li>
                <li><strong>Backend:</strong> It checks the database: "Does this email exist? Does the password match?"</li>
                <li><strong>Backend:</strong> If yes, it creates a session token (like a temporary ticket) and sends it back.</li>
                <li><strong>Frontend:</strong> Your browser receives the token and stores it.</li>
                <li><strong>Frontend:</strong> JavaScript updates the page to show your feed instead of the login screen.</li>
            </ol>

            <div class="info-box">
                <h4>Why Have a Backend?</h4>
                <p><strong>Security:</strong> You can't check passwords in the frontend - anyone could read your JavaScript code! The backend keeps sensitive operations hidden.<br><br>
                <strong>Data Storage:</strong> Browsers can't store millions of user posts. The backend has databases for that.<br><br>
                <strong>Shared Data:</strong> Your friends see YOUR posts because the backend stores them in one place everyone can access.<br><br>
                <strong>Processing Power:</strong> Heavy computations (like video encoding) happen on powerful servers, not your phone.</p>
            </div>

            <h4>What is "Full-Stack"?</h4>
            <p>Now we can finally answer the original question! A <strong>full-stack developer</strong> is someone who can work on BOTH the frontend (the dining area) AND the backend (the kitchen).</p>

            <div class="code">// Full-Stack Developer Can Do:

FRONTEND (Browser):
- Build beautiful UIs with HTML/CSS
- Make interactive pages with JavaScript
- Use frameworks like React or Vue
- Handle user interactions

BACKEND (Server):
- Write server code (Node.js, Python, etc.)
- Design databases
- Create APIs (ways for frontend to talk to backend)
- Handle authentication, payments, emails</div>

            <p>Think of it like being both a chef AND a waiter. You understand the whole restaurant, not just one part.</p>

            <h3>Part 3: Why Regular JavaScript Gets Messy</h3>

            <h4>Let's Build Something Simple (The Wrong Way First)</h4>
            <p>Remember that counter we built? Let's look at it again and understand the problems:</p>

            <div class="code">&lt;!-- Your HTML --&gt;
&lt;div id="counter-app"&gt;
  &lt;h1&gt;Click Counter&lt;/h1&gt;
  &lt;p&gt;You clicked &lt;span id="count"&gt;0&lt;/span&gt; times&lt;/p&gt;
  &lt;button id="increment-btn"&gt;Click Me!&lt;/button&gt;
  &lt;button id="reset-btn"&gt;Reset&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
// Your JavaScript
let count = 0;  // Store the count

// Step 1: Find HTML elements
const countDisplay = document.getElementById('count');
const incrementBtn = document.getElementById('increment-btn');
const resetBtn = document.getElementById('reset-btn');

// Step 2: Add event listeners
incrementBtn.addEventListener('click', function() {
  count = count + 1;
  countDisplay.textContent = count;  // Step 3: Update display
});

resetBtn.addEventListener('click', function() {
  count = 0;
  countDisplay.textContent = count;  // Step 3: Update display
});
&lt;/script&gt;</div>

            <p>This works for a simple counter. But notice the problems:</p>

            <div class="warning-box">
                <h4>âš ï¸ Problems with Vanilla JavaScript</h4>
                <p><strong>1. Manual DOM manipulation:</strong> You have to manually find every element with <span class="inline-code">getElementById</span>. What if you have 100 elements?<br><br>
                <strong>2. Manual updates:</strong> Every time <span class="inline-code">count</span> changes, YOU must remember to update <span class="inline-code">countDisplay.textContent</span>. Forget once = bug.<br><br>
                <strong>3. Scattered logic:</strong> Your data (<span class="inline-code">count</span>) is separate from your HTML. They can get out of sync.<br><br>
                <strong>4. No reusability:</strong> Want another counter? Copy-paste all this code and change IDs. Want 10 counters? Good luck.<br><br>
                <strong>5. Hard to maintain:</strong> As your app grows, you have spaghetti code everywhere.</p>
            </div>

            <h4>What Happens When Your App Grows?</h4>
            <p>Let's imagine you're building a TODO list app. Not with frameworks - just vanilla JavaScript. Here's what you'd need:</p>

            <div class="code">// Imagine all this in vanilla JavaScript:

1. Create todo HTML
   - Find the input field
   - Get the text user typed
   - Create a new &lt;li&gt; element
   - Set its text
   - Create a delete button
   - Add it to the list
   - Clear the input field

2. Delete a todo
   - Find which todo was clicked
   - Remove it from the DOM
   - Update the count display

3. Mark todo as complete
   - Find the checkbox
   - Add event listener
   - Update the styling
   - Move it to "completed" section
   - Update the count

4. Filter todos (all, active, completed)
   - Loop through ALL todos
   - Hide/show based on filter
   - Update which filter button is active

5. Save to localStorage
   - Convert todos to JSON
   - Save when anything changes
   - Load when page refreshes
   - Parse JSON back to todos

// That's HUNDREDS of lines of:
// - document.getElementById()
// - element.addEventListener()
// - element.textContent = ...
// - element.style.something = ...
// And you have to remember to update EVERYTHING
// when ANYTHING changes!</div>

            <p>Every interaction requires you to:</p>
            <ol>
                <li>Update your data (JavaScript variables)</li>
                <li>Find the right HTML elements</li>
                <li>Update those elements to match your data</li>
                <li>Make sure you didn't forget to update something</li>
            </ol>

            <div class="metaphor-box">
                <h4>The Spreadsheet Metaphor</h4>
                <p>Imagine a spreadsheet where formulas DON'T auto-calculate.<br><br>
                <strong>Without frameworks (manual):</strong> You have a column showing prices, a column showing quantities, and a total. When you change a price, you have to MANUALLY recalculate the total. Change 10 prices? Recalculate 10 times. Miss one? Your total is wrong.<br><br>
                <strong>With frameworks (automatic):</strong> Excel automatically updates the total when anything changes. You change a price - boom, total updates instantly. You never think about HOW it updates, it just DOES.<br><br>
                Frameworks are like Excel formulas for your website!</p>
            </div>

            <h4>The DOM: What You're Actually Manipulating</h4>
            <p>Before we go further, let's understand what the "DOM" is, because frameworks help you NOT have to work with it directly.</p>

            <div class="info-box">
                <h4>What is the DOM?</h4>
                <p>DOM stands for <strong>Document Object Model</strong>. Scary name, simple concept:<br><br>
                When your browser loads HTML, it converts it into a JavaScript object structure - a tree of elements that JavaScript can manipulate.<br><br>
                Your HTML is like a family tree:<br>
                <span class="inline-code">&lt;html&gt;</span> is the grandparent<br>
                <span class="inline-code">&lt;body&gt;</span> is a parent<br>
                <span class="inline-code">&lt;div&gt;</span> is a child<br>
                <span class="inline-code">&lt;p&gt;</span> inside <span class="inline-code">&lt;div&gt;</span> is a grandchild<br><br>
                The DOM lets JavaScript say "find the second child of the third div" or "change the text of this paragraph."</p>
            </div>

            <p>Working with the DOM directly is SLOW and TEDIOUS:</p>

            <div class="code">// All these DOM operations are SLOW:
const element = document.getElementById('my-div');
element.textContent = 'New text';
element.style.color = 'blue';
element.classList.add('active');

// Create new element
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello';
newDiv.className = 'card';
document.body.appendChild(newDiv);

// Remove element
const oldElement = document.getElementById('old-div');
oldElement.parentNode.removeChild(oldElement);

// Update a list of 100 items?
// Loop 100 times, update each one manually...
// SLOW and PAINFUL!</div>

            <h3>Part 4: Frontend vs Backend - Understanding the Full Picture</h3>

            <h4>The Iceberg Metaphor</h4>
            <p>Before we dive into frameworks, let's make sure you truly understand the difference between frontend and backend, because this is FUNDAMENTAL to everything you'll build.</p>

            <div class="metaphor-box">
                <h4>ğŸ§Š Websites Are Like Icebergs</h4>
                <p>When you see an iceberg, you only see the tip - about 10% of it. The other 90% is underwater, invisible but absolutely crucial.<br><br>
                <strong>The Tip (Frontend):</strong> Everything you see and interact with<br>
                â€¢ The beautiful design<br>
                â€¢ The buttons you click<br>
                â€¢ The animations<br>
                â€¢ The forms you fill out<br>
                â€¢ The images and text<br><br>
                <strong>The Underwater Part (Backend):</strong> Everything you DON'T see<br>
                â€¢ Databases storing millions of user accounts<br>
                â€¢ Servers processing thousands of requests per second<br>
                â€¢ Security systems protecting your data<br>
                â€¢ Business logic making decisions<br>
                â€¢ Payment processors handling transactions<br>
                â€¢ Email systems sending notifications<br><br>
                Both parts are EQUALLY important. The tip looks pretty, but without the underwater foundation, it would melt and disappear!</p>
            </div>

            <h4>What "Frontend" Really Means</h4>
            <p>Let's get crystal clear on this. The <strong>frontend</strong> (also called "client-side") is EVERYTHING that happens in YOUR browser, on YOUR device.</p>

            <div class="info-box">
                <h4>Frontend In Plain English</h4>
                <p><strong>Where it runs:</strong> In your web browser (Chrome, Firefox, Safari, Edge) on your computer/phone/tablet<br><br>
                <strong>What it does:</strong><br>
                â€¢ Displays the user interface (what you see)<br>
                â€¢ Handles user interactions (clicks, typing, scrolling)<br>
                â€¢ Makes things look pretty (colors, layouts, animations)<br>
                â€¢ Shows/hides elements dynamically<br>
                â€¢ Validates your input (e.g., "Please enter a valid email")<br>
                â€¢ Communicates with the backend when needed<br><br>
                <strong>Technologies used:</strong><br>
                â€¢ HTML (structure)<br>
                â€¢ CSS (styling)<br>
                â€¢ JavaScript (interactivity)<br>
                â€¢ Frameworks like React, Vue, Angular<br><br>
                <strong>Think of it as:</strong> The storefront of a shop - it's what customers see and interact with!</p>
            </div>

            <h4>What "Backend" Really Means</h4>
            <p>The <strong>backend</strong> (also called "server-side") is everything that happens on a SERVER - a powerful computer (or many computers!) somewhere in a data center.</p>

            <div class="info-box">
                <h4>Backend In Plain English</h4>
                <p><strong>Where it runs:</strong> On servers in data centers (Amazon's servers, Google's servers, your company's servers, etc.)<br><br>
                <strong>What it does:</strong><br>
                â€¢ Stores and retrieves data from databases<br>
                â€¢ Processes business logic ("Is this user allowed to delete that post?")<br>
                â€¢ Handles authentication ("Is this password correct?")<br>
                â€¢ Processes payments<br>
                â€¢ Sends emails<br>
                â€¢ Generates reports<br>
                â€¢ Performs complex calculations<br>
                â€¢ Keeps secrets safe (API keys, passwords, etc.)<br><br>
                <strong>Technologies used:</strong><br>
                â€¢ Node.js (JavaScript on the server)<br>
                â€¢ Python (Django, Flask)<br>
                â€¢ Java, C#, Ruby, PHP, Go, etc.<br>
                â€¢ Databases (PostgreSQL, MongoDB, MySQL)<br><br>
                <strong>Think of it as:</strong> The warehouse and office behind the shop - customers never see it, but it's where all the real work happens!</p>
            </div>

            <h4>The Restaurant Metaphor - COMPLETE Edition</h4>
            <p>Let's use the restaurant analogy one more time, but make it comprehensive so you'll never forget:</p>

            <div class="metaphor-box">
                <h4>ğŸ½ï¸ The Complete Restaurant Breakdown</h4>
                <p><strong>FRONTEND (Dining Area):</strong><br><br>
                <strong>The Menu:</strong> Your website's layout and navigation. It shows you what's available.<br><br>
                <strong>The Tables and Chairs:</strong> UI elements like buttons, forms, input fields - things you interact with.<br><br>
                <strong>The Decorations:</strong> CSS styling - colors, fonts, spacing that make it look nice.<br><br>
                <strong>The Lighting:</strong> Visual effects, animations, transitions that create atmosphere.<br><br>
                <strong>Your Server/Waiter:</strong> JavaScript - takes your order (input), brings you food (displays data), responds to your requests.<br><br>
                <strong>The Dining Experience:</strong> Everything you SEE, TOUCH, and EXPERIENCE as a customer.<br><br>
                <hr>
                <strong>BACKEND (Kitchen & Office):</strong><br><br>
                <strong>The Kitchen:</strong> Where the real processing happens - cooking (computing), preparing orders (processing requests).<br><br>
                <strong>The Pantry/Freezer:</strong> The database - stores ingredients (data) for long-term. Thousands of items organized and preserved.<br><br>
                <strong>The Head Chef:</strong> Business logic - makes decisions about recipes, checks quality, manages the operation.<br><br>
                <strong>The Recipe Book:</strong> Your code/algorithms - instructions for how to prepare each dish correctly.<br><br>
                <strong>The Dishwasher:</strong> Background jobs - cleanup tasks that happen behind the scenes.<br><br>
                <strong>The Cash Register/Accounting:</strong> Payment processing, financial records, secure transactions.<br><br>
                <strong>The Manager's Office:</strong> Admin tools, analytics, monitoring systems.<br><br>
                <strong>The Security System:</strong> Authentication, authorization, data protection - making sure only authorized people access certain areas.<br><br>
                <hr>
                <strong>THE COMMUNICATION:</strong><br><br>
                <strong>The Ticket System:</strong> When the waiter takes your order, they write a ticket and send it to the kitchen. That's like an HTTP request!<br><br>
                <strong>The Ready Bell:</strong> When food is ready, kitchen rings a bell. That's like an HTTP response!<br><br>
                You (customer) never enter the kitchen. You don't see the recipes or the pantry. You just enjoy the result!</p>
            </div>

            <h4>The Client-Server Model</h4>
            <p>This is the formal name for how frontend and backend communicate. It's simpler than it sounds!</p>

            <div class="info-box">
                <h4>Client-Server Model Explained</h4>
                <p><strong>CLIENT:</strong> The thing making requests (your browser, your phone app)<br><br>
                <strong>SERVER:</strong> The thing responding to requests (the backend computer)<br><br>
                <strong>REQUEST:</strong> "Hey server, I need some data!" or "Hey server, save this information!"<br><br>
                <strong>RESPONSE:</strong> "Here's your data!" or "OK, I saved it!" or "Sorry, error occurred."<br><br>
                It's a conversation. The client asks, the server answers. Every time!</p>
            </div>

            <h4>Key Terms You MUST Know</h4>
            <p>Let's define the essential vocabulary that you'll hear constantly:</p>

            <div class="code">ğŸ“˜ GLOSSARY OF ESSENTIAL TERMS:

CLIENT:
  Definition: The user's device/browser making requests
  Example: Your laptop running Chrome
  Think: The customer in the restaurant

SERVER:
  Definition: A computer that responds to requests
  Example: Amazon's computers running your favorite shopping site
  Think: The kitchen in the restaurant

REQUEST:
  Definition: A message from client asking for something
  Example: "Give me the user profile for user ID 12345"
  Think: The customer ordering food

RESPONSE:
  Definition: The server's answer to a request
  Example: "Here's the user profile data: {name: 'John', age: 30}"
  Think: The waiter bringing your food

HTTP/HTTPS:
  Definition: The protocol (set of rules) for web communication
  Example: Like saying "please" and "thank you" - a standard way to communicate
  Think: The formal etiquette between waiter and customer

API (Application Programming Interface):
  Definition: A menu of what you can request from a server
  Example: "GET /users/123" means "get user with ID 123"
  Think: The actual menu showing what dishes you can order

DATABASE:
  Definition: Organized storage for data
  Example: PostgreSQL storing millions of user accounts
  Think: The pantry/freezer storing all ingredients

FULL-STACK:
  Definition: Can work on both frontend AND backend
  Example: A developer who knows React AND Node.js
  Think: Someone who can work as both waiter AND chef</div>

            <h4>How They Communicate: The HTTP Request/Response Cycle</h4>
            <p>Every interaction between frontend and backend follows this pattern. Let's break it down step by step:</p>

            <div class="code">THE CYCLE:

1. USER ACTION (Frontend)
   â””â”€&gt; You click "Load Posts" button

2. JAVASCRIPT CAPTURES IT (Frontend)
   â””â”€&gt; Event listener says: "Button was clicked!"

3. MAKE HTTP REQUEST (Frontend)
   â””â”€&gt; Send message to server: "GET /api/posts"
   
4. REQUEST TRAVELS THROUGH INTERNET
   â””â”€&gt; Your computer â†’ ISP â†’ Internet â†’ Server's ISP â†’ Server
   
5. SERVER RECEIVES REQUEST (Backend)
   â””â”€&gt; "Someone wants posts!"
   
6. SERVER PROCESSES (Backend)
   â””â”€&gt; Query database: "SELECT * FROM posts"
   â””â”€&gt; Get results: [{id:1, title:"Hi"}, {id:2, title:"Hello"}]
   â””â”€&gt; Format as JSON
   
7. SERVER SENDS RESPONSE (Backend)
   â””â”€&gt; Status: 200 OK
   â””â”€&gt; Data: JSON array of posts
   
8. RESPONSE TRAVELS BACK
   â””â”€&gt; Server â†’ Internet â†’ Your computer
   
9. JAVASCRIPT RECEIVES RESPONSE (Frontend)
   â””â”€&gt; "Got the data!"
   
10. UPDATE UI (Frontend)
    â””â”€&gt; Loop through posts and display them on page
    â””â”€&gt; User sees the posts appear!

This entire cycle happens in MILLISECONDS!</div>

            <h4>Visual Representation: The Architecture</h4>
            <p>Here's an ASCII diagram showing how everything connects:</p>

            <div class="code">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          USER'S DEVICE (Client)             â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      WEB BROWSER (Chrome/etc)       â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚    FRONTEND (Your Code)      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ HTML (structure)         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ CSS (styling)            â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ JavaScript (behavior)    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ React/Vue components     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Renders UI, handles input  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Makes HTTP requests        â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†• HTTP
            (Request/Response)
                    â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       DATA CENTER (Server)                  â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      WEB SERVER (Node.js/etc)       â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚    BACKEND (Your Code)       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ API Routes/Endpoints     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Business Logic           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Authentication           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Data Processing          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Receives requests          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Processes data             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Sends responses            â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                    â†•                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚        DATABASE                     â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚   â€¢ User data                       â”‚   â”‚
â”‚  â”‚   â€¢ Posts, comments                 â”‚   â”‚
â”‚  â”‚   â€¢ Product catalog                 â”‚   â”‚
â”‚  â”‚   â€¢ Everything stored permanently   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</div>

            <h4>Real Code Example: Frontend Making a Request</h4>
            <p>Let's see actual code showing how frontend talks to backend:</p>

            <div class="code">// FRONTEND CODE (JavaScript in the browser)

// User clicks "Load Users" button
document.getElementById('load-users-btn').addEventListener('click', async function() {
  
  console.log('User clicked button!');
  
  // Step 1: Show loading message
  document.getElementById('status').textContent = 'Loading...';
  
  try {
    // Step 2: Make HTTP request to backend
    const response = await fetch('https://api.mywebsite.com/users');
    //                            â†‘
    //                      This is your backend URL!
    
    // Step 3: Wait for response and parse it
    const users = await response.json();
    //    â†‘
    //  This will be data like: [{id:1, name:"Alice"}, {id:2, name:"Bob"}]
    
    // Step 4: Update the UI with the data
    const userList = document.getElementById('user-list');
    userList.innerHTML = ''; // Clear old content
    
    users.forEach(user => {
      const li = document.createElement('li');
      li.textContent = `${user.name} (ID: ${user.id})`;
      userList.appendChild(li);
    });
    
    // Step 5: Update status
    document.getElementById('status').textContent = `Loaded ${users.length} users!`;
    
  } catch (error) {
    // If something went wrong
    console.error('Error:', error);
    document.getElementById('status').textContent = 'Error loading users!';
  }
});

// What happened:
// 1. User clicked button (Frontend)
// 2. JavaScript sent HTTP request to server (Frontend â†’ Backend)
// 3. Server processed request and sent back data (Backend â†’ Frontend)
// 4. JavaScript received data and updated page (Frontend)
// User sees the result!</div>

            <h4>Real Code Example: Backend Handling the Request</h4>
            <p>Now let's see what happens on the backend when that request arrives:</p>

            <div class="code">// BACKEND CODE (Node.js running on a server)

const express = require('express'); // Popular Node.js framework
const app = express();

// This is an API ENDPOINT - a URL the frontend can call
app.get('/users', async function(request, response) {
  //       â†‘                       â†‘          â†‘
  //       |                       |          |
  //    The URL path          Request from    Response we'll
  //                          frontend        send back
  
  console.log('Received request for users!');
  
  try {
    // Step 1: Query the database
    const users = await database.query('SELECT id, name, email FROM users');
    //    â†‘
    //  This fetches data from database (SQL query)
    
    // Step 2: Do some processing if needed
    // (e.g., remove sensitive data, format data, etc.)
    const safeUsers = users.map(user => ({
      id: user.id,
      name: user.name,
      // Note: We're NOT sending passwords or sensitive data!
    }));
    
    // Step 3: Send response back to frontend
    response.status(200).json(safeUsers);
    //        â†‘      â†‘       â†‘
    //        |      |       |
    //     Status   Format   The data
    //     (200 =   as JSON
    //      OK)
    
    console.log(`Sent ${safeUsers.length} users to frontend`);
    
  } catch (error) {
    // If something went wrong
    console.error('Database error:', error);
    response.status(500).json({ error: 'Internal server error' });
    //        â†‘
    //     500 = Server Error
  }
});

// Start the server
app.listen(3000, () => {
  console.log('Backend server running on port 3000');
});

// What happened:
// 1. Server received request at /users endpoint
// 2. Queried database for user data
// 3. Processed/formatted the data
// 4. Sent response back to frontend
// Frontend receives it and displays it!</div>

            <h4>What Happens When You Click "Login"?</h4>
            <p>Let's trace a complete real-world example: logging into a website. This uses BOTH frontend and backend:</p>

            <div class="code">ğŸ” THE LOGIN FLOW - Step by Step:

STEP 1: USER SEES LOGIN FORM (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: HTML form with email and password fields
Where: Your browser
Code: &lt;input type="email"&gt; &lt;input type="password"&gt; &lt;button&gt;Login&lt;/button&gt;


STEP 2: USER TYPES CREDENTIALS (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript captures what you type
Where: Your browser
Data: email = "alice@example.com", password = "secret123"


STEP 3: USER CLICKS LOGIN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript intercepts form submission
Where: Your browser
Action: Prevent default form behavior, prepare to send data


STEP 4: FRONTEND MAKES HTTP REQUEST (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Send credentials to backend
Where: Your browser sends request over internet
Request:
  Method: POST
  URL: https://api.mywebsite.com/auth/login
  Body: { email: "alice@example.com", password: "secret123" }


STEP 5: BACKEND RECEIVES REQUEST (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Server gets login request
Where: Server in data center
Action: Extract email and password from request body


STEP 6: BACKEND CHECKS DATABASE (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Query database for this user
Where: Database server
Query: SELECT * FROM users WHERE email = 'alice@example.com'
Result: User found! Now check password...


STEP 7: BACKEND VERIFIES PASSWORD (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Compare provided password with stored hash
Where: Server memory
Process:
  - Stored hash: "$2b$10$xyzabc123..." (encrypted)
  - Provided: "secret123"
  - Hash "secret123" and compare
  - Match? YES! âœ“


STEP 8: BACKEND CREATES SESSION (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Generate authentication token
Where: Server
Token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." (JWT)
Meaning: "This user is logged in, valid for 24 hours"


STEP 9: BACKEND SENDS RESPONSE (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Send success message and token
Where: Server sends over internet
Response:
  Status: 200 OK
  Body: { success: true, token: "eyJhb...", user: { name: "Alice" } }


STEP 10: FRONTEND RECEIVES RESPONSE (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript receives the success response
Where: Your browser
Action: Parse the JSON data


STEP 11: FRONTEND STORES TOKEN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Save token for future requests
Where: Browser localStorage or cookie
Code: localStorage.setItem('authToken', response.token);


STEP 12: FRONTEND UPDATES UI (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Show logged-in state
Where: Your browser
Changes:
  - Hide login form
  - Show "Welcome, Alice!"
  - Display user dashboard
  - Update navigation menu


STEP 13: FUTURE REQUESTS INCLUDE TOKEN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Every subsequent request sends token
Where: Your browser
Headers: { Authorization: "Bearer eyJhb..." }
Meaning: "I'm Alice, and here's proof!"


THE RESULT:
You're logged in! Frontend and backend worked together:
- Frontend collected your input and displayed results
- Backend verified credentials and issued a token
- Both sides communicated via HTTP
- Your browser remembers you're logged in</div>

            <div class="warning-box">
                <h4>âš ï¸ Security Note: Why Backend Matters!</h4>
                <p><strong>Never trust the frontend!</strong> Anyone can open browser dev tools and modify JavaScript. That's why:<br><br>
                âŒ NEVER check passwords on frontend<br>
                âŒ NEVER store sensitive API keys in frontend code<br>
                âŒ NEVER trust user input without backend validation<br><br>
                âœ… ALWAYS verify credentials on backend<br>
                âœ… ALWAYS validate data on backend<br>
                âœ… ALWAYS keep secrets on backend<br><br>
                Think: The frontend is a public space (the dining area). Anyone can see and manipulate it. The backend is private (the kitchen) - only authorized code runs there!</p>
            </div>

            <h4>Why You Need BOTH Frontend and Backend</h4>
            <p>Some beginners ask: "Can't I just use frontend?" or "Why not put everything in the backend?" Let's address this:</p>

            <div class="info-box">
                <h4>Frontend Alone: What You CAN'T Do</h4>
                <p>Without a backend, you can't:<br><br>
                âŒ Save data permanently (browser refresh = data lost)<br>
                âŒ Share data between users (everyone sees their own version)<br>
                âŒ Keep secrets secure (all code is visible)<br>
                âŒ Process payments (security risk!)<br>
                âŒ Send emails<br>
                âŒ Do heavy computations (would freeze the browser)<br>
                âŒ Access other APIs requiring secret keys<br><br>
                <strong>Frontend-only apps are limited to:</strong><br>
                â€¢ Simple calculators<br>
                â€¢ Static informational websites<br>
                â€¢ Games that don't save progress<br>
                â€¢ Demos and prototypes</p>
            </div>

            <div class="info-box">
                <h4>Backend Alone: What You CAN'T Do</h4>
                <p>Without a frontend, you can't:<br><br>
                âŒ Show a nice user interface (backend returns raw data)<br>
                âŒ Handle user interactions smoothly<br>
                âŒ Create responsive, animated experiences<br>
                âŒ Work offline (backend needs internet)<br>
                âŒ Provide instant feedback (every action requires server round-trip)<br><br>
                <strong>Backend-only services are:</strong><br>
                â€¢ APIs for other developers<br>
                â€¢ Command-line tools<br>
                â€¢ Server-to-server communication<br>
                â€¢ Background job processors</p>
            </div>

            <div class="metaphor-box">
                <h4>The Marriage Metaphor</h4>
                <p>Frontend and backend are like a married couple:<br><br>
                <strong>Frontend (the face of the relationship):</strong><br>
                â€¢ Presents things beautifully<br>
                â€¢ Communicates with the outside world<br>
                â€¢ Creates first impressions<br>
                â€¢ Handles social interactions<br><br>
                <strong>Backend (the foundation of the relationship):</strong><br>
                â€¢ Handles the serious work behind the scenes<br>
                â€¢ Manages resources and planning<br>
                â€¢ Makes important decisions<br>
                â€¢ Keeps everything organized and secure<br><br>
                They're DIFFERENT, but they NEED each other. The best relationships (and websites!) have both working in harmony!</p>
            </div>

            <h4>Putting It All Together: The Big Picture</h4>
            <p>Let's summarize everything with a complete example - a simple todo app:</p>

            <div class="code">ğŸ“ TODO APP - Complete Frontend/Backend Interaction:

SCENARIO: User adds a new todo item

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FRONTEND (What user sees)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  [Todo App]                                            â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Add new todo:                    â”‚                 â”‚
â”‚  â”‚ [Buy groceries____________] [Add]â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                        â”‚
â”‚  Your Todos:                                           â”‚
â”‚  â˜ Finish homework                                     â”‚
â”‚  â˜ Call mom                                            â”‚
â”‚  â˜ Buy groceries  â† Just added!                       â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHAT HAPPENED BEHIND THE SCENES:

1. User types "Buy groceries" in input box
   â†’ Frontend: JavaScript tracks every keystroke

2. User clicks "Add" button
   â†’ Frontend: Event listener fires
   â†’ Frontend: Validate input (not empty? not too long?)

3. Frontend makes HTTP request:
   â†’ POST /api/todos
   â†’ Body: { text: "Buy groceries", completed: false }
   â†’ Headers: { Authorization: "Bearer user_token_123" }

4. Request travels over internet to server
   â†’ Through WiFi â†’ ISP â†’ Internet â†’ Server ISP â†’ Server

5. Backend receives request:
   â†’ "POST request to /api/todos"
   â†’ Extract data from request body
   â†’ Verify authentication token (is this a real user?)

6. Backend validates data:
   â†’ Is text provided? âœ“
   â†’ Is text reasonable length? âœ“
   â†’ Is user authorized? âœ“

7. Backend interacts with database:
   â†’ SQL: INSERT INTO todos (user_id, text, completed) 
           VALUES (123, 'Buy groceries', false)
   â†’ Database saves it permanently
   â†’ Database returns: { id: 789, user_id: 123, text: "Buy groceries", completed: false }

8. Backend sends response:
   â†’ Status: 201 Created
   â†’ Body: { id: 789, text: "Buy groceries", completed: false }

9. Response travels back to frontend:
   â†’ Server â†’ Internet â†’ User's computer

10. Frontend receives response:
    â†’ Parse JSON data
    â†’ Create new todo element in DOM
    â†’ Append to todo list
    â†’ Clear input box
    â†’ Show success message
    â†’ User sees new todo appear!

TOTAL TIME: Usually 50-200 milliseconds!

WHAT EACH SIDE DID:

FRONTEND:
âœ“ Displayed the UI
âœ“ Captured user input
âœ“ Validated input
âœ“ Made HTTP request
âœ“ Updated UI with response
âœ“ Provided instant feedback

BACKEND:
âœ“ Received request
âœ“ Authenticated user
âœ“ Validated data (again! double-check)
âœ“ Saved to database
âœ“ Sent response

BOTH WORKED TOGETHER TO CREATE A SEAMLESS EXPERIENCE!</div>

            <h4>The Key Takeaway</h4>
            <p>Here's what you absolutely MUST remember:</p>

            <div class="info-box">
                <h4>ğŸ¯ Core Concepts to Master</h4>
                <p><strong>1. Frontend = User Interface</strong><br>
                Runs in browser. Shows things. Handles interactions. Temporary.<br><br>
                <strong>2. Backend = Business Logic + Data</strong><br>
                Runs on servers. Processes data. Stores information. Permanent.<br><br>
                <strong>3. They Communicate via HTTP</strong><br>
                Frontend makes requests. Backend sends responses. It's a conversation.<br><br>
                <strong>4. Client-Server Model</strong><br>
                Client (your browser) asks. Server (backend) answers. Every single time.<br><br>
                <strong>5. Security Lives in Backend</strong><br>
                Never trust frontend. Always verify on backend. Frontend is public, backend is private.<br><br>
                <strong>6. Full-Stack = Both Skills</strong><br>
                Understand frontend AND backend. See the complete picture. Build entire applications.<br><br>
                <strong>7. They Need Each Other</strong><br>
                Frontend without backend = pretty but useless.<br>
                Backend without frontend = powerful but invisible.<br>
                Together = magic! âœ¨</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Mental Model</h4>
                <p>When you visit ANY website, remember this:<br><br>
                1. Your browser (frontend) sends a request<br>
                2. The server (backend) processes it<br>
                3. The response travels back<br>
                4. Your browser displays it<br><br>
                <strong>Every. Single. Interaction.</strong><br><br>
                Click a button? Request â†’ Response.<br>
                Load a page? Request â†’ Response.<br>
                Submit a form? Request â†’ Response.<br>
                Like a post? Request â†’ Response.<br><br>
                It's ALWAYS frontend (you) talking to backend (server).<br><br>
                Now that you understand this, frameworks will make SO much more sense - because frameworks help you build better frontends that communicate with backends more easily!</p>
            </div>

            <h3>Part 5: Enter Frameworks - The Solution</h3>

            <h4>What Frameworks Actually Do</h4>
            <p>A framework (or library - we'll explain the difference soon) like React or Vue solves all these problems. Here's what they do:</p>

            <div class="info-box">
                <h4>What Frameworks Give You</h4>
                <p><strong>1. Automatic Updates:</strong> Change your data, and the UI updates automatically. No manual DOM manipulation.<br><br>
                <strong>2. Components:</strong> Build reusable pieces. Create a Button component once, use it 1000 times.<br><br>
                <strong>3. State Management:</strong> A smart way to store data that automatically triggers UI updates when it changes.<br><br>
                <strong>4. Declarative Code:</strong> You describe WHAT the UI should look like, not HOW to build it step-by-step.<br><br>
                <strong>5. Ecosystem:</strong> Thousands of pre-built components and tools you can use.<br><br>
                <strong>6. Performance:</strong> Frameworks are SMART about updating only what changed, not redrawing everything.</p>
            </div>

            <h4>The Declarative vs Imperative Mindset</h4>
            <p>This is THE most important mental shift when learning frameworks:</p>

            <div class="metaphor-box">
                <h4>Ordering at a Restaurant (Again!)</h4>
                <p><strong>Imperative (Vanilla JS):</strong><br>
                "Go to the kitchen. Open the fridge. Take out 3 eggs. Get a bowl from the cabinet. Crack each egg into the bowl. Whisk for 30 seconds. Get a pan from the drawer. Put it on the stove. Turn heat to medium. Wait 1 minute. Add butter. Wait for it to melt. Pour in eggs. Stir constantly with a spatula. After 2 minutes, add salt and pepper. Stir 30 more seconds. Transfer to a plate. Bring it to table 5."<br><br>
                You tell the chef EVERY SINGLE STEP. That's imperative programming.<br><br>
                <strong>Declarative (React/Vue):</strong><br>
                "I'd like scrambled eggs, please."<br><br>
                You describe WHAT you want. The chef figures out HOW to make it. That's declarative programming!</p>
            </div>

            <p>In code terms:</p>

            <div class="code">// IMPERATIVE (Vanilla JS):
// Tell the computer HOW to do everything
let count = 0;
const display = document.getElementById('count');

function increment() {
  count = count + 1;              // Step 1: Update data
  display.textContent = count;    // Step 2: Find element and update it
  
  if (count > 10) {               // Step 3: Check condition
    display.style.color = 'red';  // Step 4: Update styling
  } else {
    display.style.color = 'black';
  }
}

// DECLARATIVE (React):
// Describe WHAT you want the UI to look like
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p style={{ color: count &gt; 10 ? 'red' : 'black' }}&gt;
        Count: {count}
      &lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
// React figures out WHEN and HOW to update the DOM!</div>

            <p>See the difference? In React, you just say "when count is over 10, make it red." React handles the rest!</p>

            <h4>Why This Matters So Much</h4>
            <p>Let's compare building a shopping cart in vanilla JS vs React:</p>

            <div class="code">// VANILLA JS - YOU MUST DO EVERYTHING:
let cart = [];
const cartDisplay = document.getElementById('cart');
const totalDisplay = document.getElementById('total');
const countDisplay = document.getElementById('cart-count');

function addToCart(item) {
  // Step 1: Update data
  cart.push(item);
  
  // Step 2: Update cart display
  const li = document.createElement('li');
  li.textContent = item.name;
  cartDisplay.appendChild(li);
  
  // Step 3: Update total
  const total = cart.reduce((sum, i) => sum + i.price, 0);
  totalDisplay.textContent = '$' + total;
  
  // Step 4: Update count badge
  countDisplay.textContent = cart.length;
  
  // Step 5: Update localStorage
  localStorage.setItem('cart', JSON.stringify(cart));
  
  // Did you forget something? That's a bug!
}

// REACT - DESCRIBE WHAT YOU WANT:
function ShoppingCart() {
  const [cart, setCart] = useState([]);
  
  const addToCart = (item) => {
    setCart([...cart, item]);
    // That's IT! React updates EVERYTHING automatically:
    // - The cart list
    // - The total
    // - The count badge
    // No manual DOM manipulation!
  };
  
  const total = cart.reduce((sum, item) => sum + item.price, 0);
  
  return (
    &lt;div&gt;
      &lt;div&gt;Items: {cart.length}&lt;/div&gt;
      &lt;ul&gt;
        {cart.map(item => &lt;li&gt;{item.name}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;div&gt;Total: ${total}&lt;/div&gt;
    &lt;/div&gt;
  );
}
// React sees cart changed and re-renders EVERYTHING that uses it!</div>

            <div class="warning-box">
                <h4>âš ï¸ The Mental Shift</h4>
                <p>The hardest part of learning React/Vue isn't the syntax - it's changing how you THINK about code.<br><br>
                <strong>Stop thinking:</strong> "When this button is clicked, find this element and change its text, then find that element and update its style, then..."<br><br>
                <strong>Start thinking:</strong> "Here's what my data looks like. Here's what my UI should look like for that data. When data changes, React figures out what to update."<br><br>
                Once this clicks, everything becomes easier!</p>
            </div>

            <h4>Component-Based Architecture</h4>
            <p>Frameworks let you build your UI from small, reusable pieces called <strong>components</strong>. This is HUGE for organization:</p>

            <div class="metaphor-box">
                <h4>LEGO Blocks Metaphor</h4>
                <p>Think of components like LEGO blocks:<br><br>
                <strong>Without components (vanilla JS):</strong> You're carving one giant sculpture from a single block of marble. Want to change the left arm? You have to carefully chisel, hoping you don't break the leg.<br><br>
                <strong>With components (React/Vue):</strong> You're building with LEGO. Create an Arm component. Use it for both arms! Need to change it? Rebuild just that block. Everything else stays intact. Want to build a whole LEGO person? Combine Head + Torso + 2 Arms + 2 Legs. Each piece is independent!</p>
            </div>

            <p>Here's how you might break down a website into components:</p>

            <div class="code">// A typical website structure:

App
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ Logo
â”‚   â”œâ”€â”€ Navigation
â”‚   â”‚   â”œâ”€â”€ NavLink
â”‚   â”‚   â”œâ”€â”€ NavLink
â”‚   â”‚   â””â”€â”€ NavLink
â”‚   â””â”€â”€ UserMenu
â”‚       â”œâ”€â”€ Avatar
â”‚       â””â”€â”€ Dropdown
â”œâ”€â”€ Main
â”‚   â”œâ”€â”€ Sidebar
â”‚   â”‚   â”œâ”€â”€ SearchBox
â”‚   â”‚   â””â”€â”€ FilterList
â”‚   â”‚       â”œâ”€â”€ FilterOption
â”‚   â”‚       â””â”€â”€ FilterOption
â”‚   â””â”€â”€ Content
â”‚       â”œâ”€â”€ ProductCard
â”‚       â”œâ”€â”€ ProductCard
â”‚       â””â”€â”€ ProductCard
â”‚           â”œâ”€â”€ Image
â”‚           â”œâ”€â”€ Title
â”‚           â”œâ”€â”€ Price
â”‚           â””â”€â”€ AddToCartButton
â””â”€â”€ Footer
    â”œâ”€â”€ SocialLinks
    â””â”€â”€ Copyright

// Each of these is a COMPONENT - a reusable piece!
// Build ProductCard once, use it 1000 times for 1000 products!</div>

            <h4>Why Components Are a Game-Changer</h4>

            <div class="info-box">
                <h4>The Power of Components</h4>
                <p><strong>Reusability:</strong> Build a Button component with all your styling and logic. Use it everywhere. Change it once, it updates everywhere.<br><br>
                <strong>Maintainability:</strong> Bug in the header? You know exactly where to look - the Header component. Not searching through 5000 lines of HTML.<br><br>
                <strong>Testability:</strong> Test each component individually. Button works? Great! Header works? Perfect! Combine them with confidence.<br><br>
                <strong>Team Work:</strong> Person A builds the header, Person B builds the footer. They work in separate files and merge easily.<br><br>
                <strong>Mental Model:</strong> Think about one small piece at a time, not the entire application at once.</p>
            </div>

            <h3>Part 6: React and Vue - What's the Difference?</h3>

            <h4>Library vs Framework (Again)</h4>
            <p>You'll hear React called a "library" and Vue called a "framework" (though Vue calls itself "progressive framework"). What's the difference?</p>

            <div class="metaphor-box">
                <h4>The Toolbox vs Construction Kit Metaphor</h4>
                <p><strong>React (Library):</strong> Like a toolbox. Here are some great tools (components, hooks, JSX). YOU decide how to structure your app. Want routing? Pick a library (React Router). Want global state? Pick one (Redux, MobX, Zustand). You're the architect.<br><br>
                <strong>Vue (Framework):</strong> Like a construction kit with instructions. Vue gives you tools AND tells you the "Vue way" of doing things. It includes routing (Vue Router), state management (Pinia/Vuex), and opinions on how to structure code. Still flexible, but more guided.<br><br>
                <strong>Angular (Full Framework):</strong> Like building with a pre-designed kit. Everything is included and there's ONE way to do things. Very opinionated.</p>
            </div>

            <p>In practice, for beginners, this distinction doesn't matter much! Both React and Vue solve the same problems:</p>

            <div class="code">// What React and Vue BOTH do:
âœ… Component-based architecture
âœ… Reactive state management (data changes = UI updates)
âœ… Virtual DOM for performance
âœ… Rich ecosystem of tools and libraries
âœ… Large communities with tons of tutorials
âœ… Can build anything from simple pages to huge apps

// Differences:
React:
- Uses JSX (HTML-in-JavaScript)
- More JavaScript-heavy
- More flexible (pick your own tools)
- Bigger job market

Vue:
- Uses templates (HTML-like)
- Easier for beginners
- More batteries-included
- Growing rapidly in popularity</div>

            <h4>Which One Should You Learn?</h4>
            <p>Honest answer: EITHER! They're both excellent. Learning one makes learning the other easy because the CONCEPTS are the same.</p>

            <div class="info-box">
                <h4>Pick Based On</h4>
                <p><strong>Choose React if:</strong><br>
                â€¢ You want maximum job opportunities (React is more common in job listings)<br>
                â€¢ You like JavaScript-heavy syntax<br>
                â€¢ You want to learn the most popular library<br>
                â€¢ You're okay piecing together your own toolset<br><br>
                <strong>Choose Vue if:</strong><br>
                â€¢ You're a complete beginner (Vue is often considered easier to start with)<br>
                â€¢ You prefer HTML-like templates<br>
                â€¢ You want more built-in features<br>
                â€¢ You like clear, official documentation<br><br>
                <strong>Best advice:</strong> Flip a coin! You can't go wrong. Learn one well, then learn the other later - it'll take you a weekend because you already understand the concepts.</p>
            </div>

            <h3>Part 7: State - The Most Important Concept</h3>

            <h4>What Even IS "State"?</h4>
            <p>You'll hear "state" mentioned constantly in framework tutorials. Let's break it down to the simplest possible explanation:</p>

            <div class="info-box">
                <h4>State in Plain English</h4>
                <p><strong>State</strong> = Data that can change over time.<br><br>
                That's it! Seriously!<br><br>
                Examples of state:<br>
                â€¢ A counter value (starts at 0, changes when you click)<br>
                â€¢ Whether a user is logged in (true or false)<br>
                â€¢ Items in a shopping cart (an array that grows/shrinks)<br>
                â€¢ The current page you're on<br>
                â€¢ Form input values<br>
                â€¢ Whether a modal is open or closed<br><br>
                State is just variables that, when they change, should update what the user sees.</p>
            </div>

            <div class="metaphor-box">
                <h4>The Light Switch Metaphor</h4>
                <p>Think of state like a light switch:<br><br>
                <strong>State value:</strong> ON or OFF (true or false)<br>
                <strong>UI:</strong> The light bulb (bright or dark)<br>
                <strong>State change:</strong> Flipping the switch<br><br>
                When you flip the switch (change state), the light automatically updates. You don't manually turn the bulb on - it's CONNECTED to the switch. That's how state works! Change state, UI automatically updates.</p>
            </div>

            <h4>State vs Regular Variables</h4>
            <p>Why not just use regular variables? Great question!</p>

            <div class="code">// Regular variable (doesn't work in React/Vue):
function Counter() {
  let count = 0;  // Regular variable
  
  function increment() {
    count = count + 1;
    console.log(count);  // This works! Logs 1, 2, 3...
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Problem: The UI shows "Count: 0" FOREVER
// Even though count IS changing, React doesn't know to re-render!</div>

            <p>React doesn't automatically watch all your variables. It would be too slow! Instead, you explicitly tell React "this variable is special - when it changes, update the UI":</p>

            <div class="code">// State variable (works!):
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);  // Special state variable
  
  function increment() {
    setCount(count + 1);
    // React sees count changed and automatically re-renders the component!
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Now it works! UI updates when count changes!</div>

            <h4>Breaking Down useState</h4>
            <p>Let's understand that weird syntax:</p>

            <div class="code">const [count, setCount] = useState(0);
//     ^       ^          ^         ^
//     |       |          |         |
//     |       |          |         Initial value (count starts at 0)
//     |       |          A React function that creates state
//     |       Function to UPDATE the state
//     The STATE VALUE itself</div>

            <div class="info-box">
                <h4>Understanding Array Destructuring</h4>
                <p><span class="inline-code">useState(0)</span> returns an array with TWO things: <span class="inline-code">[value, setterFunction]</span><br><br>
                We use <strong>array destructuring</strong> to unpack them:<br><br>
                <span class="inline-code">const [count, setCount] = useState(0);</span><br><br>
                Is the same as:<br><br>
                <span class="inline-code">const stateArray = useState(0);</span><br>
                <span class="inline-code">const count = stateArray[0];  // The value</span><br>
                <span class="inline-code">const setCount = stateArray[1];  // The setter</span><br><br>
                Destructuring is just shorter! You can name them whatever you want:<br>
                <span class="inline-code">const [user, setUser] = useState(null);</span><br>
                <span class="inline-code">const [isOpen, setIsOpen] = useState(false);</span><br>
                <span class="inline-code">const [items, setItems] = useState([]);</span></p>
            </div>

            <h4>Multiple State Variables</h4>
            <p>You can have as many state variables as you want:</p>

            <div class="code">function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  
  // Each one updates independently!
  
  return (
    &lt;form&gt;
      &lt;input 
        value={email} 
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input 
        type="password"
        value={password} 
        onChange={(e) =&gt; setPassword(e.target.value)}
      /&gt;
      &lt;input 
        type="checkbox"
        checked={rememberMe}
        onChange={(e) =&gt; setRememberMe(e.target.checked)}
      /&gt;
      {error && &lt;p&gt;{error}&lt;/p&gt;}
      {loading && &lt;p&gt;Loading...&lt;/p&gt;}
      &lt;button type="submit"&gt;Log In&lt;/button&gt;
    &lt;/form&gt;
  );
}</div>

            <h3>Part 8: Recap - Where We Are Now</h3>

            <h4>What You Now Understand</h4>
            <p>Let's recap this journey from absolute zero:</p>

            <div class="info-box">
                <h4>Your Mental Model So Far</h4>
                <p><strong>1. Websites are made of three things:</strong><br>
                â€¢ HTML (structure) - what's on the page<br>
                â€¢ CSS (styling) - how it looks<br>
                â€¢ JavaScript (behavior) - what it does<br><br>
                <strong>2. Frontend vs Backend:</strong><br>
                â€¢ Frontend = what users see and interact with (runs in browser)<br>
                â€¢ Backend = hidden server code that processes data (runs on server)<br>
                â€¢ Full-stack = both!<br><br>
                <strong>3. The problem with vanilla JavaScript:</strong><br>
                â€¢ You manually manipulate the DOM (slow and tedious)<br>
                â€¢ You must remember to update the UI when data changes<br>
                â€¢ Code becomes messy as apps grow<br><br>
                <strong>4. Frameworks solve this:</strong><br>
                â€¢ Declarative (describe what, not how)<br>
                â€¢ Components (reusable pieces)<br>
                â€¢ Automatic UI updates when state changes<br>
                â€¢ Much cleaner, more maintainable code<br><br>
                <strong>5. State is the key concept:</strong><br>
                â€¢ State = data that changes<br>
                â€¢ When state changes, UI updates automatically<br>
                â€¢ React uses useState() to create state<br>
                â€¢ Vue has ref() and reactive()<br><br>
                <strong>6. React and Vue both:</strong><br>
                â€¢ Use components<br>
                â€¢ Have reactive state<br>
                â€¢ Make building UIs much easier<br>
                â€¢ Are excellent choices for beginners</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Restaurant Metaphor</h4>
                <p>Let's bring it all together with our restaurant analogy:<br><br>
                <strong>HTML:</strong> The blueprint of the restaurant (where things are)<br>
                <strong>CSS:</strong> The interior design (how it looks)<br>
                <strong>JavaScript:</strong> The staff and operations (what happens)<br>
                <strong>Frontend:</strong> The dining area (what customers experience)<br>
                <strong>Backend:</strong> The kitchen (where the real work happens)<br>
                <strong>API:</strong> The waiter (carries requests and responses between dining area and kitchen)<br>
                <strong>State:</strong> The current situation (how many tables are occupied, what's cooking, who's waiting for food)<br>
                <strong>React/Vue:</strong> An automated system that updates menus, bills, and displays automatically when orders change - instead of staff manually rewriting everything!<br><br>
                Full-stack = understanding and being able to work in EVERY part of the restaurant!</p>
            </div>

            <h4>What's Next?</h4>
            <p>Now that you understand the foundations, the rest of this chapter will teach you:</p>

            <ul>
                <li><strong>Section 2:</strong> Building actual React apps from scratch (not just theory anymore!)</li>
                <li><strong>Section 3:</strong> Building actual Vue apps from scratch</li>
                <li><strong>Section 4:</strong> Connecting frontend to backend (full-stack!)</li>
                <li><strong>Section 5:</strong> Deploying your app so the world can see it</li>
            </ul>

            <div class="warning-box">
                <h4>ğŸ¯ Your Learning Strategy</h4>
                <p><strong>Don't rush!</strong> Seriously. These concepts take time to sink in.<br><br>
                <strong>Build as you learn:</strong> Type out every code example. Change things. Break things. Fix them.<br><br>
                <strong>Expect confusion:</strong> It's NORMAL to feel lost at first. Your brain is building new neural pathways. Keep going!<br><br>
                <strong>Focus on concepts, not syntax:</strong> The syntax of React vs Vue is different, but the CONCEPTS (components, state, props) are the same. Master concepts first.<br><br>
                <strong>One thing at a time:</strong> Don't try to learn React + TypeScript + Next.js + Redux all at once. Start simple!<br><br>
                <strong>Build tiny projects:</strong> A counter. A todo list. A weather app. Each one teaches you more than reading 100 tutorials.<br><br>
                Ready? Let's build something real!</p>
            </div>

            <h3>Part 7: Building Your First Dynamic Web Page</h3>

            <h4>The Real Challenge: A Complete Todo List in Vanilla JavaScript</h4>
            <p>Before we dive into frameworks, let's build something REAL with vanilla JavaScript. You need to experience the pain points yourself to truly appreciate why frameworks exist. We're going to build a complete, working todo list app. Not a toy - something functional with add, delete, edit, and mark-as-complete features.</p>

            <div class="info-box">
                <h4>What We're Building</h4>
                <p><strong>Features:</strong><br>
                â€¢ Add new todos<br>
                â€¢ Mark todos as complete (with strikethrough)<br>
                â€¢ Delete todos<br>
                â€¢ Edit existing todos<br>
                â€¢ Filter (show all, active, or completed)<br>
                â€¢ Count remaining tasks<br>
                â€¢ Clear all completed<br><br>
                <strong>What you'll learn:</strong><br>
                â€¢ How to manipulate the DOM manually<br>
                â€¢ Event handling at scale<br>
                â€¢ Managing application state<br>
                â€¢ Where bugs hide in vanilla JS<br>
                â€¢ Why this gets messy FAST</p>
            </div>

            <h4>The Complete Code (HTML + CSS + JavaScript)</h4>
            <p>Here's the ENTIRE app. We'll walk through every line after. Type this out, save it as <span class="inline-code">todo.html</span>, and open it in your browser:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Vanilla JS Todo App&lt;/title&gt;
    &lt;style&gt;
        /* STYLING - Makes it look nice */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            width: 100%;
            max-width: 500px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        #todoInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        
        #todoInput:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #addBtn {
            background: #667eea;
            color: white;
        }
        
        #addBtn:hover {
            background: #5568d3;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .filter-btn {
            padding: 8px 16px;
            background: #f0f0f0;
            font-size: 14px;
        }
        
        .filter-btn.active {
            background: #667eea;
            color: white;
        }
        
        .filter-btn:hover {
            background: #e0e0e0;
        }
        
        .filter-btn.active:hover {
            background: #5568d3;
        }
        
        #todoList {
            list-style: none;
            margin-bottom: 20px;
        }
        
        .todo-item {
            background: #f9f9f9;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .todo-item:hover {
            background: #f0f0f0;
        }
        
        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: #999;
        }
        
        .todo-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .todo-text {
            flex: 1;
            font-size: 16px;
            word-break: break-word;
        }
        
        .todo-item.editing .todo-text {
            display: none;
        }
        
        .edit-input {
            flex: 1;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 16px;
            display: none;
        }
        
        .todo-item.editing .edit-input {
            display: block;
        }
        
        .todo-actions {
            display: flex;
            gap: 5px;
        }
        
        .edit-btn, .delete-btn, .save-btn, .cancel-btn {
            padding: 6px 12px;
            font-size: 14px;
        }
        
        .edit-btn {
            background: #4CAF50;
            color: white;
        }
        
        .delete-btn, .cancel-btn {
            background: #f44336;
            color: white;
        }
        
        .save-btn {
            background: #2196F3;
            color: white;
        }
        
        .edit-btn:hover {
            background: #45a049;
        }
        
        .delete-btn:hover, .cancel-btn:hover {
            background: #da190b;
        }
        
        .save-btn:hover {
            background: #0b7dda;
        }
        
        .todo-item.editing .edit-btn,
        .todo-item.editing .delete-btn {
            display: none;
        }
        
        .save-btn, .cancel-btn {
            display: none;
        }
        
        .todo-item.editing .save-btn,
        .todo-item.editing .cancel-btn {
            display: inline-block;
        }
        
        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .item-count {
            color: #666;
            font-size: 14px;
        }
        
        #clearCompleted {
            background: #ff6b6b;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        #clearCompleted:hover {
            background: #ee5a52;
        }
        
        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;ğŸ“ My Todo List&lt;/h1&gt;
        
        &lt;!-- Input area --&gt;
        &lt;div class="input-container"&gt;
            &lt;input type="text" id="todoInput" placeholder="What needs to be done?"&gt;
            &lt;button id="addBtn"&gt;Add&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;!-- Filter buttons --&gt;
        &lt;div class="filters"&gt;
            &lt;button class="filter-btn active" data-filter="all"&gt;All&lt;/button&gt;
            &lt;button class="filter-btn" data-filter="active"&gt;Active&lt;/button&gt;
            &lt;button class="filter-btn" data-filter="completed"&gt;Completed&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;!-- Todo list --&gt;
        &lt;ul id="todoList"&gt;&lt;/ul&gt;
        
        &lt;!-- Footer --&gt;
        &lt;div class="footer"&gt;
            &lt;span class="item-count"&gt;&lt;span id="itemCount"&gt;0&lt;/span&gt; items left&lt;/span&gt;
            &lt;button id="clearCompleted"&gt;Clear Completed&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // ========================================
        // STATE - This is our "single source of truth"
        // ========================================
        let todos = [];
        let currentFilter = 'all';
        let nextId = 1;

        // ========================================
        // DOM ELEMENTS - Cache these for performance
        // ========================================
        const todoInput = document.getElementById('todoInput');
        const addBtn = document.getElementById('addBtn');
        const todoList = document.getElementById('todoList');
        const itemCount = document.getElementById('itemCount');
        const clearCompletedBtn = document.getElementById('clearCompleted');
        const filterBtns = document.querySelectorAll('.filter-btn');

        // ========================================
        // FUNCTIONS - Each does ONE thing
        // ========================================

        // Add a new todo
        function addTodo() {
            const text = todoInput.value.trim();
            
            // Validation
            if (text === '') {
                alert('Please enter a todo!');
                return;
            }
            
            // Create todo object
            const todo = {
                id: nextId++,
                text: text,
                completed: false
            };
            
            // Add to state
            todos.push(todo);
            
            // Clear input
            todoInput.value = '';
            
            // Re-render
            render();
        }

        // Toggle todo completion
        function toggleTodo(id) {
            // Find the todo
            const todo = todos.find(t =&gt; t.id === id);
            
            // Toggle its completed status
            if (todo) {
                todo.completed = !todo.completed;
            }
            
            // Re-render
            render();
        }

        // Delete a todo
        function deleteTodo(id) {
            // Filter out the todo with this id
            todos = todos.filter(t =&gt; t.id !== id);
            
            // Re-render
            render();
        }

        // Start editing a todo
        function startEdit(id) {
            // Find the list item
            const listItem = document.querySelector(`[data-id="${id}"]`);
            
            // Add editing class
            listItem.classList.add('editing');
            
            // Focus the input
            const editInput = listItem.querySelector('.edit-input');
            editInput.focus();
            editInput.select();
        }

        // Save edited todo
        function saveEdit(id) {
            // Find the list item and input
            const listItem = document.querySelector(`[data-id="${id}"]`);
            const editInput = listItem.querySelector('.edit-input');
            const newText = editInput.value.trim();
            
            // Validation
            if (newText === '') {
                alert('Todo cannot be empty!');
                return;
            }
            
            // Find and update the todo
            const todo = todos.find(t =&gt; t.id === id);
            if (todo) {
                todo.text = newText;
            }
            
            // Re-render
            render();
        }

        // Cancel editing
        function cancelEdit(id) {
            // Find the list item
            const listItem = document.querySelector(`[data-id="${id}"]`);
            
            // Remove editing class
            listItem.classList.remove('editing');
        }

        // Clear all completed todos
        function clearCompleted() {
            todos = todos.filter(t =&gt; !t.completed);
            render();
        }

        // Change filter
        function setFilter(filter) {
            currentFilter = filter;
            
            // Update active button
            filterBtns.forEach(btn =&gt; {
                btn.classList.remove('active');
                if (btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
            
            // Re-render
            render();
        }

        // Get filtered todos
        function getFilteredTodos() {
            if (currentFilter === 'active') {
                return todos.filter(t =&gt; !t.completed);
            } else if (currentFilter === 'completed') {
                return todos.filter(t =&gt; t.completed);
            }
            return todos; // 'all'
        }

        // ========================================
        // RENDER - The most important function
        // ========================================
        function render() {
            // Get todos to display based on filter
            const filteredTodos = getFilteredTodos();
            
            // Clear the list
            todoList.innerHTML = '';
            
            // If no todos, show empty state
            if (filteredTodos.length === 0) {
                todoList.innerHTML = '&lt;div class="empty-state"&gt;No todos to show&lt;/div&gt;';
            } else {
                // Create a list item for each todo
                filteredTodos.forEach(todo =&gt; {
                    // Create elements
                    const li = document.createElement('li');
                    li.className = 'todo-item';
                    li.dataset.id = todo.id;
                    if (todo.completed) {
                        li.classList.add('completed');
                    }
                    
                    // Checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = todo.completed;
                    checkbox.addEventListener('change', () =&gt; toggleTodo(todo.id));
                    
                    // Text span
                    const textSpan = document.createElement('span');
                    textSpan.className = 'todo-text';
                    textSpan.textContent = todo.text;
                    
                    // Edit input (hidden by default)
                    const editInput = document.createElement('input');
                    editInput.type = 'text';
                    editInput.className = 'edit-input';
                    editInput.value = todo.text;
                    
                    // Actions container
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'todo-actions';
                    
                    // Edit button
                    const editBtn = document.createElement('button');
                    editBtn.className = 'edit-btn';
                    editBtn.textContent = 'Edit';
                    editBtn.addEventListener('click', () =&gt; startEdit(todo.id));
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.addEventListener('click', () =&gt; deleteTodo(todo.id));
                    
                    // Save button (shown during edit)
                    const saveBtn = document.createElement('button');
                    saveBtn.className = 'save-btn';
                    saveBtn.textContent = 'Save';
                    saveBtn.addEventListener('click', () =&gt; saveEdit(todo.id));
                    
                    // Cancel button (shown during edit)
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'cancel-btn';
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.addEventListener('click', () =&gt; cancelEdit(todo.id));
                    
                    // Assemble everything
                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);
                    actionsDiv.appendChild(saveBtn);
                    actionsDiv.appendChild(cancelBtn);
                    
                    li.appendChild(checkbox);
                    li.appendChild(textSpan);
                    li.appendChild(editInput);
                    li.appendChild(actionsDiv);
                    
                    todoList.appendChild(li);
                });
            }
            
            // Update count
            const activeCount = todos.filter(t =&gt; !t.completed).length;
            itemCount.textContent = activeCount;
        }

        // ========================================
        // EVENT LISTENERS - Wire up the UI
        // ========================================

        // Add button
        addBtn.addEventListener('click', addTodo);

        // Enter key in input
        todoInput.addEventListener('keypress', (e) =&gt; {
            if (e.key === 'Enter') {
                addTodo();
            }
        });

        // Filter buttons
        filterBtns.forEach(btn =&gt; {
            btn.addEventListener('click', () =&gt; {
                setFilter(btn.dataset.filter);
            });
        });

        // Clear completed button
        clearCompletedBtn.addEventListener('click', clearCompleted);

        // Initial render
        render();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="warning-box">
                <h4>ğŸ˜… That's A LOT of Code!</h4>
                <p>Yes! This is about 400 lines of code for a simple todo app. And we haven't even added features like:<br><br>
                â€¢ Saving to localStorage (so todos persist on refresh)<br>
                â€¢ Drag and drop reordering<br>
                â€¢ Due dates<br>
                â€¢ Categories/tags<br>
                â€¢ Search/filter by keyword<br><br>
                Each feature would add MANY more lines. This is the pain we're trying to solve!</p>
            </div>

            <h4>Walking Through the Code</h4>
            <p>Let's break down what's happening section by section:</p>

            <div class="info-box">
                <h4>1. The State (Lines 246-248)</h4>
                <p><span class="inline-code">let todos = [];</span> - This array holds ALL our todos. It's our "single source of truth."<br>
                <span class="inline-code">let currentFilter = 'all';</span> - Tracks which filter is active.<br>
                <span class="inline-code">let nextId = 1;</span> - Counter to give each todo a unique ID.<br><br>
                <strong>Key concept:</strong> All our data lives in these variables. When they change, we need to update the UI to match.</p>
            </div>

            <div class="info-box">
                <h4>2. Caching DOM Elements (Lines 253-258)</h4>
                <p>We grab references to all the HTML elements we'll need:<br>
                <span class="inline-code">const todoInput = document.getElementById('todoInput');</span><br><br>
                <strong>Why cache?</strong> Finding elements in the DOM is slow. By saving references, we avoid searching every time.</p>
            </div>

            <div class="info-box">
                <h4>3. The addTodo Function (Lines 265-284)</h4>
                <p>This function:<br>
                1. Gets the input value: <span class="inline-code">todoInput.value.trim()</span><br>
                2. Validates it's not empty<br>
                3. Creates a todo object: <span class="inline-code">{ id, text, completed }</span><br>
                4. Adds it to the <span class="inline-code">todos</span> array<br>
                5. Clears the input<br>
                6. Calls <span class="inline-code">render()</span> to update the UI<br><br>
                <strong>Notice:</strong> We update the data first, THEN call render to update the UI. This pattern repeats everywhere.</p>
            </div>

            <div class="info-box">
                <h4>4. The render Function (Lines 350-440) - THE MOST IMPORTANT!</h4>
                <p>This is where the magic (and pain) happens. Every time data changes, we call <span class="inline-code">render()</span> which:<br><br>
                1. <strong>Clears everything:</strong> <span class="inline-code">todoList.innerHTML = '';</span><br>
                2. <strong>Gets filtered todos:</strong> Based on current filter (all/active/completed)<br>
                3. <strong>Creates elements for each todo:</strong><br>
                   â€¢ <span class="inline-code">document.createElement('li')</span><br>
                   â€¢ <span class="inline-code">document.createElement('input')</span> for checkbox<br>
                   â€¢ <span class="inline-code">document.createElement('span')</span> for text<br>
                   â€¢ <span class="inline-code">document.createElement('button')</span> for edit/delete<br>
                4. <strong>Adds event listeners to each element</strong><br>
                5. <strong>Appends everything to the DOM</strong><br>
                6. <strong>Updates the count</strong><br><br>
                <strong>The problem:</strong> We're recreating and re-attaching EVERYTHING every single time, even if only one todo changed!</p>
            </div>

            <h4>The Pain Points (Where Bugs Live)</h4>
            <p>Now that you see the code, let's identify the problems:</p>

            <div class="warning-box">
                <h4>Problem #1: Manual DOM Manipulation Everywhere</h4>
                <p>Look at the <span class="inline-code">render()</span> function. We're manually:<br>
                â€¢ Creating every element<br>
                â€¢ Setting every property<br>
                â€¢ Adding every event listener<br>
                â€¢ Appending every child<br><br>
                <strong>What could go wrong?</strong><br>
                â€¢ Forget to add a class? The styling breaks.<br>
                â€¢ Forget to add an event listener? The button doesn't work.<br>
                â€¢ Typo in a class name? CSS doesn't apply.<br>
                â€¢ Wrong parent? Element appears in the wrong place.<br><br>
                There are DOZENS of places where one tiny mistake breaks everything.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #2: State Synchronization</h4>
                <p>We have to manually keep the UI in sync with our state. Look at this pattern:<br><br>
                1. User clicks a button<br>
                2. Event handler updates <span class="inline-code">todos</span> array<br>
                3. Event handler calls <span class="inline-code">render()</span><br>
                4. <span class="inline-code">render()</span> rebuilds the entire UI from <span class="inline-code">todos</span><br><br>
                <strong>What could go wrong?</strong><br>
                â€¢ Forget to call <span class="inline-code">render()</span>? UI doesn't update.<br>
                â€¢ Call <span class="inline-code">render()</span> too early? UI shows stale data.<br>
                â€¢ Update the UI directly without updating state? Now state and UI are out of sync!<br><br>
                This is called the "state synchronization problem" and it's a NIGHTMARE at scale.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #3: Performance</h4>
                <p>Our <span class="inline-code">render()</span> function is BRUTAL:<br><br>
                â€¢ <span class="inline-code">todoList.innerHTML = '';</span> - Destroys ALL elements<br>
                â€¢ Then we recreate ALL elements<br>
                â€¢ Then we add event listeners to ALL elements<br>
                â€¢ Then we append ALL elements<br><br>
                <strong>Even if we only changed ONE todo, we rebuild EVERYTHING!</strong><br><br>
                With 5 todos, this is fine. With 500 todos, your app will lag. With 5000 todos, it'll freeze.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #4: Event Listener Memory Leaks</h4>
                <p>Every time we call <span class="inline-code">render()</span>, we:<br>
                1. Delete all the old elements (with their event listeners)<br>
                2. Create new elements<br>
                3. Add new event listeners<br><br>
                The browser is smart enough to clean up most of this, but in complex apps, you can leak memory if you're not careful. Leaked event listeners pile up and slow down your app.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #5: Code Organization</h4>
                <p>Look at how spread out everything is:<br>
                â€¢ State is at the top<br>
                â€¢ DOM elements are cached in the middle<br>
                â€¢ Functions are scattered<br>
                â€¢ Event listeners are at the bottom<br>
                â€¢ The render logic is 90 lines long<br><br>
                To understand what happens when you click "Edit," you have to trace through:<br>
                1. Event listener (line 448)<br>
                2. <span class="inline-code">startEdit()</span> function (line 309)<br>
                3. DOM manipulation (line 313-317)<br>
                4. Then clicking "Save" goes through a different path...<br><br>
                It's manageable for a todo app. But imagine an app with 50 features!</p>
            </div>

            <div class="metaphor-box">
                <h4>The LEGO Analogy</h4>
                <p>Building with vanilla JavaScript is like:<br><br>
                <strong>Making each LEGO brick from scratch:</strong><br>
                â€¢ Get plastic<br>
                â€¢ Melt it<br>
                â€¢ Pour into mold<br>
                â€¢ Wait for it to cool<br>
                â€¢ Remove from mold<br>
                â€¢ Paint it<br>
                â€¢ Repeat for EVERY SINGLE BRICK<br><br>
                Then, every time you want to change your LEGO creation, you melt down ALL the bricks and recreate them from scratch!<br><br>
                Frameworks give you pre-made bricks that snap together easily. And when you want to change something, you just swap out the bricks you need - you don't rebuild everything!</p>
            </div>

            <h4>Try This Exercise</h4>
            <p>To really feel the pain, try adding these features to the vanilla JS todo app:</p>

            <div class="code">// Feature 1: Add due dates
// You'll need to:
// - Add a date input to the HTML
// - Update the todo object to include a date
// - Modify render() to display the date
// - Add sorting by date
// - Add visual indicator for overdue todos
// Pain level: ğŸ¤¯ High - You'll touch MANY functions

// Feature 2: Add categories/tags
// You'll need to:
// - Add category selection dropdown
// - Update todo object
// - Modify render() to show categories
// - Add filter by category
// - Update the filter buttons UI
// Pain level: ğŸ¤¯ğŸ¤¯ Very High - State management becomes complex

// Feature 3: Save to localStorage
// You'll need to:
// - Save todos array to localStorage on every change
// - Load todos from localStorage on page load
// - Handle JSON serialization
// - Add error handling for corrupted data
// Pain level: ğŸ¤¯ğŸ¤¯ğŸ¤¯ Extreme - Easy to create bugs</div>

            <p>Each feature multiplies the complexity. The codebase becomes harder to maintain, bugs become harder to find, and new developers struggle to understand how it all fits together.</p>

            <div class="info-box">
                <h4>ğŸ¯ Key Takeaway</h4>
                <p>This vanilla JavaScript approach works, and understanding it is CRUCIAL. But now you've felt the pain:<br><br>
                â€¢ Too much manual DOM manipulation<br>
                â€¢ State synchronization is error-prone<br>
                â€¢ Performance suffers<br>
                â€¢ Code organization is messy<br>
                â€¢ Scaling is hard<br><br>
                This is exactly why frameworks were invented. They solve these problems so you can focus on building features instead of wrestling with the DOM.</p>
            </div>

            <h3>Part 8: Why Frameworks Save Your Life</h3>

            <h4>Let's Recap the Problems</h4>
            <p>From our vanilla JavaScript todo app, we identified five major pain points:</p>

            <div class="code">// Problem 1: Manual DOM Manipulation
const li = document.createElement('li');
li.className = 'todo-item';
const span = document.createElement('span');
span.textContent = todo.text;
li.appendChild(span);
// ... 20 more lines for one todo item

// Problem 2: State Synchronization
todos.push(newTodo);  // Update state
render();             // Don't forget this or UI breaks!

// Problem 3: Performance
todoList.innerHTML = '';  // Delete EVERYTHING
todos.forEach(createTodoElement);  // Rebuild EVERYTHING

// Problem 4: Event Listeners
// Added every render, need to be cleaned up

// Problem 5: Code Organization
// State, functions, event listeners all scattered</div>

            <p>Now imagine you're building not a simple todo app, but Facebook, or Twitter, or Amazon. The complexity would be UNMANAGEABLE. You'd spend 90% of your time managing DOM updates and hunting bugs, and only 10% actually building features.</p>

            <div class="metaphor-box">
                <h4>Frameworks as Helpers</h4>
                <p>Think of a framework as hiring a really smart assistant:<br><br>
                <strong>Without a framework (vanilla JS):</strong><br>
                You: "Hey, I need to show this list of todos on the page."<br>
                You: *Spends 2 hours writing createElement, appendChild, event listeners, etc.*<br><br>
                <strong>With a framework:</strong><br>
                You: "Hey, here's a list of todos. Please display them."<br>
                Framework: "Done! And if the list changes, I'll automatically update the page for you."<br>
                You: "Thanks! Now I can focus on building features."<br><br>
                The framework handles all the tedious, error-prone DOM manipulation. You just describe what you want, and it makes it happen.</p>
            </div>

            <h4>What Frameworks Actually Do</h4>
            <p>Let's break down the specific problems frameworks solve:</p>

            <div class="info-box">
                <h4>1. Automatic State Management</h4>
                <p><strong>The problem:</strong> You have to manually call <span class="inline-code">render()</span> every time data changes.<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks track your data (called "state"). When state changes, they automatically update the UI. You don't call render yourself - it just happens!<br><br>
                <strong>In React:</strong><br>
                <span class="inline-code">const [count, setCount] = useState(0);</span><br>
                When you call <span class="inline-code">setCount(1)</span>, React automatically re-renders the component.<br><br>
                <strong>In Vue:</strong><br>
                <span class="inline-code">const count = ref(0);</span><br>
                When you change <span class="inline-code">count.value = 1</span>, Vue automatically updates the DOM.<br><br>
                No more forgetting to call render. No more state/UI sync bugs!</p>
            </div>

            <div class="info-box">
                <h4>2. Declarative Programming</h4>
                <p><strong>The problem:</strong> You have to tell the browser HOW to create every element (imperative).<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks let you declare WHAT you want, not HOW to create it (declarative).<br><br>
                <strong>Imperative (vanilla JS):</strong><br>
                "Create a div. Set its class to 'todo'. Create a span. Set its text to the todo text. Append the span to the div. Append the div to the list."<br><br>
                <strong>Declarative (framework):</strong><br>
                "Here's what a todo should look like. Show all of them."<br><br>
                The framework figures out the HOW. You just describe the WHAT.</p>
            </div>

            <div class="info-box">
                <h4>3. Component-Based Architecture</h4>
                <p><strong>The problem:</strong> Code is scattered everywhere and hard to organize.<br><br>
                <strong>How frameworks fix it:</strong><br>
                Everything is organized into <strong>components</strong> - self-contained pieces that include:<br>
                â€¢ The UI (HTML)<br>
                â€¢ The logic (JavaScript)<br>
                â€¢ The styling (CSS, optionally)<br><br>
                Instead of one giant 400-line file, you have:<br>
                â€¢ <span class="inline-code">TodoApp.js</span> - The main app<br>
                â€¢ <span class="inline-code">TodoInput.js</span> - Just the input area<br>
                â€¢ <span class="inline-code">TodoItem.js</span> - Just one todo item<br>
                â€¢ <span class="inline-code">TodoFilters.js</span> - Just the filter buttons<br><br>
                Each component is 20-50 lines, easy to understand, easy to test, easy to reuse!</p>
            </div>

            <div class="info-box">
                <h4>4. Efficient Updates (Virtual DOM)</h4>
                <p><strong>The problem:</strong> We delete and recreate everything on every change (slow!).<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks use a "virtual DOM" - a lightweight copy of the real DOM in memory.<br><br>
                <strong>The process:</strong><br>
                1. You change state<br>
                2. Framework creates a new virtual DOM with the changes<br>
                3. Framework compares (diffs) new virtual DOM vs old virtual DOM<br>
                4. Framework calculates the MINIMUM changes needed<br>
                5. Framework applies ONLY those changes to the real DOM<br><br>
                <strong>Result:</strong> If you change one todo, only that one element updates. Not the entire list!</p>
            </div>

            <div class="metaphor-box">
                <h4>The Virtual DOM Explained</h4>
                <p>Imagine you're editing a document:<br><br>
                <strong>Without Virtual DOM (vanilla JS):</strong><br>
                Every time you change one word, you delete the entire document and retype everything from scratch. Slow and wasteful!<br><br>
                <strong>With Virtual DOM:</strong><br>
                You type changes in a draft (virtual DOM). When you're done, a smart assistant compares your draft to the original, highlights exactly what changed (just one word), and updates only that word in the real document. Fast and efficient!<br><br>
                That's what React and Vue do. They work on a virtual copy, figure out the minimal changes, then update the real DOM efficiently.</p>
            </div>

            <h4>The Same Todo App, But With Framework Pseudocode</h4>
            <p>Let's see how our 400-line todo app would look with framework thinking. This isn't real React or Vue yet - just the concept:</p>

            <div class="code">// Pseudocode for framework approach
// (Not real code - just showing the concept!)

// STATE - Just declare your data
state = {
  todos: [],
  filter: 'all'
}

// COMPONENT - Describe what the UI should look like
function TodoApp() {
  // UI is a FUNCTION of state
  return (
    &lt;div&gt;
      &lt;h1&gt;My Todo List&lt;/h1&gt;
      
      &lt;TodoInput /&gt;
      &lt;TodoFilters /&gt;
      
      {state.todos
        .filter(matchesCurrentFilter)
        .map(todo =&gt; &lt;TodoItem todo={todo} /&gt;)
      }
      
      &lt;TodoFooter /&gt;
    &lt;/div&gt;
  )
}

// When state changes, framework automatically re-renders
function addTodo(text) {
  state.todos.push({ id: nextId++, text, completed: false })
  // That's it! Framework handles the rest
}

function toggleTodo(id) {
  const todo = state.todos.find(t =&gt; t.id === id)
  todo.completed = !todo.completed
  // Framework automatically updates just this one todo in the UI!
}</div>

            <div class="info-box">
                <h4>Compare the Approach</h4>
                <p><strong>Vanilla JS (400 lines):</strong><br>
                â€¢ Manual createElement for everything<br>
                â€¢ Manual event listener attachment<br>
                â€¢ Manual render() function that rebuilds everything<br>
                â€¢ Manual state synchronization<br>
                â€¢ State and UI code completely separated<br><br>
                <strong>Framework (~50 lines):</strong><br>
                â€¢ Declare components with JSX/templates<br>
                â€¢ State and UI logic together in one place<br>
                â€¢ Automatic rendering when state changes<br>
                â€¢ Automatic efficient updates<br>
                â€¢ Much easier to read and maintain!</p>
            </div>

            <h4>Components as LEGO Blocks</h4>
            <p>The component model is one of the most powerful concepts in modern web development. Let's understand it deeply:</p>

            <div class="metaphor-box">
                <h4>The LEGO Metaphor (Again!)</h4>
                <p>Remember when we compared vanilla JS to making each LEGO brick from scratch? Frameworks give you pre-made bricks!<br><br>
                <strong>Components are like LEGO blocks:</strong><br><br>
                â€¢ <strong>Self-contained:</strong> Each block knows its shape, color, and how it connects<br>
                â€¢ <strong>Reusable:</strong> Use the same block type many times<br>
                â€¢ <strong>Composable:</strong> Combine simple blocks to make complex structures<br>
                â€¢ <strong>Interchangeable:</strong> Swap out blocks without affecting others<br><br>
                Just like you can build a house, a car, or a spaceship from the same LEGO blocks, you can build any web app from components!</p>
            </div>

            <div class="code">// Component thinking example

// A Button component (reusable!)
function Button(props) {
  return &lt;button onClick={props.onClick}&gt;{props.text}&lt;/button&gt;
}

// Use it everywhere
&lt;Button text="Save" onClick={save} /&gt;
&lt;Button text="Delete" onClick={del} /&gt;
&lt;Button text="Cancel" onClick={cancel} /&gt;

// Each button looks the same but does different things
// Change the Button component once, all buttons update!

// TodoItem component (reusable!)
function TodoItem(props) {
  return (
    &lt;div className="todo"&gt;
      &lt;Checkbox checked={props.todo.completed} /&gt;
      &lt;Text&gt;{props.todo.text}&lt;/Text&gt;
      &lt;Button text="Edit" onClick={props.onEdit} /&gt;
      &lt;Button text="Delete" onClick={props.onDelete} /&gt;
    &lt;/div&gt;
  )
}

// Use it for every todo
{todos.map(todo =&gt; 
  &lt;TodoItem 
    todo={todo} 
    onEdit={() =&gt; editTodo(todo.id)}
    onDelete={() =&gt; deleteTodo(todo.id)}
  /&gt;
)}</div>

            <div class="info-box">
                <h4>Component Benefits</h4>
                <p><strong>1. Reusability:</strong> Write once, use everywhere<br>
                <strong>2. Maintainability:</strong> Fix a bug in one place, fixed everywhere<br>
                <strong>3. Testability:</strong> Test each component independently<br>
                <strong>4. Collaboration:</strong> Different devs work on different components<br>
                <strong>5. Mental model:</strong> Think in building blocks, not giant monolithic code<br><br>
                Components change how you think about building UIs!</p>
            </div>

            <h4>Declarative vs Imperative - The Fundamental Shift</h4>
            <p>This is THE key concept that makes frameworks so powerful:</p>

            <div class="info-box">
                <h4>Imperative Programming (Vanilla JS)</h4>
                <p>You tell the computer exactly HOW to do every step:<br><br>
                <span class="inline-code">const div = document.createElement('div');</span><br>
                <span class="inline-code">div.className = 'container';</span><br>
                <span class="inline-code">const p = document.createElement('p');</span><br>
                <span class="inline-code">p.textContent = 'Hello!';</span><br>
                <span class="inline-code">div.appendChild(p);</span><br>
                <span class="inline-code">document.body.appendChild(div);</span><br><br>
                It's like giving someone directions: "Walk 3 blocks, turn left, walk 2 more blocks, turn right..."</p>
            </div>

            <div class="info-box">
                <h4>Declarative Programming (Frameworks)</h4>
                <p>You declare WHAT you want, framework figures out HOW:<br><br>
                <span class="inline-code">&lt;div className="container"&gt;</span><br>
                <span class="inline-code">  &lt;p&gt;Hello!&lt;/p&gt;</span><br>
                <span class="inline-code">&lt;/div&gt;</span><br><br>
                It's like giving someone an address: "123 Main Street." They figure out how to get there!<br><br>
                <strong>The magic:</strong> When state changes, you don't tell the framework HOW to update. You just declare what the UI should look like NOW, and the framework figures out the updates!</p>
            </div>

            <div class="code">// Imperative: You control every step
if (user.loggedIn) {
  // Remove login button
  const loginBtn = document.getElementById('login');
  loginBtn.remove();
  
  // Add logout button
  const logoutBtn = document.createElement('button');
  logoutBtn.textContent = 'Logout';
  logoutBtn.addEventListener('click', logout);
  document.body.appendChild(logoutBtn);
  
  // Show user name
  const userName = document.createElement('span');
  userName.textContent = user.name;
  document.body.appendChild(userName);
} else {
  // Remove logout button and user name
  // Add login button
  // ...tons more code
}

// Declarative: Just describe the current state
function Header() {
  return (
    &lt;div&gt;
      {user.loggedIn ? (
        &lt;&gt;
          &lt;span&gt;{user.name}&lt;/span&gt;
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/&gt;
      ) : (
        &lt;button onClick={showLogin}&gt;Login&lt;/button&gt;
      )}
    &lt;/div&gt;
  )
}
// Framework handles all the adding/removing/updating!</div>

            <div class="metaphor-box">
                <h4>The Light Switch Metaphor</h4>
                <p><strong>Imperative (vanilla JS):</strong><br>
                "Go to the light switch. Extend your arm. Move your hand to the switch. Push the switch down. Retract your arm. Walk away."<br><br>
                <strong>Declarative (framework):</strong><br>
                "The light should be on." The framework handles all the steps.<br><br>
                You focus on WHAT (light on/off), not HOW (arm movement, switch mechanics)!</p>
            </div>

            <h4>Recap: Why Frameworks Matter</h4>

            <div class="info-box">
                <h4>Frameworks Give You:</h4>
                <p>âœ… <strong>Automatic state management</strong> - UI updates when data changes<br>
                âœ… <strong>Declarative syntax</strong> - Describe what, not how<br>
                âœ… <strong>Component architecture</strong> - Organized, reusable code<br>
                âœ… <strong>Efficient updates</strong> - Virtual DOM minimizes changes<br>
                âœ… <strong>Less boilerplate</strong> - Write less code<br>
                âœ… <strong>Fewer bugs</strong> - No manual DOM sync<br>
                âœ… <strong>Better performance</strong> - Optimized updates<br>
                âœ… <strong>Easier collaboration</strong> - Clear code structure<br>
                âœ… <strong>Massive ecosystem</strong> - Libraries, tools, community<br><br>
                Result: You spend time building features, not wrestling with DOM manipulation!</p>
            </div>

            <h3>Part 9: What You're About to Learn</h3>

            <h4>The Journey Ahead</h4>
            <p>Congratulations! You've made it through the hardest part - understanding WHY frameworks exist and WHAT problems they solve. You've seen the pain of vanilla JavaScript, and you understand the concepts that make frameworks powerful. Now it's time to learn HOW to actually use them!</p>

            <div class="metaphor-box">
                <h4>You've Built the Foundation!</h4>
                <p>Think of what we've covered so far as building a solid foundation for a house:<br><br>
                âœ… You understand what websites are (HTML, CSS, JavaScript)<br>
                âœ… You understand how client-server communication works<br>
                âœ… You understand frontend vs backend<br>
                âœ… You understand state and reactivity<br>
                âœ… You've built something real in vanilla JS<br>
                âœ… You understand why frameworks exist<br>
                âœ… You understand components and declarative programming<br><br>
                Now we're ready to build the house! And because you understand the foundation, learning React and Vue will be SO much easier.</p>
            </div>

            <h4>Roadmap for the Rest of Chapter 8</h4>
            <p>Here's exactly what you'll learn in the remaining sections:</p>

            <div class="info-box">
                <h4>Section 2: React Fundamentals</h4>
                <p><strong>What you'll build:</strong> Real React applications from scratch<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Setting up a React project (Create React App)<br>
                â€¢ JSX - React's HTML-in-JavaScript syntax<br>
                â€¢ Components - Building blocks of React<br>
                â€¢ Props - Passing data between components<br>
                â€¢ State - Managing data that changes<br>
                â€¢ Events - Handling user interactions<br>
                â€¢ Lists and keys - Rendering dynamic data<br>
                â€¢ Forms - Handling user input<br>
                â€¢ Lifecycle - What happens when components mount/update/unmount<br>
                â€¢ Hooks - useState, useEffect, and more<br><br>
                <strong>Projects:</strong><br>
                â€¢ Counter app (React basics)<br>
                â€¢ Todo list (the one we built, but in React!)<br>
                â€¢ Weather app (fetching real API data)<br>
                â€¢ User profile manager (forms and validation)</p>
            </div>

            <div class="info-box">
                <h4>Section 3: Vue Fundamentals</h4>
                <p><strong>What you'll build:</strong> Real Vue applications from scratch<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Setting up a Vue project (Vite + Vue)<br>
                â€¢ Templates - Vue's HTML-based syntax<br>
                â€¢ Components - Single File Components (.vue files)<br>
                â€¢ Props and emits - Parent-child communication<br>
                â€¢ Reactive data - ref() and reactive()<br>
                â€¢ Computed properties - Derived state<br>
                â€¢ Watchers - Responding to data changes<br>
                â€¢ Directives - v-if, v-for, v-model, etc.<br>
                â€¢ Events - @click and event modifiers<br>
                â€¢ Composition API - Modern Vue approach<br><br>
                <strong>Projects:</strong><br>
                â€¢ Counter app (Vue basics)<br>
                â€¢ Todo list (same app, different framework!)<br>
                â€¢ Shopping cart (reactivity and computed properties)<br>
                â€¢ Blog reader (components and data flow)</p>
            </div>

            <div class="info-box">
                <h4>Section 4: Connecting Frontend to Backend</h4>
                <p><strong>What you'll build:</strong> Full-stack applications!<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ What is an API? (REST, JSON, HTTP methods)<br>
                â€¢ Using fetch() to get data from servers<br>
                â€¢ Sending data to servers (POST, PUT, DELETE)<br>
                â€¢ Handling loading states<br>
                â€¢ Error handling<br>
                â€¢ Authentication (login/logout)<br>
                â€¢ JWT tokens<br>
                â€¢ Protected routes<br>
                â€¢ CORS - What it is and how to fix it<br><br>
                <strong>Projects:</strong><br>
                â€¢ Weather dashboard (fetch data from weather API)<br>
                â€¢ User authentication system (register, login, protected pages)<br>
                â€¢ Blog with comments (CRUD operations)<br>
                â€¢ Real-time chat (WebSockets intro)</p>
            </div>

            <div class="info-box">
                <h4>Section 5: Advanced Patterns & State Management</h4>
                <p><strong>What you'll build:</strong> Complex, production-ready apps<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Context API (React) / Provide/Inject (Vue)<br>
                â€¢ Redux (React) / Pinia (Vue)<br>
                â€¢ Global state management<br>
                â€¢ Routing (React Router / Vue Router)<br>
                â€¢ Code splitting and lazy loading<br>
                â€¢ Performance optimization<br>
                â€¢ Testing basics<br>
                â€¢ Deployment (Vercel, Netlify)<br><br>
                <strong>Projects:</strong><br>
                â€¢ E-commerce site (cart, checkout, routing)<br>
                â€¢ Social media feed (infinite scroll, optimization)<br>
                â€¢ Dashboard app (complex state, charts)<br>
                â€¢ Your final project (you choose!)</p>
            </div>

            <h4>How to Approach Learning</h4>
            <p>Before we dive in, let's set you up for success with a solid learning strategy:</p>

            <div class="warning-box">
                <h4>ğŸ¯ Learning Strategy for Maximum Success</h4>
                <p><strong>1. Type EVERY code example yourself</strong><br>
                Don't copy-paste. Type it out. Your fingers need to learn the patterns. When you make typos, you learn. When you fix errors, you learn even more!<br><br>
                <strong>2. Experiment and break things</strong><br>
                After typing an example, change things:<br>
                â€¢ Change variable names<br>
                â€¢ Add features<br>
                â€¢ Remove code and see what breaks<br>
                This is how you TRULY learn what each piece does!<br><br>
                <strong>3. Build the same project in BOTH React and Vue</strong><br>
                This chapter teaches both frameworks because seeing the SAME app built two ways solidifies the concepts. You'll realize the frameworks are more similar than different!<br><br>
                <strong>4. Focus on concepts, not memorization</strong><br>
                You don't need to memorize syntax. You need to understand:<br>
                â€¢ What is a component?<br>
                â€¢ How does state work?<br>
                â€¢ How do props flow?<br>
                â€¢ How do events work?<br>
                The syntax is easy to look up!<br><br>
                <strong>5. Use the browser console</strong><br>
                Add console.log() EVERYWHERE at first. See what's in your props. See when your component renders. See what events fire. This is debugging and learning simultaneously!<br><br>
                <strong>6. Read error messages carefully</strong><br>
                React and Vue have EXCELLENT error messages. They tell you exactly what's wrong and often how to fix it. Don't panic - read the error!<br><br>
                <strong>7. Build tiny projects constantly</strong><br>
                After each section, build something small:<br>
                â€¢ Finished learning state? Build a color picker<br>
                â€¢ Finished learning lists? Build a shopping list<br>
                â€¢ Finished learning forms? Build a survey<br>
                Tiny projects = huge learning!<br><br>
                <strong>8. Don't rush to "advanced" topics</strong><br>
                Master the basics FIRST. You don't need Redux, TypeScript, Next.js, or any "advanced" stuff yet. Get comfortable with basic React/Vue first. Seriously!<br><br>
                <strong>9. Expect to feel confused</strong><br>
                You will feel lost sometimes. THIS IS NORMAL. Your brain is creating new neural pathways. Confusion means you're learning! Keep going. It WILL click!<br><br>
                <strong>10. Teach someone else</strong><br>
                After each section, explain what you learned to someone (or even your rubber duck). If you can teach it, you know it!</p>
            </div>

            <div class="metaphor-box">
                <h4>Learning to Code is Like Learning a Language</h4>
                <p>When you learned to speak as a child, you didn't:<br>
                â€¢ Memorize grammar rules first<br>
                â€¢ Read textbooks about sentence structure<br>
                â€¢ Study vocabulary lists<br><br>
                You:<br>
                â€¢ Heard words repeatedly<br>
                â€¢ Tried to say them (made mistakes!)<br>
                â€¢ Got corrections<br>
                â€¢ Practiced constantly<br>
                â€¢ Gradually understood patterns<br><br>
                Learning React/Vue is the SAME! Type code, make mistakes, get errors, fix them, see patterns emerge. This is the natural way to learn!</p>
            </div>

            <h4>React vs Vue - Which Should You Learn?</h4>
            <p>You might be wondering: "Should I learn React or Vue?" Great question!</p>

            <div class="info-box">
                <h4>The Answer: Learn BOTH (kind of)</h4>
                <p><strong>Here's what I recommend:</strong><br><br>
                1. <strong>Go through Section 2 (React) completely</strong><br>
                   Build all the projects, understand all the concepts<br><br>
                2. <strong>Then go through Section 3 (Vue)</strong><br>
                   You'll be AMAZED how fast you learn it because you already know the concepts from React!<br><br>
                3. <strong>Then pick ONE to specialize in</strong><br>
                   Based on job market in your area, personal preference, or project needs<br><br>
                <strong>Why learn both?</strong><br>
                â€¢ Understanding both makes you DEEPLY understand the concepts<br>
                â€¢ You'll see multiple approaches to the same problems<br>
                â€¢ You'll be hireable for more jobs<br>
                â€¢ Switching between them becomes easy<br>
                â€¢ You'll understand the "why" not just the "how"<br><br>
                <strong>But I only have time for one!</strong><br>
                If you truly can only learn one:<br>
                â€¢ <strong>Learn React</strong> if you want maximum job opportunities (React is more popular)<br>
                â€¢ <strong>Learn Vue</strong> if you want gentler learning curve and cleaner syntax<br><br>
                Honestly though? Both are excellent. You can't go wrong!</p>
            </div>

            <div class="info-box">
                <h4>Quick Comparison</h4>
                <p><strong>React:</strong><br>
                âœ… More job opportunities<br>
                âœ… Larger ecosystem<br>
                âœ… Backed by Meta (Facebook)<br>
                âœ… JSX (HTML in JavaScript)<br>
                âœ… More flexible (also more overwhelming)<br>
                âŒ Steeper learning curve<br>
                âŒ More decisions to make<br><br>
                <strong>Vue:</strong><br>
                âœ… Easier to learn<br>
                âœ… Cleaner syntax<br>
                âœ… Great documentation<br>
                âœ… Templates (HTML-based)<br>
                âœ… More opinionated (guides you)<br>
                âŒ Fewer jobs than React<br>
                âŒ Smaller ecosystem<br><br>
                <strong>Truth:</strong> Both are fantastic. Both can build anything. The differences matter less than you think!</p>
            </div>

            <h4>What Success Looks Like</h4>
            <p>By the end of this chapter, you will be able to:</p>

            <div class="code">// Build a full-stack todo app from scratch
// Frontend:
- [ ] Create a React/Vue app
- [ ] Build multiple components
- [ ] Manage state (add, edit, delete todos)
- [ ] Handle forms and validation
- [ ] Make it look beautiful with CSS
- [ ] Deploy it online

// Backend:
- [ ] Create a simple REST API
- [ ] Connect to a database
- [ ] Handle authentication
- [ ] Secure routes

// Full-Stack:
- [ ] Connect frontend to backend
- [ ] Fetch data from API
- [ ] Send data to API
- [ ] Handle errors gracefully
- [ ] Add loading states
- [ ] Make it production-ready</div>

            <div class="warning-box">
                <h4>ğŸš€ You CAN Do This!</h4>
                <p>I know this seems like a LOT. It is! But remember:<br><br>
                <strong>You're not learning everything at once.</strong> We're taking it step by step, concept by concept, project by project.<br><br>
                <strong>Thousands of people have done this before you.</strong> Many started knowing LESS than you do now. If they can do it, you absolutely can too!<br><br>
                <strong>It's normal to struggle.</strong> Every professional developer struggled when they were learning. The difference between them and people who gave up? They kept going!<br><br>
                <strong>You'll surprise yourself.</strong> In a few weeks, you'll look back at this section and think "wow, I can't believe I thought that was hard!" You're about to level up MASSIVELY!<br><br>
                <strong>We're in this together.</strong> This book is designed to guide you every step of the way. You're not alone!<br><br>
                Ready? Take a deep breath. Get a coffee or tea. Let's build something amazing! ğŸ‰</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Metaphor: You're Learning to Fly</h4>
                <p>Right now, you're in ground school. You understand how planes work (HTML, CSS, JS), why we need autopilot (frameworks), and what all the instruments do (components, state, props).<br><br>
                In Section 2, you'll take your first flight with an instructor (React).<br><br>
                In Section 3, you'll fly a different plane (Vue) and realize flying is flying, regardless of the aircraft.<br><br>
                In Section 4, you'll learn to navigate (connect to backends).<br><br>
                By the end, you'll be a licensed pilot, capable of flying solo! âœˆï¸<br><br>
                The sky is the limit. Let's go!</p>
            </div>
        </section>

        <section id="first-react-app" class="section">
            <h2 class="section-title">Building Your First React App</h2>
            <p class="section-intro">Now that you understand what React is, let's actually BUILD something! In this section, we'll create real, working React applications from scratch. No build tools, no complexityâ€”just you, React, and a web browser. By the end, you'll have built a counter app and a todo list app, and you'll understand exactly how React works.</p>

            <div class="metaphor-box">
                <h4>Learning by Building</h4>
                <p>Think of this like learning to ride a bike. Reading about balance and pedaling is useful, but you only REALLY learn when you actually get on the bike and try it yourself. That's what we're doing hereâ€”we're getting on the React bike and riding!</p>
            </div>

            <h3>Setting Up React (The Easy Way)</h3>

            <p>There are two ways to use React: the complex way (with build tools, npm, webpack, etc.) and the simple way (just including React from a CDN). We're starting with the simple way so you can focus on learning React, not fighting with configuration files.</p>

            <div class="info-box">
                <h4>What's a CDN?</h4>
                <p><strong>CDN stands for Content Delivery Network.</strong> It's basically a way to include libraries from the internet directly in your HTML file. Think of it like checking out a book from a library instead of buying itâ€”you get to use React without downloading or installing anything!</p>
            </div>

            <h4>Your First React HTML File</h4>

            <p>Create a new file called <span class="inline-code">react-app.html</span> and add this code:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;My First React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- This is where React will put our app --&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;!-- Include React from CDN --&gt;
    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    
    &lt;!-- Include Babel to transform JSX --&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;!-- Our React code goes here --&gt;
    &lt;script type="text/babel"&gt;
        // React code coming soon!
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="warning-box">
                <h4>About Those Script Tags</h4>
                <p><strong>Three script tags, three jobs:</strong><br><br>
                1. <span class="inline-code">react.development.js</span> - The React library itself<br>
                2. <span class="inline-code">react-dom.development.js</span> - Connects React to the browser's DOM<br>
                3. <span class="inline-code">babel.min.js</span> - Transforms JSX (that HTML-like syntax) into regular JavaScript<br><br>
                The <span class="inline-code">type="text/babel"</span> tells Babel to process this script.</p>
            </div>

            <h3>Creating Your First Component</h3>

            <p>Let's create the simplest possible React componentâ€”a "Hello World" message.</p>

            <div class="code">&lt;script type="text/babel"&gt;
    // This is a React component - just a function that returns JSX
    function HelloWorld() {
        return &lt;h1&gt;Hello, World! I'm using React!&lt;/h1&gt;;
    }

    // Get the root div
    const root = ReactDOM.createRoot(document.getElementById('root'));
    
    // Render our component
    root.render(&lt;HelloWorld /&gt;);
&lt;/script&gt;</div>

            <p>Save your file and open it in a browser. You should see "Hello, World! I'm using React!" on the screen. Congratulationsâ€”you just created your first React component!</p>

            <div class="metaphor-box">
                <h4>What Just Happened?</h4>
                <p>Think of React components like LEGO blocks. The <span class="inline-code">HelloWorld</span> function is a block you created. The <span class="inline-code">root.render()</span> command takes your block and puts it on the page. The <span class="inline-code">&lt;HelloWorld /&gt;</span> syntax is how you "use" your block.</p>
            </div>

            <h3>Understanding JSX</h3>

            <p>JSX is that HTML-looking code inside your JavaScript. It's not actually HTMLâ€”it's a special syntax that React uses to describe what the UI should look like.</p>

            <div class="code">// JSX looks like HTML
const element = &lt;h1&gt;Hello!&lt;/h1&gt;;

// But it's actually JavaScript! Babel transforms it to:
const element = React.createElement('h1', null, 'Hello!');

// You can use JavaScript expressions in JSX with curly braces {}
const name = "Alice";
const greeting = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;

// You can do math
const math = &lt;p&gt;2 + 2 = {2 + 2}&lt;/p&gt;;

// You can call functions
function getGreeting() {
    return "Good morning";
}
const message = &lt;p&gt;{getGreeting()}&lt;/p&gt;;</div>

            <div class="info-box">
                <h4>JSX Rules</h4>
                <p>â€¢ Must have ONE parent element (wrap multiple elements in a <span class="inline-code">&lt;div&gt;</span> or <span class="inline-code">&lt;&gt;...&lt;/&gt;</span>)<br>
                â€¢ Use <span class="inline-code">className</span> instead of <span class="inline-code">class</span> (class is a JavaScript keyword)<br>
                â€¢ Close all tags, even self-closing ones: <span class="inline-code">&lt;img /&gt;</span>, <span class="inline-code">&lt;br /&gt;</span><br>
                â€¢ Use camelCase for attributes: <span class="inline-code">onClick</span>, not <span class="inline-code">onclick</span></p>
            </div>

            <h3>Props: Passing Data to Components</h3>

            <p>Props (short for "properties") are how you pass data from one component to another. Think of props like function arguments.</p>

            <div class="code">// Component that accepts props
function Greeting(props) {
    return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// Using the component with different props
root.render(
    &lt;div&gt;
        &lt;Greeting name="Alice" /&gt;
        &lt;Greeting name="Bob" /&gt;
        &lt;Greeting name="Charlie" /&gt;
    &lt;/div&gt;
);

// More complex props
function UserCard(props) {
    return (
        &lt;div style={{border: '1px solid black', padding: '10px', margin: '10px'}}&gt;
            &lt;h2&gt;{props.name}&lt;/h2&gt;
            &lt;p&gt;Age: {props.age}&lt;/p&gt;
            &lt;p&gt;Email: {props.email}&lt;/p&gt;
        &lt;/div&gt;
    );
}

root.render(
    &lt;UserCard 
        name="Alice" 
        age={25} 
        email="alice@example.com" 
    /&gt;
);</div>

            <div class="metaphor-box">
                <h4>Props Are Like Recipe Ingredients</h4>
                <p>Imagine a component is a recipe for making a sandwich. Props are the ingredients you pass in. The same "sandwich recipe" can make different sandwiches depending on what ingredients (props) you give itâ€”turkey sandwich, veggie sandwich, etc.</p>
            </div>

            <h3>State: Data That Changes</h3>

            <p>State is data that can change over time. When state changes, React automatically re-renders the component to show the new data. This is where React gets really powerful!</p>

            <div class="code">function Counter() {
    // useState creates a piece of state
    // count is the current value
    // setCount is the function to update it
    const [count, setCount] = React.useState(0);

    return (
        &lt;div&gt;
            &lt;h2&gt;Counter: {count}&lt;/h2&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
                Click to Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</div>

            <p>Let me break down what's happening:</p>

            <ul>
                <li><span class="inline-code">React.useState(0)</span> - Creates state with initial value of 0</li>
                <li><span class="inline-code">count</span> - The current value (starts at 0)</li>
                <li><span class="inline-code">setCount</span> - Function to update the count</li>
                <li><span class="inline-code">onClick</span> - Run code when button is clicked</li>
                <li>When <span class="inline-code">setCount</span> is called, React re-renders the component with the new count</li>
            </ul>

            <h3>Event Handling</h3>

            <p>React uses camelCase event names (<span class="inline-code">onClick</span>, not <span class="inline-code">onclick</span>) and you pass functions as event handlers.</p>

            <div class="code">function EventExamples() {
    const [text, setText] = React.useState('');
    const [clicks, setClicks] = React.useState(0);

    // Handle button click
    function handleClick() {
        alert('Button clicked!');
        setClicks(clicks + 1);
    }

    // Handle input change
    function handleChange(event) {
        setText(event.target.value);
    }

    // Handle form submit
    function handleSubmit(event) {
        event.preventDefault(); // Prevent page reload
        alert(`You typed: ${text}`);
    }

    return (
        &lt;div&gt;
            &lt;h2&gt;Event Handling Examples&lt;/h2&gt;
            
            &lt;button onClick={handleClick}&gt;
                Click me! (Clicks: {clicks})
            &lt;/button&gt;

            &lt;form onSubmit={handleSubmit}&gt;
                &lt;input 
                    type="text" 
                    value={text} 
                    onChange={handleChange}
                    placeholder="Type something..."
                /&gt;
                &lt;button type="submit"&gt;Submit&lt;/button&gt;
            &lt;/form&gt;

            &lt;p&gt;You typed: {text}&lt;/p&gt;
        &lt;/div&gt;
    );
}</div>

            <h3>Complete Counter App</h3>

            <p>Let's build a complete counter app with increment, decrement, and reset buttons:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;React Counter App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f0f0f0;
        }
        .counter-app {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }
        .count-display {
            font-size: 72px;
            font-weight: bold;
            margin: 20px 0;
            color: #333;
        }
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover {
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
        }
        .btn-increment {
            background: #4CAF50;
            color: white;
        }
        .btn-decrement {
            background: #f44336;
            color: white;
        }
        .btn-reset {
            background: #2196F3;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;script type="text/babel"&gt;
        function CounterApp() {
            const [count, setCount] = React.useState(0);

            function increment() {
                setCount(count + 1);
            }

            function decrement() {
                setCount(count - 1);
            }

            function reset() {
                setCount(0);
            }

            return (
                &lt;div className="counter-app"&gt;
                    &lt;h1&gt;React Counter&lt;/h1&gt;
                    &lt;div className="count-display"&gt;{count}&lt;/div&gt;
                    &lt;div className="buttons"&gt;
                        &lt;button className="btn-decrement" onClick={decrement}&gt;
                            - Decrement
                        &lt;/button&gt;
                        &lt;button className="btn-reset" onClick={reset}&gt;
                            Reset
                        &lt;/button&gt;
                        &lt;button className="btn-increment" onClick={increment}&gt;
                            + Increment
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(&lt;CounterApp /&gt;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Complete Todo List App</h3>

            <p>Now let's build something more complexâ€”a todo list where you can add, complete, and delete tasks. This is a COMPLETE, working app you can copy and use!</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;React Todo App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .todo-app {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .add-todo {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .add-todo input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .add-todo button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            transition: background 0.3s;
        }
        .todo-item:hover {
            background: #f0f0f0;
        }
        .todo-item.completed {
            opacity: 0.6;
        }
        .todo-item.completed .todo-text {
            text-decoration: line-through;
        }
        .todo-checkbox {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .todo-text {
            flex: 1;
            font-size: 16px;
        }
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-stats {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;script type="text/babel"&gt;
        function TodoApp() {
            const [todos, setTodos] = React.useState([]);
            const [inputText, setInputText] = React.useState('');

            // Add a new todo
            function addTodo() {
                if (inputText.trim() === '') return; // Don't add empty todos

                const newTodo = {
                    id: Date.now(), // Simple unique ID
                    text: inputText,
                    completed: false
                };

                setTodos([...todos, newTodo]);
                setInputText(''); // Clear input
            }

            // Toggle todo completion
            function toggleTodo(id) {
                setTodos(todos.map(todo => 
                    todo.id === id 
                        ? { ...todo, completed: !todo.completed }
                        : todo
                ));
            }

            // Delete a todo
            function deleteTodo(id) {
                setTodos(todos.filter(todo => todo.id !== id));
            }

            // Handle Enter key in input
            function handleKeyPress(event) {
                if (event.key === 'Enter') {
                    addTodo();
                }
            }

            // Calculate stats
            const totalTodos = todos.length;
            const completedTodos = todos.filter(todo => todo.completed).length;
            const remainingTodos = totalTodos - completedTodos;

            return (
                &lt;div className="todo-app"&gt;
                    &lt;h1&gt;ğŸ“ My Todo List&lt;/h1&gt;
                    
                    &lt;div className="add-todo"&gt;
                        &lt;input
                            type="text"
                            value={inputText}
                            onChange={(e) =&gt; setInputText(e.target.value)}
                            onKeyPress={handleKeyPress}
                            placeholder="What do you need to do?"
                        /&gt;
                        &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
                    &lt;/div&gt;

                    &lt;div className="todo-list"&gt;
                        {todos.map(todo =&gt; (
                            &lt;div 
                                key={todo.id} 
                                className={`todo-item ${todo.completed ? 'completed' : ''}`}
                            &gt;
                                &lt;input
                                    type="checkbox"
                                    className="todo-checkbox"
                                    checked={todo.completed}
                                    onChange={() =&gt; toggleTodo(todo.id)}
                                /&gt;
                                &lt;div className="todo-text"&gt;{todo.text}&lt;/div&gt;
                                &lt;button 
                                    className="delete-btn"
                                    onClick={() =&gt; deleteTodo(todo.id)}
                                &gt;
                                    Delete
                                &lt;/button&gt;
                            &lt;/div&gt;
                        ))}
                    &lt;/div&gt;

                    {todos.length &gt; 0 && (
                        &lt;div className="todo-stats"&gt;
                            {totalTodos} total â€¢ {completedTodos} completed â€¢ {remainingTodos} remaining
                        &lt;/div&gt;
                    )}

                    {todos.length === 0 && (
                        &lt;div className="todo-stats"&gt;
                            No todos yet. Add one above! ğŸ‘†
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(&lt;TodoApp /&gt;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Deep Dive: useState Hook</h3>
            
            <p>We've used <span class="inline-code">useState</span> in our apps, but let's really understand it. What IS a hook? Why does React need them?</p>

            <div class="metaphor-box">
                <h4>Hooks as Power Outlets</h4>
                <p>Imagine React features (state, effects, context) as electricity flowing through your app. <strong>Hooks are like power outlets</strong>â€”they let you "plug in" and access that electricity from your components.<br><br>
                Before hooks (old React), only class components could access state. Hooks let ANY component access React features!</p>
            </div>

            <h4>useState Patterns</h4>
            
            <p>Let's explore different ways to use useState with complete examples:</p>

            <div class="code">// Pattern 1: Simple boolean toggle
function ToggleExample() {
  const [isOn, setIsOn] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;p&gt;The light is {isOn ? 'ON' : 'OFF'}&lt;/p&gt;
      &lt;button onClick={() =&gt; setIsOn(!isOn)}&gt;
        Toggle
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Pattern 2: Number increment/decrement
function CounterExample() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Pattern 3: Text input
function InputExample() {
  const [text, setText] = useState('');
  
  return (
    &lt;div&gt;
      &lt;input 
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder="Type something..."
      /&gt;
      &lt;p&gt;You typed: {text}&lt;/p&gt;
      &lt;p&gt;Length: {text.length} characters&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Pattern 4: Object state
function UserExample() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: ''
  });
  
  const updateField = (field, value) =&gt; {
    setUser({
      ...user,  // Copy existing fields
      [field]: value  // Update specific field
    });
  };
  
  return (
    &lt;div&gt;
      &lt;input 
        value={user.name}
        onChange={(e) =&gt; updateField('name', e.target.value)}
        placeholder="Name"
      /&gt;
      &lt;input 
        value={user.email}
        onChange={(e) =&gt; updateField('email', e.target.value)}
        placeholder="Email"
      /&gt;
      &lt;input 
        value={user.age}
        onChange={(e) =&gt; updateField('age', e.target.value)}
        placeholder="Age"
      /&gt;
      &lt;p&gt;Name: {user.name}&lt;/p&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Age: {user.age}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Pattern 5: Array state
function ListExample() {
  const [items, setItems] = useState(['Apple', 'Banana']);
  const [newItem, setNewItem] = useState('');
  
  const addItem = () =&gt; {
    if (newItem.trim()) {
      setItems([...items, newItem]);
      setNewItem('');
    }
  };
  
  const removeItem = (index) =&gt; {
    setItems(items.filter((_, i) =&gt; i !== index));
  };
  
  return (
    &lt;div&gt;
      &lt;input 
        value={newItem}
        onChange={(e) =&gt; setNewItem(e.target.value)}
        placeholder="Add item"
      /&gt;
      &lt;button onClick={addItem}&gt;Add&lt;/button&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt;
            {item}
            &lt;button onClick={() =&gt; removeItem(index)}&gt;Remove&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Common useState Mistakes</h4>
                <p><strong>Mistake 1: Mutating state directly</strong><br>
                <span class="inline-code">âŒ user.name = 'Alice'; // WRONG - React won't detect this change</span><br>
                <span class="inline-code">âœ… setUser({...user, name: 'Alice'}); // RIGHT - create new object</span><br><br>
                
                <strong>Mistake 2: Using stale state</strong><br>
                <span class="inline-code">âŒ setCount(count + 1); setCount(count + 1); // Only adds 1!</span><br>
                <span class="inline-code">âœ… setCount(prev =&gt; prev + 1); setCount(prev =&gt; prev + 1); // Adds 2!</span><br><br>
                
                <strong>Mistake 3: Too many state variables</strong><br>
                Instead of 10 separate useState calls, group related data into objects.</p>
            </div>

            <h3>Deep Dive: useEffect Hook</h3>
            
            <p>The second most important hook! <span class="inline-code">useEffect</span> lets you perform "side effects" - things that reach outside your component like fetching data, setting up subscriptions, or manually changing the DOM.</p>

            <div class="metaphor-box">
                <h4>useEffect as a News Alert</h4>
                <p>Imagine you want to know when something changes:<br><br>
                <strong>Without useEffect:</strong> You have to constantly check: "Did it change? How about now? Now?"<br>
                <strong>With useEffect:</strong> You set up an alert: "Tell me when X changes, and I'll do Y."<br><br>
                useEffect says: "React, watch these values. When they change, run this function."</p>
            </div>

            <h4>useEffect Patterns</h4>

            <div class="code">// Pattern 1: Run once on mount (like componentDidMount)
function MountExample() {
  const [data, setData] = useState(null);
  
  useEffect(() =&gt; {
    console.log('Component mounted!');
    // Good for: initial data fetch, setup
    
    fetch('https://api.example.com/data')
      .then(res =&gt; res.json())
      .then(data =&gt; setData(data));
  }, []); // Empty array = run once
  
  return &lt;div&gt;{data ? data.message : 'Loading...'}&lt;/div&gt;;
}

// Pattern 2: Run when specific value changes
function WatchExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() =&gt; {
    document.title = `Count: ${count}`;
    console.log('Count changed to:', count);
  }, [count]); // Runs when count changes
  
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;
}

// Pattern 3: Cleanup (important!)
function TimerExample() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(prev =&gt; prev + 1);
    }, 1000);
    
    // Cleanup function - runs when component unmounts
    return () =&gt; {
      console.log('Cleaning up timer');
      clearInterval(interval);
    };
  }, []);
  
  return &lt;div&gt;Seconds: {seconds}&lt;/div&gt;;
}

// Pattern 4: Multiple useEffects (separate concerns)
function MultiEffectExample() {
  const [userId, setUserId] = useState(1);
  const [theme, setTheme] = useState('light');
  
  // Effect 1: Fetch user data
  useEffect(() =&gt; {
    fetch(`https://api.example.com/users/${userId}`)
      .then(res =&gt; res.json())
      .then(data =&gt; console.log('User:', data));
  }, [userId]);
  
  // Effect 2: Update body class
  useEffect(() =&gt; {
    document.body.className = theme;
  }, [theme]);
  
  return &lt;div&gt;User {userId} with {theme} theme&lt;/div&gt;;
}</div>

            <div class="info-box">
                <h4>useEffect Dependency Array Rules</h4>
                <p><strong>Empty array []:</strong> Run once on mount<br>
                <strong>No array:</strong> Run after EVERY render (usually too much!)<br>
                <strong>[var1, var2]:</strong> Run when var1 OR var2 changes<br><br>
                React will warn you if you forget to include dependencies. Listen to those warnings!</p>
            </div>

            <h3>Complete Example: Weather App with API</h3>
            
            <p>Let's build a real app that fetches data from an API and updates based on user input:</p>

            <div class="code">function WeatherApp() {
  const [city, setCity] = useState('London');
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [inputValue, setInputValue] = useState('');
  
  useEffect(() =&gt; {
    setLoading(true);
    setError(null);
    
    // Simulated API call (replace with real API)
    fetch(`https://api.weatherapi.com/v1/current.json?key=YOUR_KEY&q=${city}`)
      .then(response =&gt; {
        if (!response.ok) throw new Error('City not found');
        return response.json();
      })
      .then(data =&gt; {
        setWeather({
          temp: data.current.temp_c,
          condition: data.current.condition.text,
          icon: data.current.condition.icon
        });
        setLoading(false);
      })
      .catch(err =&gt; {
        setError(err.message);
        setLoading(false);
      });
  }, [city]);
  
  const handleSearch = (e) =&gt; {
    e.preventDefault();
    if (inputValue.trim()) {
      setCity(inputValue);
    }
  };
  
  return (
    &lt;div style={{ padding: '20px', fontFamily: 'Arial' }}&gt;
      &lt;h1&gt;Weather App&lt;/h1&gt;
      
      &lt;form onSubmit={handleSearch}&gt;
        &lt;input
          value={inputValue}
          onChange={(e) =&gt; setInputValue(e.target.value)}
          placeholder="Enter city name"
          style={{ padding: '10px', fontSize: '16px', marginRight: '10px' }}
        /&gt;
        &lt;button type="submit" style={{ padding: '10px 20px', fontSize: '16px' }}&gt;
          Search
        &lt;/button&gt;
      &lt;/form&gt;
      
      {loading && &lt;p&gt;Loading weather for {city}...&lt;/p&gt;}
      
      {error && &lt;p style={{ color: 'red' }}&gt;Error: {error}&lt;/p&gt;}
      
      {weather && !loading && !error && (
        &lt;div style={{ marginTop: '20px', padding: '20px', border: '1px solid #ddd', borderRadius: '8px' }}&gt;
          &lt;h2&gt;{city}&lt;/h2&gt;
          &lt;img src={weather.icon} alt={weather.condition} /&gt;
          &lt;p style={{ fontSize: '32px', margin: '10px 0' }}&gt;{weather.temp}Â°C&lt;/p&gt;
          &lt;p&gt;{weather.condition}&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>What This App Demonstrates</h4>
                <p>âœ… <strong>State management:</strong> Multiple pieces of state (city, weather, loading, error)<br>
                âœ… <strong>Side effects:</strong> Fetching data with useEffect<br>
                âœ… <strong>Conditional rendering:</strong> Loading states, error states, success states<br>
                âœ… <strong>Form handling:</strong> Controlled input and submission<br>
                âœ… <strong>Real-world pattern:</strong> This is how actual production apps handle API calls!</p>
            </div>

            <h3>React Router: Multi-Page Apps</h3>
            
            <p>So far, our apps have been single-page. But what if you want multiple pages like Home, About, Contact? Enter React Router!</p>

            <div class="code">// First, include React Router from CDN (add to HTML head)
// &lt;script src="https://unpkg.com/react-router-dom@6/dist/umd/react-router-dom.production.min.js"&gt;&lt;/script&gt;

const { BrowserRouter, Routes, Route, Link, useParams } = window.ReactRouterDOM;

function Home() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Home Page&lt;/h1&gt;
      &lt;p&gt;Welcome to my app!&lt;/p&gt;
    &lt;/div&gt;
  );
}

function About() {
  return (
    &lt;div&gt;
      &lt;h1&gt;About Page&lt;/h1&gt;
      &lt;p&gt;This app was built with React!&lt;/p&gt;
    &lt;/div&gt;
  );
}

function UserProfile() {
  const { userId } = useParams(); // Get URL parameter
  return (
    &lt;div&gt;
      &lt;h1&gt;User Profile&lt;/h1&gt;
      &lt;p&gt;Viewing user: {userId}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;nav&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt; | 
        &lt;Link to="/about"&gt;About&lt;/Link&gt; | 
        &lt;Link to="/user/123"&gt;User 123&lt;/Link&gt;
      &lt;/nav&gt;
      
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/user/:userId" element={&lt;UserProfile /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>You're Now a Legit React Developer!</h4>
                <p>Look at what you've mastered:<br><br>
                âœ… Components and JSX<br>
                âœ… Props and children<br>
                âœ… useState for state management<br>
                âœ… useEffect for side effects<br>
                âœ… Event handling<br>
                âœ… Conditional rendering<br>
                âœ… Lists and keys<br>
                âœ… Forms and controlled inputs<br>
                âœ… API calls and loading states<br>
                âœ… Routing and navigation<br><br>
                These are the CORE skills. Everything else in React builds on this foundation. You're ready to build real applications!</p>
            </div>

            <h3>Practice Exercises</h3>

            <div class="info-box">
                <h4>Try These Challenges</h4>
                <p><strong>Challenge 1: Color Picker</strong><br>
                Create a component with three buttons (Red, Green, Blue). When clicked, change the background color of a div.<br><br>
                
                <strong>Challenge 2: Simple Calculator</strong><br>
                Create a calculator with two number inputs and buttons for +, -, Ã—, Ã·. Display the result.<br><br>
                
                <strong>Challenge 3: Shopping Cart</strong><br>
                Create a simple shopping cart. Add items with names and prices. Show the total cost. Add "Remove" buttons.<br><br>
                
                <strong>Challenge 4: Text Character Counter</strong><br>
                Create a textarea that shows how many characters the user has typed (like Twitter's character counter).</p>
            </div>

            <div class="metaphor-box">
                <h4>You Just Built Real React Apps!</h4>
                <p>Think about what you just did: You built actual, working applications without any fancy build tools or setup. You understand components, props, state, and eventsâ€”the core concepts of React. Everything else in React is just building on these fundamentals. You're not a beginner anymoreâ€”you're a React developer!</p>
            </div>
        </section>

        <!-- SECTION 3: Building Your First Vue App -->
        <section id="first-vue-app" class="section">
            <h2 class="section-title">Building Your First Vue App</h2>
            <p class="section-intro">Vue is React's friendly cousinâ€”it does similar things but with a different approach. Many beginners actually find Vue easier to learn because it uses familiar HTML templates instead of JSX. Let's build the same counter and todo apps in Vue so you can see the differences and decide which you prefer!</p>

            <div class="metaphor-box">
                <h4>React vs Vue: Two Paths, Same Destination</h4>
                <p>Think of React and Vue like automatic vs manual transmission cars. Both get you where you need to go. React (manual) gives you more control but has a steeper learning curve. Vue (automatic) is easier to pick up and handles more stuff automatically. Neither is "better"â€”it depends on what you prefer!</p>
            </div>

            <h3>Setting Up Vue (CDN Method)</h3>

            <p>Just like React, we can use Vue from a CDN. Vue setup is actually simplerâ€”we only need ONE script tag!</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;My First Vue App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Vue app goes here --&gt;
    &lt;div id="app"&gt;&lt;/div&gt;

    &lt;!-- Include Vue from CDN --&gt;
    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        // Vue code coming soon!
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="info-box">
                <h4>Vue vs React Setup</h4>
                <p><strong>React needs:</strong> 3 script tags (React, ReactDOM, Babel)<br>
                <strong>Vue needs:</strong> Just 1 script tag!<br><br>
                Why? Vue doesn't need JSX transformationâ€”it uses regular HTML templates that the browser already understands.</p>
            </div>

            <h3>Creating Your First Vue Component</h3>
            
            <p>Let's create the simplest possible Vue appâ€”a "Hello World" message.</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My First Vue App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;!-- Vue template goes here --&gt;
        &lt;h1&gt;{{ message }}&lt;/h1&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    message: 'Hello, World! I\'m using Vue!'
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <p>Open this in a browser and you'll see "Hello, World! I'm using Vue!" That's your first Vue app!</p>

            <div class="metaphor-box">
                <h4>What's Different from React?</h4>
                <p>Notice how the template is just regular HTML? The <span class="inline-code">{{ message }}</span> syntax is how Vue puts JavaScript data into your HTML. It's simpler than JSXâ€”no need to learn new syntax rules, it's just HTML with little placeholders for your data!</p>
            </div>

            <h3>Understanding Vue's Template Syntax</h3>

            <p>Vue uses double curly braces <span class="inline-code">{{ }}</span> to insert data into your HTML. This is called "text interpolation."</p>

            <div class="code">&lt;div id="app"&gt;
    &lt;!-- Display a variable --&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    
    &lt;!-- Do math --&gt;
    &lt;p&gt;2 + 2 = {{ 2 + 2 }}&lt;/p&gt;
    
    &lt;!-- Use ternary operator --&gt;
    &lt;p&gt;{{ isLoggedIn ? 'Welcome!' : 'Please log in' }}&lt;/p&gt;
    
    &lt;!-- Call methods --&gt;
    &lt;p&gt;{{ getMessage() }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
    data() {
        return {
            message: 'Hello Vue!',
            isLoggedIn: true
        }
    },
    methods: {
        getMessage() {
            return this.message.toUpperCase();
        }
    }
}).mount('#app');
&lt;/script&gt;</div>

            <h4>Vue Directives</h4>

            <p>Directives are special attributes that start with <span class="inline-code">v-</span>. They add special behavior to your HTML.</p>

            <div class="code">&lt;div id="app"&gt;
    &lt;!-- v-if: Show/hide based on condition --&gt;
    &lt;p v-if="isVisible"&gt;You can see me!&lt;/p&gt;
    
    &lt;!-- v-else: Show when v-if is false --&gt;
    &lt;p v-if="isLoggedIn"&gt;Welcome back!&lt;/p&gt;
    &lt;p v-else&gt;Please log in&lt;/p&gt;
    
    &lt;!-- v-show: Toggle CSS display (element stays in DOM) --&gt;
    &lt;p v-show="showMessage"&gt;Toggle me!&lt;/p&gt;
    
    &lt;!-- v-for: Loop through arrays --&gt;
    &lt;ul&gt;
        &lt;li v-for="item in items" :key="item"&gt;{{ item }}&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;!-- v-on: Listen to events (shorthand: @) --&gt;
    &lt;button v-on:click="handleClick"&gt;Click Me&lt;/button&gt;
    &lt;button @click="count++"&gt;Increment: {{ count }}&lt;/button&gt;
    
    &lt;!-- v-bind: Bind attributes (shorthand: :) --&gt;
    &lt;img v-bind:src="imageSrc"&gt;
    &lt;img :src="imageSrc"&gt;
    
    &lt;!-- v-model: Two-way data binding --&gt;
    &lt;input v-model="textInput"&gt;
    &lt;p&gt;You typed: {{ textInput }}&lt;/p&gt;
&lt;/div&gt;</div>

            <div class="info-box">
                <h4>Quick Reference: Vue Directives</h4>
                <p><strong>v-if / v-else:</strong> Conditional rendering (removes from DOM)<br>
                <strong>v-show:</strong> Toggle visibility (hides with CSS)<br>
                <strong>v-for:</strong> Loop through arrays/objects<br>
                <strong>v-on (or @):</strong> Listen to events<br>
                <strong>v-bind (or :):</strong> Bind attributes<br>
                <strong>v-model:</strong> Two-way data binding for forms</p>
            </div>

            <h3>Complete Vue Counter App</h3>

            <p>Let's build the same counter we made in React, but with Vue:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue Counter App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f0f0f0;
        }
        .counter-app {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }
        .count-display {
            font-size: 72px;
            font-weight: bold;
            margin: 20px 0;
            color: #333;
        }
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); }
        button:active { transform: scale(0.95); }
        .btn-increment { background: #42b883; color: white; }
        .btn-decrement { background: #f44336; color: white; }
        .btn-reset { background: #2196F3; color: white; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;div class="counter-app"&gt;
            &lt;h1&gt;Vue Counter&lt;/h1&gt;
            &lt;div class="count-display"&gt;{{ count }}&lt;/div&gt;
            &lt;div class="buttons"&gt;
                &lt;button class="btn-decrement" @click="decrement"&gt;- Decrement&lt;/button&gt;
                &lt;button class="btn-reset" @click="reset"&gt;Reset&lt;/button&gt;
                &lt;button class="btn-increment" @click="increment"&gt;+ Increment&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    count: 0
                };
            },
            methods: {
                increment() {
                    this.count++;
                },
                decrement() {
                    this.count--;
                },
                reset() {
                    this.count = 0;
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Complete Vue Todo App</h3>

            <p>Now the full todo list in Vue:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue Todo App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .todo-app {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 { text-align: center; color: #333; }
        .add-todo { display: flex; gap: 10px; margin-bottom: 20px; }
        .add-todo input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .add-todo button {
            padding: 10px 20px;
            font-size: 16px;
            background: #42b883;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .todo-item:hover { background: #f0f0f0; }
        .todo-item.completed { opacity: 0.6; }
        .todo-item.completed .todo-text { text-decoration: line-through; }
        .todo-checkbox {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .todo-text { flex: 1; font-size: 16px; }
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-stats {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;div class="todo-app"&gt;
            &lt;h1&gt;ğŸ“ My Vue Todo List&lt;/h1&gt;
            
            &lt;div class="add-todo"&gt;
                &lt;input 
                    v-model="newTodoText"
                    @keyup.enter="addTodo"
                    placeholder="What do you need to do?"
                &gt;
                &lt;button @click="addTodo"&gt;Add&lt;/button&gt;
            &lt;/div&gt;

            &lt;div class="todo-list"&gt;
                &lt;div 
                    v-for="todo in todos" 
                    :key="todo.id"
                    :class="['todo-item', { completed: todo.completed }]"
                &gt;
                    &lt;input
                        type="checkbox"
                        class="todo-checkbox"
                        v-model="todo.completed"
                    &gt;
                    &lt;div class="todo-text"&gt;{{ todo.text }}&lt;/div&gt;
                    &lt;button class="delete-btn" @click="deleteTodo(todo.id)"&gt;
                        Delete
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div v-if="todos.length &gt; 0" class="todo-stats"&gt;
                {{ todos.length }} total â€¢ {{ completedCount }} completed â€¢ {{ remainingCount }} remaining
            &lt;/div&gt;

            &lt;div v-else class="todo-stats"&gt;
                No todos yet. Add one above! ğŸ‘†
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    newTodoText: '',
                    todos: []
                };
            },
            computed: {
                completedCount() {
                    return this.todos.filter(todo =&gt; todo.completed).length;
                },
                remainingCount() {
                    return this.todos.length - this.completedCount;
                }
            },
            methods: {
                addTodo() {
                    if (this.newTodoText.trim() === '') return;
                    
                    this.todos.push({
                        id: Date.now(),
                        text: this.newTodoText,
                        completed: false
                    });
                    
                    this.newTodoText = '';
                },
                deleteTodo(id) {
                    this.todos = this.todos.filter(todo =&gt; todo.id !== id);
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Deep Dive: Vue Direct ives</h3>
            
            <p>Vue has special HTML attributes called "directives" that give your templates superpowers. Let's explore the most important ones:</p>

            <h4>v-if, v-else-if, v-else - Conditional Rendering</h4>

            <div class="code">&lt;div id="app"&gt;
  &lt;p v-if="score >= 90"&gt;Grade: A - Excellent!&lt;/p&gt;
  &lt;p v-else-if="score >= 80"&gt;Grade: B - Great job!&lt;/p&gt;
  &lt;p v-else-if="score >= 70"&gt;Grade: C - Good&lt;/p&gt;
  &lt;p v-else&gt;Grade: F - Need to study more&lt;/p&gt;
  
  &lt;button @click="score += 10"&gt;Increase Score&lt;/button&gt;
  &lt;p&gt;Current Score: {{ score }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      score: 75
    }
  }
}).mount('#app');
&lt;/script&gt;</div>

            <h4>v-show - Toggle Visibility</h4>

            <div class="code">&lt;div id="app"&gt;
  &lt;button @click="isVisible = !isVisible"&gt;Toggle&lt;/button&gt;
  &lt;p v-show="isVisible"&gt;Now you see me!&lt;/p&gt;
&lt;/div&gt;</div>

            <div class="warning-box">
                <h4>v-if vs v-show</h4>
                <p><strong>v-if:</strong> Completely removes/adds element from DOM<br>
                <strong>v-show:</strong> Just toggles CSS display property<br><br>
                Use v-if when toggling is rare. Use v-show when toggling frequently (better performance).</p>
            </div>

            <h4>v-for - Rendering Lists</h4>

            <div class="code">&lt;div id="app"&gt;
  &lt;h3&gt;My Shopping List&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li v-for="(item, index) in items" :key="item.id"&gt;
      {{ index + 1 }}. {{ item.name }} - ${{ item.price }}
      &lt;button @click="removeItem(item.id)"&gt;Remove&lt;/button&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;p&gt;Total Items: {{ items.length }}&lt;/p&gt;
  &lt;p&gt;Total Cost: ${{ totalCost }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      items: [
        { id: 1, name: 'Laptop', price: 999 },
        { id: 2, name: 'Mouse', price: 29 },
        { id: 3, name: 'Keyboard', price: 79 }
      ]
    }
  },
  computed: {
    totalCost() {
      return this.items.reduce((sum, item) => sum + item.price, 0);
    }
  },
  methods: {
    removeItem(id) {
      this.items = this.items.filter(item => item.id !== id);
    }
  }
}).mount('#app');
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Always Use :key with v-for!</h4>
                <p>The <span class="inline-code">:key</span> attribute helps Vue track which items changed. Always use a unique ID, never use the index as key if your list can be reordered or items can be removed.</p>
            </div>

            <h4>v-model - Two-Way Data Binding</h4>

            <div class="code">&lt;div id="app"&gt;
  &lt;!-- Text input --&gt;
  &lt;input v-model="name" placeholder="Enter your name"&gt;
  &lt;p&gt;Hello, {{ name }}!&lt;/p&gt;
  
  &lt;!-- Textarea --&gt;
  &lt;textarea v-model="message" placeholder="Type a message"&gt;&lt;/textarea&gt;
  &lt;p&gt;Message length: {{ message.length }}&lt;/p&gt;
  
  &lt;!-- Checkbox --&gt;
  &lt;input type="checkbox" v-model="agreed"&gt;
  &lt;label&gt;I agree to terms&lt;/label&gt;
  &lt;p v-if="agreed"&gt;Thanks for agreeing!&lt;/p&gt;
  
  &lt;!-- Radio buttons --&gt;
  &lt;input type="radio" v-model="plan" value="free"&gt; Free
  &lt;input type="radio" v-model="plan" value="pro"&gt; Pro
  &lt;p&gt;Selected plan: {{ plan }}&lt;/p&gt;
  
  &lt;!-- Select dropdown --&gt;
  &lt;select v-model="country"&gt;
    &lt;option value="us"&gt;United States&lt;/option&gt;
    &lt;option value="uk"&gt;United Kingdom&lt;/option&gt;
    &lt;option value="ca"&gt;Canada&lt;/option&gt;
  &lt;/select&gt;
  &lt;p&gt;Country: {{ country }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      name: '',
      message: '',
      agreed: false,
      plan: 'free',
      country: 'us'
    }
  }
}).mount('#app');
&lt;/script&gt;</div>

            <h3>Computed Properties - Smart Data</h3>

            <p>Computed properties are like formulas in Excelâ€”they automatically recalculate when their dependencies change.</p>

            <div class="code">&lt;div id="app"&gt;
  &lt;h3&gt;Shopping Cart&lt;/h3&gt;
  
  &lt;div v-for="item in cart" :key="item.id"&gt;
    {{ item.name }} - ${{ item.price }} x 
    &lt;input v-model.number="item.quantity" type="number" min="1" style="width: 50px"&gt;
    = ${{ item.price * item.quantity }}
  &lt;/div&gt;
  
  &lt;hr&gt;
  &lt;p&gt;&lt;strong&gt;Subtotal: ${{ subtotal }}&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;Tax (10%): ${{ tax }}&lt;/p&gt;
  &lt;p&gt;Shipping: ${{ shipping }}&lt;/p&gt;
  &lt;h3&gt;Total: ${{ total }}&lt;/h3&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      cart: [
        { id: 1, name: 'Laptop', price: 999, quantity: 1 },
        { id: 2, name: 'Mouse', price: 29, quantity: 2 }
      ]
    }
  },
  computed: {
    subtotal() {
      return this.cart.reduce((sum, item) => {
        return sum + (item.price * item.quantity);
      }, 0);
    },
    tax() {
      return this.subtotal * 0.1;
    },
    shipping() {
      return this.subtotal > 100 ? 0 : 10;
    },
    total() {
      return this.subtotal + this.tax + this.shipping;
    }
  }
}).mount('#app');
&lt;/script&gt;</div>

            <div class="metaphor-box">
                <h4>Why Computed Over Methods?</h4>
                <p>You COULD calculate these in methods, but computed properties are <strong>cached</strong>. They only recalculate when dependencies change. If you call a method 10 times, it runs 10 times. A computed property? Calculated once, cached, reused. Much more efficient!</p>
            </div>

            <h3>Watchers - React to Changes</h3>

            <p>Watchers let you perform actions when data changes. Great for async operations or complex logic.</p>

            <div class="code">&lt;div id="app"&gt;
  &lt;input v-model="searchQuery" placeholder="Search products..."&gt;
  &lt;p v-if="loading"&gt;Searching...&lt;/p&gt;
  &lt;ul v-else&gt;
    &lt;li v-for="result in searchResults" :key="result"&gt;{{ result }}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      searchQuery: '',
      searchResults: [],
      loading: false
    }
  },
  watch: {
    searchQuery(newQuery) {
      if (newQuery.length < 3) {
        this.searchResults = [];
        return;
      }
      
      this.loading = true;
      
      // Simulate API call
      setTimeout(() => {
        this.searchResults = [
          `Result for "${newQuery}" #1`,
          `Result for "${newQuery}" #2`,
          `Result for "${newQuery}" #3`
        ];
        this.loading = false;
      }, 500);
    }
  }
}).mount('#app');
&lt;/script&gt;</div>

            <h3>Lifecycle Hooks - Component Life Stages</h3>

            <p>Components have a lifecycleâ€”they're born (mounted), live (updated), and die (unmounted). Lifecycle hooks let you run code at each stage.</p>

            <div class="code">&lt;div id="app"&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;p&gt;Count: {{ count }}&lt;/p&gt;
  &lt;button @click="count++"&gt;Increment&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
  data() {
    return {
      message: 'Hello',
      count: 0
    }
  },
  
  beforeCreate() {
    console.log('beforeCreate: Component is about to be created');
  },
  
  created() {
    console.log('created: Component created, data is ready');
    // Good for: Initial API calls
    this.message = 'Component created!';
  },
  
  beforeMount() {
    console.log('beforeMount: About to add to DOM');
  },
  
  mounted() {
    console.log('mounted: Component is in the DOM!');
    // Good for: DOM manipulation, third-party library setup
    document.title = 'Vue App Loaded';
  },
  
  beforeUpdate() {
    console.log('beforeUpdate: Data changed, about to update DOM');
  },
  
  updated() {
    console.log('updated: DOM has been updated');
  },
  
  beforeUnmount() {
    console.log('beforeUnmount: Component about to be removed');
  },
  
  unmounted() {
    console.log('unmounted: Component removed from DOM');
    // Good for: Cleanup (remove event listeners, clear timers)
  }
}).mount('#app');
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Most Commonly Used Hooks</h4>
                <p><strong>created:</strong> Fetch initial data<br>
                <strong>mounted:</strong> Access DOM, set up libraries<br>
                <strong>beforeUnmount:</strong> Cleanup (timers, listeners)<br><br>
                The others are less commonly needed but good to know!</p>
            </div>

            <h3>Complete Vue Todo App with All Features</h3>

            <p>Let's combine everything we've learned into one complete, feature-rich todo app:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Complete Vue Todo App&lt;/title&gt;
  &lt;style&gt;
    body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }
    .todo-item { display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
    .todo-item.completed { text-decoration: line-through; opacity: 0.6; }
    .todo-text { flex: 1; margin: 0 10px; }
    button { padding: 5px 10px; margin: 0 5px; cursor: pointer; }
    input[type="text"] { padding: 10px; width: 70%; font-size: 16px; }
    .stats { margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 5px; }
    .filter-buttons { margin: 15px 0; }
    .filter-buttons button { margin: 0 5px; }
    .filter-buttons button.active { background: #007bff; color: white; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;ğŸ“ Vue Todo App&lt;/h1&gt;
    
    &lt;!-- Add todo form --&gt;
    &lt;form @submit.prevent="addTodo"&gt;
      &lt;input 
        v-model.trim="newTodoText"
        type="text" 
        placeholder="What needs to be done?"
        required
      &gt;
      &lt;button type="submit"&gt;Add&lt;/button&gt;
    &lt;/form&gt;
    
    &lt;!-- Filter buttons --&gt;
    &lt;div class="filter-buttons"&gt;
      &lt;button 
        v-for="f in filters" 
        :key="f"
        @click="currentFilter = f"
        :class="{ active: currentFilter === f }"
      &gt;
        {{ f }}
      &lt;/button&gt;
    &lt;/div&gt;
    
    &lt;!-- Todo list --&gt;
    &lt;div v-if="filteredTodos.length"&gt;
      &lt;div 
        v-for="todo in filteredTodos" 
        :key="todo.id"
        class="todo-item"
        :class="{ completed: todo.completed }"
      &gt;
        &lt;input 
          type="checkbox" 
          v-model="todo.completed"
        &gt;
        &lt;div class="todo-text"&gt;{{ todo.text }}&lt;/div&gt;
        &lt;button @click="editTodo(todo)"&gt;Edit&lt;/button&gt;
        &lt;button @click="deleteTodo(todo.id)"&gt;Delete&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;p v-else style="text-align: center; color: #999; margin-top: 30px;"&gt;
      No todos to show!
    &lt;/p&gt;
    
    &lt;!-- Statistics --&gt;
    &lt;div class="stats" v-if="todos.length"&gt;
      &lt;strong&gt;Statistics:&lt;/strong&gt;&lt;br&gt;
      Total: {{ stats.total }} | 
      Active: {{ stats.active }} | 
      Completed: {{ stats.completed }} | 
      Progress: {{ stats.progress }}%
      
      &lt;br&gt;&lt;br&gt;
      &lt;button @click="clearCompleted" v-if="stats.completed"&gt;
        Clear Completed
      &lt;/button&gt;
      &lt;button @click="toggleAll"&gt;
        {{ allCompleted ? 'Unmark All' : 'Complete All' }}
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    const { createApp } = Vue;
    
    createApp({
      data() {
        return {
          todos: [],
          newTodoText: '',
          currentFilter: 'All',
          filters: ['All', 'Active', 'Completed'],
          nextId: 1
        }
      },
      
      computed: {
        filteredTodos() {
          if (this.currentFilter === 'Active') {
            return this.todos.filter(t => !t.completed);
          }
          if (this.currentFilter === 'Completed') {
            return this.todos.filter(t => t.completed);
          }
          return this.todos;
        },
        
        stats() {
          const total = this.todos.length;
          const completed = this.todos.filter(t => t.completed).length;
          const active = total - completed;
          const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
          
          return { total, completed, active, progress };
        },
        
        allCompleted() {
          return this.todos.length > 0 && this.todos.every(t => t.completed);
        }
      },
      
      methods: {
        addTodo() {
          if (this.newTodoText) {
            this.todos.push({
              id: this.nextId++,
              text: this.newTodoText,
              completed: false,
              createdAt: new Date()
            });
            this.newTodoText = '';
            this.saveTodos();
          }
        },
        
        deleteTodo(id) {
          this.todos = this.todos.filter(t => t.id !== id);
          this.saveTodos();
        },
        
        editTodo(todo) {
          const newText = prompt('Edit todo:', todo.text);
          if (newText !== null && newText.trim()) {
            todo.text = newText.trim();
            this.saveTodos();
          }
        },
        
        clearCompleted() {
          this.todos = this.todos.filter(t => !t.completed);
          this.saveTodos();
        },
        
        toggleAll() {
          const newState = !this.allCompleted;
          this.todos.forEach(t => t.completed = newState);
          this.saveTodos();
        },
        
        saveTodos() {
          localStorage.setItem('vue-todos', JSON.stringify(this.todos));
        },
        
        loadTodos() {
          const saved = localStorage.getItem('vue-todos');
          if (saved) {
            this.todos = JSON.parse(saved);
            this.nextId = Math.max(...this.todos.map(t => t.id), 0) + 1;
          }
        }
      },
      
      watch: {
        todos: {
          handler() {
            // Auto-save whenever todos change
            this.saveTodos();
          },
          deep: true  // Watch nested properties
        }
      },
      
      mounted() {
        this.loadTodos();
        console.log('Vue Todo App loaded!');
      }
    }).mount('#app');
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="info-box">
                <h4>Advanced Features in This App</h4>
                <p>âœ… <strong>Computed properties:</strong> filteredTodos, stats, allCompleted<br>
                âœ… <strong>Methods:</strong> All CRUD operations<br>
                âœ… <strong>Watchers:</strong> Deep watch on todos for auto-save<br>
                âœ… <strong>Lifecycle hooks:</strong> mounted to load from localStorage<br>
                âœ… <strong>Directives:</strong> v-if, v-for, v-model, @click, :class<br>
                âœ… <strong>LocalStorage:</strong> Data persists across refreshes<br>
                âœ… <strong>Dynamic classes:</strong> Visual feedback for completed todos</p>
            </div>

            <h3>Vue vs React: Which Should You Choose?</h3>

            <div class="card-grid">
                <div class="card">
                    <h4>Choose React if...</h4>
                    <p>â€¢ You prefer JavaScript-first approach<br>
                    â€¢ You want maximum flexibility<br>
                    â€¢ You like a large ecosystem<br>
                    â€¢ You're building complex SPAs<br>
                    â€¢ Job market demands React skills</p>
                </div>
                <div class="card">
                    <h4>Choose Vue if...</h4>
                    <p>â€¢ You prefer template-based HTML<br>
                    â€¢ You want easier learning curve<br>
                    â€¢ You like comprehensive official tools<br>
                    â€¢ You want great documentation<br>
                    â€¢ You value simplicity</p>
                </div>
            </div>

            <div class="metaphor-box">
                <h4>The Truth: Both Are Great!</h4>
                <p>Honestly? Both React and Vue are excellent choices. The "best" framework is the one YOU understand and can be productive with. Many developers know both! Don't stress too much about this decisionâ€”what matters most is understanding the core concepts (components, state, props, events) which work similarly in both.</p>
            </div>
        </section>

        <!-- SECTION 4: Understanding State Management -->
        <section id="understanding-state" class="section">
            <h2 class="section-title">Understanding State Management</h2>
            <p class="section-intro">As your apps grow, managing data across multiple components becomes tricky. This is where state management comes in. Don't worryâ€”we'll explain it with simple examples and show you when (and when NOT) to use it!</p>

            <h3>What IS State?</h3>
            
            <p>Vue was created by Evan You after working with Angular at Google. He wanted to extract the parts he really liked about Angular and build something lighter and more flexible. The result is a framework that prioritizes:</p>

            <ul>
                <li><strong>Approachability:</strong> Gentle learning curve, especially if you know HTML, CSS, and basic JavaScript</li>
                <li><strong>Versatility:</strong> Works for projects of any size, from progressive enhancement to full SPAs</li>
                <li><strong>Performance:</strong> Fast virtual DOM implementation with automatic optimization</li>
                <li><strong>Developer Experience:</strong> Excellent tooling, clear error messages, and comprehensive documentation</li>
            </ul>

            <h4>Vue vs React: Key Differences</h4>

            <p>If you're familiar with React, here are the main philosophical differences:</p>

            <div class="code">// REACT: JavaScript-centric, JSX everywhere
function Counter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

// VUE: Template-based, HTML-centric approach
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
    &lt;button @click="count++"&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
const count = ref(0);
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Template vs JSX</h4>
                <p><strong>Vue templates</strong> are easier to read and write for most developers, especially those with HTML/CSS backgrounds. <strong>React JSX</strong> offers more JavaScript flexibility but has a steeper learning curve. Vue supports both approaches - you can use templates OR JSX render functions.</p>
            </div>

            <h3>2. Vue Fundamentals: Template Syntax & Directives</h3>

            <p>Vue's template syntax extends HTML with powerful directives that make building dynamic interfaces intuitive. Let's master each directive with practical examples.</p>

            <h4>Text Interpolation & Expressions</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Basic interpolation --&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  
  &lt;!-- JavaScript expressions work! --&gt;
  &lt;p&gt;{{ message.toUpperCase() }}&lt;/p&gt;
  &lt;p&gt;{{ number + 1 }}&lt;/p&gt;
  &lt;p&gt;{{ isActive ? 'Yes' : 'No' }}&lt;/p&gt;
  
  &lt;!-- Ternary operators, method calls --&gt;
  &lt;p&gt;{{ reversedMessage() }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, computed } from 'vue';

const message = ref('Hello Vue!');
const number = ref(41);
const isActive = ref(true);

function reversedMessage() {
  return message.value.split('').reverse().join('');
}
&lt;/script&gt;</div>

            <h4>v-bind: Dynamic Attributes</h4>

            <p>The <span class="inline-code">v-bind</span> directive dynamically binds attributes to expressions. The shorthand <span class="inline-code">:</span> is commonly used.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;img v-bind:src="imageSrc" v-bind:alt="imageAlt"&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;img :src="imageSrc" :alt="imageAlt"&gt;
  
  &lt;!-- Binding classes --&gt;
  &lt;div :class="{ active: isActive, 'text-danger': hasError }"&gt;&lt;/div&gt;
  &lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;
  
  &lt;!-- Binding styles --&gt;
  &lt;div :style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
  
  &lt;!-- Binding multiple attributes --&gt;
  &lt;div v-bind="objectOfAttrs"&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const imageSrc = ref('https://vuejs.org/logo.svg');
const imageAlt = ref('Vue Logo');
const isActive = ref(true);
const hasError = ref(false);
const activeColor = ref('#42b883');
const fontSize = ref(16);
const objectOfAttrs = ref({
  id: 'container',
  class: 'wrapper'
});
&lt;/script&gt;</div>

            <h4>v-on: Event Handling</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;button v-on:click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Method handler --&gt;
  &lt;button @click="handleClick"&gt;Click Me&lt;/button&gt;
  
  &lt;!-- Inline handler with parameters --&gt;
  &lt;button @click="say('hello')"&gt;Say Hello&lt;/button&gt;
  
  &lt;!-- Event modifiers --&gt;
  &lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;
  &lt;button @click.stop="doThis"&gt;&lt;/button&gt;
  &lt;button @click.once="doThisOnce"&gt;&lt;/button&gt;
  
  &lt;!-- Key modifiers --&gt;
  &lt;input @keyup.enter="submit"&gt;
  &lt;input @keyup.esc="clearInput"&gt;
&lt;/template&gt;

&lt;script setup&gt;
const count = ref(0);

function handleClick(event) {
  console.log('Button clicked!', event);
}

function say(message) {
  alert(message);
}
&lt;/script&gt;</div>

            <h4>v-model: Two-Way Binding</h4>

            <p>The <span class="inline-code">v-model</span> directive creates two-way data binding on form inputs, perfect for handling user input.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Text input --&gt;
  &lt;input v-model="text" placeholder="Type something"&gt;
  &lt;p&gt;You typed: {{ text }}&lt;/p&gt;
  
  &lt;!-- Textarea --&gt;
  &lt;textarea v-model="message"&gt;&lt;/textarea&gt;
  
  &lt;!-- Checkbox --&gt;
  &lt;input type="checkbox" v-model="checked" id="checkbox"&gt;
  &lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;
  
  &lt;!-- Multiple checkboxes --&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Alice"&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Bob"&gt;
  &lt;p&gt;Checked: {{ checkedNames }}&lt;/p&gt;
  
  &lt;!-- Radio buttons --&gt;
  &lt;input type="radio" v-model="picked" value="One"&gt;
  &lt;input type="radio" v-model="picked" value="Two"&gt;
  
  &lt;!-- Select --&gt;
  &lt;select v-model="selected"&gt;
    &lt;option disabled value=""&gt;Choose one&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  
  &lt;!-- v-model modifiers --&gt;
  &lt;input v-model.lazy="msg"&gt;        &lt;!-- Update on change, not input --&gt;
  &lt;input v-model.number="age"&gt;      &lt;!-- Auto-typecast to number --&gt;
  &lt;input v-model.trim="username"&gt;   &lt;!-- Auto-trim whitespace --&gt;
&lt;/template&gt;

&lt;script setup&gt;
const text = ref('');
const message = ref('');
const checked = ref(false);
const checkedNames = ref([]);
const picked = ref('');
const selected = ref('');
const msg = ref('');
const age = ref(0);
const username = ref('');
&lt;/script&gt;</div>

            <h4>v-if, v-else-if, v-else: Conditional Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;div v-if="type === 'A'"&gt;
    Type A content
  &lt;/div&gt;
  &lt;div v-else-if="type === 'B'"&gt;
    Type B content
  &lt;/div&gt;
  &lt;div v-else&gt;
    Not A or B
  &lt;/div&gt;
  
  &lt;!-- Using template for grouping --&gt;
  &lt;template v-if="loginStatus === 'loggedIn'"&gt;
    &lt;h1&gt;Welcome back!&lt;/h1&gt;
    &lt;p&gt;Your dashboard&lt;/p&gt;
  &lt;/template&gt;
&lt;/template&gt;</div>

            <div class="warning-box">
                <h4>v-if vs v-show</h4>
                <p><strong>v-if:</strong> Conditionally renders the element (truly removes/adds to DOM). Higher toggle cost, lazy rendering.<br><br>
                <strong>v-show:</strong> Always renders but toggles CSS display. Lower toggle cost, immediate rendering.<br><br>
                <strong>Use v-if</strong> when the condition rarely changes. <strong>Use v-show</strong> for frequent toggling.</p>
            </div>

            <h4>v-for: List Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Array iteration --&gt;
  &lt;ul&gt;
    &lt;li v-for="(item, index) in items" :key="item.id"&gt;
      {{ index }}: {{ item.text }}
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;!-- Object iteration --&gt;
  &lt;div v-for="(value, key, index) in userObject" :key="key"&gt;
    {{ index }}. {{ key }}: {{ value }}
  &lt;/div&gt;
  
  &lt;!-- Range --&gt;
  &lt;span v-for="n in 10" :key="n"&gt;{{ n }}&lt;/span&gt;
  
  &lt;!-- v-for with v-if (not recommended on same element) --&gt;
  &lt;template v-for="item in items" :key="item.id"&gt;
    &lt;li v-if="!item.hidden"&gt;{{ item.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/template&gt;

&lt;script setup&gt;
const items = ref([
  { id: 1, text: 'Learn Vue', hidden: false },
  { id: 2, text: 'Build App', hidden: false },
  { id: 3, text: 'Deploy', hidden: true }
]);

const userObject = ref({
  name: 'Alice',
  age: 28,
  email: 'alice@example.com'
});
&lt;/script&gt;</div>

            <div class="warning-box">
                <h4>Always Use :key with v-for</h4>
                <p>Vue needs keys to track each node's identity for efficient DOM updates. Without keys, Vue uses an "in-place patch" strategy that can cause issues with stateful components or animations. Always provide unique, stable keys!</p>
            </div>

            <h3>3. Composition API Deep Dive</h3>

            <p>The Composition API is Vue 3's revolutionary approach to organizing component logic. It provides better code reusability, type inference, and logical organization compared to the Options API.</p>

            <h4>Why Composition API?</h4>

            <div class="metaphor-box">
                <h4>Organization by Concern</h4>
                <p>The Options API organizes code by option type (data, methods, computed, etc.) - like organizing books by size. The Composition API organizes by logical concern - like organizing books by topic. When you need to understand the "user authentication" feature, all related code is together rather than scattered across multiple options.</p>
            </div>

            <h4>setup() and &lt;script setup&gt;</h4>

            <div class="code">&lt;!-- Traditional setup() function --&gt;
&lt;script&gt;
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const double = computed(() =&gt; count.value * 2);
    
    function increment() {
      count.value++;
    }
    
    // Must return everything you want to expose to template
    return {
      count,
      double,
      increment
    };
  }
};
&lt;/script&gt;

&lt;!-- Modern &lt;script setup&gt; (preferred!) --&gt;
&lt;script setup&gt;
import { ref, computed } from 'vue';

// Everything defined here is automatically exposed to template
const count = ref(0);
const double = computed(() =&gt; count.value * 2);

function increment() {
  count.value++;
}
// No need to return anything!
&lt;/script&gt;</div>

            <h4>ref() vs reactive()</h4>

            <p>Understanding the difference between <span class="inline-code">ref</span> and <span class="inline-code">reactive</span> is crucial for mastering Vue's reactivity system.</p>

            <div class="code">&lt;script setup&gt;
import { ref, reactive } from 'vue';

// ref: For primitives and single values
const count = ref(0);
const message = ref('Hello');
const user = ref({ name: 'Alice' });

// Access via .value in script, automatic unwrap in template
count.value++;                    // In script: need .value
console.log(user.value.name);     // In script: need .value

// reactive: For objects only
const state = reactive({
  count: 0,
  message: 'Hello',
  nested: {
    value: 42
  }
});

// Direct access, no .value needed
state.count++;
state.nested.value = 100;

// GOTCHA: Destructuring loses reactivity with reactive()
const { count, message } = state;  // âŒ NOT reactive anymore!

// Use toRefs() to maintain reactivity
import { toRefs } from 'vue';
const { count, message } = toRefs(state);  // âœ… Still reactive!
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>When to Use ref vs reactive</h4>
                <p><strong>Use ref():</strong> For primitive values, single objects, or when you need to replace the entire object reference.<br><br>
                <strong>Use reactive():</strong> For complex objects with many properties that you'll mutate in place.<br><br>
                <strong>Common pattern:</strong> Many developers use <span class="inline-code">ref()</span> for everything for consistency, even for objects.</p>
            </div>

            <h4>computed(): Derived State</h4>

            <div class="code">&lt;script setup&gt;
import { ref, computed } from 'vue';

const firstName = ref('John');
const lastName = ref('Doe');

// Read-only computed
const fullName = computed(() =&gt; {
  return `${firstName.value} ${lastName.value}`;
});

// Writable computed (getter + setter)
const fullNameWritable = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ');
  }
});

// Computed with complex logic
const items = ref([
  { id: 1, name: 'Apple', price: 1.5, quantity: 3 },
  { id: 2, name: 'Banana', price: 0.8, quantity: 5 }
]);

const totalPrice = computed(() =&gt; {
  return items.value.reduce((total, item) =&gt; {
    return total + (item.price * item.quantity);
  }, 0).toFixed(2);
});

const expensiveItems = computed(() =&gt; {
  return items.value.filter(item =&gt; item.price &gt; 1);
});
&lt;/script&gt;</div>

            <h4>watch() and watchEffect()</h4>

            <p>Vue provides two ways to react to reactive state changes: <span class="inline-code">watch()</span> and <span class="inline-code">watchEffect()</span>.</p>

            <div class="code">&lt;script setup&gt;
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);
const user = ref({ name: 'Alice', age: 25 });

// watch: Explicit source, access old and new values
watch(count, (newValue, oldValue) =&gt; {
  console.log(`Count changed from ${oldValue} to ${newValue}`);
});

// watch multiple sources
watch([count, user], ([newCount, newUser], [oldCount, oldUser]) =&gt; {
  console.log('Count or user changed');
});

// watch with options
watch(user, (newUser) =&gt; {
  console.log('User changed:', newUser);
}, {
  deep: true,       // Watch nested properties
  immediate: true   // Run immediately on mount
});

// watchEffect: Automatic dependency tracking
watchEffect(() =&gt; {
  // Automatically tracks count and user.name as dependencies
  console.log(`${user.value.name} has count: ${count.value}`);
});

// watchEffect with cleanup
watchEffect((onCleanup) =&gt; {
  const timer = setTimeout(() =&gt; {
    console.log('Delayed log:', count.value);
  }, 1000);
  
  // Cleanup function runs before next execution and on unmount
  onCleanup(() =&gt; {
    clearTimeout(timer);
  });
});
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>watch vs watchEffect</h4>
                <p><strong>Use watch()</strong> when you need to access previous values, watch specific sources, or perform side effects only when certain dependencies change.<br><br>
                <strong>Use watchEffect()</strong> for simpler cases where you want automatic dependency tracking and don't need old values.</p>
            </div>

            <h3>4. Component Communication</h3>

            <h4>Props: Parent to Child</h4>

            <div class="code">&lt;!-- Child Component: UserCard.vue --&gt;
&lt;template&gt;
  &lt;div class="user-card"&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
    &lt;p&gt;Role: {{ role }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define props with TypeScript-style type annotation
const props = defineProps({
  user: {
    type: Object,
    required: true
  },
  role: {
    type: String,
    default: 'Guest'
  },
  age: {
    type: Number,
    validator: (value) =&gt; value &gt;= 0
  }
});

// Access props
console.log(props.user.name);
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;UserCard :user="currentUser" role="Admin" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import UserCard from './UserCard.vue';
const currentUser = ref({ name: 'Alice', age: 28 });
&lt;/script&gt;</div>

            <h4>Emits: Child to Parent</h4>

            <div class="code">&lt;!-- Child Component: CustomButton.vue --&gt;
&lt;template&gt;
  &lt;button @click="handleClick"&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define emits
const emit = defineEmits(['click', 'custom-event']);

function handleClick(event) {
  // Emit with data
  emit('click', { timestamp: Date.now(), event });
  emit('custom-event', 'some data');
}
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;CustomButton @click="onButtonClick" @custom-event="onCustom"&gt;
    Click Me
  &lt;/CustomButton&gt;
&lt;/template&gt;

&lt;script setup&gt;
function onButtonClick(data) {
  console.log('Button clicked at:', data.timestamp);
}

function onCustom(data) {
  console.log('Custom event:', data);
}
&lt;/script&gt;</div>

            <h4>provide/inject: Deep Component Communication</h4>

            <div class="code">&lt;!-- Grandparent Component --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue';

const theme = ref('dark');
const user = ref({ name: 'Alice', role: 'admin' });

// Provide to all descendants
provide('theme', theme);
provide('user', user);

// Provide with read-only access
import { readonly } from 'vue';
provide('config', readonly({
  apiUrl: 'https://api.example.com'
}));
&lt;/script&gt;

&lt;!-- Deep Child Component (any level deep) --&gt;
&lt;script setup&gt;
import { inject } from 'vue';

// Inject provided values
const theme = inject('theme');
const user = inject('user');

// Inject with default value
const config = inject('config', { apiUrl: 'fallback' });

// Now you can use theme, user, config
console.log(theme.value);  // 'dark'
&lt;/script&gt;</div>

            <h4>Slots: Content Distribution</h4>

            <div class="code">&lt;!-- Card Component with Slots --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;div class="card-header"&gt;
      &lt;slot name="header"&gt;Default Header&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-body"&gt;
      &lt;slot&gt;Default Content&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-footer"&gt;
      &lt;slot name="footer" :data="footerData"&gt;
        Default Footer
      &lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const footerData = ref({ timestamp: new Date() });
&lt;/script&gt;

&lt;!-- Using the Card --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;template #header&gt;
      &lt;h2&gt;My Custom Header&lt;/h2&gt;
    &lt;/template&gt;
    
    &lt;!-- Default slot --&gt;
    &lt;p&gt;This is the main content&lt;/p&gt;
    
    &lt;!-- Scoped slot receiving data --&gt;
    &lt;template #footer="{ data }"&gt;
      &lt;small&gt;Last updated: {{ data.timestamp }}&lt;/small&gt;
    &lt;/template&gt;
  &lt;/Card&gt;
&lt;/template&gt;</div>

            <h3>5. Pinia State Management</h3>

            <p>Pinia is the official state management solution for Vue 3, replacing Vuex. It offers a simpler API, better TypeScript support, and modular design.</p>

            <h4>Creating a Store</h4>

            <div class="code">// stores/counter.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

// Composition API style (recommended)
export const useCounterStore = defineStore('counter', () =&gt; {
  // State
  const count = ref(0);
  const name = ref('Counter Store');
  
  // Getters (computed)
  const doubleCount = computed(() =&gt; count.value * 2);
  const isEven = computed(() =&gt; count.value % 2 === 0);
  
  // Actions (functions)
  function increment() {
    count.value++;
  }
  
  function incrementBy(amount) {
    count.value += amount;
  }
  
  async function fetchCount() {
    const response = await fetch('/api/count');
    const data = await response.json();
    count.value = data.count;
  }
  
  return {
    count,
    name,
    doubleCount,
    isEven,
    increment,
    incrementBy,
    fetchCount
  };
});

// Options API style (alternative)
export const useCounterStore = defineStore('counter', {
  state: () =&gt; ({
    count: 0,
    name: 'Counter Store'
  }),
  getters: {
    doubleCount: (state) =&gt; state.count * 2,
    isEven: (state) =&gt; state.count % 2 === 0
  },
  actions: {
    increment() {
      this.count++;
    },
    incrementBy(amount) {
      this.count += amount;
    }
  }
});</div>

            <h4>Using Stores in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ counter.count }}&lt;/p&gt;
    &lt;p&gt;Double: {{ counter.doubleCount }}&lt;/p&gt;
    &lt;p&gt;Is Even: {{ counter.isEven }}&lt;/p&gt;
    &lt;button @click="counter.increment"&gt;Increment&lt;/button&gt;
    &lt;button @click="counter.incrementBy(5)"&gt;Add 5&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useCounterStore } from '@/stores/counter';

// Get store instance
const counter = useCounterStore();

// Destructure with reactivity (use storeToRefs!)
import { storeToRefs } from 'pinia';
const { count, doubleCount, isEven } = storeToRefs(counter);
const { increment, incrementBy } = counter;  // Actions don't need storeToRefs

// Watch store state
watch(() =&gt; counter.count, (newCount) =&gt; {
  console.log('Count changed:', newCount);
});
&lt;/script&gt;</div>

            <h4>Complex Store Example: User Authentication</h4>

            <div class="code">// stores/auth.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () =&gt; {
  // State
  const user = ref(null);
  const token = ref(localStorage.getItem('token') || null);
  const loading = ref(false);
  const error = ref(null);
  
  // Getters
  const isAuthenticated = computed(() =&gt; !!token.value);
  const userRole = computed(() =&gt; user.value?.role || 'guest');
  const isAdmin = computed(() =&gt; userRole.value === 'admin');
  
  // Actions
  async function login(email, password) {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      token.value = data.token;
      user.value = data.user;
      
      localStorage.setItem('token', data.token);
      
      return true;
    } catch (err) {
      error.value = err.message;
      return false;
    } finally {
      loading.value = false;
    }
  }
  
  function logout() {
    user.value = null;
    token.value = null;
    localStorage.removeItem('token');
  }
  
  async function fetchUser() {
    if (!token.value) return;
    
    try {
      const response = await fetch('/api/user', {
        headers: { Authorization: `Bearer ${token.value}` }
      });
      
      const data = await response.json();
      user.value = data;
    } catch (err) {
      // Token invalid, logout
      logout();
    }
  }
  
  return {
    user,
    token,
    loading,
    error,
    isAuthenticated,
    userRole,
    isAdmin,
    login,
    logout,
    fetchUser
  };
});</div>

            <h3>6. Vue Router Deep Dive</h3>

            <h4>Router Setup</h4>

            <div class="code">// router/index.js
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

const routes = [
  {
    path: '/',
    name: 'home',
    component: Home
  },
  {
    path: '/about',
    name: 'about',
    component: About
  },
  {
    path: '/user/:id',
    name: 'user',
    component: () =&gt; import('@/views/User.vue'),  // Lazy loading
    props: true  // Pass route params as props
  },
  {
    path: '/dashboard',
    component: () =&gt; import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: '',
        name: 'dashboard-home',
        component: () =&gt; import('@/views/DashboardHome.vue')
      },
      {
        path: 'profile',
        name: 'profile',
        component: () =&gt; import('@/views/Profile.vue')
      }
    ]
  },
  {
    // Catch all 404
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () =&gt; import('@/views/NotFound.vue')
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;</div>

            <h4>Navigation Guards</h4>

            <div class="code">// Global navigation guard
router.beforeEach(async (to, from) =&gt; {
  const authStore = useAuthStore();
  
  // Check authentication
  if (to.meta.requiresAuth &amp;&amp; !authStore.isAuthenticated) {
    return { name: 'login' };
  }
  
  // Check admin access
  if (to.meta.requiresAdmin &amp;&amp; !authStore.isAdmin) {
    return { name: 'forbidden' };
  }
  
  // Allow navigation
  return true;
});

// Per-route guard
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from) =&gt; {
      if (!isAdmin()) {
        return { name: 'home' };
      }
    }
  }
];</div>

            <h4>Using Router in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- Declarative navigation --&gt;
    &lt;router-link to="/"&gt;Home&lt;/router-link&gt;
    &lt;router-link :to="{ name: 'user', params: { id: 123 } }"&gt;
      User 123
    &lt;/router-link&gt;
    
    &lt;!-- Router view --&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRouter, useRoute } from 'vue-router';

const router = useRouter();
const route = useRoute();

// Programmatic navigation
function goToUser(id) {
  router.push({ name: 'user', params: { id } });
}

function goBack() {
  router.go(-1);
}

// Access route params/query
const userId = computed(() =&gt; route.params.id);
const searchQuery = computed(() =&gt; route.query.search);

// Watch route changes
watch(() =&gt; route.params.id, (newId) =&gt; {
  console.log('User ID changed:', newId);
});
&lt;/script&gt;</div>

            <h3>7. Composables: Reusable Logic</h3>

            <p>Composables are the Vue equivalent of React hooks - reusable functions that encapsulate stateful logic.</p>

            <div class="code">// composables/useFetch.js
import { ref } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);
  const loading = ref(false);
  
  async function fetchData() {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  }
  
  fetchData();
  
  return { data, error, loading, refetch: fetchData };
}

// Usage in component
&lt;script setup&gt;
import { useFetch } from '@/composables/useFetch';

const { data: users, loading, error } = useFetch('/api/users');
&lt;/script&gt;

// composables/useLocalStorage.js
import { ref, watch } from 'vue';

export function useLocalStorage(key, defaultValue) {
  const storedValue = localStorage.getItem(key);
  const data = ref(storedValue ? JSON.parse(storedValue) : defaultValue);
  
  watch(data, (newValue) =&gt; {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return data;
}

// Usage
const user = useLocalStorage('user', { name: 'Guest' });

// composables/useMousePosition.js
export function useMousePosition() {
  const x = ref(0);
  const y = ref(0);
  
  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }
  
  onMounted(() =&gt; {
    window.addEventListener('mousemove', update);
  });
  
  onUnmounted(() =&gt; {
    window.removeEventListener('mousemove', update);
  });
  
  return { x, y };
}</div>

            <h3>8. Lifecycle Hooks</h3>

            <div class="code">&lt;script setup&gt;
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted
} from 'vue';

// Before component is mounted to DOM
onBeforeMount(() =&gt; {
  console.log('Before mount');
});

// After component is mounted (DOM available)
onMounted(() =&gt; {
  console.log('Mounted - DOM ready');
  // Perfect for:
  // - API calls
  // - DOM manipulation
  // - Setting up listeners
});

// Before reactive data changes trigger re-render
onBeforeUpdate(() =&gt; {
  console.log('Before update');
});

// After reactive data changes and DOM updates
onUpdated(() =&gt; {
  console.log('Updated - DOM has changed');
});

// Before component is unmounted
onBeforeUnmount(() =&gt; {
  console.log('Before unmount');
  // Cleanup here
});

// After component is unmounted
onUnmounted(() =&gt; {
  console.log('Unmounted');
  // Final cleanup
});
&lt;/script&gt;</div>

            <h3>9. Form Handling & Validation</h3>

            <h4>Advanced v-model</h4>

            <div class="code">&lt;!-- Custom component with v-model --&gt;
&lt;!-- CustomInput.vue --&gt;
&lt;template&gt;
  &lt;input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  &gt;
&lt;/template&gt;

&lt;script setup&gt;
defineProps(['modelValue']);
defineEmits(['update:modelValue']);
&lt;/script&gt;

&lt;!-- Usage --&gt;
&lt;CustomInput v-model="text" /&gt;

&lt;!-- Multiple v-models --&gt;
&lt;UserForm
  v-model:firstName="firstName"
  v-model:lastName="lastName"
/&gt;</div>

            <h4>Form Validation with Vuelidate</h4>

            <div class="code">&lt;script setup&gt;
import { useVuelidate } from '@vuelidate/core';
import { required, email, minLength } from '@vuelidate/validators';

const formData = reactive({
  email: '',
  password: '',
  confirmPassword: ''
});

const rules = {
  email: { required, email },
  password: { required, minLength: minLength(8) },
  confirmPassword: {
    required,
    sameAs: (value) =&gt; value === formData.password
  }
};

const v$ = useVuelidate(rules, formData);

async function submitForm() {
  const isValid = await v$.value.$validate();
  
  if (!isValid) {
    console.log('Validation errors:', v$.value.$errors);
    return;
  }
  
  // Submit form
  console.log('Form valid, submitting...');
}
&lt;/script&gt;

&lt;template&gt;
  &lt;form @submit.prevent="submitForm"&gt;
    &lt;div&gt;
      &lt;input v-model="formData.email" placeholder="Email"&gt;
      &lt;span v-if="v$.email.$error"&gt;
        {{ v$.email.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;input v-model="formData.password" type="password"&gt;
      &lt;span v-if="v$.password.$error"&gt;
        {{ v$.password.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;</div>

            <h3>10. Performance Optimization</h3>

            <div class="code">&lt;template&gt;
  &lt;!-- v-once: Render once, never update --&gt;
  &lt;p v-once&gt;{{ staticContent }}&lt;/p&gt;
  
  &lt;!-- v-memo: Skip re-render if dependencies unchanged --&gt;
  &lt;div v-memo="[user.id, user.name]"&gt;
    &lt;UserCard :user="user" /&gt;
  &lt;/div&gt;
  
  &lt;!-- Lazy load components --&gt;
  &lt;component :is="AsyncComponent" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue';

// Lazy load heavy component
const AsyncComponent = defineAsyncComponent(() =&gt;
  import('./HeavyComponent.vue')
);

// Computed caching (automatically memoized)
const expensiveComputation = computed(() =&gt; {
  return items.value.reduce((sum, item) =&gt; sum + item.price, 0);
});

// Use shallowRef for large objects you rarely mutate
import { shallowRef } from 'vue';
const bigDataset = shallowRef({ /* thousands of items */ });
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Vue Performance Tips</h4>
                <p>
                â€¢ Use <span class="inline-code">v-show</span> for frequently toggled elements<br>
                â€¢ Use <span class="inline-code">v-if</span> for rarely changed conditions<br>
                â€¢ Always provide keys for v-for<br>
                â€¢ Lazy load route components<br>
                â€¢ Use computed for expensive calculations<br>
                â€¢ Use shallowRef/shallowReactive for large data structures<br>
                â€¢ Implement virtual scrolling for large lists (vue-virtual-scroller)<br>
                â€¢ Debounce expensive operations (user input, API calls)
                </p>
            </div>

            <div class="metaphor-box">
                <h4>Vue's Philosophy: Progressive Simplicity</h4>
                <p>Vue is designed to be incrementally adoptable - you start simple and add complexity only when needed. It's like learning to drive: you start with the basics (turning, braking), then gradually add advanced skills (parallel parking, highway merging). You don't need to know everything to be productive, but the advanced features are there when you're ready.</p>
            </div>

            <h3>Part 5: Advanced State Patterns & Best Practices</h3>
            
            <h4>Lifting State Up: The Fundamental Pattern</h4>
            
            <p>When two sibling components need to share state, you lift it up to their common parent. This is the most common state management pattern you'll use:</p>

            <div class="code">// âŒ Bad: Each component has its own copy of state (out of sync!)
function ComponentA() {
  const [count, setCount] = useState(0);
  return &lt;div&gt;Count: {count}&lt;/div&gt;;
}

function ComponentB() {
  const [count, setCount] = useState(0);  // Different count!
  return &lt;div&gt;Count: {count}&lt;/div&gt;;
}

// âœ… Good: Share state through common parent
function Parent() {
  const [count, setCount] = useState(0);  // Single source of truth
  
  return (
    &lt;div&gt;
      &lt;ComponentA count={count} onIncrement={() => setCount(count + 1)} /&gt;
      &lt;ComponentB count={count} onDecrement={() => setCount(count - 1)} /&gt;
    &lt;/div&gt;
  );
}

function ComponentA({ count, onIncrement }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={onIncrement}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}

function ComponentB({ count, onDecrement }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Double: {count * 2}&lt;/p&gt;
      &lt;button onClick={onDecrement}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>The Thermostat Analogy</h4>
                <p><strong>Bad approach:</strong> Each room has its own thermostat with no communication. Living room thinks it's 60Â°F, bedroom thinks it's 80Â°F. They fight each other and waste energy!<br><br>
                <strong>Good approach:</strong> One central thermostat controls the whole house. All rooms agree on the temperature. When one room requests a change, it affects the entire system consistently.<br><br>
                <strong>Lifting state up</strong> means finding the lowest common ancestor that all components needing the data can access, then managing state there.</p>
            </div>

            <h4>Derived State: Don't Store What You Can Calculate</h4>
            
            <div class="code">// âŒ Bad: Storing derived state (can get out of sync!)
function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);  // Derived from items!
  const [itemCount, setItemCount] = useState(0);  // Also derived!
  
  const addItem = (item) => {
    setItems([...items, item]);
    setTotal(total + item.price);  // Must remember to update both!
    setItemCount(itemCount + 1);
  };
  
  const removeItem = (index) => {
    const removed = items[index];
    setItems(items.filter((_, i) => i !== index));
    setTotal(total - removed.price);  // Easy to forget!
    setItemCount(itemCount - 1);
  };
  // Problem: total and itemCount can get out of sync if we forget to update them
}

// âœ… Good: Calculate derived state on every render
function ShoppingCart() {
  const [items, setItems] = useState([]);
  
  // Calculated every render (cheap operations)
  const total = items.reduce((sum, item) => sum + item.price, 0);
  const itemCount = items.length;
  
  const addItem = (item) => {
    setItems([...items, item]);
    // total and itemCount update automatically!
  };
  
  const removeItem = (index) => {
    setItems(items.filter((_, i) => i !== index));
    // No need to manually update anything else
  };
  
  return (
    &lt;div&gt;
      &lt;p&gt;Items: {itemCount}&lt;/p&gt;
      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;
      &lt;ul&gt;
        {items.map((item, i) => (
          &lt;li key={i}&gt;
            {item.name} - ${item.price}
            &lt;button onClick={() => removeItem(i)}&gt;Remove&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>Rule: Single Source of Truth</h4>
                <p>For any piece of data, there should be ONE place it's stored, and everything else should calculate from it.<br><br>
                <strong>Store:</strong> Raw data (items array, user input)<br>
                <strong>Calculate:</strong> Everything else (totals, counts, filtered/sorted data)<br><br>
                <strong>Why?</strong> Prevents bugs where data gets out of sync. Your UI always shows consistent information. It's easier to reason about - you only update one thing!</p>
            </div>

            <h4>State vs Props: Understanding Ownership</h4>
            
            <div class="code">// STATE: Data owned by this component
function Counter() {
  const [count, setCount] = useState(0);  // STATE: Can read AND write
  
  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}

// PROPS: Data passed from parent (read-only)
function Display({ value, color }) {  // PROPS: Can only read
  // Can't do: value = 10; (error!)
  // Can't do: color = 'blue'; (error!)
  
  return &lt;p style={{ color }}&gt;{value}&lt;/p&gt;;
}

// Combining both
function Parent() {
  const [count, setCount] = useState(0);  // STATE in parent
  
  return (
    &lt;div&gt;
      &lt;Display value={count} color=\"blue\" /&gt;  {/* Passed as PROPS */}
      &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>State vs Props = Variables vs Function Arguments</h4>
                <p><strong>State:</strong> Like a variable INSIDE a function - you can read AND write:<br>
                <code>let x = 5;  // Can change<br>
                x = 10;  // OK!</code><br><br>
                <strong>Props:</strong> Like function ARGUMENTS - you can only read, not modify:<br>
                <code>function example(x) {<br>
                &nbsp;&nbsp;console.log(x);  // OK - reading<br>
                &nbsp;&nbsp;x = 10;  // Bad practice - don't modify arguments!<br>
                }</code><br><br>
                If a child component wants to change props, it must ask the parent by calling a function the parent provided!</p>
            </div>

            <h3>Part 6: When to Use What</h3>
            
            <h4>Decision Tree: Local vs Lifted vs Global State</h4>
            
            <div class="code">// 1. LOCAL STATE: Only one component needs it
function SearchBox() {
  const [query, setQuery] = useState('');  // Only SearchBox uses this
  
  return (
    &lt;input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    /&gt;
  );
}

// 2. LIFTED STATE: A few nearby components need it
function SearchPage() {
  const [query, setQuery] = useState('');  // Parent owns it
  
  return (
    &lt;div&gt;
      &lt;SearchBox query={query} setQuery={setQuery} /&gt;
      &lt;SearchResults query={query} /&gt;  {/* Both need query */}
    &lt;/div&gt;
  );
}

// 3. GLOBAL STATE: Many unrelated components across the app need it
// Examples:
// - User authentication (isLoggedIn, username, avatar)
// - Shopping cart (navbar shows count, cart page shows items, checkout uses data)
// - Theme (dark mode / light mode affects entire UI)
// - Language/locale (every component with text needs it)
// - Notifications/toasts (triggered from anywhere, shown globally)</div>

            <div class="info-box">
                <h4>Ask These Questions:</h4>
                <p><strong>1. Does only this component need it?</strong><br>
                â†’ Use <code>useState</code> right here<br><br>
                <strong>2. Do parent and child, or siblings, need it?</strong><br>
                â†’ Lift state up to common parent<br><br>
                <strong>3. Do 3+ unrelated components need it?</strong><br>
                â†’ Consider Context API<br><br>
                <strong>4. Is state complex with many actions?</strong><br>
                â†’ Consider Redux/Zustand<br><br>
                <strong>5. Do I need time-travel debugging or middleware?</strong><br>
                â†’ Definitely use Redux</p>
            </div>

            <h3>Part 7: Common State Management Mistakes</h3>
            
            <div class="warning-box">
                <h4>Mistake #1: Mutating State Directly</h4>
                <p><strong>âŒ NEVER DO THIS:</strong></p>
                <div class="code">const [todos, setTodos] = useState([]);

// DON'T!
todos.push(newTodo);  // Mutates array directly
setTodos(todos);  // React won't detect the change!

const [user, setUser] = useState({ name: 'Alice', age: 25 });

// DON'T!
user.age = 26;  // Mutates object directly
setUser(user);  // React won't see the change!</div>
                <p><strong>âœ… ALWAYS CREATE NEW OBJECTS/ARRAYS:</strong></p>
                <div class="code">// Arrays: Use spread operator or concat
setTodos([...todos, newTodo]);  // New array!
setTodos(todos.concat(newTodo));  // Also creates new array

// Objects: Use spread operator
setUser({ ...user, age: 26 });  // New object!</div>
                <p><strong>Why?</strong> React compares old state reference to new state reference. If it's the same object (even with modified contents), React thinks nothing changed and won't re-render!</p>
            </div>

            <div class="warning-box">
                <h4>Mistake #2: Stale Closures in Callbacks</h4>
                <p><strong>âŒ BUG: Count gets stuck at 1</strong></p>
                <div class="code">function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      console.log(count);  // Always logs 0!
      setCount(count + 1);  // count is stale (captured as 0)
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);  // Empty deps = count never updates in callback
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}
// UI shows: 0 â†’ 1 â†’ 1 â†’ 1 â†’ 1... (stuck!)</div>
                <p><strong>âœ… FIX: Use functional update</strong></p>
                <div class="code">function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);  // prev is always current!
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}
// UI shows: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4... (correct!)</div>
                <p><strong>Why?</strong> The callback captures <code>count</code> from when useEffect ran (0). Use <code>prev => prev + 1</code> to always get the LATEST value directly from React's state!</p>
            </div>

            <div class="warning-box">
                <h4>Mistake #3: Too Many State Variables</h4>
                <p><strong>âŒ Hard to manage:</strong></p>
                <div class="code">function UserProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [city, setCity] = useState('');
  const [country, setCountry] = useState('');
  // 6 separate useState calls = messy!
}</div>
                <p><strong>âœ… Group related state:</strong></p>
                <div class="code">function UserProfile() {
  const [user, setUser] = useState({
    firstName: '',
    lastName: '',
    email: '',
    age: 0,
    city: '',
    country: '',
  });
  
  const updateField = (field, value) => {
    setUser({ ...user, [field]: value });
  };
  
  return (
    &lt;input
      value={user.firstName}
      onChange={(e) => updateField('firstName', e.target.value)}
    /&gt;
  );
}</div>
                <p><strong>Even better: Use useReducer for complex state:</strong></p>
                <div class="code">function reducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return { ...state, [action.field]: action.value };
    case 'RESET':
      return { firstName: '', lastName: '', email: '', age: 0, city: '', country: '' };
    default:
      return state;
  }
}

function UserProfile() {
  const [user, dispatch] = useReducer(reducer, {
    firstName: '',
    lastName: '',
    email: '',
    age: 0,
    city: '',
    country: '',
  });
  
  return (
    &lt;div&gt;
      &lt;input
        value={user.firstName}
        onChange={(e) => dispatch({
          type: 'UPDATE_FIELD',
          field: 'firstName',
          value: e.target.value
        })}
      /&gt;
      &lt;button onClick={() => dispatch({ type: 'RESET' })}&gt;
        Reset
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</div>
            </div>

            <div class="warning-box">
                <h4>Mistake #4: Prop Drilling Hell</h4>
                <p><strong>âŒ Passing props through 5 layers:</strong></p>
                <div class="code">function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  return &lt;Layout user={user} /&gt;;
}

function Layout({ user }) {
  return &lt;Sidebar user={user} /&gt;;
}

function Sidebar({ user }) {
  return &lt;Menu user={user} /&gt;;
}

function Menu({ user }) {
  return &lt;UserWidget user={user} /&gt;;
}

function UserWidget({ user }) {
  return &lt;p&gt;{user.name}&lt;/p&gt;;  // Finally used here!
}
// Layout, Sidebar, Menu don't even USE user - just pass it down!</div>
                <p><strong>âœ… Use Context to skip layers:</strong></p>
                <div class="code">const UserContext = createContext();

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  
  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;Layout /&gt;  {/* No user prop! */}
    &lt;/UserContext.Provider&gt;
  );
}

function Layout() {
  return &lt;Sidebar /&gt;;  {/* No user prop! */}
}

function Sidebar() {
  return &lt;Menu /&gt;;  {/* No user prop! */}
}

function Menu() {
  return &lt;UserWidget /&gt;;  {/* No user prop! */}
}

function UserWidget() {
  const user = useContext(UserContext);  // Grab it directly!
  return &lt;p&gt;{user.name}&lt;/p&gt;;
}</div>
                <p><strong>Why?</strong> Context lets deeply nested components access data WITHOUT passing props through every layer in between. Use it when data is needed by many components at different nesting levels!</p>
            </div>

            <h3>Part 8: Advanced Pattern - Custom Hooks for State Logic</h3>
            
            <p>Extract reusable state logic into custom hooks to keep components clean:</p>

            <div class="code">// âœ… Custom hook for form handling
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues({ ...values, [name]: value });
    
    // Clear error when user types
    if (errors[name]) {
      setErrors({ ...errors, [name]: '' });
    }
  };
  
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched({ ...touched, [name]: true });
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!values.email.includes('@')) {
      newErrors.email = 'Invalid email';
    }
    
    if (values.password.length < 8) {
      newErrors.password = 'Password must be 8+ characters';
    }
    
    if (values.password !== values.confirmPassword) {
      newErrors.confirmPassword = 'Passwords must match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };
  
  return { values, errors, touched, handleChange, handleBlur, validate, reset };
}

// Use in component
function SignupForm() {
  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    validate,
    reset,
  } = useForm({
    email: '',
    password: '',
    confirmPassword: '',
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (validate()) {
      console.log('Valid!', values);
      // Submit to API...
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;input
          name="email"
          type="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Email"
        /&gt;
        {touched.email && errors.email && (
          &lt;span style={{ color: 'red' }}&gt;{errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        /&gt;
        {touched.password && errors.password && (
          &lt;span style={{ color: 'red' }}&gt;{errors.password}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="confirmPassword"
          type="password"
          value={values.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Confirm Password"
        /&gt;
        {touched.confirmPassword && errors.confirmPassword && (
          &lt;span style={{ color: 'red' }}&gt;{errors.confirmPassword}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Sign Up&lt;/button&gt;
      &lt;button type="button" onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/form&gt;
  );
}</div>

            <div class="info-box">
                <h4>Why Custom Hooks Are Powerful</h4>
                <p><strong>1. Reusability:</strong> Use the same logic in multiple components (multiple forms can use useForm)<br>
                <strong>2. Organization:</strong> Keep components clean, move complex logic to hooks<br>
                <strong>3. Testing:</strong> Test hooks independently from components<br>
                <strong>4. Sharing:</strong> Publish hooks as npm packages for the community<br>
                <strong>5. Composition:</strong> Build complex hooks by combining simpler ones<br><br>
                Custom hooks are functions that USE other hooks (useState, useEffect, etc.). They MUST start with <code>use</code> (React convention)!</p>
            </div>

            <h4>More Useful Custom Hooks</h4>
            
            <div class="code">// Hook for localStorage persistence
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : initialValue;
    } catch {
      return initialValue;
    }
  });
  
  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch {
      console.error('Failed to save to localStorage');
    }
  }, [key, value]);
  
  return [value, setValue];
}

// Usage: Persists across page refreshes!
function App() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [todos, setTodos] = useLocalStorage('todos', []);
  
  return (
    &lt;div className={theme}&gt;
      &lt;button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}&gt;
        Toggle Theme
      &lt;/button&gt;
      {/* todos automatically save to localStorage */}
    &lt;/div&gt;
  );
}

// Hook for responsive window size
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Usage
function ResponsiveComponent() {
  const { width } = useWindowSize();
  
  return (
    &lt;div&gt;
      {width > 768 ? (
        &lt;DesktopNav /&gt;
      ) : (
        &lt;MobileMenu /&gt;
      )}
    &lt;/div&gt;
  );
}

// Hook for debounced value (performance!)
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage: Don't search on every keystroke!
function SearchBox() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);  // Wait 500ms after typing stops
  
  useEffect(() => {
    if (debouncedQuery) {
      // Make API call
      fetch(`/api/search?q=${debouncedQuery}`)
        .then(r => r.json())
        .then(results => console.log(results));
    }
  }, [debouncedQuery]);  // Only runs when typing stops for 500ms!
  
  return (
    &lt;input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    /&gt;
  );
}

// Hook for API fetch
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    setError(null);
    
    fetch(url)
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch');
        return res.json();
      })
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error.message);
        setLoading(false);
      });
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>ğŸ‰ You're a State Management MASTER!</h4>
                <p>You now deeply understand:<br><br>
                âœ… What state is (data that changes over time)<br>
                âœ… Local vs lifted vs global state (when to use each)<br>
                âœ… Derived state (calculate, don't store)<br>
                âœ… State vs props (ownership vs passed data)<br>
                âœ… Common mistakes (mutations, stale closures, prop drilling)<br>
                âœ… Solutions (Context API, useReducer for complex state)<br>
                âœ… Custom hooks (extracting reusable logic)<br><br>
                State management is the CORE of modern frontend development. Everything you've learned here applies to React, Vue, Svelte, and other frameworks. The patterns are universal!<br><br>
                You're now ready to build complex applications with confidence. You know when to use simple useState, when to lift state up, when to reach for Context, and when to consider Redux. You can create custom hooks to make your code cleaner and more reusable.<br><br>
                <strong>Next challenge:</strong> Build a full e-commerce app with cart, auth, filters, and sorting. Apply ALL these patterns together and watch how they solve real problems. You got this! ğŸš€</p>
            </div>
        </section>

        <!-- SECTION 3: State Management (Redux, Zustand, Recoil, Context) -->
        <section id="state-management" class="section">
            <h2 class="section-title">State Management</h2>
            <p class="section-intro">As your apps grow bigger, you'll notice something: passing data between components gets messy FAST. You end up passing props through 5 layers of components just to get data where it needs to go. That's where state management comes in. Let's understand why it exists and when you actually need it.</p>

            <h3>What Even IS State Management?</h3>
            
            <p>Let's start with a simple question: what is "state"?</p>

            <div class="metaphor-box">
                <h4>State is Just Data That Changes</h4>
                <p>Think of state like the current "status" of your app:<br><br>
                â€¢ Is the user logged in? (state: <span class="inline-code">isLoggedIn = true</span>)<br>
                â€¢ What's in the shopping cart? (state: <span class="inline-code">cartItems = [...]</span>)<br>
                â€¢ Is the modal open? (state: <span class="inline-code">modalOpen = false</span>)<br>
                â€¢ What page are we on? (state: <span class="inline-code">currentPage = 'home'</span>)<br><br>
                State is literally just variables that your app cares about. When state changes, your UI updates to match.</p>
            </div>

            <h4>The Problem: Prop Drilling Hell</h4>
            
            <p>Imagine you have this component structure:</p>

            <div class="code">App
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ UserMenu
â”‚   â”‚   â””â”€â”€ Avatar (needs user data!)
â”‚   â””â”€â”€ Notifications
â”œâ”€â”€ Sidebar
â”‚   â””â”€â”€ Profile (needs user data!)
â””â”€â”€ MainContent
    â””â”€â”€ Dashboard (needs user data!)</div>

            <p>The user data lives in <span class="inline-code">App</span>, but three components deep down need it. In regular React, you'd have to do this:</p>

            <div class="code">// App.jsx
function App() {
  const [user, setUser] = useState({name: 'Alice', email: 'alice@example.com'});
  
  return (
    &lt;div&gt;
      &lt;Header user={user} /&gt;  {/* Pass it down */}
      &lt;Sidebar user={user} /&gt;  {/* Pass it again */}
      &lt;MainContent user={user} /&gt;  {/* And again! */}
    &lt;/div&gt;
  );
}

// Header.jsx
function Header({ user }) {
  return (
    &lt;header&gt;
      &lt;UserMenu user={user} /&gt;  {/* Pass it down more! */}
    &lt;/header&gt;
  );
}

// UserMenu.jsx
function UserMenu({ user }) {
  return (
    &lt;div&gt;
      &lt;Avatar user={user} /&gt;  {/* FINALLY! */}
    &lt;/div&gt;
  );
}

// Avatar.jsx
function Avatar({ user }) {
  return &lt;img src={user.avatar} alt={user.name} /&gt;;
}</div>

            <div class="warning-box">
                <h4>The Prop Drilling Problem</h4>
                <p>This is called <strong>"prop drilling"</strong> - passing props through components that don't even use them, just to get data to deeply nested children. Problems:<br><br>
                â€¢ Components in the middle don't need the data but must pass it<br>
                â€¢ Adding/removing props means changing many files<br>
                â€¢ It's annoying and error-prone<br>
                â€¢ Your code becomes a mess of prop passing</p>
            </div>

            <h3>The Solution: Global State</h3>
            
            <p>What if instead of passing data through every component, you could put it in a "global store" that ANY component can access?</p>

            <div class="metaphor-box">
                <h4>The Billboard Metaphor</h4>
                <p><strong>Prop Drilling:</strong> Like whispering a message from person to person down a line. Each person has to remember and pass it along.<br><br>
                <strong>Global State:</strong> Like putting the message on a billboard. Everyone can just look up and see it whenever they need it. No passing required!</p>
            </div>

            <h4>React Context: Built-in Solution</h4>
            
            <p>React has a built-in way to share state globally: <strong>Context</strong>.</p>

            <div class="code">// 1. Create a context
import { createContext, useContext, useState } from 'react';

const UserContext = createContext();

// 2. Provide the data at the top level
function App() {
  const [user, setUser] = useState({name: 'Alice', email: 'alice@example.com'});
  
  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      &lt;Header /&gt;
      &lt;Sidebar /&gt;
      &lt;MainContent /&gt;
    &lt;/UserContext.Provider&gt;
  );
}

// 3. Use the data anywhere (no prop drilling!)
function Avatar() {
  const { user } = useContext(UserContext);
  
  return &lt;img src={user.avatar} alt={user.name} /&gt;;
}

// No need to pass user through Header or UserMenu anymore!</div>

            <div class="info-box">
                <h4>How Context Works</h4>
                <p><strong>Provider:</strong> Wraps your app and makes data available<br>
                <strong>Consumer:</strong> Any component that needs the data can "consume" it with <span class="inline-code">useContext</span><br><br>
                Think of Provider as the billboard owner, and consumers as people reading the billboard.</p>
            </div>

            <h4>When Do You Actually Need State Management?</h4>
            
            <p>Not every app needs global state! Here's when you DO and DON'T need it:</p>

            <div class="code">// DON'T need global state - simple component state is fine
function Counter() {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() => setCount(count + 1)}&gt;{count}&lt;/button&gt;
}

// DON'T need global state - just passing one level down
function ParentComponent() {
  const [data, setData] = useState('hello');
  return &lt;ChildComponent data={data} /&gt;
}

// DO need global state - many components need this data
function App() {
  // User info, theme, shopping cart, auth status
  // Used by Header, Sidebar, Footer, Dashboard, Profile...
  // DON'T want to prop drill through everything!
}</div>

            <div class="info-box">
                <h4>Simple Rule</h4>
                <p><strong>Use local state (useState)</strong> when:<br>
                â€¢ Only one component needs the data<br>
                â€¢ Data doesn't need to be shared<br><br>
                <strong>Use global state (Context/Redux)</strong> when:<br>
                â€¢ Multiple unrelated components need the same data<br>
                â€¢ You're passing props through 3+ levels<br>
                â€¢ Data needs to persist across page navigation</p>
            </div>

            <h3>Introduction to Redux (Advanced Option)</h3>
            
            <p>Context is great for small apps. For big apps with LOTS of global state, developers often use <strong>Redux</strong>.</p>

            <div class="metaphor-box">
                <h4>Context vs Redux</h4>
                <p><strong>Context:</strong> Like a bulletin board in your house. Good for a few messages.<br><br>
                <strong>Redux:</strong> Like a filing cabinet system with organized drawers and labels. Better when you have LOTS of data to manage.<br><br>
                For beginners: Start with Context. Graduate to Redux when you feel Context getting messy.</p>
            </div>

            <h4>Complete Shopping Cart Example</h4>
            
            <p>Let's build a shopping cart with Context to see state management in action:</p>

            <div class="code">// CartContext.jsx
import { createContext, useContext, useState } from 'react';

const CartContext = createContext();

export function CartProvider({ children }) {
  const [cart, setCart] = useState([]);
  
  const addToCart = (item) => {
    setCart([...cart, item]);
  };
  
  const removeFromCart = (itemId) => {
    setCart(cart.filter(item => item.id !== itemId));
  };
  
  const totalPrice = cart.reduce((sum, item) => sum + item.price, 0);
  
  return (
    &lt;CartContext.Provider value={{ cart, addToCart, removeFromCart, totalPrice }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

export function useCart() {
  return useContext(CartContext);
}

// App.jsx
function App() {
  return (
    &lt;CartProvider&gt;
      &lt;Header /&gt;
      &lt;ProductList /&gt;
      &lt;Cart /&gt;
    &lt;/CartProvider&gt;
  );
}

// Header.jsx (shows cart count)
function Header() {
  const { cart } = useCart();
  
  return (
    &lt;header&gt;
      &lt;h1&gt;My Shop&lt;/h1&gt;
      &lt;div&gt;Cart: {cart.length} items&lt;/div&gt;
    &lt;/header&gt;
  );
}

// ProductList.jsx (adds items)
function ProductList() {
  const { addToCart } = useCart();
  const products = [
    { id: 1, name: 'Laptop', price: 999 },
    { id: 2, name: 'Mouse', price: 29 }
  ];
  
  return (
    &lt;div&gt;
      {products.map(product => (
        &lt;div key={product.id}&gt;
          &lt;h3&gt;{product.name}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;button onClick={() => addToCart(product)}&gt;
            Add to Cart
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Cart.jsx (displays cart)
function Cart() {
  const { cart, removeFromCart, totalPrice } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Your Cart&lt;/h2&gt;
      {cart.map(item => (
        &lt;div key={item.id}&gt;
          &lt;span&gt;{item.name} - ${item.price}&lt;/span&gt;
          &lt;button onClick={() => removeFromCart(item.id)}&gt;
            Remove
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
      &lt;h3&gt;Total: ${totalPrice}&lt;/h3&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>What Just Happened?</h4>
                <p><strong>1. CartProvider:</strong> Wraps the app and holds cart state<br>
                <strong>2. useCart hook:</strong> Makes it easy to access cart anywhere<br>
                <strong>3. Multiple components:</strong> Header, ProductList, and Cart all use the same cart data<br>
                <strong>4. No prop drilling:</strong> Each component directly accesses what it needs</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered State Management Basics!</h4>
                <p>You now understand when and why to use state management. For most beginner projects, Context is more than enough. As you build bigger apps, you'll naturally feel when you need something more powerful like Redux. Don't overcomplicateâ€”use the simplest solution that works!</p>
            </div>

            <h3>Redux Toolkit: The Professional Way</h3>
            
            <p>You've learned Context for simple state management. Now let's talk about Redux Toolkit (RTK)â€”the industry standard for complex apps. While Context is great for small projects, Redux shines when you have lots of shared state, complex logic, or need time-travel debugging.</p>

            <div class="metaphor-box">
                <h4>Context vs Redux: The Restaurant Analogy</h4>
                <p><strong>Context API:</strong> A small family restaurant where the owner (provider) remembers everyone's orders in their head. Works great for 10-20 customers.<br><br>
                <strong>Redux:</strong> A massive chain restaurant with an advanced kitchen system. Orders go to a central dispatch (store), specialized chefs (reducers) handle each type of dish, and there's a detailed log of every order ever made. Overkill for a small place, but essential for scale.</p>
            </div>

            <div class="info-box">
                <h4>Why Redux Toolkit?</h4>
                <p><strong>Old Redux:</strong> Required tons of boilerplate codeâ€”separate action types, action creators, reducers with switch statements. Everyone complained it was too verbose.<br>
                <strong>Redux Toolkit:</strong> The Redux team said "We hear you!" and created RTK. It's the official, recommended way to use Reduxâ€”less code, better practices built-in, and much easier to learn.</p>
            </div>

            <h3>Installing Redux Toolkit</h3>
            
            <p>First, install Redux Toolkit and React-Redux (the React bindings):</p>

            <div class="code-block">
                <pre><code>npm install @reduxjs/toolkit react-redux</code></pre>
            </div>

            <p>That's it! Two packages and you're ready to go.</p>

            <h3>Setting Up Your Store</h3>
            
            <p>The <strong>store</strong> is Redux's central databaseâ€”it holds all your app's state in one place. With Redux Toolkit, creating a store is super simple:</p>

            <div class="code-block">
                <pre><code>// store.js
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {
    // We'll add reducers here soon
  },
});

// In App.jsx
import { Provider } from 'react-redux';
import { store } from './store';

function App() {
  return (
    &lt;Provider store={store}&gt;
      &lt;YourApp /&gt;
    &lt;/Provider&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>What's Happening?</h4>
                <p><strong>configureStore:</strong> Creates your Redux store with good defaults (dev tools, middleware, etc.)<br>
                <strong>Provider:</strong> Just like Context Providerâ€”wraps your app and makes the store available everywhere<br>
                <strong>reducer object:</strong> Will hold different "slices" of state (like users, products, cart, etc.)</p>
            </div>

            <h3>Creating Your First Slice</h3>
            
            <p>A <strong>slice</strong> is a piece of your state plus all the logic to update it. Think of it like a mini-reducer for one feature. Redux Toolkit's <code>createSlice</code> generates actions and reducers automatically!</p>

            <div class="code-block">
                <pre><code>// counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    reset: (state) => {
      state.value = 0;
    },
  },
});

// Export actions (automatically generated!)
export const { increment, decrement, reset } = counterSlice.actions;

// Export reducer
export default counterSlice.reducer;</code></pre>
            </div>

            <div class="metaphor-box">
                <h4>Understanding Slices: The Kitchen Station Metaphor</h4>
                <p>Imagine a restaurant kitchen with different stations:<br><br>
                <strong>Slice = Station:</strong> The pasta station handles all pasta orders<br>
                <strong>initialState = Starting ingredients:</strong> What's on the counter when you start<br>
                <strong>reducers = Recipes:</strong> Each recipe (increment, decrement) says how to transform the ingredients<br>
                <strong>Actions = Order tickets:</strong> When someone orders, a ticket arrives telling the station what to make</p>
            </div>

            <div class="info-box">
                <h4>Magic of createSlice</h4>
                <p><strong>You write:</strong> Simple functions that modify state<br>
                <strong>RTK automatically creates:</strong> Action creators, action types, and a reducer<br>
                <strong>Immer magic:</strong> You can "mutate" state directly! RTK uses Immer library under the hood to make it immutable. <code>state.value += 1</code> looks like mutation but actually creates a new state.</p>
            </div>

            <h3>Connecting the Slice to Your Store</h3>
            
            <p>Now connect your slice to the store:</p>

            <div class="code-block">
                <pre><code>// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});</code></pre>
            </div>

            <p>Your store now has a <code>counter</code> section in its state tree. The full state looks like: <code>{ counter: { value: 0 } }</code></p>

            <h3>Using Redux in Components: Counter App</h3>
            
            <p>Now for the fun partâ€”using your Redux state in React components! You'll use two hooks:</p>

            <ul>
                <li><code>useSelector</code>: Read data from the store</li>
                <li><code>useDispatch</code>: Send actions to update the store</li>
            </ul>

            <div class="code-block">
                <pre><code>// Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, reset } from './counterSlice';

function Counter() {
  // useSelector: pick which part of state you need
  const count = useSelector((state) => state.counter.value);
  
  // useDispatch: get the dispatch function
  const dispatch = useDispatch();

  return (
    &lt;div className="counter"&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      
      &lt;button onClick={() => dispatch(increment())}&gt;
        + Increment
      &lt;/button&gt;
      
      &lt;button onClick={() => dispatch(decrement())}&gt;
        - Decrement
      &lt;/button&gt;
      
      &lt;button onClick={() => dispatch(reset())}&gt;
        Reset
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Breaking It Down</h4>
                <p><strong>useSelector((state) => state.counter.value):</strong><br>
                - Function that "selects" a piece of state<br>
                - <code>state</code> = entire Redux store<br>
                - <code>state.counter</code> = your counter slice<br>
                - <code>state.counter.value</code> = the actual count number<br><br>
                <strong>dispatch(increment()):</strong><br>
                - <code>increment()</code> creates an action object<br>
                - <code>dispatch()</code> sends it to the store<br>
                - Store runs the reducer, updates state<br>
                - Component re-renders with new value</p>
            </div>

            <h3>Adding Actions with Payloads</h3>
            
            <p>Sometimes you want to send data with your action. Let's add an action to increment by a specific amount:</p>

            <div class="code-block">
                <pre><code>// counterSlice.js
const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    reset: (state) => {
      state.value = 0;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, reset, incrementByAmount } = counterSlice.actions;</code></pre>
            </div>

            <p>Now use it in your component:</p>

            <div class="code-block">
                <pre><code>function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();
  const [amount, setAmount] = useState(5);

  return (
    &lt;div className="counter"&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      
      &lt;button onClick={() => dispatch(increment())}&gt;+1&lt;/button&gt;
      &lt;button onClick={() => dispatch(decrement())}&gt;-1&lt;/button&gt;
      &lt;button onClick={() => dispatch(reset())}&gt;Reset&lt;/button&gt;
      
      &lt;hr /&gt;
      
      &lt;input
        type="number"
        value={amount}
        onChange={(e) => setAmount(Number(e.target.value))}
      /&gt;
      
      &lt;button onClick={() => dispatch(incrementByAmount(amount))}&gt;
        Add {amount}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Understanding action.payload</h4>
                <p>When you call <code>incrementByAmount(5)</code>, Redux Toolkit automatically creates this action:<br>
                <code>{ type: 'counter/incrementByAmount', payload: 5 }</code><br><br>
                In the reducer, <code>action.payload</code> contains whatever you passed in. It's the "data" of the action!</p>
            </div>

            <h3>Real Example: Todo App with Redux Toolkit</h3>
            
            <p>Counters are cute, but let's build something real. Here's a complete todo app with Redux Toolkit showing all the concepts together:</p>

            <div class="code-block">
                <pre><code>// todoSlice.js
import { createSlice } from '@reduxjs/toolkit';

const todoSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    filter: 'all', // 'all', 'active', 'completed'
  },
  reducers: {
    addTodo: (state, action) => {
      state.items.push({
        id: Date.now(),
        text: action.payload,
        completed: false,
      });
    },
    
    toggleTodo: (state, action) => {
      const todo = state.items.find(item => item.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    
    deleteTodo: (state, action) => {
      state.items = state.items.filter(item => item.id !== action.payload);
    },
    
    setFilter: (state, action) => {
      state.filter = action.payload;
    },
    
    clearCompleted: (state) => {
      state.items = state.items.filter(item => !item.completed);
    },
  },
});

export const {
  addTodo,
  toggleTodo,
  deleteTodo,
  setFilter,
  clearCompleted,
} = todoSlice.actions;

export default todoSlice.reducer;</code></pre>
            </div>

            <div class="info-box">
                <h4>Notice the Pattern</h4>
                <p>Each reducer function:<br>
                <strong>1. Gets state:</strong> Current state of the slice<br>
                <strong>2. Gets action:</strong> Contains payload (the data)<br>
                <strong>3. Updates state:</strong> "Mutate" it directly (Immer handles immutability)<br>
                <strong>4. No return needed:</strong> Just modify state and you're done!</p>
            </div>

            <p>Add the todo reducer to your store:</p>

            <div class="code-block">
                <pre><code>// store.js
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

export const store = configureStore({
  reducer: {
    todos: todoReducer,
  },
});</code></pre>
            </div>

            <h3>Todo Component: Putting It All Together</h3>
            
            <p>Now build the UI that uses this state:</p>

            <div class="code-block">
                <pre><code>// TodoApp.jsx
import { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  addTodo,
  toggleTodo,
  deleteTodo,
  setFilter,
  clearCompleted,
} from './todoSlice';

function TodoApp() {
  const [input, setInput] = useState('');
  const dispatch = useDispatch();
  
  // Get state from Redux
  const todos = useSelector((state) => state.todos.items);
  const filter = useSelector((state) => state.todos.filter);

  // Handle adding todo
  const handleAdd = () => {
    if (input.trim()) {
      dispatch(addTodo(input));
      setInput('');
    }
  };

  // Filter todos based on current filter
  const filteredTodos = todos.filter((todo) => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true; // 'all'
  });

  return (
    &lt;div className="todo-app"&gt;
      &lt;h1&gt;Redux Todo List&lt;/h1&gt;

      {/* Add Todo Form */}
      &lt;div className="add-todo"&gt;
        &lt;input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
          placeholder="What needs to be done?"
        /&gt;
        &lt;button onClick={handleAdd}&gt;Add&lt;/button&gt;
      &lt;/div&gt;

      {/* Filter Buttons */}
      &lt;div className="filters"&gt;
        &lt;button
          className={filter === 'all' ? 'active' : ''}
          onClick={() => dispatch(setFilter('all'))}
        &gt;
          All
        &lt;/button&gt;
        &lt;button
          className={filter === 'active' ? 'active' : ''}
          onClick={() => dispatch(setFilter('active'))}
        &gt;
          Active
        &lt;/button&gt;
        &lt;button
          className={filter === 'completed' ? 'active' : ''}
          onClick={() => dispatch(setFilter('completed'))}
        &gt;
          Completed
        &lt;/button&gt;
      &lt;/div&gt;

      {/* Todo List */}
      &lt;ul className="todo-list"&gt;
        {filteredTodos.map((todo) => (
          &lt;li key={todo.id} className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() => dispatch(deleteTodo(todo.id))}&gt;
              Delete
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;

      {/* Stats and Actions */}
      &lt;div className="footer"&gt;
        &lt;span&gt;
          {todos.filter((t) => !t.completed).length} items left
        &lt;/span&gt;
        &lt;button onClick={() => dispatch(clearCompleted())}&gt;
          Clear Completed
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="metaphor-box">
                <h4>The Redux Flow in Action</h4>
                <p><strong>User clicks "Add":</strong><br>
                1. Component calls <code>dispatch(addTodo(input))</code><br>
                2. Action flows to Redux store: <code>{ type: 'todos/addTodo', payload: 'Buy milk' }</code><br>
                3. Store runs the reducer, which adds the todo to state<br>
                4. Store notifies all subscribers: "State changed!"<br>
                5. useSelector hooks re-run, components get new data<br>
                6. React re-renders with updated UI<br><br>
                It's like a well-orchestrated danceâ€”everyone knows their role!</p>
            </div>

            <div class="info-box">
                <h4>Why This Code is Clean</h4>
                <p><strong>Separation of concerns:</strong><br>
                - Slice = All state logic in one place<br>
                - Component = Just UI and dispatching actions<br><br>
                <strong>Easy to test:</strong> Test reducers separately from components<br>
                <strong>Time-travel debugging:</strong> Redux DevTools lets you rewind/replay actions<br>
                <strong>Predictable:</strong> Same action + same state = same result, always</p>
            </div>

            <h3>Understanding Filtering Logic</h3>
            
            <p>Notice how filtering works in the todo appâ€”it's a common pattern:</p>

            <div class="code-block">
                <pre><code>// In component
const todos = useSelector((state) => state.todos.items);
const filter = useSelector((state) => state.todos.filter);

// Filter in the component
const filteredTodos = todos.filter((todo) => {
  if (filter === 'active') return !todo.completed;
  if (filter === 'completed') return todo.completed;
  return true; // 'all'
});</code></pre>
            </div>

            <p><strong>Why filter in the component?</strong> Derived data (filtered list) doesn't need to be in Redux state. The source of truth is the full <code>todos</code> array and the <code>filter</code> string. The filtered array is computed on-the-fly.</p>

            <div class="info-box">
                <h4>Alternative: Selector Functions</h4>
                <p>For more complex derived data, you can create selector functions:<br><br>
                <code>// todoSlice.js<br>
                export const selectFilteredTodos = (state) => {<br>
                &nbsp;&nbsp;const { items, filter } = state.todos;<br>
                &nbsp;&nbsp;if (filter === 'active') return items.filter(t => !t.completed);<br>
                &nbsp;&nbsp;if (filter === 'completed') return items.filter(t => t.completed);<br>
                &nbsp;&nbsp;return items;<br>
                };<br><br>
                // In component<br>
                const filteredTodos = useSelector(selectFilteredTodos);</code><br><br>
                This keeps filtering logic in the slice file, making it reusable!</p>
            </div>

            <h3>Multiple Slices: Scaling Your Store</h3>
            
            <p>Real apps have multiple features. Each gets its own slice:</p>

            <div class="code-block">
                <pre><code>// store.js
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './features/todos/todoSlice';
import userReducer from './features/user/userSlice';
import cartReducer from './features/cart/cartSlice';

export const store = configureStore({
  reducer: {
    todos: todoReducer,
    user: userReducer,
    cart: cartReducer,
  },
});</code></pre>
            </div>

            <p>Your state tree now looks like:</p>

            <div class="code-block">
                <pre><code>{
  todos: {
    items: [...],
    filter: 'all',
  },
  user: {
    name: 'Alice',
    loggedIn: true,
  },
  cart: {
    items: [...],
    total: 89.99,
  },
}</code></pre>
            </div>

            <p>Each slice is independent. They don't know about each other, which keeps your code modular and maintainable.</p>

            <div class="metaphor-box">
                <h4>The Department Store Metaphor</h4>
                <p>Your Redux store is like a department store:<br><br>
                <strong>Electronics department:</strong> Has its own inventory and staff (electronics slice)<br>
                <strong>Clothing department:</strong> Separate inventory and staff (clothing slice)<br>
                <strong>Central register:</strong> The store (configureStore) knows about all departments<br>
                <strong>Shoppers:</strong> Components can visit any department they need<br><br>
                Each department operates independently but is part of one store!</p>
            </div>

            <h3>When to Use Redux vs Context</h3>
            
            <p>Here's the honest truth about when to reach for Redux:</p>

            <div class="info-box">
                <h4>Use Context When:</h4>
                <p>âœ… Small app (1-10 components)<br>
                âœ… State is simple (user info, theme, language)<br>
                âœ… Updates are infrequent<br>
                âœ… You're learningâ€”Context is easier to start with<br>
                âœ… Team is small and prefers simplicity</p>
            </div>

            <div class="info-box">
                <h4>Use Redux Toolkit When:</h4>
                <p>âœ… Medium/large app (50+ components)<br>
                âœ… Complex state logic (lots of interactions between data)<br>
                âœ… Many components need the same data<br>
                âœ… You need time-travel debugging<br>
                âœ… Working with a team (Redux patterns are well-known)<br>
                âœ… State updates from multiple sources (user actions, websockets, timers)</p>
            </div>

            <div class="metaphor-box">
                <h4>The Tool Analogy</h4>
                <p><strong>Context:</strong> A Swiss Army knifeâ€”versatile, portable, good for most tasks<br>
                <strong>Redux:</strong> A full toolboxâ€”heavy to carry, but has the right tool for every job<br><br>
                Don't bring a toolbox to cut an apple. But don't try to build a house with just a pocket knife!</p>
            </div>

            <h3>Redux DevTools: Your Debugging Superpower</h3>
            
            <p>One of Redux's killer features is the Redux DevTools browser extension. Install it and you get:</p>

            <ul>
                <li><strong>Action history:</strong> See every action that's been dispatched</li>
                <li><strong>State inspector:</strong> View your entire state tree at any point</li>
                <li><strong>Time-travel:</strong> Click any past action to see what state looked like then</li>
                <li><strong>Action replay:</strong> Re-run actions to test behavior</li>
                <li><strong>State diff:</strong> See exactly what changed with each action</li>
            </ul>

            <div class="code-block">
                <pre><code>// DevTools work automatically with configureStore!
// No extra setup neededâ€”just install the browser extension

// Example: What you see in DevTools after adding a todo
Action: todos/addTodo
Payload: "Buy milk"

Diff:
+ items[0] = { id: 1234, text: "Buy milk", completed: false }

Next State:
{
  todos: {
    items: [{ id: 1234, text: "Buy milk", completed: false }],
    filter: "all"
  }
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Why DevTools Are Amazing</h4>
                <p>Imagine debugging a bug where "sometimes the cart total is wrong." With Redux DevTools:<br><br>
                1. Open DevTools, see all actions<br>
                2. Find the "addToCart" action<br>
                3. See exactly what payload was sent<br>
                4. Check state before and after<br>
                5. Spot the bug in 30 seconds<br><br>
                Without it? You'd be adding console.logs everywhere and refreshing the page 50 times!</p>
            </div>

            <h3>Redux Toolkit Best Practices</h3>
            
            <p>Here are some tips for writing clean Redux code:</p>

            <div class="info-box">
                <h4>1. Keep Slices Focused</h4>
                <p>Each slice should handle one feature or domain:<br>
                âœ… userSlice, cartSlice, productsSlice<br>
                âŒ appSlice that has everything<br><br>
                Think of slices as chapters in a bookâ€”each has a clear topic.</p>
            </div>

            <div class="info-box">
                <h4>2. Don't Put Everything in Redux</h4>
                <p>Not all state needs to be global:<br>
                <strong>Redux:</strong> User info, cart, products, todos<br>
                <strong>Local state:</strong> Form inputs, modal open/closed, hover effects<br><br>
                Rule of thumb: If only one component cares, use useState!</p>
            </div>

            <div class="info-box">
                <h4>3. Name Actions Clearly</h4>
                <p>Action names should describe what happened, not what to do:<br>
                âœ… addTodo, userLoggedIn, cartUpdated<br>
                âŒ setData, updateState, handleClick<br><br>
                Good names make your DevTools history readable like a story!</p>
            </div>

            <div class="info-box">
                <h4>4. Organize Files by Feature</h4>
                <p>Don't put all slices in one folder. Group by feature:<br>
                <code>features/<br>
                &nbsp;&nbsp;todos/<br>
                &nbsp;&nbsp;&nbsp;&nbsp;todoSlice.js<br>
                &nbsp;&nbsp;&nbsp;&nbsp;TodoList.jsx<br>
                &nbsp;&nbsp;&nbsp;&nbsp;TodoItem.jsx<br>
                &nbsp;&nbsp;user/<br>
                &nbsp;&nbsp;&nbsp;&nbsp;userSlice.js<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Profile.jsx<br>
                &nbsp;&nbsp;cart/<br>
                &nbsp;&nbsp;&nbsp;&nbsp;cartSlice.js<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Cart.jsx</code><br><br>
                Related code stays togetherâ€”easier to find and maintain!</p>
            </div>

            <div class="metaphor-box">
                <h4>You're Now a Redux Toolkit Developer!</h4>
                <p>You've learned the modern way to handle state in professional React apps. Redux Toolkit eliminates the boilerplate, gives you amazing dev tools, and scales from small apps to massive codebases. Remember: start with Context for simple projects, but when your app grows complex, Redux Toolkit is your friend. You've got both tools in your beltâ€”use the right one for the job!</p>
            </div>
        </section>

        <!-- SECTION 4: API Integration -->
        <section id="api-integration" class="section">
            <h2 class="section-title">API Integration</h2>
            <p class="section-intro">Your frontend is looking good! But right now it's like a beautiful restaurant with no kitchenâ€”it has no data. Real apps need to talk to servers to get data, save user info, fetch products, etc. That's where APIs come in. Let's learn how to connect your frontend to the backend!</p>

            <h3>What is an API? (Review from Section 1)</h3>
            
            <p>Quick recap: API stands for Application Programming Interface. In simple terms, it's a menu of actions your app can request from a server.</p>

            <div class="metaphor-box">
                <h4>The Restaurant Menu Metaphor</h4>
                <p>An API is like a restaurant menu:<br><br>
                <strong>Menu:</strong> "You can order: burger, pizza, salad"<br>
                <strong>API:</strong> "You can request: user data, product list, weather info"<br><br>
                You (frontend) look at the menu, place an order, and the kitchen (backend) prepares it and sends it back.</p>
            </div>

            <h4>HTTP Methods: The Basic Actions</h4>
            
            <p>When talking to APIs, you use different "methods" depending on what you want to do:</p>

            <div class="code">GET    - Read/Fetch data ("Give me the user info")
POST   - Create new data ("Create a new user account")
PUT    - Update existing data ("Update user email")
DELETE - Remove data ("Delete this post")

// Think of it like:
GET    = Read a book
POST   = Write a new book
PUT    = Edit an existing book
DELETE = Throw away a book</div>

            <h3>Making Your First API Request</h3>
            
            <p>JavaScript has a built-in function called <span class="inline-code">fetch()</span> that lets you talk to APIs:</p>

            <div class="code">// Basic fetch syntax
fetch('https://api.example.com/users')
  .then(response => response.json())  // Convert to JavaScript object
  .then(data => {
    console.log(data);  // Do something with the data
  })
  .catch(error => {
    console.error('Error:', error);  // Handle errors
  });</div>

            <p>Let's break this down step by step:</p>

            <div class="info-box">
                <h4>How fetch() Works</h4>
                <p><strong>1. fetch(url):</strong> Makes a request to the URL<br>
                <strong>2. .then(response => ...):</strong> Waits for server response<br>
                <strong>3. response.json():</strong> Converts response to usable JavaScript<br>
                <strong>4. .then(data => ...):</strong> Now you have the data!<br>
                <strong>5. .catch(error => ...):</strong> Handles errors if something goes wrong</p>
            </div>

            <h4>Modern Way: async/await (Easier to Read!)</h4>
            
            <p>There's a cleaner way to write fetch requests:</p>

            <div class="code">// Modern async/await syntax (preferred!)
async function getUsers() {
  try {
    const response = await fetch('https://api.example.com/users');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

getUsers();</div>

            <div class="metaphor-box">
                <h4>Why async/await is Better</h4>
                <p>Think of <span class="inline-code">.then().then().then()</span> like nested Russian dolls - you keep opening one to get to the next.<br><br>
                <span class="inline-code">async/await</span> is like laying everything out in a line - much easier to read and understand!</p>
            </div>

            <h3>Complete React Example: Fetching User Data</h3>
            
            <div class="code">import React, { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);  // Store users
  const [loading, setLoading] = useState(true);  // Track loading state
  const [error, setError] = useState(null);  // Track errors
  
  useEffect(() => {
    // Fetch users when component mounts
    async function fetchUsers() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        
        if (!response.ok) {
          throw new Error('Failed to fetch');
        }
        
        const data = await response.json();
        setUsers(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    
    fetchUsers();
  }, []);  // Empty array = run once when component loads
  
  // Show loading
  if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;
  
  // Show error
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;
  
  // Show users
  return (
    &lt;div&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
      &lt;ul&gt;
        {users.map(user => (
          &lt;li key={user.id}&gt;{user.name} - {user.email}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>The Three States Pattern</h4>
                <p>When fetching data, always track:<br><br>
                <strong>1. Loading:</strong> Waiting for data<br>
                <strong>2. Error:</strong> Something went wrong<br>
                <strong>3. Success:</strong> Got the data!<br><br>
                This gives users feedback instead of a blank screen.</p>
            </div>

            <h3>Sending Data: POST Requests</h3>
            
            <p>GET requests fetch data. POST requests send data to create something new:</p>

            <div class="code">async function createUser(userData) {
  try {
    const response = await fetch('https://api.example.com/users', {
      method: 'POST',  // Specify POST method
      headers: {
        'Content-Type': 'application/json'  // Tell server we're sending JSON
      },
      body: JSON.stringify(userData)  // Convert JavaScript object to JSON string
    });
    
    const data = await response.json();
    console.log('User created:', data);
  } catch (error) {
    console.error('Error creating user:', error);
  }
}

// Usage
createUser({
  name: 'Alice',
  email: 'alice@example.com',
  age: 28
});</div>

            <h4>Complete Form Submission Example</h4>
            
            <div class="code">function SignupForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  const [message, setMessage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();  // Prevent page reload
    setIsSubmitting(true);
    setMessage('');
    
    try {
      const response = await fetch('https://api.example.com/signup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (!response.ok) {
        throw new Error('Signup failed');
      }
      
      const data = await response.json();
      setMessage('Signup successful! Welcome ' + data.username);
    } catch (error) {
      setMessage('Error: ' + error.message);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        placeholder="Username"
        value={formData.username}
        onChange={(e) => setFormData({...formData, username: e.target.value})}
      /&gt;
      &lt;input
        type="email"
        placeholder="Email"
        value={formData.email}
        onChange={(e) => setFormData({...formData, email: e.target.value})}
      /&gt;
      &lt;input
        type="password"
        placeholder="Password"
        value={formData.password}
        onChange={(e) => setFormData({...formData, password: e.target.value})}
      /&gt;
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Signing up...' : 'Sign Up'}
      &lt;/button&gt;
      {message && &lt;p&gt;{message}&lt;/p&gt;}
    &lt;/form&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Common API Mistakes</h4>
                <p><strong>1. Forgetting await:</strong> Without await, you get a Promise, not the data<br>
                <strong>2. Not handling errors:</strong> Always use try/catch<br>
                <strong>3. Not showing loading state:</strong> Users see blank screen<br>
                <strong>4. Forgetting headers:</strong> Server needs to know you're sending JSON<br>
                <strong>5. CORS errors:</strong> Your backend needs to allow requests from your frontend domain</p>
            </div>

            <div class="metaphor-box">
                <h4>You're Now Full-Stack Ready!</h4>
                <p>Congratulations! You now know how to connect a frontend to a backend. Your components can fetch data, submit forms, and create a complete user experience. This is THE skill that makes you a full-stack developerâ€”you can build the beautiful frontend AND connect it to real data!</p>
            </div>

            <h3>Error Handling Deep Dive: Making APIs Production-Ready</h3>
            
            <p>You've learned the basics of fetch, but real-world APIs are messy. Networks fail, servers crash, APIs return unexpected data. Let's learn how to handle errors like a professional developer and give users a smooth experience even when things go wrong!</p>

            <div class="metaphor-box">
                <h4>The Unreliable Restaurant Delivery</h4>
                <p>Imagine ordering food delivery. Things can go wrong at different stages:<br><br>
                <strong>Network error:</strong> Your phone has no signalâ€”order never leaves your device<br>
                <strong>HTTP error:</strong> Restaurant is closed (404), kitchen is overwhelmed (503)<br>
                <strong>Data error:</strong> You ordered pizza, got sushi (API sent wrong data)<br><br>
                You need to handle ALL these scenarios gracefully instead of just showing "Something went wrong"!</p>
            </div>

            <h4>Network Errors vs HTTP Errors</h4>
            
            <p>There are TWO types of errors when making API calls, and they need different handling:</p>

            <div class="code-block">
                <pre><code>// Network Error: Request never reached the server
// Examples: No internet, DNS failed, CORS blocked

try {
  const response = await fetch('https://api.example.com/data');
  // If we get here, request succeeded!
} catch (error) {
  // Network error caught here
  console.error('Network error:', error);
  // Show user: "Check your internet connection"
}

// HTTP Error: Server responded, but with error status
// Examples: 404 Not Found, 500 Server Error, 401 Unauthorized

try {
  const response = await fetch('https://api.example.com/data');
  
  if (!response.ok) {
    // Server sent error status (400, 404, 500, etc.)
    throw new Error(`HTTP error! Status: ${response.status}`);
  }
  
  const data = await response.json();
} catch (error) {
  console.error('HTTP error:', error);
  // Show user: "Server is having issues, try again later"
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Key Insight: fetch() Doesn't Reject on HTTP Errors!</h4>
                <p><strong>Surprising behavior:</strong> fetch() only throws errors for network failures, NOT for HTTP error statuses like 404 or 500!<br><br>
                <strong>response.ok:</strong> Returns false if status is 400-599<br>
                <strong>response.status:</strong> The actual HTTP status code (200, 404, 500, etc.)<br><br>
                You MUST check <code>response.ok</code> manually to catch HTTP errors!</p>
            </div>

            <h4>Complete Error Handling Pattern</h4>
            
            <p>Here's the professional way to handle ALL types of errors:</p>

            <div class="code-block">
                <pre><code>async function fetchWithErrorHandling(url) {
  try {
    // Make request
    const response = await fetch(url);
    
    // Check if response is OK (status 200-299)
    if (!response.ok) {
      // Handle different HTTP errors
      if (response.status === 404) {
        throw new Error('Resource not found');
      } else if (response.status === 401) {
        throw new Error('Unauthorized - please login');
      } else if (response.status === 500) {
        throw new Error('Server error - try again later');
      } else {
        throw new Error(`HTTP error: ${response.status}`);
      }
    }
    
    // Parse JSON
    const data = await response.json();
    
    // Validate data structure
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid data received');
    }
    
    return { success: true, data };
    
  } catch (error) {
    // Network error or thrown error
    if (error.name === 'TypeError') {
      // Network error (no internet, DNS failure, etc.)
      return {
        success: false,
        error: 'Network error - check your connection',
        details: error.message
      };
    } else {
      // HTTP error or data validation error
      return {
        success: false,
        error: error.message,
        details: error.message
      };
    }
  }
}

// Usage
const result = await fetchWithErrorHandling('https://api.example.com/users');

if (result.success) {
  console.log('Data:', result.data);
} else {
  console.error('Error:', result.error);
}</code></pre>
            </div>

            <h4>Loading, Error, and Success States in React</h4>
            
            <p>Every API call in React should track three states to give users feedback:</p>

            <div class="code-block">
                <pre><code>function UserProfile({ userId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function loadUser() {
      try {
        // Start loading
        setLoading(true);
        setError(null);
        
        const response = await fetch(`https://api.example.com/users/${userId}`);
        
        if (!response.ok) {
          throw new Error(`Failed to load user: ${response.status}`);
        }
        
        const userData = await response.json();
        
        // Success!
        setData(userData);
        
      } catch (err) {
        // Error occurred
        setError(err.message);
      } finally {
        // Always stop loading, whether success or error
        setLoading(false);
      }
    }
    
    loadUser();
  }, [userId]);
  
  // Render loading state
  if (loading) {
    return (
      &lt;div className="loading"&gt;
        &lt;div className="spinner"&gt;&lt;/div&gt;
        &lt;p&gt;Loading user profile...&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  // Render error state
  if (error) {
    return (
      &lt;div className="error"&gt;
        &lt;h3&gt;âŒ Oops! Something went wrong&lt;/h3&gt;
        &lt;p&gt;{error}&lt;/p&gt;
        &lt;button onClick={() => window.location.reload()}&gt;
          Try Again
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
  // Render success state
  return (
    &lt;div className="user-profile"&gt;
      &lt;h2&gt;{data.name}&lt;/h2&gt;
      &lt;p&gt;Email: {data.email}&lt;/p&gt;
      &lt;p&gt;Joined: {new Date(data.createdAt).toLocaleDateString()}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>The Three States Pattern</h4>
                <p><strong>Loading (waiting):</strong> Show spinner, skeleton UI, or "Loading..." message<br>
                <strong>Error (failed):</strong> Show user-friendly error with retry button<br>
                <strong>Success (got data):</strong> Show the actual content<br><br>
                This pattern gives users feedback at every stage and prevents confusion!</p>
            </div>

            <h4>User-Friendly Error Messages</h4>
            
            <p>Don't show technical errors to users. Translate them into friendly messages:</p>

            <div class="code-block">
                <pre><code>function getErrorMessage(error) {
  // Network errors
  if (error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
    return {
      title: 'Connection Problem',
      message: 'Please check your internet connection and try again.',
      icon: 'ğŸ“¡'
    };
  }
  
  // Timeout errors
  if (error.message.includes('timeout')) {
    return {
      title: 'Request Timed Out',
      message: 'The server took too long to respond. Please try again.',
      icon: 'â±ï¸'
    };
  }
  
  // Authentication errors
  if (error.status === 401 || error.status === 403) {
    return {
      title: 'Access Denied',
      message: 'Please log in to view this content.',
      icon: 'ğŸ”’'
    };
  }
  
  // Not found errors
  if (error.status === 404) {
    return {
      title: 'Not Found',
      message: 'The requested content could not be found.',
      icon: 'ğŸ”'
    };
  }
  
  // Server errors
  if (error.status >= 500) {
    return {
      title: 'Server Error',
      message: 'Our servers are having issues. Please try again in a few minutes.',
      icon: 'ğŸ› ï¸'
    };
  }
  
  // Generic error
  return {
    title: 'Something Went Wrong',
    message: 'An unexpected error occurred. Please try again.',
    icon: 'âŒ'
  };
}

// Usage in component
function DataDisplay() {
  const [error, setError] = useState(null);
  
  // ... fetch logic ...
  
  if (error) {
    const errorInfo = getErrorMessage(error);
    return (
      &lt;div className="error-display"&gt;
        &lt;span className="error-icon"&gt;{errorInfo.icon}&lt;/span&gt;
        &lt;h3&gt;{errorInfo.title}&lt;/h3&gt;
        &lt;p&gt;{errorInfo.message}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  // ... rest of component ...
}</code></pre>
            </div>

            <h4>Retry Logic: Automatic Recovery</h4>
            
            <p>Sometimes errors are temporary (network hiccup, server restart). Implement retry logic to recover automatically:</p>

            <div class="code-block">
                <pre><code>async function fetchWithRetry(url, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }
      
      return await response.json();
      
    } catch (error) {
      const isLastAttempt = i === maxRetries - 1;
      
      if (isLastAttempt) {
        // All retries failed
        throw new Error(`Failed after ${maxRetries} attempts: ${error.message}`);
      }
      
      // Wait before retrying (exponential backoff)
      const waitTime = delay * Math.pow(2, i);
      console.log(`Retry ${i + 1}/${maxRetries} after ${waitTime}ms...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
}

// Usage
try {
  const data = await fetchWithRetry('https://api.example.com/data');
  console.log('Success:', data);
} catch (error) {
  console.error('All retries failed:', error);
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Exponential Backoff Explained</h4>
                <p><strong>First retry:</strong> Wait 1 second (1000ms)<br>
                <strong>Second retry:</strong> Wait 2 seconds (2000ms)<br>
                <strong>Third retry:</strong> Wait 4 seconds (4000ms)<br><br>
                This gives the server time to recover and prevents overwhelming it with requests. It's the polite way to retry!</p>
            </div>

            <div class="warning-box">
                <h4>When NOT to Retry</h4>
                <p><strong>Don't retry:</strong> 400 Bad Request, 401 Unauthorized, 404 Not Found<br>
                These are client errorsâ€”retrying won't help!<br><br>
                <strong>Do retry:</strong> 500 Server Error, 503 Service Unavailable, Network timeout<br>
                These are temporary issues that might resolve.</p>
            </div>

            <h3>Axios: The Better fetch() Alternative</h3>
            
            <p>While fetch() is built into browsers, the Axios library provides a much better developer experience with automatic error handling, request/response transformation, and powerful features. Most professional React developers use Axios!</p>

            <div class="metaphor-box">
                <h4>fetch() vs Axios: The Tool Comparison</h4>
                <p><strong>fetch():</strong> A basic hammerâ€”gets the job done but requires extra work for advanced tasks<br>
                <strong>Axios:</strong> A power drill with attachmentsâ€”does everything fetch() does PLUS automatic JSON parsing, better errors, interceptors, and more!<br><br>
                Both work, but Axios makes your life easier.</p>
            </div>

            <h4>Installing and Setting Up Axios</h4>
            
            <div class="code-block">
                <pre><code>// Install via npm
npm install axios

// Import in your component
import axios from 'axios';</code></pre>
            </div>

            <h4>Why Axios is Better Than fetch()</h4>
            
            <p>Let's compare the same request with fetch() vs Axios:</p>

            <div class="code-block">
                <pre><code>// With fetch() - more code, manual parsing
try {
  const response = await fetch('https://api.example.com/users');
  
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  
  const data = await response.json();  // Manual JSON parsing
  console.log(data);
} catch (error) {
  console.error('Error:', error);
}

// With Axios - cleaner, auto parsing
try {
  const response = await axios.get('https://api.example.com/users');
  console.log(response.data);  // Already parsed JSON!
} catch (error) {
  console.error('Error:', error.response?.status, error.message);
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Axios Advantages</h4>
                <p><strong>1. Automatic JSON parsing:</strong> No need for <code>.json()</code><br>
                <strong>2. Better error handling:</strong> Automatically rejects on HTTP errors<br>
                <strong>3. Request/response interceptors:</strong> Modify requests globally<br>
                <strong>4. Timeout support:</strong> Built-in timeout configuration<br>
                <strong>5. Progress tracking:</strong> Upload/download progress events<br>
                <strong>6. Cancel requests:</strong> Abort ongoing requests<br>
                <strong>7. Cleaner syntax:</strong> Less boilerplate code</p>
            </div>

            <h4>Basic Axios CRUD Operations</h4>
            
            <div class="code-block">
                <pre><code>// GET request
const getUsers = async () => {
  const response = await axios.get('https://api.example.com/users');
  return response.data;
};

// POST request (create)
const createUser = async (userData) => {
  const response = await axios.post('https://api.example.com/users', userData);
  return response.data;
};

// PUT request (update)
const updateUser = async (userId, userData) => {
  const response = await axios.put(`https://api.example.com/users/${userId}`, userData);
  return response.data;
};

// DELETE request
const deleteUser = async (userId) => {
  const response = await axios.delete(`https://api.example.com/users/${userId}`);
  return response.data;
};

// Usage
const users = await getUsers();
const newUser = await createUser({ name: 'Alice', email: 'alice@example.com' });
const updated = await updateUser(123, { name: 'Alice Updated' });
await deleteUser(123);</code></pre>
            </div>

            <h4>Creating an Axios Instance with Base Configuration</h4>
            
            <p>Instead of repeating the base URL and headers in every request, create a configured Axios instance:</p>

            <div class="code-block">
                <pre><code>// api.js - Create configured instance
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,  // 10 seconds
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;

// Now in your components
import api from './api';

// No need to repeat base URL!
const users = await api.get('/users');
const user = await api.get(`/users/${userId}`);
const created = await api.post('/users', { name: 'Bob' });</code></pre>
            </div>

            <h4>Interceptors: Automatic Auth Token Injection</h4>
            
            <p>Interceptors let you modify requests/responses globally. The most common use case: adding authentication tokens to every request!</p>

            <div class="code-block">
                <pre><code>// api.js - Setup with interceptor
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
});

// Request interceptor - runs before EVERY request
api.interceptors.request.use(
  (config) => {
    // Get token from localStorage
    const token = localStorage.getItem('authToken');
    
    // Add token to headers if it exists
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    console.log('Request:', config.method.toUpperCase(), config.url);
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - runs after EVERY response
api.interceptors.response.use(
  (response) => {
    console.log('Response:', response.status, response.config.url);
    return response;
  },
  (error) => {
    // Handle errors globally
    if (error.response?.status === 401) {
      // Unauthorized - redirect to login
      console.log('Token expired, redirecting to login...');
      localStorage.removeItem('authToken');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;</code></pre>
            </div>

            <div class="metaphor-box">
                <h4>Interceptors: The Security Guard Metaphor</h4>
                <p><strong>Request interceptor:</strong> Security guard at entranceâ€”checks every person entering (request) and adds ID badge (auth token)<br>
                <strong>Response interceptor:</strong> Security guard at exitâ€”checks everyone leaving (response) and handles issues (expired badge = redirect to reception)</p>
            </div>

            <h4>Global Error Handling with Axios</h4>
            
            <p>Handle all API errors in one place instead of try-catch in every component:</p>

            <div class="code-block">
                <pre><code>// api.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com',
});

// Global error handler
api.interceptors.response.use(
  (response) => response,
  (error) => {
    // Network error
    if (!error.response) {
      console.error('Network error:', error);
      alert('Network error! Check your connection.');
      return Promise.reject({ message: 'Network error' });
    }
    
    // HTTP errors
    const status = error.response.status;
    
    if (status === 401) {
      alert('Session expired. Please login again.');
      // Redirect to login
      window.location.href = '/login';
    } else if (status === 403) {
      alert('You do not have permission to access this.');
    } else if (status === 404) {
      alert('Resource not found.');
    } else if (status >= 500) {
      alert('Server error. Please try again later.');
    }
    
    return Promise.reject(error);
  }
);

export default api;</code></pre>
            </div>

            <h4>Request/Response Transformation</h4>
            
            <p>Axios lets you transform data automatically before sending or after receiving:</p>

            <div class="code-block">
                <pre><code>const api = axios.create({
  baseURL: 'https://api.example.com',
  
  // Transform request data
  transformRequest: [(data) => {
    // Add timestamp to all requests
    return {
      ...data,
      timestamp: new Date().toISOString(),
    };
  }],
  
  // Transform response data
  transformResponse: [(data) => {
    // Parse JSON and add helper methods
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      receivedAt: new Date().toISOString(),
    };
  }],
});</code></pre>
            </div>

            <div class="warning-box">
                <h4>Axios Error Object Structure</h4>
                <p>When Axios throws an error, it has this structure:<br><br>
                <code>error.response</code>: Server responded with error status (data, status, headers)<br>
                <code>error.request</code>: Request was made but no response<br>
                <code>error.message</code>: Error message<br><br>
                Always check <code>error.response</code> first to determine error type!</p>
            </div>

            <h3>React Query: The Ultimate Data Fetching Solution</h3>
            
            <p>You've learned fetch() and Axios, but there's an even better way: React Query (also called TanStack Query). It's a library that handles ALL the hard parts of data fetchingâ€”caching, background updates, loading states, error handling, and moreâ€”automatically!</p>

            <div class="metaphor-box">
                <h4>The Smart Refrigerator Metaphor</h4>
                <p><strong>Without React Query:</strong> Every time you want milk, you walk to the store, buy it, walk back. If multiple people want milk at the same time, everyone goes to the store separately.<br><br>
                <strong>With React Query:</strong> You have a smart refrigerator that:<br>
                â€¢ Stores milk (caching)<br>
                â€¢ Knows when milk is getting old and automatically buys fresh (background refetch)<br>
                â€¢ If someone already went to the store, others just take from the fridge (deduplication)<br>
                â€¢ Shows you when milk is being fetched (loading states)<br><br>
                React Query is your smart refrigerator for API data!</p>
            </div>

            <h4>Why React Query? The Problem It Solves</h4>
            
            <p>Without React Query, you write this in EVERY component:</p>

            <div class="code-block">
                <pre><code>// Without React Query - repetitive code
function UserList() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch('/api/users');
        const data = await response.json();
        setData(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }
    fetchData();
  }, []);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  return &lt;div&gt;{/* render data */}&lt;/div&gt;;
}</code></pre>
            </div>

            <p>With React Query, it's just:</p>

            <div class="code-block">
                <pre><code>// With React Query - simple and powerful!
import { useQuery } from '@tanstack/react-query';

function UserList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  return &lt;div&gt;{/* render data */}&lt;/div&gt;;
}</code></pre>
            </div>

            <div class="info-box">
                <h4>React Query Superpowers</h4>
                <p><strong>Automatic caching:</strong> Data fetched once is cachedâ€”other components get it instantly<br>
                <strong>Background refetch:</strong> Automatically refreshes stale data<br>
                <strong>Deduplication:</strong> Multiple components requesting same data? Only one request made<br>
                <strong>Optimistic updates:</strong> UI updates instantly before server confirms<br>
                <strong>Retry logic:</strong> Automatically retries failed requests<br>
                <strong>Pagination/Infinite scroll:</strong> Built-in support<br>
                <strong>DevTools:</strong> Amazing dev tools to inspect queries and cache</p>
            </div>

            <h4>Installing and Setting Up React Query</h4>
            
            <div class="code-block">
                <pre><code>// Install
npm install @tanstack/react-query

// Setup in App.jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;YourApp /&gt;
    &lt;/QueryClientProvider&gt;
  );
}</code></pre>
            </div>

            <h4>useQuery Hook: Fetching Data</h4>
            
            <p>The <code>useQuery</code> hook is for GET requestsâ€”fetching data:</p>

            <div class="code-block">
                <pre><code>import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

function ProductList() {
  const { 
    data,           // The fetched data
    isLoading,      // Is currently fetching for the first time
    error,          // Error object if fetch failed
    isError,        // Boolean - did an error occur?
    isFetching,     // Is fetching (includes background refetch)
    refetch         // Function to manually refetch
  } = useQuery({
    queryKey: ['products'],  // Unique key for this query
    queryFn: async () => {   // Function that fetches data
      const response = await axios.get('/api/products');
      return response.data;
    },
    staleTime: 5 * 60 * 1000,  // Consider data fresh for 5 minutes
    cacheTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
    retry: 3,                   // Retry failed requests 3 times
  });
  
  if (isLoading) {
    return (
      &lt;div className="loading"&gt;
        &lt;span className="spinner"&gt;&lt;/span&gt;
        Loading products...
      &lt;/div&gt;
    );
  }
  
  if (isError) {
    return (
      &lt;div className="error"&gt;
        &lt;p&gt;Error: {error.message}&lt;/p&gt;
        &lt;button onClick={() => refetch()}&gt;Try Again&lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Products&lt;/h2&gt;
      {isFetching && &lt;div&gt;Updating...&lt;/div&gt;}
      &lt;div className="product-grid"&gt;
        {data.map(product => (
          &lt;div key={product.id} className="product-card"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Understanding queryKey</h4>
                <p>The <code>queryKey</code> is like a unique identifier for your data:<br><br>
                <code>['products']</code> - All products<br>
                <code>['products', { category: 'electronics' }]</code> - Electronics products<br>
                <code>['user', userId]</code> - Specific user<br><br>
                React Query uses this key to cache and retrieve data. Components with the same key share cached data!</p>
            </div>

            <h4>Query with Dynamic Parameters</h4>
            
            <div class="code-block">
                <pre><code>function UserProfile({ userId }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],  // Key includes userId
    queryFn: async () => {
      const response = await axios.get(`/api/users/${userId}`);
      return response.data;
    },
    enabled: !!userId,  // Only run if userId exists
  });
  
  // When userId changes, React Query automatically:
  // 1. Checks if data for new userId is cached
  // 2. If yes, returns cached data instantly
  // 3. If no, fetches new data
  // 4. Updates cache with new data
  
  if (!userId) return &lt;div&gt;Select a user&lt;/div&gt;;
  if (isLoading) return &lt;div&gt;Loading user...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <h4>useMutation Hook: Creating, Updating, Deleting Data</h4>
            
            <p>The <code>useMutation</code> hook is for POST, PUT, DELETE requestsâ€”changing data:</p>

            <div class="code-block">
                <pre><code>import { useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';

function CreateProductForm() {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: async (newProduct) => {
      const response = await axios.post('/api/products', newProduct);
      return response.data;
    },
    onSuccess: () => {
      // Invalidate and refetch products list
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    },
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const newProduct = {
      name: formData.get('name'),
      price: parseFloat(formData.get('price')),
    };
    mutation.mutate(newProduct);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input name="name" placeholder="Product name" required /&gt;
      &lt;input name="price" type="number" placeholder="Price" required /&gt;
      
      &lt;button 
        type="submit" 
        disabled={mutation.isPending}
      &gt;
        {mutation.isPending ? 'Creating...' : 'Create Product'}
      &lt;/button&gt;
      
      {mutation.isError && (
        &lt;div className="error"&gt;Error: {mutation.error.message}&lt;/div&gt;
      )}
      
      {mutation.isSuccess && (
        &lt;div className="success"&gt;Product created successfully!&lt;/div&gt;
      )}
    &lt;/form&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>Cache Invalidation</h4>
                <p><strong>Problem:</strong> After creating a product, the products list still shows old data (cached)<br>
                <strong>Solution:</strong> <code>invalidateQueries</code> marks data as stale, triggering automatic refetch<br><br>
                Think of it like marking milk in the fridge as expiredâ€”React Query automatically goes to the store to get fresh milk!</p>
            </div>

            <h4>Complete CRUD Example with React Query</h4>
            
            <p>Let's build a complete todo app with Create, Read, Update, Delete using React Query:</p>

            <div class="code-block">
                <pre><code>import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useState } from 'react';

const api = axios.create({ baseURL: '/api' });

function TodoApp() {
  const queryClient = useQueryClient();
  const [newTodo, setNewTodo] = useState('');
  
  // READ - Fetch all todos
  const { data: todos, isLoading, error } = useQuery({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await api.get('/todos');
      return response.data;
    },
  });
  
  // CREATE - Add new todo
  const createMutation = useMutation({
    mutationFn: async (text) => {
      const response = await api.post('/todos', { text, completed: false });
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
      setNewTodo('');
    },
  });
  
  // UPDATE - Toggle todo completion
  const updateMutation = useMutation({
    mutationFn: async ({ id, completed }) => {
      const response = await api.put(`/todos/${id}`, { completed });
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
  
  // DELETE - Remove todo
  const deleteMutation = useMutation({
    mutationFn: async (id) => {
      await api.delete(`/todos/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
  
  const handleCreate = (e) => {
    e.preventDefault();
    if (!newTodo.trim()) return;
    createMutation.mutate(newTodo);
  };
  
  const handleToggle = (todo) => {
    updateMutation.mutate({ 
      id: todo.id, 
      completed: !todo.completed 
    });
  };
  
  const handleDelete = (id) => {
    if (window.confirm('Delete this todo?')) {
      deleteMutation.mutate(id);
    }
  };
  
  if (isLoading) return &lt;div&gt;Loading todos...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;div className="todo-app"&gt;
      &lt;h1&gt;My Todos&lt;/h1&gt;
      
      {/* Create form */}
      &lt;form onSubmit={handleCreate}&gt;
        &lt;input
          value={newTodo}
          onChange={(e) => setNewTodo(e.target.value)}
          placeholder="What needs to be done?"
        /&gt;
        &lt;button type="submit" disabled={createMutation.isPending}&gt;
          {createMutation.isPending ? 'Adding...' : 'Add'}
        &lt;/button&gt;
      &lt;/form&gt;
      
      {/* Todo list */}
      &lt;ul className="todo-list"&gt;
        {todos.map(todo => (
          &lt;li key={todo.id} className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggle(todo)}
              disabled={updateMutation.isPending}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button 
              onClick={() => handleDelete(todo.id)}
              disabled={deleteMutation.isPending}
            &gt;
              Delete
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      
      {/* Stats */}
      &lt;div className="stats"&gt;
        Total: {todos.length} | 
        Active: {todos.filter(t => !t.completed).length} | 
        Completed: {todos.filter(t => t.completed).length}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="metaphor-box">
                <h4>React Query's Magic: The Smart Assistant</h4>
                <p>Imagine having a smart assistant who:<br><br>
                <strong>Remembers everything:</strong> "I already fetched todos 2 minutes ago, here you go!" (caching)<br>
                <strong>Keeps things fresh:</strong> "Let me check if there are updates..." (background refetch)<br>
                <strong>Coordinates requests:</strong> "3 people asked for todos at onceâ€”I'll make one request" (deduplication)<br>
                <strong>Handles failures gracefully:</strong> "Request failed, trying again..." (retry logic)<br><br>
                That's React Queryâ€”your smart data assistant!</p>
            </div>

            <h4>Optimistic Updates: Instant UI Feedback</h4>
            
            <p>Make your app feel lightning fast by updating the UI before the server responds:</p>

            <div class="code-block">
                <pre><code>const deleteMutation = useMutation({
  mutationFn: async (todoId) => {
    await api.delete(`/todos/${todoId}`);
  },
  
  // Optimistic update: Update UI immediately
  onMutate: async (todoId) => {
    // Cancel ongoing queries
    await queryClient.cancelQueries({ queryKey: ['todos'] });
    
    // Get current todos
    const previousTodos = queryClient.getQueryData(['todos']);
    
    // Optimistically update UI
    queryClient.setQueryData(['todos'], (old) => 
      old.filter(todo => todo.id !== todoId)
    );
    
    // Return context for rollback
    return { previousTodos };
  },
  
  // If mutation fails, rollback
  onError: (err, todoId, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos);
    alert('Failed to delete. Please try again.');
  },
  
  // Always refetch after success or error
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  },
});</code></pre>
            </div>

            <div class="info-box">
                <h4>Optimistic Updates Flow</h4>
                <p><strong>1. onMutate:</strong> Update UI instantly (before server response)<br>
                <strong>2. User sees change immediately:</strong> Feels super fast!<br>
                <strong>3. Server responds:</strong> Success or error<br>
                <strong>4. onError:</strong> If failed, rollback to previous state<br>
                <strong>5. onSettled:</strong> Refetch to ensure data matches server<br><br>
                Result: App feels instant, but stays in sync with server!</p>
            </div>

            <div class="warning-box">
                <h4>When to Use Each Tool</h4>
                <p><strong>fetch():</strong> Simple projects, learning basics, one-off requests<br>
                <strong>Axios:</strong> Need better error handling, interceptors, or request transformation<br>
                <strong>React Query:</strong> Complex apps with lots of data fetching, need caching/sync<br><br>
                <strong>Recommended combo:</strong> Axios + React Query = Best developer experience!</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered Advanced API Integration!</h4>
                <p>You now know how professionals handle APIs in production apps. You can handle errors gracefully, use Axios for clean requests, and leverage React Query for intelligent caching and state management. These skills separate junior developers from senior developersâ€”you're building apps that scale and provide amazing user experiences!</p>
            </div>
        </section>

        <!-- SECTION 5: Real-Time Features -->
        <section id="realtime-features" class="section">
            <h2 class="section-title">Real-Time Features</h2>
            <p class="section-intro">So far, your app fetches data when a page loads. But what if you want LIVE updatesâ€”like a chat app where messages appear instantly, or a stock ticker that updates prices in real-time? That's where WebSockets come in. Let's learn how to make your app "live"!</p>

            <h3>The Problem with Regular HTTP</h3>
            
            <p>Remember our restaurant metaphor? Regular HTTP (fetch requests) works like this:</p>

            <div class="metaphor-box">
                <h4>HTTP: One-Time Orders</h4>
                <p><strong>You:</strong> "Can I have a burger?" (GET request)<br>
                <strong>Kitchen:</strong> "Here's your burger!" (Response)<br>
                <strong>Connection closes.</strong><br><br>
                If you want updates, you have to keep asking: "Any new messages? How about now? Now?" This is called <strong>polling</strong> and it's inefficient.</p>
            </div>

            <h4>The Solution: WebSockets (Two-Way Connection)</h4>
            
            <div class="metaphor-box">
                <h4>WebSockets: Open Phone Line</h4>
                <p>Instead of placing separate orders, imagine having an open phone line with the kitchen:<br><br>
                <strong>You:</strong> "Keep me updated on order status"<br>
                <strong>Kitchen:</strong> "Will do! I'll call you when things change"<br>
                <strong>Connection stays open.</strong><br><br>
                The kitchen can now send you updates INSTANTLY without you asking each time.</p>
            </div>

            <h3>When Do You Need Real-Time?</h3>
            
            <p>Real-time features are POWERFUL but add complexity. Use them when:</p>

            <div class="code">// DO use real-time for:
â€¢ Chat applications (messages appear instantly)
â€¢ Live notifications ("John liked your post!")
â€¢ Multiplayer games (player positions update)
â€¢ Live dashboards (stock prices, analytics)
â€¢ Collaborative editing (Google Docs style)

// DON'T use real-time for:
â€¢ Static content (blog posts, product listings)
â€¢ Data that rarely changes (user profiles)
â€¢ One-time actions (form submissions)</div>

            <div class="info-box">
                <h4>Simple Rule</h4>
                <p>If data changes <strong>every few seconds and users need immediate updates</strong>, use real-time. Otherwise, regular fetch requests are simpler and perfectly fine!</p>
            </div>

            <h3>Simple WebSocket Example</h3>
            
            <p>Here's how to create a WebSocket connection in JavaScript:</p>

            <div class="code">// 1. Connect to WebSocket server
const socket = new WebSocket('ws://localhost:3000');

// 2. Listen for connection open
socket.onopen = () => {
  console.log('Connected to server!');
  socket.send('Hello server!');  // Send a message
};

// 3. Listen for messages from server
socket.onmessage = (event) => {
  console.log('Message from server:', event.data);
};

// 4. Listen for errors
socket.onerror = (error) => {
  console.error('WebSocket error:', error);
};

// 5. Listen for connection close
socket.onclose = () => {
  console.log('Disconnected from server');
};</div>

            <div class="info-box">
                <h4>WebSocket Events</h4>
                <p><strong>onopen:</strong> Connection established<br>
                <strong>onmessage:</strong> Received data from server<br>
                <strong>onerror:</strong> Something went wrong<br>
                <strong>onclose:</strong> Connection closed<br><br>
                Think of these like notification settingsâ€”you're telling the app what to do when each event happens.</p>
            </div>

            <h4>Complete React Chat Example</h4>
            
            <div class="code">import React, { useState, useEffect, useRef } from 'react';

function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef(null);
  
  useEffect(() => {
    // Connect to WebSocket server when component mounts
    socketRef.current = new WebSocket('ws://localhost:3000');
    
    socketRef.current.onopen = () => {
      console.log('Connected!');
      setIsConnected(true);
    };
    
    socketRef.current.onmessage = (event) => {
      // Add new message to list
      const newMessage = JSON.parse(event.data);
      setMessages(prev => [...prev, newMessage]);
    };
    
    socketRef.current.onclose = () => {
      console.log('Disconnected');
      setIsConnected(false);
    };
    
    // Cleanup: close connection when component unmounts
    return () => {
      socketRef.current.close();
    };
  }, []);  // Empty array = run once when component loads
  
  const sendMessage = (e) => {
    e.preventDefault();
    
    if (!inputValue.trim()) return;  // Don't send empty messages
    
    const message = {
      text: inputValue,
      timestamp: new Date().toISOString(),
      username: 'You'
    };
    
    // Send to server
    socketRef.current.send(JSON.stringify(message));
    
    // Clear input
    setInputValue('');
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Chat Room&lt;/h2&gt;
      &lt;div&gt;Status: {isConnected ? 'âœ… Connected' : 'âŒ Disconnected'}&lt;/div&gt;
      
      &lt;div style={{ border: '1px solid #ccc', padding: '10px', height: '300px', overflowY: 'scroll' }}&gt;
        {messages.map((msg, index) => (
          &lt;div key={index}&gt;
            &lt;strong&gt;{msg.username}:&lt;/strong&gt; {msg.text}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      &lt;form onSubmit={sendMessage}&gt;
        &lt;input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Type a message..."
          disabled={!isConnected}
        /&gt;
        &lt;button type="submit" disabled={!isConnected}&gt;
          Send
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Important: useRef for WebSockets</h4>
                <p>Notice we used <span class="inline-code">useRef</span> instead of <span class="inline-code">useState</span> for the socket? That's because:<br><br>
                â€¢ We don't want React re-rendering when socket changes<br>
                â€¢ We need the SAME socket instance across re-renders<br>
                â€¢ <span class="inline-code">useRef</span> persists values without causing re-renders</p>
            </div>

            <h3>Simple Backend Example (Node.js)</h3>
            
            <p>To test your WebSocket frontend, you need a simple backend. Here's a basic Node.js WebSocket server:</p>

            <div class="code">// Install: npm install ws
const WebSocket = require('ws');

const server = new WebSocket.Server({ port: 3000 });

const clients = new Set();

server.on('connection', (socket) => {
  console.log('Client connected');
  clients.add(socket);
  
  // When client sends message, broadcast to all clients
  socket.on('message', (message) => {
    console.log('Received:', message);
    
    // Send to all connected clients
    clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  socket.on('close', () => {
    console.log('Client disconnected');
    clients.delete(socket);
  });
});

console.log('WebSocket server running on ws://localhost:3000');</div>

            <div class="info-box">
                <h4>What This Server Does</h4>
                <p><strong>1. Creates WebSocket server</strong> on port 3000<br>
                <strong>2. Tracks connected clients</strong> in a Set<br>
                <strong>3. Receives messages</strong> and broadcasts to all clients<br>
                <strong>4. Handles disconnections</strong> by removing from Set<br><br>
                This creates a simple chat room where everyone sees everyone's messages!</p>
            </div>

            <h4>Socket.io: The Easy Way</h4>
            
            <p>Raw WebSockets are powerful but basic. Most developers use <strong>Socket.io</strong> libraryâ€”it adds automatic reconnection, rooms, and easier APIs:</p>

            <div class="code">// Backend with Socket.io (easier!)
const io = require('socket.io')(3000);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  socket.on('chat-message', (message) => {
    // Broadcast to everyone except sender
    socket.broadcast.emit('chat-message', message);
  });
  
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

// Frontend with Socket.io
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

// Send message
socket.emit('chat-message', { text: 'Hello!' });

// Receive messages
socket.on('chat-message', (message) => {
  console.log('New message:', message);
});</div>

            <div class="metaphor-box">
                <h4>You've Unlocked Real-Time!</h4>
                <p>Real-time features make apps feel alive and responsive. Chat apps, live notifications, collaborative toolsâ€”they all use WebSockets or Socket.io. You now have the foundation to build interactive, live experiences. Start with simple chat, then expand to more complex features as you grow!</p>
            </div>

            <h3>Part 1: WebSocket Deep Dive</h3>

            <p>Let's take a deeper look at WebSocketsâ€”what they are, how they differ from other techniques, and when you should (and shouldn't) use them.</p>

            <h4>WebSockets vs Polling: The Full Story</h4>

            <p>Before WebSockets existed, developers had to use "polling" to get live updates. Let's compare these approaches:</p>

            <div class="code">// METHOD 1: Short Polling (old way, inefficient)
// Client asks "Any updates?" every few seconds

setInterval(() => {
  fetch('/api/messages')
    .then(res => res.json())
    .then(data => {
      // Check if there are new messages
      updateUI(data);
    });
}, 3000);  // Ask every 3 seconds

// Problems:
// âŒ Wastes bandwidth (99% of requests return "no new data")
// âŒ Delayed updates (up to 3 seconds)
// âŒ Server overload (thousands of unnecessary requests)
// âŒ Battery drain on mobile devices</div>

            <div class="code">// METHOD 2: Long Polling (better, but still hacky)
// Client asks once, server holds request until there's data

function longPoll() {
  fetch('/api/messages/long-poll')
    .then(res => res.json())
    .then(data => {
      updateUI(data);
      longPoll();  // Immediately ask again
    });
}

longPoll();

// Better than short polling:
// âœ… Instant updates (server responds when data arrives)
// âœ… Less wasted requests

// But still problematic:
// âŒ Complex server logic
// âŒ Still opens/closes connections repeatedly
// âŒ HTTP overhead for each request</div>

            <div class="code">// METHOD 3: WebSockets (modern way, best!)
// Persistent two-way connection

const socket = new WebSocket('ws://localhost:3000');

socket.onmessage = (event) => {
  updateUI(JSON.parse(event.data));
};

// Advantages:
// âœ… TRUE real-time (instant updates)
// âœ… Bidirectional (server can push to client anytime)
// âœ… Low overhead (one persistent connection)
// âœ… Efficient (no repeated handshakes)
// âœ… Battery-friendly</div>

            <div class="metaphor-box">
                <h4>The Delivery Service Analogy</h4>
                <p><strong>Short Polling:</strong> You walk to the post office every hour asking "Any mail for me?" Most times: "Nope." Exhausting!<br><br>
                <strong>Long Polling:</strong> You wait at the post office until mail arrives, then go home and come right back. Better, but you're constantly walking back and forth.<br><br>
                <strong>WebSockets:</strong> The post office calls you instantly when mail arrives. You stay home relaxing. Perfect!</p>
            </div>

            <h4>When to Use WebSockets</h4>

            <p>WebSockets are powerful, but not always necessary. Here's an honest guide:</p>

            <div class="info-box">
                <h4>âœ… PERFECT Use Cases for WebSockets</h4>
                <p><strong>Chat Applications:</strong> Messages must appear instantly<br>
                <strong>Live Notifications:</strong> "Alice commented on your post" appears in real-time<br>
                <strong>Multiplayer Games:</strong> Player positions update every frame<br>
                <strong>Collaborative Editing:</strong> Google Docs-style simultaneous editing<br>
                <strong>Live Dashboards:</strong> Stock prices, analytics, server monitoring<br>
                <strong>Live Sports Scores:</strong> Score updates as they happen<br>
                <strong>Live Auctions:</strong> Bids appear instantly to all users</p>
            </div>

            <div class="warning-box">
                <h4>âŒ DON'T Use WebSockets For</h4>
                <p><strong>Static content:</strong> Blog posts, product catalogs (changes rarely)<br>
                <strong>User profiles:</strong> Data changes infrequently, fetch on load is fine<br>
                <strong>Form submissions:</strong> One-time actions don't need persistent connections<br>
                <strong>Data that updates slowly:</strong> If updates happen every 10+ minutes, use polling<br>
                <strong>Public read-only data:</strong> News articles, documentation</p>
            </div>

            <div class="info-box">
                <h4>The Golden Rule</h4>
                <p>Use WebSockets when <strong>data changes frequently (every few seconds) AND users need immediate visibility</strong>. Otherwise, regular fetch/polling is simpler and often sufficient!</p>
            </div>

            <h4>WebSocket Connection Lifecycle</h4>

            <p>Understanding the four stages of a WebSocket connection is crucial for building robust real-time apps:</p>

            <div class="code">const socket = new WebSocket('ws://localhost:3000');

// STAGE 1: CONNECTING
// (Implicitâ€”happens automatically when you create the WebSocket)
console.log('Attempting to connect...');

// STAGE 2: OPEN (Connected!)
socket.onopen = (event) => {
  console.log('âœ… Connection established!');
  console.log('Socket state:', socket.readyState);  // 1 = OPEN
  
  // Now you can send messages
  socket.send(JSON.stringify({
    type: 'join',
    username: 'Alice'
  }));
};

// STAGE 3: MESSAGE (Receiving data)
socket.onmessage = (event) => {
  console.log('ğŸ“¨ Received:', event.data);
  
  // event.data is always a string, parse if JSON
  const message = JSON.parse(event.data);
  
  // Handle different message types
  if (message.type === 'chat') {
    displayChatMessage(message);
  } else if (message.type === 'notification') {
    showNotification(message);
  }
};

// STAGE 4: ERROR (Something went wrong)
socket.onerror = (error) => {
  console.error('âŒ WebSocket error:', error);
  // Show user-friendly error message
  alert('Connection error. Please refresh the page.');
};

// STAGE 5: CLOSE (Connection ended)
socket.onclose = (event) => {
  console.log('ğŸ”Œ Connection closed');
  console.log('Code:', event.code);      // 1000 = normal close
  console.log('Reason:', event.reason);  // Optional reason string
  console.log('Clean:', event.wasClean); // true if closed properly
  
  // Common close codes:
  // 1000 = Normal closure
  // 1001 = Going away (page refresh)
  // 1006 = Abnormal closure (no close frame)
  // 1008 = Policy violation
  // 1011 = Server error
  
  if (!event.wasClean) {
    // Unexpected disconnectâ€”attempt to reconnect
    setTimeout(() => {
      console.log('Attempting to reconnect...');
      reconnect();
    }, 3000);
  }
};</div>

            <div class="info-box">
                <h4>Understanding socket.readyState</h4>
                <p>The <span class="inline-code">readyState</span> property tells you the current connection status:<br><br>
                <strong>0 (CONNECTING):</strong> Socket is being created, not ready yet<br>
                <strong>1 (OPEN):</strong> Connection is alive, ready to send/receive<br>
                <strong>2 (CLOSING):</strong> Connection is closing<br>
                <strong>3 (CLOSED):</strong> Connection is closed or couldn't be opened<br><br>
                Always check <span class="inline-code">socket.readyState === 1</span> before sending messages!</p>
            </div>

            <h4>Sending Different Types of Data</h4>

            <p>WebSockets can send more than just strings. Here are the different data types you can send:</p>

            <div class="code">const socket = new WebSocket('ws://localhost:3000');

socket.onopen = () => {
  // 1. String (most commonâ€”JSON)
  socket.send(JSON.stringify({ message: 'Hello!' }));
  
  // 2. Plain text string
  socket.send('Simple text message');
  
  // 3. ArrayBuffer (for binary data like images)
  const buffer = new ArrayBuffer(8);
  socket.send(buffer);
  
  // 4. Blob (for file uploads)
  const blob = new Blob(['file contents'], { type: 'text/plain' });
  socket.send(blob);
};

// Receiving different types
socket.onmessage = (event) => {
  if (typeof event.data === 'string') {
    // Text message
    console.log('String:', event.data);
    
    // Try parsing as JSON
    try {
      const parsed = JSON.parse(event.data);
      console.log('JSON:', parsed);
    } catch (e) {
      console.log('Plain text:', event.data);
    }
  } else if (event.data instanceof Blob) {
    // Binary data (Blob)
    event.data.text().then(text => {
      console.log('Blob contents:', text);
    });
  } else if (event.data instanceof ArrayBuffer) {
    // Binary data (ArrayBuffer)
    console.log('ArrayBuffer:', event.data);
  }
};</div>

            <div class="info-box">
                <h4>Best Practice: Use JSON</h4>
                <p>For 99% of applications, send JSON strings:<br><br>
                <strong>Why?</strong><br>
                âœ… Easy to structure complex data<br>
                âœ… Works everywhere (browser, Node.js)<br>
                âœ… Human-readable for debugging<br>
                âœ… Easy to add fields later<br><br>
                Only use binary (ArrayBuffer/Blob) for large files or performance-critical data like game positions.</p>
            </div>

            <div class="metaphor-box">
                <h4>The Phone Call Metaphor (Revisited)</h4>
                <p>WebSocket connection lifecycle is like a phone call:<br><br>
                <strong>CONNECTING:</strong> Dialing the number (beep... beep...)<br>
                <strong>OPEN:</strong> "Hello?" Connection established, you can talk!<br>
                <strong>MESSAGE:</strong> Back-and-forth conversation<br>
                <strong>ERROR:</strong> Static, bad signal, dropped call<br>
                <strong>CLOSE:</strong> "Goodbye!" Hang up the phone<br><br>
                Unlike letters (HTTP), the line stays open the whole time!</p>
            </div>

            <h3>Part 2: Socket.io Basics</h3>

            <p>Raw WebSockets work great, but Socket.io makes everything easier. It's the most popular WebSocket library, adding automatic reconnection, rooms, and better error handling. Let's learn it!</p>

            <h4>Why Socket.io Instead of Raw WebSockets?</h4>

            <div class="code">// RAW WebSocket Problems:

// âŒ No automatic reconnection
socket.onclose = () => {
  // You have to manually reconnect
  setTimeout(() => {
    socket = new WebSocket('ws://localhost:3000');
    setupListeners(socket);
  }, 3000);
};

// âŒ No built-in event system
socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  // Manual routingâ€”messy!
  if (data.type === 'chat') {
    handleChat(data);
  } else if (data.type === 'notification') {
    handleNotification(data);
  }
};

// âŒ No rooms/namespaces
// Hard to send messages to specific groups of users

// âŒ No fallback for older browsers
// If WebSockets aren't supported, connection fails</div>

            <div class="code">// Socket.io Solutions:

// âœ… Automatic reconnection (built-in!)
const socket = io('http://localhost:3000');
// That's it! Reconnects automatically if connection drops

// âœ… Event-based system (much cleaner)
socket.on('chat-message', (data) => {
  handleChat(data);
});

socket.on('notification', (data) => {
  handleNotification(data);
});

// âœ… Rooms and namespaces (easy group messaging)
socket.emit('join-room', 'room-123');
socket.to('room-123').emit('message', 'Hello room!');

// âœ… Automatic fallback to HTTP long-polling
// Works even on ancient browsers!</div>

            <h4>Installing Socket.io</h4>

            <p>Socket.io has two parts: server library (Node.js) and client library (browser). Let's set both up.</p>

            <div class="code">// BACKEND: Install Socket.io server
// Run in your Node.js project folder:
npm install socket.io

// FRONTEND: Install Socket.io client
// Run in your React project folder:
npm install socket.io-client</div>

            <h4>Basic Socket.io Server (Node.js)</h4>

            <p>Here's a complete Socket.io server that handles connections, messages, and disconnections:</p>

            <div class="code">// server.js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000',  // Your React app URL
    methods: ['GET', 'POST']
  }
});

// Track connected users
let users = {};

// Handle new connections
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // Listen for 'join' event
  socket.on('join', (username) => {
    users[socket.id] = username;
    console.log(`${username} joined (${socket.id})`);
    
    // Tell everyone a user joined
    io.emit('user-joined', {
      username,
      userCount: Object.keys(users).length
    });
  });
  
  // Listen for 'chat-message' event
  socket.on('chat-message', (data) => {
    console.log('Message from', users[socket.id], ':', data.text);
    
    // Broadcast to ALL clients (including sender)
    io.emit('chat-message', {
      id: socket.id,
      username: users[socket.id],
      text: data.text,
      timestamp: Date.now()
    });
  });
  
  // Listen for 'private-message' event
  socket.on('private-message', ({ to, text }) => {
    // Send only to specific user
    socket.to(to).emit('private-message', {
      from: socket.id,
      username: users[socket.id],
      text,
      timestamp: Date.now()
    });
  });
  
  // Handle disconnection
  socket.on('disconnect', () => {
    const username = users[socket.id];
    delete users[socket.id];
    
    console.log('User disconnected:', username);
    
    // Tell everyone a user left
    io.emit('user-left', {
      username,
      userCount: Object.keys(users).length
    });
  });
});

// Start server
const PORT = 3001;
server.listen(PORT, () => {
  console.log(`Socket.io server running on http://localhost:${PORT}`);
});</div>

            <div class="info-box">
                <h4>Understanding Socket.io Server Events</h4>
                <p><strong>io.on('connection', callback):</strong> Fires when a client connects<br>
                <strong>socket.on(eventName, callback):</strong> Listen for custom events from this client<br>
                <strong>socket.emit(eventName, data):</strong> Send to this client only<br>
                <strong>socket.broadcast.emit(event, data):</strong> Send to all EXCEPT this client<br>
                <strong>io.emit(eventName, data):</strong> Send to ALL clients (broadcast)<br>
                <strong>socket.to(room).emit(event, data):</strong> Send to specific room<br>
                <strong>socket.on('disconnect', callback):</strong> Fires when client disconnects</p>
            </div>

            <h4>Socket.io Client (React)</h4>

            <p>Now let's build a React frontend that connects to our Socket.io server:</p>

            <div class="code">// ChatApp.jsx
import { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';

function ChatApp() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [username, setUsername] = useState('');
  const [isJoined, setIsJoined] = useState(false);
  const [userCount, setUserCount] = useState(0);
  const socketRef = useRef(null);
  
  useEffect(() => {
    // Connect to Socket.io server
    socketRef.current = io('http://localhost:3001');
    
    // Listen for chat messages
    socketRef.current.on('chat-message', (message) => {
      setMessages(prev => [...prev, message]);
    });
    
    // Listen for user joined
    socketRef.current.on('user-joined', (data) => {
      setUserCount(data.userCount);
      setMessages(prev => [...prev, {
        type: 'system',
        text: `${data.username} joined the chat`,
        timestamp: Date.now()
      }]);
    });
    
    // Listen for user left
    socketRef.current.on('user-left', (data) => {
      setUserCount(data.userCount);
      setMessages(prev => [...prev, {
        type: 'system',
        text: `${data.username} left the chat`,
        timestamp: Date.now()
      }]);
    });
    
    // Cleanup on unmount
    return () => {
      socketRef.current.disconnect();
    };
  }, []);
  
  const handleJoin = (e) => {
    e.preventDefault();
    if (!username.trim()) return;
    
    // Tell server we joined
    socketRef.current.emit('join', username);
    setIsJoined(true);
  };
  
  const handleSend = (e) => {
    e.preventDefault();
    if (!inputValue.trim()) return;
    
    // Send message to server
    socketRef.current.emit('chat-message', {
      text: inputValue
    });
    
    setInputValue('');
  };
  
  if (!isJoined) {
    return (
      &lt;div className="join-screen"&gt;
        &lt;h1&gt;Socket.io Chat&lt;/h1&gt;
        &lt;form onSubmit={handleJoin}&gt;
          &lt;input
            type="text"
            placeholder="Enter your name"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          /&gt;
          &lt;button type="submit"&gt;Join Chat&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
  
  return (
    &lt;div className="chat-app"&gt;
      &lt;header&gt;
        &lt;h1&gt;Socket.io Chat&lt;/h1&gt;
        &lt;p&gt;{userCount} user{userCount !== 1 ? 's' : ''} online&lt;/p&gt;
      &lt;/header&gt;
      
      &lt;div className="messages"&gt;
        {messages.map((msg, index) => (
          &lt;div key={index} className={`message ${msg.type || 'chat'}`}&gt;
            {msg.type === 'system' ? (
              &lt;em&gt;{msg.text}&lt;/em&gt;
            ) : (
              &lt;&gt;
                &lt;strong&gt;{msg.username}:&lt;/strong&gt; {msg.text}
              &lt;/&gt;
            )}
            &lt;span className="timestamp"&gt;
              {new Date(msg.timestamp).toLocaleTimeString()}
            &lt;/span&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      &lt;form onSubmit={handleSend} className="message-form"&gt;
        &lt;input
          type="text"
          placeholder="Type a message..."
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
        /&gt;
        &lt;button type="submit"&gt;Send&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}

export default ChatApp;</div>

            <div class="info-box">
                <h4>How This Chat App Works</h4>
                <p><strong>1. User joins:</strong> Enters name, emits 'join' event to server<br>
                <strong>2. Server broadcasts:</strong> Tells all clients "{username} joined"<br>
                <strong>3. User sends message:</strong> Emits 'chat-message' to server<br>
                <strong>4. Server broadcasts:</strong> Sends message to all connected clients<br>
                <strong>5. All clients receive:</strong> Add message to their message list<br>
                <strong>6. React re-renders:</strong> New message appears in UI<br><br>
                It's a loop: emit â†’ server receives â†’ server broadcasts â†’ all clients receive!</p>
            </div>

            <h4>Rooms and Namespaces</h4>

            <p>Socket.io's killer feature is "rooms"â€”you can group clients and send messages to specific groups only. Perfect for private chats or game lobbies!</p>

            <div class="code">// SERVER: Creating and using rooms

io.on('connection', (socket) => {
  // Join a room
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
    console.log(`Socket ${socket.id} joined room ${roomId}`);
    
    // Tell others in the room
    socket.to(roomId).emit('user-joined-room', {
      userId: socket.id
    });
  });
  
  // Send message to a room
  socket.on('room-message', ({ roomId, text }) => {
    // Send to everyone in the room
    io.to(roomId).emit('room-message', {
      userId: socket.id,
      text,
      timestamp: Date.now()
    });
  });
  
  // Leave a room
  socket.on('leave-room', (roomId) => {
    socket.leave(roomId);
    console.log(`Socket ${socket.id} left room ${roomId}`);
    
    // Tell others in the room
    socket.to(roomId).emit('user-left-room', {
      userId: socket.id
    });
  });
  
  // Get all rooms this socket is in
  console.log('Socket rooms:', socket.rooms);
  // Set { 'socket-id', 'room-1', 'room-2' }
});</div>

            <div class="code">// CLIENT: Using rooms in React

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const socketRef = useRef(null);
  
  useEffect(() => {
    socketRef.current = io('http://localhost:3001');
    
    // Join the room
    socketRef.current.emit('join-room', roomId);
    
    // Listen for room messages
    socketRef.current.on('room-message', (message) => {
      setMessages(prev => [...prev, message]);
    });
    
    // Cleanup: leave room when component unmounts
    return () => {
      socketRef.current.emit('leave-room', roomId);
      socketRef.current.disconnect();
    };
  }, [roomId]);
  
  const sendMessage = (text) => {
    socketRef.current.emit('room-message', {
      roomId,
      text
    });
  };
  
  // ... rest of component
}</div>

            <div class="info-box">
                <h4>Understanding Rooms</h4>
                <p><strong>Room = Group of sockets:</strong> Like a private channel<br>
                <strong>socket.join(room):</strong> Add this socket to the room<br>
                <strong>socket.leave(room):</strong> Remove this socket from the room<br>
                <strong>io.to(room).emit(event, data):</strong> Send to all sockets in the room<br>
                <strong>socket.rooms:</strong> Set of all rooms this socket is in<br><br>
                Use cases: Private messages, game lobbies, team channels, video call rooms!</p>
            </div>

            <h4>Complete Example: Multi-Room Chat</h4>

            <p>Let's build a Slack-like app where users can create and join multiple rooms:</p>

            <div class="code">// MultiRoomChat.jsx
import { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';

function MultiRoomChat() {
  const [rooms, setRooms] = useState(['general', 'random']);
  const [currentRoom, setCurrentRoom] = useState('general');
  const [messages, setMessages] = useState({
    general: [],
    random: []
  });
  const [inputValue, setInputValue] = useState('');
  const [newRoomName, setNewRoomName] = useState('');
  const socketRef = useRef(null);
  
  useEffect(() => {
    socketRef.current = io('http://localhost:3001');
    
    // Join default room
    socketRef.current.emit('join-room', currentRoom);
    
    // Listen for room messages
    socketRef.current.on('room-message', ({ roomId, userId, text, timestamp }) => {
      setMessages(prev => ({
        ...prev,
        [roomId]: [...(prev[roomId] || []), { userId, text, timestamp }]
      }));
    });
    
    return () => {
      socketRef.current.disconnect();
    };
  }, []);
  
  const switchRoom = (newRoom) => {
    // Leave current room
    socketRef.current.emit('leave-room', currentRoom);
    
    // Join new room
    socketRef.current.emit('join-room', newRoom);
    
    setCurrentRoom(newRoom);
  };
  
  const createRoom = (e) => {
    e.preventDefault();
    if (!newRoomName.trim() || rooms.includes(newRoomName)) return;
    
    setRooms(prev => [...prev, newRoomName]);
    setMessages(prev => ({ ...prev, [newRoomName]: [] }));
    switchRoom(newRoomName);
    setNewRoomName('');
  };
  
  const sendMessage = (e) => {
    e.preventDefault();
    if (!inputValue.trim()) return;
    
    socketRef.current.emit('room-message', {
      roomId: currentRoom,
      text: inputValue
    });
    
    setInputValue('');
  };
  
  return (
    &lt;div className="multi-room-chat"&gt;
      &lt;aside className="sidebar"&gt;
        &lt;h2&gt;Rooms&lt;/h2&gt;
        &lt;ul&gt;
          {rooms.map(room => (
            &lt;li
              key={room}
              className={room === currentRoom ? 'active' : ''}
              onClick={() => switchRoom(room)}
            &gt;
              # {room}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        
        &lt;form onSubmit={createRoom}&gt;
          &lt;input
            type="text"
            placeholder="New room name"
            value={newRoomName}
            onChange={(e) => setNewRoomName(e.target.value)}
          /&gt;
          &lt;button type="submit"&gt;Create&lt;/button&gt;
        &lt;/form&gt;
      &lt;/aside&gt;
      
      &lt;main className="chat-main"&gt;
        &lt;header&gt;
          &lt;h1&gt;# {currentRoom}&lt;/h1&gt;
        &lt;/header&gt;
        
        &lt;div className="messages"&gt;
          {(messages[currentRoom] || []).map((msg, index) => (
            &lt;div key={index} className="message"&gt;
              &lt;strong&gt;User {msg.userId.slice(0, 6)}:&lt;/strong&gt; {msg.text}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
        
        &lt;form onSubmit={sendMessage}&gt;
          &lt;input
            type="text"
            placeholder={`Message # ${currentRoom}`}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
          /&gt;
          &lt;button type="submit"&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}

export default MultiRoomChat;</div>

            <div class="metaphor-box">
                <h4>The Office Building Metaphor</h4>
                <p>Socket.io rooms are like an office building:<br><br>
                <strong>Building = Server:</strong> Houses all rooms<br>
                <strong>Rooms = Conference rooms:</strong> Different groups meet in different rooms<br>
                <strong>People = Sockets:</strong> Can enter/leave rooms<br>
                <strong>Announcements:</strong> Broadcasting in one room doesn't affect others<br><br>
                You can be in multiple rooms at onceâ€”like having meetings in different conference rooms!</p>
            </div>

            <h3>Part 3: React Integration Patterns</h3>

            <p>Now that you understand Socket.io, let's explore best practices for integrating it into React apps. We'll cover connection management, custom hooks, and handling edge cases.</p>

            <h4>Pattern 1: useEffect for Socket Connection</h4>

            <p>The most important rule: Create and cleanup socket connections in useEffect.</p>

            <div class="code">import { useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';

function ChatComponent() {
  const [messages, setMessages] = useState([]);
  const socketRef = useRef(null);
  
  useEffect(() => {
    // SETUP: Create socket connection
    socketRef.current = io('http://localhost:3001', {
      // Optional configuration
      reconnection: true,           // Auto-reconnect (default: true)
      reconnectionDelay: 1000,      // Wait 1s before reconnecting
      reconnectionAttempts: 5,      // Try 5 times max
    });
    
    // Register event listeners
    socketRef.current.on('connect', () => {
      console.log('Connected:', socketRef.current.id);
    });
    
    socketRef.current.on('message', (data) => {
      setMessages(prev => [...prev, data]);
    });
    
    socketRef.current.on('disconnect', () => {
      console.log('Disconnected');
    });
    
    // CLEANUP: Disconnect when component unmounts
    return () => {
      console.log('Cleaning up socket connection');
      socketRef.current.disconnect();
    };
  }, []);  // Empty dependency array = run once on mount
  
  // ... rest of component
}</div>

            <div class="warning-box">
                <h4>âš ï¸ Common Mistake: Creating Socket in Component Body</h4>
                <p>WRONG:<br>
                <code>const socket = io('http://localhost:3001');  // BAD!</code><br><br>
                This creates a new connection on EVERY re-render! Your app will create hundreds of connections. Always create sockets in useEffect with empty dependency array.</p>
            </div>

            <div class="info-box">
                <h4>Why useRef Instead of useState?</h4>
                <p><strong>useState:</strong> Causes re-renders when updated<br>
                <strong>useRef:</strong> Persists across re-renders without causing re-renders<br><br>
                Socket connections don't need to trigger re-renders. Use useRef to store the socket object, and useState to store the data (messages, user list, etc.) that should trigger UI updates.</p>
            </div>

            <h4>Pattern 2: Custom useSocket Hook</h4>

            <p>For reusable socket logic, create a custom hook. This keeps your components clean and makes socket management consistent:</p>

            <div class="code">// hooks/useSocket.js
import { useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';

export function useSocket(serverUrl, options = {}) {
  const socketRef = useRef(null);
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  
  useEffect(() => {
    // Create socket connection
    socketRef.current = io(serverUrl, {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
      ...options
    });
    
    // Connection opened
    socketRef.current.on('connect', () => {
      console.log('Socket connected:', socketRef.current.id);
      setIsConnected(true);
    });
    
    // Connection closed
    socketRef.current.on('disconnect', () => {
      console.log('Socket disconnected');
      setIsConnected(false);
    });
    
    // Generic message handler (optional)
    socketRef.current.onAny((event, ...args) => {
      setLastMessage({ event, args, timestamp: Date.now() });
    });
    
    // Cleanup
    return () => {
      socketRef.current.disconnect();
    };
  }, [serverUrl]);
  
  // Helper function to emit events
  const emit = (event, data) => {
    if (socketRef.current && isConnected) {
      socketRef.current.emit(event, data);
    } else {
      console.warn('Socket not connected. Cannot emit:', event);
    }
  };
  
  // Helper function to listen to events
  const on = (event, callback) => {
    if (socketRef.current) {
      socketRef.current.on(event, callback);
    }
  };
  
  // Helper function to remove listeners
  const off = (event, callback) => {
    if (socketRef.current) {
      socketRef.current.off(event, callback);
    }
  };
  
  return {
    socket: socketRef.current,
    isConnected,
    lastMessage,
    emit,
    on,
    off
  };
}</code></div>

            <div class="code">// Using the custom hook in a component

import { useState, useEffect } from 'react';
import { useSocket } from './hooks/useSocket';

function ChatWithHook() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const { isConnected, emit, on } = useSocket('http://localhost:3001');
  
  useEffect(() => {
    // Listen for chat messages
    const handleMessage = (data) => {
      setMessages(prev => [...prev, data]);
    };
    
    on('chat-message', handleMessage);
    
    // Cleanup listener when component unmounts
    return () => {
      off('chat-message', handleMessage);
    };
  }, [on]);
  
  const sendMessage = (e) => {
    e.preventDefault();
    if (!inputValue.trim() || !isConnected) return;
    
    emit('chat-message', {
      text: inputValue,
      timestamp: Date.now()
    });
    
    setInputValue('');
  };
  
  return (
    &lt;div&gt;
      &lt;div&gt;Status: {isConnected ? 'âœ… Connected' : 'âŒ Disconnected'}&lt;/div&gt;
      
      &lt;div className="messages"&gt;
        {messages.map((msg, index) => (
          &lt;div key={index}&gt;{msg.text}&lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      &lt;form onSubmit={sendMessage}&gt;
        &lt;input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          disabled={!isConnected}
        /&gt;
        &lt;button type="submit" disabled={!isConnected}&gt;
          Send
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</code></div>

            <div class="info-box">
                <h4>Benefits of Custom Hooks</h4>
                <p>âœ… <strong>Reusable:</strong> Use in multiple components without repeating code<br>
                âœ… <strong>Testable:</strong> Test socket logic separately from UI<br>
                âœ… <strong>Clean components:</strong> No socket setup clutter in component code<br>
                âœ… <strong>Centralized config:</strong> Change socket settings in one place<br>
                âœ… <strong>Built-in state:</strong> Connection status, last message, etc.</p>
            </div>

            <h4>Pattern 3: Handling Reconnection</h4>

            <p>Networks are unreliable. Users lose WiFi, servers restart, connections drop. Your app needs to handle reconnections gracefully:</p>

            <div class="code">import { useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';

function RobustChatApp() {
  const [messages, setMessages] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('connecting');
  const [reconnectAttempt, setReconnectAttempt] = useState(0);
  const socketRef = useRef(null);
  
  useEffect(() => {
    socketRef.current = io('http://localhost:3001', {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity  // Keep trying forever
    });
    
    // Initial connection attempt
    socketRef.current.on('connect', () => {
      console.log('Connected!');
      setConnectionStatus('connected');
      setReconnectAttempt(0);
      
      // Re-join rooms, re-sync state, etc.
      socketRef.current.emit('sync-state');
    });
    
    // Connection attempt failed
    socketRef.current.on('connect_error', (error) => {
      console.error('Connection error:', error.message);
      setConnectionStatus('error');
    });
    
    // Disconnected
    socketRef.current.on('disconnect', (reason) => {
      console.log('Disconnected:', reason);
      setConnectionStatus('disconnected');
      
      if (reason === 'io server disconnect') {
        // Server kicked us outâ€”manually reconnect
        socketRef.current.connect();
      }
      // Otherwise, auto-reconnect is handled by Socket.io
    });
    
    // Attempting to reconnect
    socketRef.current.io.on('reconnect_attempt', (attemptNumber) => {
      console.log('Reconnection attempt:', attemptNumber);
      setConnectionStatus('reconnecting');
      setReconnectAttempt(attemptNumber);
    });
    
    // Successfully reconnected
    socketRef.current.io.on('reconnect', (attemptNumber) => {
      console.log('Reconnected after', attemptNumber, 'attempts');
      setConnectionStatus('connected');
      setReconnectAttempt(0);
      
      // Re-sync state after reconnection
      socketRef.current.emit('sync-state');
    });
    
    // Failed to reconnect
    socketRef.current.io.on('reconnect_failed', () => {
      console.error('Reconnection failed');
      setConnectionStatus('failed');
    });
    
    // Message received
    socketRef.current.on('chat-message', (message) => {
      setMessages(prev => [...prev, message]);
    });
    
    return () => {
      socketRef.current.disconnect();
    };
  }, []);
  
  // Render connection status UI
  const renderStatus = () => {
    switch (connectionStatus) {
      case 'connecting':
        return &lt;div className="status connecting"&gt;ğŸ”„ Connecting...&lt;/div&gt;;
      case 'connected':
        return &lt;div className="status connected"&gt;âœ… Connected&lt;/div&gt;;
      case 'disconnected':
        return &lt;div className="status disconnected"&gt;âš ï¸ Disconnected&lt;/div&gt;;
      case 'reconnecting':
        return (
          &lt;div className="status reconnecting"&gt;
            ğŸ”„ Reconnecting... (attempt {reconnectAttempt})
          &lt;/div&gt;
        );
      case 'error':
        return &lt;div className="status error"&gt;âŒ Connection error&lt;/div&gt;;
      case 'failed':
        return (
          &lt;div className="status failed"&gt;
            âŒ Connection failed
            &lt;button onClick={() => socketRef.current.connect()}&gt;
              Retry
            &lt;/button&gt;
          &lt;/div&gt;
        );
      default:
        return null;
    }
  };
  
  return (
    &lt;div className="chat-app"&gt;
      {renderStatus()}
      
      &lt;div className="messages"&gt;
        {messages.map((msg, index) => (
          &lt;div key={index}&gt;{msg.text}&lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {/* ... message input */}
    &lt;/div&gt;
  );
}</code></div>

            <div class="info-box">
                <h4>Reconnection Events</h4>
                <p><strong>connect:</strong> Successfully connected<br>
                <strong>connect_error:</strong> Connection attempt failed<br>
                <strong>disconnect:</strong> Connection closed<br>
                <strong>reconnect_attempt:</strong> Trying to reconnect (emits attempt number)<br>
                <strong>reconnect:</strong> Successfully reconnected<br>
                <strong>reconnect_failed:</strong> All reconnection attempts failed<br><br>
                Handle these events to show users what's happening!</p>
            </div>

            <h4>Pattern 4: Cleanup on Unmount</h4>

            <p>Always clean up socket connections when components unmount. Otherwise, you create memory leaks and zombie connections.</p>

            <div class="code">useEffect(() => {
  const socket = io('http://localhost:3001');
  
  socket.on('message', handleMessage);
  socket.on('notification', handleNotification);
  socket.on('user-joined', handleUserJoined);
  
  // CLEANUP: Remove ALL listeners and disconnect
  return () => {
    // Option 1: Remove specific listeners
    socket.off('message', handleMessage);
    socket.off('notification', handleNotification);
    socket.off('user-joined', handleUserJoined);
    
    // Option 2: Remove all listeners (easier)
    socket.removeAllListeners();
    
    // Always disconnect
    socket.disconnect();
  };
}, []);</code></div>

            <div class="warning-box">
                <h4>âš ï¸ Memory Leak Warning</h4>
                <p>If you don't clean up listeners, they keep accumulating:<br><br>
                â€¢ Component mounts â†’ adds listener<br>
                â€¢ Component unmounts â†’ listener stays (LEAK!)<br>
                â€¢ Component mounts again â†’ adds ANOTHER listener<br>
                â€¢ Now you have 2 listeners for the same event<br><br>
                Result: Messages appear twice, notifications fire multiple times, chaos! Always cleanup in useEffect return function.</p>
            </div>

            <h4>Complete Real-World Example: Live Notifications</h4>

            <p>Let's build a notification system that shows live alerts to users:</p>

            <div class="code">// NotificationProvider.jsx
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';

const NotificationContext = createContext();

export function NotificationProvider({ children, userId }) {
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const socketRef = useRef(null);
  
  useEffect(() => {
    // Connect to notification server
    socketRef.current = io('http://localhost:3001/notifications', {
      query: { userId }  // Send userId to server
    });
    
    socketRef.current.on('connect', () => {
      console.log('Notification socket connected');
    });
    
    // Receive new notification
    socketRef.current.on('notification', (notification) => {
      setNotifications(prev => [notification, ...prev]);
      setUnreadCount(prev => prev + 1);
      
      // Show browser notification
      if (Notification.permission === 'granted') {
        new Notification(notification.title, {
          body: notification.message,
          icon: '/notification-icon.png'
        });
      }
      
      // Play sound
      const audio = new Audio('/notification-sound.mp3');
      audio.play().catch(e => console.log('Audio play failed:', e));
    });
    
    return () => {
      socketRef.current.disconnect();
    };
  }, [userId]);
  
  const markAsRead = (notificationId) => {
    setNotifications(prev =>
      prev.map(n =>
        n.id === notificationId ? { ...n, read: true } : n
      )
    );
    setUnreadCount(prev => Math.max(0, prev - 1));
    
    // Tell server
    socketRef.current.emit('mark-read', notificationId);
  };
  
  const markAllAsRead = () => {
    setNotifications(prev =>
      prev.map(n => ({ ...n, read: true }))
    );
    setUnreadCount(0);
    
    socketRef.current.emit('mark-all-read');
  };
  
  const clearAll = () => {
    setNotifications([]);
    setUnreadCount(0);
    socketRef.current.emit('clear-all');
  };
  
  return (
    &lt;NotificationContext.Provider
      value={{
        notifications,
        unreadCount,
        markAsRead,
        markAllAsRead,
        clearAll
      }}
    &gt;
      {children}
    &lt;/NotificationContext.Provider&gt;
  );
}

// Custom hook to use notifications
export function useNotifications() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotifications must be used within NotificationProvider');
  }
  return context;
}</code></div>

            <div class="code">// NotificationBell.jsx (using the context)
import { useState } from 'react';
import { useNotifications } from './NotificationProvider';

function NotificationBell() {
  const [isOpen, setIsOpen] = useState(false);
  const { notifications, unreadCount, markAsRead, markAllAsRead } = useNotifications();
  
  return (
    &lt;div className="notification-bell"&gt;
      &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
        ğŸ””
        {unreadCount > 0 && (
          &lt;span className="badge"&gt;{unreadCount}&lt;/span&gt;
        )}
      &lt;/button&gt;
      
      {isOpen && (
        &lt;div className="notification-dropdown"&gt;
          &lt;div className="notification-header"&gt;
            &lt;h3&gt;Notifications&lt;/h3&gt;
            {unreadCount > 0 && (
              &lt;button onClick={markAllAsRead}&gt;
                Mark all as read
              &lt;/button&gt;
            )}
          &lt;/div&gt;
          
          &lt;div className="notification-list"&gt;
            {notifications.length === 0 ? (
              &lt;p&gt;No notifications&lt;/p&gt;
            ) : (
              notifications.map(notif => (
                &lt;div
                  key={notif.id}
                  className={`notification-item ${!notif.read ? 'unread' : ''}`}
                  onClick={() => markAsRead(notif.id)}
                &gt;
                  &lt;strong&gt;{notif.title}&lt;/strong&gt;
                  &lt;p&gt;{notif.message}&lt;/p&gt;
                  &lt;span className="time"&gt;
                    {new Date(notif.timestamp).toLocaleTimeString()}
                  &lt;/span&gt;
                &lt;/div&gt;
              ))
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></div>

            <div class="metaphor-box">
                <h4>The Doorbell Metaphor</h4>
                <p>Socket.io notifications are like a smart doorbell:<br><br>
                <strong>Traditional approach (polling):</strong> Walk to your door every 5 minutes to check if anyone's there. Exhausting!<br><br>
                <strong>WebSocket approach:</strong> Doorbell rings when someone arrives. You relax inside until you hear it. Perfect!<br><br>
                Real-time notifications keep users engaged without wasting resources checking for updates constantly.</p>
            </div>

            <div class="info-box">
                <h4>Socket.io Best Practices Recap</h4>
                <p>âœ… <strong>Create socket in useEffect</strong> with empty dependency array<br>
                âœ… <strong>Use useRef</strong> to store socket object<br>
                âœ… <strong>Always cleanup</strong> in useEffect return function<br>
                âœ… <strong>Handle reconnection</strong> gracefully with status UI<br>
                âœ… <strong>Show connection status</strong> to users<br>
                âœ… <strong>Use custom hooks</strong> for reusable socket logic<br>
                âœ… <strong>Use Context</strong> to share socket data across components<br>
                âœ… <strong>Emit events sparingly</strong>â€”don't spam the server<br>
                âœ… <strong>Validate data</strong> before emitting/after receiving</p>
            </div>
        </section>

        <!-- SECTION 6: Authentication -->
        <section id="authentication" class="section">
            <h2 class="section-title">Authentication & Authorization</h2>
            <p class="section-intro">Almost every real app needs users to log in. But how does a website "remember" you're logged in? How does it prevent others from accessing your account? Let's demystify authenticationâ€”it's simpler than you think!</p>

            <h3>Authentication vs Authorization (What's the Difference?)</h3>
            
            <div class="metaphor-box">
                <h4>The Concert Venue Metaphor</h4>
                <p><strong>Authentication:</strong> Proving WHO you are<br>
                â†’ Showing your ID at the door: "Yes, you are Alice"<br><br>
                <strong>Authorization:</strong> Proving WHAT you can access<br>
                â†’ Checking your ticket type: "VIP ticket = backstage access"<br><br>
                <strong>Authentication = Identity</strong><br>
                <strong>Authorization = Permissions</strong></p>
            </div>

            <h4>How Login Actually Works (Step-by-Step)</h4>
            
            <p>Let's walk through what happens when you log in to a website:</p>

            <div class="code">1. User enters username + password
2. Frontend sends credentials to backend (POST /login)
3. Backend checks database: "Does this user exist?"
4. Backend checks password: "Does it match the stored hash?"
5. If valid: Backend generates a TOKEN (like a temporary badge)
6. Backend sends token back to frontend
7. Frontend stores token (usually in localStorage)
8. For future requests, frontend includes token in headers
9. Backend validates token: "Is this token valid?"
10. If valid: Backend processes request
11. If invalid/expired: Backend returns 401 Unauthorized

Logout = Delete the token</div>

            <div class="info-box">
                <h4>What's a Token?</h4>
                <p>A token is a long random string that proves you're logged in. Think of it like a temporary ID badge:<br><br>
                <strong>Example token:</strong> <span class="inline-code">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</span><br><br>
                The token contains encoded info (user ID, expiration time) that the backend can decode and verify. Most apps use <strong>JWT (JSON Web Tokens)</strong>.</p>
            </div>

            <h3>Complete Login Flow (Frontend)</h3>
            
            <div class="code">import React, { useState } from 'react';

function LoginPage() {
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);
    
    try {
      const response = await fetch('https://api.example.com/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Invalid credentials');
      }
      
      const data = await response.json();
      
      // Store token in localStorage
      localStorage.setItem('authToken', data.token);
      
      // Redirect to dashboard or home
      window.location.href = '/dashboard';
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Login&lt;/h2&gt;
      &lt;form onSubmit={handleLogin}&gt;
        &lt;input
          type="email"
          placeholder="Email"
          value={credentials.email}
          onChange={(e) => setCredentials({...credentials, email: e.target.value})}
          required
        /&gt;
        &lt;input
          type="password"
          placeholder="Password"
          value={credentials.password}
          onChange={(e) => setCredentials({...credentials, password: e.target.value})}
          required
        /&gt;
        &lt;button type="submit" disabled={isLoading}&gt;
          {isLoading ? 'Logging in...' : 'Login'}
        &lt;/button&gt;
        {error && &lt;p style={{color: 'red'}}&gt;{error}&lt;/p&gt;}
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</div>

            <h4>Making Authenticated Requests</h4>
            
            <p>Once logged in, include the token in ALL requests to protected endpoints:</p>

            <div class="code">// Get user profile (protected route)
async function getUserProfile() {
  const token = localStorage.getItem('authToken');
  
  const response = await fetch('https://api.example.com/profile', {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`  // Include token!
    }
  });
  
  if (response.status === 401) {
    // Token invalid/expired - redirect to login
    localStorage.removeItem('authToken');
    window.location.href = '/login';
    return;
  }
  
  const data = await response.json();
  return data;
}</div>

            <div class="warning-box">
                <h4>Security: Bearer Token Format</h4>
                <p>The <span class="inline-code">Authorization: Bearer TOKEN</span> format is standard. The backend expects this exact format. "Bearer" means "whoever holds (bears) this token has access."</p>
            </div>

            <h3>Protected Routes in React</h3>
            
            <p>How do you prevent users from accessing pages unless they're logged in? Use a <strong>ProtectedRoute</strong> component:</p>

            <div class="code">import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const token = localStorage.getItem('authToken');
  
  // If no token, redirect to login
  if (!token) {
    return &lt;Navigate to="/login" /&gt;;
  }
  
  // If token exists, show the page
  return children;
}

// Usage in your routes
function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;Route path="/signup" element={&lt;SignupPage /&gt;} /&gt;
      
      {/* Protected routes */}
      &lt;Route path="/dashboard" element={
        &lt;ProtectedRoute&gt;
          &lt;Dashboard /&gt;
        &lt;/ProtectedRoute&gt;
      } /&gt;
      
      &lt;Route path="/profile" element={
        &lt;ProtectedRoute&gt;
          &lt;Profile /&gt;
        &lt;/ProtectedRoute&gt;
      } /&gt;
    &lt;/Routes&gt;
  );
}</div>

            <div class="info-box">
                <h4>How ProtectedRoute Works</h4>
                <p><strong>1. Check for token:</strong> Does user have authToken in localStorage?<br>
                <strong>2. If NO:</strong> Redirect to /login<br>
                <strong>3. If YES:</strong> Render the protected page<br><br>
                This ensures users can't access pages by typing the URL directly.</p>
            </div>

            <h4>Complete Auth Context (Global State)</h4>
            
            <p>For a real app, you'll want authentication state available everywhere:</p>

            <div class="code">import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Check if user is logged in on mount
  useEffect(() => {
    const token = localStorage.getItem('authToken');
    if (token) {
      // Fetch user data from backend
      fetchUserProfile(token)
        .then(userData => setUser(userData))
        .catch(() => {
          // Token invalid
          localStorage.removeItem('authToken');
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    const data = await response.json();
    localStorage.setItem('authToken', data.token);
    setUser(data.user);
  };
  
  const logout = () => {
    localStorage.removeItem('authToken');
    setUser(null);
    window.location.href = '/login';
  };
  
  return (
    &lt;AuthContext.Provider value={{ user, login, logout, loading }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

export function useAuth() {
  return useContext(AuthContext);
}

// Usage in any component
function Dashboard() {
  const { user, logout } = useAuth();
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>You're Now Security-Aware!</h4>
                <p>Authentication is fundamental to almost every app. You now understand tokens, protected routes, and global auth state. Remember: NEVER store passwords in frontend, ALWAYS use HTTPS in production, and tokens should expire (typically 1-7 days). You're ready to build secure, user-based applications!</p>
            </div>

            <h3>JWT Deep Dive: Understanding JSON Web Tokens</h3>
            
            <p>JWT (JSON Web Token) is the most popular authentication method for modern web apps. Let's understand exactly how it works!</p>

            <div class="metaphor-box">
                <h4>The Concert Wristband Metaphor</h4>
                <p>Imagine you go to a multi-day music festival:<br><br>
                <strong>Day 1:</strong> You buy a ticket, they verify your payment, and give you a <strong>wristband</strong><br>
                <strong>Days 2-3:</strong> You just show your wristbandâ€”no need to prove payment again<br>
                <strong>The wristband:</strong> Has a holographic seal that can't be forged<br>
                <strong>Security guards:</strong> Check the wristband is real and hasn't expired<br><br>
                <strong>JWT = Digital wristband</strong><br>
                It proves you're authenticated without checking the database every time!</p>
            </div>

            <h4>JWT Structure: Three Parts</h4>
            
            <p>A JWT looks like a long string with three parts separated by dots:</p>

            <div class="code-block">
                <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMzQ1LCJlbWFpbCI6ImFsaWNlQGV4YW1wbGUuY29tIiwiZXhwIjoxNzA2ODk2MDAwfQ.4sF7kM2pN_xQ9vZwR8bH3jL5nP2qW1eY8tR6uI0oK4m

         HEADER              .              PAYLOAD              .              SIGNATURE
    (Algorithm + Type)           (User data + Claims)            (Verification)</code></pre>
            </div>

            <p>Let's decode each part:</p>

            <div class="code-block">
                <pre><code>// PART 1: HEADER (Base64 encoded)
{
  "alg": "HS256",     // Algorithm used (HMAC SHA-256)
  "typ": "JWT"        // Token type
}

// PART 2: PAYLOAD (Base64 encoded) - The actual data!
{
  "userId": 12345,
  "email": "alice@example.com",
  "role": "admin",
  "exp": 1706896000    // Expiration timestamp
}

// PART 3: SIGNATURE (Encrypted)
// Created by: HMACSHA256(
//   base64UrlEncode(header) + "." + base64UrlEncode(payload),
//   your-secret-key
// )
// This ensures the token hasn't been tampered with!</code></pre>
            </div>

            <div class="info-box">
                <h4>Why JWT is Secure</h4>
                <p><strong>1. Payload is readable:</strong> Anyone can decode the Base64 (it's not encrypted)<br>
                <strong>2. BUT the signature can't be forged:</strong> Only the server has the secret key<br>
                <strong>3. If someone changes the payload:</strong> The signature won't match â†’ token is invalid<br>
                <strong>4. Tampering detection:</strong> Server immediately knows if token was modified<br><br>
                Think of it like a sealed envelope with a wax seal. You can see through the envelope (payload), but you can't break the seal without it being obvious (signature).</p>
            </div>

            <div class="warning-box">
                <h4>âš ï¸ Critical Security Rules for JWT</h4>
                <p><strong>1. NEVER put sensitive data in JWT:</strong> Don't store passwords, credit cards, SSNs<br>
                <strong>2. Always use HTTPS:</strong> JWTs can be stolen if sent over HTTP<br>
                <strong>3. Set expiration times:</strong> Tokens should expire (1 hour to 7 days)<br>
                <strong>4. Secret key must be strong:</strong> Use long random strings, never commit to Git<br>
                <strong>5. Validate on every request:</strong> Always check signature and expiration</p>
            </div>

            <h4>Access Tokens vs Refresh Tokens</h4>
            
            <p>Professional apps use TWO types of tokens for better security:</p>

            <div class="code-block">
                <pre><code>// ACCESS TOKEN (Short-lived: 15 minutes to 1 hour)
{
  "userId": 12345,
  "role": "user",
  "exp": 1706896000  // Expires in 15 minutes
}
// Purpose: Used for API requests
// Stored: In memory (React state) or localStorage
// If stolen: Limited damage - expires quickly

// REFRESH TOKEN (Long-lived: 7 days to 30 days)
{
  "userId": 12345,
  "tokenVersion": 2,
  "exp": 1709574400  // Expires in 7 days
}
// Purpose: Get new access tokens when old one expires
// Stored: httpOnly cookie (can't be accessed by JavaScript)
// If stolen: Can be invalidated on the server</code></pre>
            </div>

            <div class="info-box">
                <h4>How the Two-Token System Works</h4>
                <p><strong>Step 1: User logs in</strong><br>
                â†’ Server sends BOTH access token + refresh token<br><br>
                <strong>Step 2: Making API requests</strong><br>
                â†’ Send access token in Authorization header<br>
                â†’ If access token is valid: Process request<br>
                â†’ If access token is expired: Use refresh token to get new one<br><br>
                <strong>Step 3: Access token expires (after 15 min)</strong><br>
                â†’ Frontend sends refresh token to /refresh endpoint<br>
                â†’ Server validates refresh token<br>
                â†’ Server sends NEW access token<br>
                â†’ Continue using the app seamlessly!<br><br>
                <strong>Step 4: User logs out</strong><br>
                â†’ Server invalidates refresh token<br>
                â†’ Even if someone stole the token, it's now useless</p>
            </div>

            <div class="code-block">
                <pre><code>// Complete two-token flow implementation
class AuthService {
  constructor() {
    this.accessToken = null;
    this.refreshToken = null;
  }
  
  async login(credentials) {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    const data = await response.json();
    
    // Store tokens
    this.accessToken = data.accessToken;
    this.refreshToken = data.refreshToken;
    
    // Store refresh token in httpOnly cookie (if using cookies)
    // Server sets: Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict
    
    return data.user;
  }
  
  async makeAuthenticatedRequest(url, options = {}) {
    // Try request with current access token
    let response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${this.accessToken}`
      }
    });
    
    // If access token expired (401), refresh it
    if (response.status === 401) {
      const refreshed = await this.refreshAccessToken();
      
      if (!refreshed) {
        // Refresh failed - redirect to login
        window.location.href = '/login';
        return;
      }
      
      // Retry request with new access token
      response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${this.accessToken}`
        }
      });
    }
    
    return response;
  }
  
  async refreshAccessToken() {
    try {
      const response = await fetch('/api/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken: this.refreshToken })
      });
      
      if (!response.ok) return false;
      
      const data = await response.json();
      this.accessToken = data.accessToken;
      return true;
    } catch {
      return false;
    }
  }
  
  logout() {
    this.accessToken = null;
    this.refreshToken = null;
    // Tell server to invalidate refresh token
    fetch('/api/logout', { method: 'POST' });
    window.location.href = '/login';
  }
}

// Usage
const auth = new AuthService();

// Login
await auth.login({ email: 'alice@example.com', password: '***' });

// Make requests (automatically handles token refresh!)
const response = await auth.makeAuthenticatedRequest('/api/user/profile');
const userData = await response.json();</code></pre>
            </div>

            <h4>Where to Store Tokens: The Big Decision</h4>
            
            <p>This is one of the most debated topics in web security. Let's compare all options:</p>

            <div class="info-box">
                <h4>Option 1: localStorage</h4>
                <p><strong>How it works:</strong><br>
                <code>localStorage.setItem('token', data.token)</code><br><br>
                <strong>âœ… Pros:</strong><br>
                â€¢ Simple to implement<br>
                â€¢ Token persists across browser restarts<br>
                â€¢ Easy to access from JavaScript<br><br>
                <strong>âŒ Cons:</strong><br>
                â€¢ Vulnerable to XSS attacks (malicious scripts can steal tokens)<br>
                â€¢ Any third-party script can access it<br><br>
                <strong>When to use:</strong> Simple apps, learning projects, low-risk scenarios</p>
            </div>

            <div class="info-box">
                <h4>Option 2: httpOnly Cookies</h4>
                <p><strong>How it works:</strong><br>
                Server sets: <code>Set-Cookie: token=...; HttpOnly; Secure; SameSite=Strict</code><br><br>
                <strong>âœ… Pros:</strong><br>
                â€¢ JavaScript CANNOT access it (immune to XSS)<br>
                â€¢ Browser automatically sends it with requests<br>
                â€¢ Most secure option<br><br>
                <strong>âŒ Cons:</strong><br>
                â€¢ Vulnerable to CSRF attacks (need CSRF tokens)<br>
                â€¢ Requires backend configuration<br>
                â€¢ More complex to implement<br><br>
                <strong>When to use:</strong> Production apps with sensitive data, banking, healthcare</p>
            </div>

            <div class="info-box">
                <h4>Option 3: Memory (React State)</h4>
                <p><strong>How it works:</strong><br>
                <code>const [token, setToken] = useState(null)</code><br><br>
                <strong>âœ… Pros:</strong><br>
                â€¢ Most secure against XSS<br>
                â€¢ Token disappears on page refresh<br><br>
                <strong>âŒ Cons:</strong><br>
                â€¢ User logged out on every refresh (bad UX)<br>
                â€¢ Need to combine with refresh tokens in httpOnly cookies<br><br>
                <strong>When to use:</strong> For access tokens in a two-token system</p>
            </div>

            <div class="warning-box">
                <h4>âš ï¸ Recommended Approach for Production</h4>
                <p><strong>Best practice: Hybrid approach</strong><br><br>
                1. <strong>Access token:</strong> Store in memory (React state) - short-lived (15 min)<br>
                2. <strong>Refresh token:</strong> Store in httpOnly cookie - long-lived (7 days)<br>
                3. <strong>On page refresh:</strong> Use refresh token to get new access token<br>
                4. <strong>Add CSRF protection:</strong> Use CSRF tokens for cookie-based auth<br><br>
                This gives you both security AND good user experience!</p>
            </div>

            <h3>Complete Login & Register Flow</h3>
            
            <p>Now let's build a production-ready authentication system with proper validation and error handling:</p>

            <div class="code-block">
                <pre><code>import React, { useState } from 'react';

function RegisterPage() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: '',
    name: ''
  });
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');
  
  // Validation function
  const validateForm = () => {
    const newErrors = {};
    
    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!emailRegex.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }
    
    // Name validation
    if (!formData.name) {
      newErrors.name = 'Name is required';
    } else if (formData.name.length < 2) {
      newErrors.name = 'Name must be at least 2 characters';
    }
    
    // Password validation
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    } else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(formData.password)) {
      newErrors.password = 'Password must contain uppercase, lowercase, and number';
    }
    
    // Confirm password validation
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form
    if (!validateForm()) {
      return;
    }
    
    setIsLoading(true);
    setSuccessMessage('');
    
    try {
      const response = await fetch('https://api.example.com/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: formData.email,
          password: formData.password,
          name: formData.name
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Registration failed');
      }
      
      const data = await response.json();
      
      // Store token
      localStorage.setItem('authToken', data.token);
      
      setSuccessMessage('Registration successful! Redirecting...');
      
      // Redirect to dashboard after 2 seconds
      setTimeout(() => {
        window.location.href = '/dashboard';
      }, 2000);
      
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    &lt;div className="auth-container"&gt;
      &lt;h2&gt;Create Account&lt;/h2&gt;
      
      &lt;form onSubmit={handleSubmit}&gt;
        {/* Name field */}
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="name"&gt;Full Name&lt;/label&gt;
          &lt;input
            id="name"
            type="text"
            name="name"
            value={formData.name}
            onChange={handleChange}
            className={errors.name ? 'error' : ''}
          /&gt;
          {errors.name && &lt;span className="error-message"&gt;{errors.name}&lt;/span&gt;}
        &lt;/div&gt;
        
        {/* Email field */}
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
          &lt;input
            id="email"
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            className={errors.email ? 'error' : ''}
          /&gt;
          {errors.email && &lt;span className="error-message"&gt;{errors.email}&lt;/span&gt;}
        &lt;/div&gt;
        
        {/* Password field */}
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
          &lt;input
            id="password"
            type="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            className={errors.password ? 'error' : ''}
          /&gt;
          {errors.password && &lt;span className="error-message"&gt;{errors.password}&lt;/span&gt;}
          &lt;small&gt;Must be 8+ characters with uppercase, lowercase, and number&lt;/small&gt;
        &lt;/div&gt;
        
        {/* Confirm Password field */}
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="confirmPassword"&gt;Confirm Password&lt;/label&gt;
          &lt;input
            id="confirmPassword"
            type="password"
            name="confirmPassword"
            value={formData.confirmPassword}
            onChange={handleChange}
            className={errors.confirmPassword ? 'error' : ''}
          /&gt;
          {errors.confirmPassword && &lt;span className="error-message"&gt;{errors.confirmPassword}&lt;/span&gt;}
        &lt;/div&gt;
        
        {/* Submit button */}
        &lt;button type="submit" disabled={isLoading}&gt;
          {isLoading ? 'Creating account...' : 'Register'}
        &lt;/button&gt;
        
        {/* Error/Success messages */}
        {errors.submit && &lt;div className="error-banner"&gt;{errors.submit}&lt;/div&gt;}
        {successMessage && &lt;div className="success-banner"&gt;{successMessage}&lt;/div&gt;}
      &lt;/form&gt;
      
      &lt;p&gt;Already have an account? &lt;a href="/login"&gt;Login here&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <h4>Login Page with Remember Me</h4>

            <div class="code-block">
                <pre><code>import React, { useState } from 'react';

function LoginPage() {
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const [rememberMe, setRememberMe] = useState(false);
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setErrors({});
    setIsLoading(true);
    
    try {
      const response = await fetch('https://api.example.com/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Invalid email or password');
      }
      
      const data = await response.json();
      
      // Store token based on "Remember Me"
      if (rememberMe) {
        localStorage.setItem('authToken', data.token);
      } else {
        sessionStorage.setItem('authToken', data.token);  // Clears on tab close
      }
      
      // Store user info
      localStorage.setItem('user', JSON.stringify(data.user));
      
      // Redirect
      const redirectTo = new URLSearchParams(window.location.search).get('redirect') || '/dashboard';
      window.location.href = redirectTo;
      
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    &lt;div className="auth-container"&gt;
      &lt;h2&gt;Welcome Back&lt;/h2&gt;
      
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
          &lt;input
            id="email"
            type="email"
            value={credentials.email}
            onChange={(e) => setCredentials({...credentials, email: e.target.value})}
            required
          /&gt;
        &lt;/div&gt;
        
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
          &lt;input
            id="password"
            type="password"
            value={credentials.password}
            onChange={(e) => setCredentials({...credentials, password: e.target.value})}
            required
          /&gt;
        &lt;/div&gt;
        
        &lt;div className="form-group checkbox"&gt;
          &lt;label&gt;
            &lt;input
              type="checkbox"
              checked={rememberMe}
              onChange={(e) => setRememberMe(e.target.checked)}
            /&gt;
            Remember me for 30 days
          &lt;/label&gt;
        &lt;/div&gt;
        
        &lt;button type="submit" disabled={isLoading}&gt;
          {isLoading ? 'Logging in...' : 'Login'}
        &lt;/button&gt;
        
        {errors.submit && &lt;div className="error-banner"&gt;{errors.submit}&lt;/div&gt;}
      &lt;/form&gt;
      
      &lt;div className="auth-links"&gt;
        &lt;a href="/forgot-password"&gt;Forgot password?&lt;/a&gt;
        &lt;a href="/register"&gt;Create account&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <div class="info-box">
                <h4>localStorage vs sessionStorage</h4>
                <p><strong>localStorage:</strong> Data persists forever (until manually cleared)<br>
                â†’ Use for "Remember Me" functionality<br><br>
                <strong>sessionStorage:</strong> Data cleared when tab closes<br>
                â†’ Use for temporary sessions (better security)<br><br>
                Let users choose based on whether they're on a public or private device!</p>
            </div>

            <h4>Automatic Token Refresh</h4>

            <p>Silently refresh tokens before they expire for seamless user experience:</p>

            <div class="code-block">
                <pre><code>import { useEffect, useRef } from 'react';

function useTokenRefresh() {
  const refreshTimeoutRef = useRef(null);
  
  const scheduleTokenRefresh = (expiresIn) => {
    // Refresh 5 minutes before expiration
    const refreshTime = (expiresIn - 300) * 1000;  // Convert to milliseconds
    
    if (refreshTimeoutRef.current) {
      clearTimeout(refreshTimeoutRef.current);
    }
    
    refreshTimeoutRef.current = setTimeout(async () => {
      try {
        const token = localStorage.getItem('authToken');
        
        const response = await fetch('https://api.example.com/refresh', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          localStorage.setItem('authToken', data.token);
          
          // Schedule next refresh
          scheduleTokenRefresh(data.expiresIn);
        } else {
          // Token refresh failed - logout
          localStorage.removeItem('authToken');
          window.location.href = '/login';
        }
      } catch (error) {
        console.error('Token refresh failed:', error);
        window.location.href = '/login';
      }
    }, refreshTime);
  };
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('authToken');
    
    if (token) {
      // Decode token to get expiration time
      try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        const expiresIn = payload.exp - Math.floor(Date.now() / 1000);
        
        if (expiresIn > 0) {
          scheduleTokenRefresh(expiresIn);
        } else {
          // Token already expired
          localStorage.removeItem('authToken');
          window.location.href = '/login';
        }
      } catch (error) {
        console.error('Invalid token:', error);
        localStorage.removeItem('authToken');
      }
    }
    
    // Cleanup on unmount
    return () => {
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current);
      }
    };
  }, []);
}

// Usage in App.js
function App() {
  useTokenRefresh();  // Automatically handles token refresh!
  
  return (
    &lt;div&gt;
      {/* Your app */}
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <h4>Logout Functionality</h4>

            <div class="code-block">
                <pre><code>function LogoutButton() {
  const [isLoggingOut, setIsLoggingOut] = useState(false);
  
  const handleLogout = async () => {
    setIsLoggingOut(true);
    
    try {
      const token = localStorage.getItem('authToken');
      
      // Tell server to invalidate token (optional but recommended)
      await fetch('https://api.example.com/logout', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      // Clear local data regardless of server response
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
      sessionStorage.clear();
      
      // Redirect to login
      window.location.href = '/login';
    }
  };
  
  return (
    &lt;button onClick={handleLogout} disabled={isLoggingOut}&gt;
      {isLoggingOut ? 'Logging out...' : 'Logout'}
    &lt;/button&gt;
  );
}</code></pre>
            </div>

            <h3>Auth Context Pattern: Complete Implementation</h3>
            
            <p>The best way to manage authentication state in React is with Context API. This makes user info and auth functions available throughout your app:</p>

            <div class="code-block">
                <pre><code>// src/contexts/AuthContext.jsx
import React, { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Check if user is logged in on mount
  useEffect(() => {
    const initAuth = async () => {
      const token = localStorage.getItem('authToken');
      
      if (!token) {
        setLoading(false);
        return;
      }
      
      try {
        // Verify token and get user data
        const response = await fetch('https://api.example.com/auth/me', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          const userData = await response.json();
          setUser(userData);
        } else {
          // Token invalid
          localStorage.removeItem('authToken');
        }
      } catch (err) {
        console.error('Auth initialization error:', err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    initAuth();
  }, []);
  
  const login = async (credentials) => {
    setError(null);
    
    try {
      const response = await fetch('https://api.example.com/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Login failed');
      }
      
      const data = await response.json();
      
      // Store token
      localStorage.setItem('authToken', data.token);
      
      // Set user
      setUser(data.user);
      
      return { success: true };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    }
  };
  
  const register = async (userData) => {
    setError(null);
    
    try {
      const response = await fetch('https://api.example.com/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Registration failed');
      }
      
      const data = await response.json();
      
      // Store token
      localStorage.setItem('authToken', data.token);
      
      // Set user
      setUser(data.user);
      
      return { success: true };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    }
  };
  
  const logout = async () => {
    try {
      const token = localStorage.getItem('authToken');
      
      // Tell server to invalidate token
      await fetch('https://api.example.com/logout', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` }
      });
    } catch (err) {
      console.error('Logout error:', err);
    } finally {
      // Clear local state
      localStorage.removeItem('authToken');
      setUser(null);
    }
  };
  
  const updateUser = (updates) => {
    setUser(prev => ({ ...prev, ...updates }));
  };
  
  const value = {
    user,
    loading,
    error,
    login,
    register,
    logout,
    updateUser,
    isAuthenticated: !!user
  };
  
  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

// Custom hook to use auth context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
}</code></pre>
            </div>

            <h4>Setting Up AuthProvider in Your App</h4>

            <div class="code-block">
                <pre><code>// src/App.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import ProtectedRoute from './components/ProtectedRoute';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';

function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;BrowserRouter&gt;
        &lt;Routes&gt;
          {/* Public routes */}
          &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
          &lt;Route path="/register" element={&lt;RegisterPage /&gt;} /&gt;
          
          {/* Protected routes */}
          &lt;Route
            path="/dashboard"
            element={
              &lt;ProtectedRoute&gt;
                &lt;Dashboard /&gt;
              &lt;/ProtectedRoute&gt;
            }
          /&gt;
          
          &lt;Route
            path="/profile"
            element={
              &lt;ProtectedRoute&gt;
                &lt;Profile /&gt;
              &lt;/ProtectedRoute&gt;
            }
          /&gt;
        &lt;/Routes&gt;
      &lt;/BrowserRouter&gt;
    &lt;/AuthProvider&gt;
  );
}

export default App;</code></pre>
            </div>

            <h4>Using Auth in Components</h4>

            <div class="code-block">
                <pre><code>// Simple usage - check if logged in
function Header() {
  const { user, logout, isAuthenticated } = useAuth();
  
  return (
    &lt;header&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      
      {isAuthenticated ? (
        &lt;div&gt;
          &lt;span&gt;Welcome, {user.name}!&lt;/span&gt;
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;div&gt;
          &lt;a href="/login"&gt;Login&lt;/a&gt;
          &lt;a href="/register"&gt;Sign Up&lt;/a&gt;
        &lt;/div&gt;
      )}
    &lt;/header&gt;
  );
}

// In login page
function LoginPage() {
  const { login, error } = useAuth();
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const navigate = useNavigate();
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const result = await login(credentials);
    
    if (result.success) {
      navigate('/dashboard');
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      {/* form fields */}
      {error && &lt;div className="error"&gt;{error}&lt;/div&gt;}
    &lt;/form&gt;
  );
}

// In dashboard
function Dashboard() {
  const { user, loading } = useAuth();
  
  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      &lt;p&gt;Welcome back, {user.name}!&lt;/p&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Role: {user.role}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>

            <h4>Advanced: Role-Based Protection</h4>

            <div class="code-block">
                <pre><code>// Check user role in ProtectedRoute
function ProtectedRoute({ children, requiredRole }) {
  const { user, loading, isAuthenticated } = useAuth();
  
  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" /&gt;;
  }
  
  // Check role if specified
  if (requiredRole && user.role !== requiredRole) {
    return &lt;div&gt;Access Denied: Insufficient permissions&lt;/div&gt;;
  }
  
  return children;
}

// Usage: Admin-only route
&lt;Route
  path="/admin"
  element={
    &lt;ProtectedRoute requiredRole="admin"&gt;
      &lt;AdminPanel /&gt;
    &lt;/ProtectedRoute&gt;
  }
/&gt;</code></pre>
            </div>

            <div class="info-box">
                <h4>Why Auth Context is Powerful</h4>
                <p><strong>âœ… Single source of truth:</strong> User state is centralized<br>
                <strong>âœ… Available everywhere:</strong> Any component can access auth with useAuth()<br>
                <strong>âœ… Automatic updates:</strong> When user logs in/out, ALL components re-render<br>
                <strong>âœ… Clean code:</strong> No prop drilling, no Redux for simple auth<br>
                <strong>âœ… Easy to test:</strong> Mock AuthProvider in tests<br><br>
                For most apps, Context is perfect for authentication!</p>
            </div>

            <h4>Complete Working Example: Mini Auth App</h4>

            <div class="code-block">
                <pre><code>// Full mini app with authentication
import React, { createContext, useContext, useState } from 'react';

// Mock API (replace with real backend)
const mockAPI = {
  async login(credentials) {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    if (credentials.email === 'demo@example.com' && credentials.password === 'password123') {
      return {
        token: 'mock-jwt-token-12345',
        user: { id: 1, name: 'Demo User', email: 'demo@example.com', role: 'user' }
      };
    }
    throw new Error('Invalid credentials');
  },
  
  async getProfile(token) {
    await new Promise(resolve => setTimeout(resolve, 500));
    return { id: 1, name: 'Demo User', email: 'demo@example.com', role: 'user' };
  }
};

// Auth Context
const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const login = async (credentials) => {
    setLoading(true);
    try {
      const data = await mockAPI.login(credentials);
      localStorage.setItem('authToken', data.token);
      setUser(data.user);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    localStorage.removeItem('authToken');
    setUser(null);
  };
  
  return (
    &lt;AuthContext.Provider value={{ user, loading, login, logout, isAuthenticated: !!user }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

function useAuth() {
  return useContext(AuthContext);
}

// Login Component
function Login({ onSuccess }) {
  const { login, loading } = useAuth();
  const [email, setEmail] = useState('demo@example.com');
  const [password, setPassword] = useState('password123');
  const [error, setError] = useState('');
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    const result = await login({ email, password });
    
    if (result.success) {
      onSuccess();
    } else {
      setError(result.error);
    }
  };
  
  return (
    &lt;div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}&gt;
      &lt;h2&gt;Login&lt;/h2&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;div&gt;
          &lt;input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Email"
            style={{ width: '100%', padding: '10px', marginBottom: '10px' }}
          /&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Password"
            style={{ width: '100%', padding: '10px', marginBottom: '10px' }}
          /&gt;
        &lt;/div&gt;
        &lt;button type="submit" disabled={loading} style={{ padding: '10px 20px' }}&gt;
          {loading ? 'Logging in...' : 'Login'}
        &lt;/button&gt;
        {error && &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}
      &lt;/form&gt;
      &lt;p&gt;Hint: demo@example.com / password123&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Dashboard Component
function Dashboard() {
  const { user, logout } = useAuth();
  
  return (
    &lt;div style={{ padding: '20px' }}&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Role: {user.role}&lt;/p&gt;
      &lt;button onClick={logout} style={{ padding: '10px 20px' }}&gt;Logout&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Main App
function MiniAuthApp() {
  const { isAuthenticated } = useAuth();
  const [showDashboard, setShowDashboard] = useState(false);
  
  return (
    &lt;div&gt;
      {!isAuthenticated || !showDashboard ? (
        &lt;Login onSuccess={() => setShowDashboard(true)} /&gt;
      ) : (
        &lt;Dashboard /&gt;
      )}
    &lt;/div&gt;
  );
}

// Root component
function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;MiniAuthApp /&gt;
    &lt;/AuthProvider&gt;
  );
}

export default App;</code></pre>
            </div>

            <div class="metaphor-box">
                <h4>ğŸ‰ You're Now an Authentication Expert!</h4>
                <p>You've mastered one of the most important aspects of web development:<br><br>
                âœ… <strong>JWT tokens:</strong> How they work and why they're secure<br>
                âœ… <strong>Access + Refresh tokens:</strong> Professional two-token system<br>
                âœ… <strong>Storage options:</strong> localStorage vs httpOnly cookies vs memory<br>
                âœ… <strong>Login/Register flows:</strong> With validation and error handling<br>
                âœ… <strong>Protected routes:</strong> Keeping pages secure<br>
                âœ… <strong>Auth Context:</strong> Global authentication state<br>
                âœ… <strong>Automatic refresh:</strong> Seamless user experience<br><br>
                Authentication is no longer a mysteryâ€”you can build secure, professional-grade auth systems. Remember: security is about layers. Use HTTPS, validate everything, expire tokens, and never trust user input. You're ready to build real-world applications!</p>
            </div>
        </section>

        <!-- SECTION 7: File Uploads -->
        <section id="file-uploads" class="section">
            <h2 class="section-title">File Uploads & Media</h2>
            <p class="section-intro">Users need to upload profile pictures, documents, videosâ€”how do you handle files in your web app? Let's learn how to accept file uploads, validate them, preview images, and send them to your backend!</p>

            <h3>The HTML File Input</h3>
            
            <p>The simplest way to let users select files is the HTML file input:</p>

            <div class="code">&lt;input type="file" /&gt;

// With restrictions:
&lt;input type="file" accept="image/*" /&gt;  {/* Only images */}
&lt;input type="file" accept=".pdf,.doc,.docx" /&gt;  {/* Only documents */}
&lt;input type="file" multiple /&gt;  {/* Allow multiple files */}</div>

            <h3>Complete React File Upload Example</h3>
            
            <div class="code">import React, { useState } from 'react';

function ImageUpload() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [preview, setPreview] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [message, setMessage] = useState('');
  
  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    
    if (!file) return;
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
      setMessage('Please select an image file');
      return;
    }
    
    // Validate file size (e.g., max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      setMessage('File too large (max 5MB)');
      return;
    }
    
    setSelectedFile(file);
    
    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result);
    };
    reader.readAsDataURL(file);
  };
  
  const handleUpload = async () => {
    if (!selectedFile) return;
    
    setUploading(true);
    setMessage('');
    
    // Create FormData (special format for file uploads)
    const formData = new FormData();
    formData.append('image', selectedFile);
    
    try {
      const response = await fetch('https://api.example.com/upload', {
        method: 'POST',
        body: formData  // Don't set Content-Type - browser does it automatically
      });
      
      if (!response.ok) throw new Error('Upload failed');
      
      const data = await response.json();
      setMessage('Upload successful! URL: ' + data.url);
    } catch (error) {
      setMessage('Error: ' + error.message);
    } finally {
      setUploading(false);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Upload Image&lt;/h2&gt;
      
      &lt;input type="file" accept="image/*" onChange={handleFileSelect} /&gt;
      
      {preview && (
        &lt;div&gt;
          &lt;h3&gt;Preview:&lt;/h3&gt;
          &lt;img src={preview} alt="Preview" style={{ maxWidth: '300px' }} /&gt;
        &lt;/div&gt;
      )}
      
      &lt;button onClick={handleUpload} disabled={!selectedFile || uploading}&gt;
        {uploading ? 'Uploading...' : 'Upload'}
      &lt;/button&gt;
      
      {message && &lt;p&gt;{message}&lt;/p&gt;}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>Key File Upload Concepts</h4>
                <p><strong>1. FormData:</strong> Special object for sending files (can mix files + text data)<br>
                <strong>2. FileReader:</strong> Reads file contents for preview<br>
                <strong>3. Validation:</strong> Check type and size before uploading<br>
                <strong>4. No Content-Type header:</strong> Browser sets it automatically with boundary</p>
            </div>

            <div class="metaphor-box">
                <h4>You Can Now Handle File Uploads!</h4>
                <p>File uploads are essential for modern apps. Whether it's profile pictures, documents, or media filesâ€”you now have the foundation to handle them securely and efficiently!</p>
            </div>

            <h3>Part 2: Advanced File Upload Patterns</h3>
            
            <h4>Multiple File Uploads</h4>
            
            <p>Users often need to upload multiple files at once. Let's handle that:</p>

            <div class="code">function MultiFileUpload() {
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [uploading, setUploading] = useState(false);
  
  const handleFilesSelect = (e) => {
    const selectedFiles = Array.from(e.target.files);
    
    // Validate each file
    const validFiles = selectedFiles.filter(file => {
      if (file.size > 5 * 1024 * 1024) {
        alert(`${file.name} is too large (max 5MB)`);
        return false;
      }
      return true;
    });
    
    setFiles(validFiles);
    
    // Create previews for images
    const newPreviews = [];
    validFiles.forEach(file => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onloadend = () => {
          newPreviews.push({ name: file.name, url: reader.result });
          if (newPreviews.length === validFiles.length) {
            setPreviews(newPreviews);
          }
        };
        reader.readAsDataURL(file);
      }
    });
  };
  
  const handleUpload = async () => {
    if (files.length === 0) return;
    
    setUploading(true);
    const formData = new FormData();
    
    // Append all files
    files.forEach((file, index) => {
      formData.append('files', file);  // Note: same key for multiple files
    });
    
    try {
      const response = await fetch('/api/upload-multiple', {
        method: 'POST',
        body: formData,
      });
      
      const data = await response.json();
      
      if (response.ok) {
        alert(`Uploaded ${data.files.length} files successfully!`);
        setFiles([]);
        setPreviews([]);
      }
    } catch (error) {
      alert('Upload failed: ' + error.message);
    } finally {
      setUploading(false);
    }
  };
  
  const removeFile = (index) => {
    setFiles(files.filter((_, i) => i !== index));
    setPreviews(previews.filter((_, i) => i !== index));
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="file"
        multiple
        accept="image/*"
        onChange={handleFilesSelect}
      /&gt;
      
      &lt;div className="preview-grid"&gt;
        {previews.map((preview, index) => (
          &lt;div key={index} className="preview-item"&gt;
            &lt;img src={preview.url} alt={preview.name} /&gt;
            &lt;button onClick={() => removeFile(index)}&gt;Remove&lt;/button&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {files.length > 0 && (
        &lt;button onClick={handleUpload} disabled={uploading}&gt;
          {uploading ? 'Uploading...' : `Upload ${files.length} files`}
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}</div>

            <h4>Upload Progress Tracking</h4>
            
            <p>For large files, users want to see upload progress. Use <code>XMLHttpRequest</code> for progress events:</p>

            <div class="code">function FileUploadWithProgress() {
  const [file, setFile] = useState(null);
  const [progress, setProgress] = useState(0);
  const [uploading, setUploading] = useState(false);
  
  const handleUpload = () => {
    if (!file) return;
    
    const formData = new FormData();
    formData.append('file', file);
    
    const xhr = new XMLHttpRequest();
    
    // Track upload progress
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        setProgress(Math.round(percentComplete));
      }
    });
    
    // Handle completion
    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        alert('Upload complete!');
        setProgress(0);
        setFile(null);
      } else {
        alert('Upload failed!');
      }
      setUploading(false);
    });
    
    // Handle errors
    xhr.addEventListener('error', () => {
      alert('Upload error!');
      setUploading(false);
    });
    
    // Send request
    xhr.open('POST', '/api/upload');
    xhr.send(formData);
    setUploading(true);
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="file"
        onChange={(e) => setFile(e.target.files[0])}
      /&gt;
      
      {uploading && (
        &lt;div&gt;
          &lt;progress value={progress} max="100"&gt;{progress}%&lt;/progress&gt;
          &lt;span&gt;{progress}%&lt;/span&gt;
        &lt;/div&gt;
      )}
      
      &lt;button onClick={handleUpload} disabled={!file || uploading}&gt;
        Upload
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>Why XMLHttpRequest Instead of Fetch?</h4>
                <p><code>fetch()</code> doesn't support upload progress events yet. For progress tracking, you need <code>XMLHttpRequest</code> (the old way of making requests). Alternatively, use libraries like Axios that handle this for you!</p>
            </div>

            <h3>Part 3: Drag and Drop Uploads</h3>
            
            <p>Users love drag-and-drop! It's more intuitive than clicking a file input:</p>

            <div class="code">function DragDropUpload() {
  const [isDragging, setIsDragging] = useState(false);
  const [file, setFile] = useState(null);
  
  const handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };
  
  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };
  
  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
    
    const droppedFile = e.dataTransfer.files[0];
    
    if (droppedFile) {
      // Validate file type
      if (!droppedFile.type.startsWith('image/')) {
        alert('Please drop an image file');
        return;
      }
      
      // Validate file size (5MB max)
      if (droppedFile.size > 5 * 1024 * 1024) {
        alert('File too large (max 5MB)');
        return;
      }
      
      setFile(droppedFile);
    }
  };
  
  return (
    &lt;div
      onDragEnter={handleDragEnter}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      style={{
        border: isDragging ? '2px dashed #0066cc' : '2px dashed #ccc',
        borderRadius: '8px',
        padding: '40px',
        textAlign: 'center',
        backgroundColor: isDragging ? '#e6f2ff' : '#f9f9f9',
        transition: 'all 0.3s',
        cursor: 'pointer',
      }}
    &gt;
      {file ? (
        &lt;div&gt;
          &lt;p&gt;ğŸ“„ {file.name}&lt;/p&gt;
          &lt;p&gt;{(file.size / 1024).toFixed(2)} KB&lt;/p&gt;
          &lt;button onClick={() => setFile(null)}&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;p&gt;{isDragging ? 'Drop file here!' : 'Drag & drop a file here'}&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>Drag and Drop Events</h4>
                <p><strong>dragenter:</strong> User drags file over the drop zone<br>
                <strong>dragover:</strong> User continues dragging over the zone (fires repeatedly)<br>
                <strong>dragleave:</strong> User drags file out of the zone<br>
                <strong>drop:</strong> User releases the file!<br><br>
                You MUST call <code>e.preventDefault()</code> on all events or the browser will try to open the file!</p>
            </div>

            <h3>Part 4: Cloud Storage Integration</h3>
            
            <h4>Uploading to Cloudinary</h4>
            
            <p>For production apps, you usually upload to cloud storage services like Cloudinary, AWS S3, or Google Cloud Storage. Here's a Cloudinary example:</p>

            <div class="code">// Client-side upload to Cloudinary
function CloudinaryUpload() {
  const [file, setFile] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  
  const handleUpload = async () => {
    if (!file) return;
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', 'your_upload_preset');  // Set in Cloudinary dashboard
    
    setUploading(true);
    
    try {
      const response = await fetch(
        'https://api.cloudinary.com/v1_1/your_cloud_name/image/upload',
        {
          method: 'POST',
          body: formData,
        }
      );
      
      const data = await response.json();
      
      if (response.ok) {
        setImageUrl(data.secure_url);  // URL of uploaded image
        alert('Uploaded to Cloudinary!');
      }
    } catch (error) {
      alert('Upload failed: ' + error.message);
    } finally {
      setUploading(false);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="file"
        accept="image/*"
        onChange={(e) => setFile(e.target.files[0])}
      /&gt;
      
      &lt;button onClick={handleUpload} disabled={!file || uploading}&gt;
        {uploading ? 'Uploading...' : 'Upload to Cloudinary'}
      &lt;/button&gt;
      
      {imageUrl && (
        &lt;div&gt;
          &lt;p&gt;Uploaded image:&lt;/p&gt;
          &lt;img src={imageUrl} alt="Uploaded" style={{ maxWidth: '400px' }} /&gt;
          &lt;p&gt;URL: {imageUrl}&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>Why Use Cloud Storage?</h4>
                <p><strong>Your server:</strong> Limited storage, you pay for bandwidth, have to manage backups<br>
                <strong>Cloud storage:</strong> Unlimited storage, CDN delivery (fast worldwide), automatic backups, image transformations<br><br>
                For production apps, always use cloud storage for user uploads!</p>
            </div>

            <h4>Backend File Handling (Node.js Example)</h4>
            
            <p>If you want to handle uploads on your own server, use Multer (Node.js middleware):</p>

            <div class="code">// server.js
const express = require('express');
const multer = require('multer');
const path = require('path');

const app = express();

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');  // Save to uploads folder
  },
  filename: (req, file, cb) => {
    // Generate unique filename
    const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueName + path.extname(file.originalname));
  },
});

// File filter (validation)
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);  // Accept file
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, GIF allowed.'), false);
  }
};

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 },  // 5MB max
  fileFilter: fileFilter,
});

// Single file upload endpoint
app.post('/api/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  res.json({
    message: 'File uploaded successfully',
    filename: req.file.filename,
    path: `/uploads/${req.file.filename}`,
    size: req.file.size,
  });
});

// Multiple files upload endpoint
app.post('/api/upload-multiple', upload.array('files', 10), (req, res) => {
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ error: 'No files uploaded' });
  }
  
  const files = req.files.map(file => ({
    filename: file.filename,
    path: `/uploads/${file.filename}`,
    size: file.size,
  }));
  
  res.json({
    message: `Uploaded ${files.length} files`,
    files: files,
  });
});

// Serve uploaded files
app.use('/uploads', express.static('uploads'));

app.listen(3000, () => console.log('Server running on port 3000'));</div>

            <div class="warning-box">
                <h4>Security Considerations</h4>
                <p><strong>1. Validate file type:</strong> Check MIME type AND file extension<br>
                <strong>2. Limit file size:</strong> Prevent huge uploads that could crash your server<br>
                <strong>3. Sanitize filenames:</strong> Remove special characters, prevent path traversal<br>
                <strong>4. Scan for viruses:</strong> Use services like ClamAV for production<br>
                <strong>5. Store outside web root:</strong> Don't let users directly execute uploaded files<br>
                <strong>6. Use HTTPS:</strong> Files sent over HTTP can be intercepted</p>
            </div>

            <h3>Part 5: Image Cropping and Editing</h3>
            
            <p>Sometimes users need to crop or resize images before uploading. Use libraries like React Crop or React Easy Crop:</p>

            <div class="code">// Using react-easy-crop
import React, { useState, useCallback } from 'react';
import Cropper from 'react-easy-crop';

function ImageCropper() {
  const [imageSrc, setImageSrc] = useState(null);
  const [crop, setCrop] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState(null);
  
  const onFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setImageSrc(reader.result);
      };
      reader.readAsDataURL(file);
    }
  };
  
  const onCropComplete = useCallback((croppedArea, croppedAreaPixels) => {
    setCroppedAreaPixels(croppedAreaPixels);
  }, []);
  
  const handleCrop = async () => {
    // Use croppedAreaPixels to crop the image
    // (Implementation requires canvas manipulation)
    console.log('Crop area:', croppedAreaPixels);
  };
  
  return (
    &lt;div&gt;
      &lt;input type="file" accept="image/*" onChange={onFileChange} /&gt;
      
      {imageSrc && (
        &lt;div style={{ position: 'relative', width: '100%', height: '400px' }}&gt;
          &lt;Cropper
            image={imageSrc}
            crop={crop}
            zoom={zoom}
            aspect={1}  // Square crop
            onCropChange={setCrop}
            onZoomChange={setZoom}
            onCropComplete={onCropComplete}
          /&gt;
        &lt;/div&gt;
      )}
      
      {imageSrc && (
        &lt;div&gt;
          &lt;input
            type="range"
            min={1}
            max={3}
            step={0.1}
            value={zoom}
            onChange={(e) => setZoom(e.target.value)}
          /&gt;
          &lt;button onClick={handleCrop}&gt;Crop & Upload&lt;/button&gt;
        &lt;/div&gt      )}
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>File Uploads: Mastered! ğŸ“</h4>
                <p>You now know:<br><br>
                âœ… Basic file inputs and FormData<br>
                âœ… Preview images before upload<br>
                âœ… Multiple file uploads<br>
                âœ… Progress tracking<br>
                âœ… Drag and drop<br>
                âœ… Cloud storage (Cloudinary)<br>
                âœ… Backend handling (Multer)<br>
                âœ… Image cropping<br><br>
                File uploads are no longer intimidating. Start with basics, then add features as needed. Remember: validate EVERYTHING, limit sizes, and use cloud storage for production!</p>
            </div>

            <h3>Part 4: Advanced File Upload Patterns</h3>
            
            <h4>Resumable Uploads for Large Files</h4>
            
            <p>For huge files (videos, datasets), you want to upload in CHUNKS so if the connection fails, you can resume from where you left off:</p>

            <div class="code">// Chunked upload implementation
async function uploadLargeFile(file) {
  const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
  const chunks = Math.ceil(file.size / CHUNK_SIZE);
  const uploadId = Date.now(); // Unique upload session ID
  
  for (let chunkIndex = 0; chunkIndex < chunks; chunkIndex++) {
    const start = chunkIndex * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);
    
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('chunkIndex', chunkIndex);
    formData.append('totalChunks', chunks);
    formData.append('uploadId', uploadId);
    formData.append('fileName', file.name);
    
    const response = await fetch('/api/upload-chunk', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error(`Chunk ${chunkIndex} failed`);
    }
    
    // Update progress
    const progress = ((chunkIndex + 1) / chunks) * 100;
    console.log(`Uploaded ${progress.toFixed(2)}%`);
  }
  
  // Finalize upload (backend merges chunks)
  await fetch('/api/finalize-upload', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ uploadId, fileName: file.name }),
  });
}

// Backend (Node.js + Express)
const fs = require('fs');
const path = require('path');

app.post('/api/upload-chunk', upload.single('chunk'), (req, res) => {
  const { chunkIndex, uploadId, fileName } = req.body;
  const chunkDir = path.join(__dirname, 'uploads', uploadId);
  
  // Create directory for this upload session
  if (!fs.existsSync(chunkDir)) {
    fs.mkdirSync(chunkDir, { recursive: true });
  }
  
  // Save chunk
  const chunkPath = path.join(chunkDir, `chunk-${chunkIndex}`);
  fs.renameSync(req.file.path, chunkPath);
  
  res.json({ success: true });
});

app.post('/api/finalize-upload', (req, res) => {
  const { uploadId, fileName } = req.body;
  const chunkDir = path.join(__dirname, 'uploads', uploadId);
  const finalPath = path.join(__dirname, 'uploads', fileName);
  
  // Get all chunks in order
  const chunks = fs.readdirSync(chunkDir)
    .sort((a, b) => {
      const aNum = parseInt(a.split('-')[1]);
      const bNum = parseInt(b.split('-')[1]);
      return aNum - bNum;
    });
  
  // Merge chunks into final file
  const writeStream = fs.createWriteStream(finalPath);
  
  for (const chunk of chunks) {
    const chunkPath = path.join(chunkDir, chunk);
    const data = fs.readFileSync(chunkPath);
    writeStream.write(data);
  }
  
  writeStream.end();
  
  // Cleanup chunks
  fs.rmSync(chunkDir, { recursive: true });
  
  res.json({ success: true, url: `/uploads/${fileName}` });
});</div>

            <div class="metaphor-box">
                <h4>Chunked Upload = Sending a Book Page by Page</h4>
                <p>Instead of mailing an entire book (might get lost!):<br><br>
                <strong>1.</strong> Split the book into pages<br>
                <strong>2.</strong> Mail one page at a time with page numbers<br>
                <strong>3.</strong> Recipient reassembles pages in order<br>
                <strong>4.</strong> If page 7 gets lost, just resend page 7!<br><br>
                This is how YouTube, Google Drive, and Dropbox handle large file uploads. If your internet cuts out, you resume from the last successful chunk instead of starting over!</p>
            </div>

            <h4>Security: File Type Validation</h4>
            
            <div class="warning-box">
                <h4>âš ï¸ NEVER Trust File Extensions!</h4>
                <p>An attacker can rename <code>virus.exe</code> to <code>cute-cat.jpg</code>. Your backend must validate the ACTUAL file type by reading the file's "magic bytes" (first few bytes that identify file types).</p>
            </div>

            <div class="code">// Frontend: Basic validation (not enough!)
function validateFile(file) {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  
  if (!allowedTypes.includes(file.type)) {
    alert('Only JPEG, PNG, and GIF images allowed');
    return false;
  }
  
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    alert('File must be under 5MB');
    return false;
  }
  
  return true;
}

// Backend: Proper validation (REQUIRED!)
const fileType = require('file-type');

app.post('/api/upload', upload.single('file'), async (req, res) => {
  const buffer = fs.readFileSync(req.file.path);
  
  // Check ACTUAL file type by reading magic bytes
  const type = await fileType.fromBuffer(buffer);
  
  if (!type || !['image/jpeg', 'image/png', 'image/gif'].includes(type.mime)) {
    fs.unlinkSync(req.file.path); // Delete malicious file
    return res.status(400).json({ error: 'Invalid file type' });
  }
  
  // Also check file size (Multer does this, but double-check)
  if (buffer.length > 5 * 1024 * 1024) {
    fs.unlinkSync(req.file.path);
    return res.status(400).json({ error: 'File too large' });
  }
  
  res.json({ success: true });
});</div>

            <h4>Image Compression Before Upload</h4>
            
            <p>Users might upload 10MB photos from their phones. Compress images on the frontend to save bandwidth:</p>

            <div class="code">// Install: npm install browser-image-compression
import imageCompression from 'browser-image-compression';

async function handleImageUpload(file) {
  const options = {
    maxSizeMB: 1,        // Max file size 1MB
    maxWidthOrHeight: 1920, // Max dimension 1920px
    useWebWorker: true,  // Use web worker for performance
  };
  
  try {
    const compressedFile = await imageCompression(file, options);
    
    console.log('Original:', file.size / 1024 / 1024, 'MB');
    console.log('Compressed:', compressedFile.size / 1024 / 1024, 'MB');
    
    // Now upload compressed file
    const formData = new FormData();
    formData.append('file', compressedFile);
    
    await fetch('/api/upload', {
      method: 'POST',
      body: formData,
    });
  } catch (error) {
    console.error('Compression failed:', error);
  }
}

// React component
function ImageUploadWithCompression() {
  const [preview, setPreview] = useState(null);
  const [compressing, setCompressing] = useState(false);
  
  const handleChange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    setCompressing(true);
    
    const compressed = await imageCompression(file, {
      maxSizeMB: 1,
      maxWidthOrHeight: 1920,
    });
    
    setCompressing(false);
    
    // Show preview
    const reader = new FileReader();
    reader.onloadend = () => setPreview(reader.result);
    reader.readAsDataURL(compressed);
    
    // Upload compressed file
    const formData = new FormData();
    formData.append('file', compressed);
    
    await fetch('/api/upload', {
      method: 'POST',
      body: formData,
    });
  };
  
  return (
    &lt;div&gt;
      &lt;input type=\"file\" accept=\"image/*\" onChange={handleChange} /&gt;
      {compressing && &lt;p&gt;Compressing...&lt;/p&gt;}
      {preview && &lt;img src={preview} width=\"300\" /&gt;}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>When to Compress</h4>
                <p><strong>Compress on frontend:</strong> Photos, thumbnails, avatars<br>
                <strong>Don't compress:</strong> Documents (PDFs, Word), archives (ZIP), already compressed formats (MP4 video)<br><br>
                Compression reduces bandwidth costs, speeds up uploads, and improves user experience on slow connections!</p>
            </div>

            <h3>Part 5: Advanced Cloud Storage Patterns</h3>
            
            <h4>Direct Upload to S3 (Bypass Your Server)</h4>
            
            <p>For large files, uploading through your server wastes bandwidth and memory. Instead, get a signed URL from your server, then upload DIRECTLY to S3:</p>

            <div class="code">// Backend: Generate presigned URL
const AWS = require('aws-sdk');
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY,
  secretAccessKey: process.env.AWS_SECRET_KEY,
  region: 'us-east-1',
});

app.post('/api/get-upload-url', async (req, res) => {
  const { fileName, fileType } = req.body;
  
  const params = {
    Bucket: 'my-bucket',
    Key: `uploads/${Date.now()}-${fileName}`,
    Expires: 60, // URL valid for 60 seconds
    ContentType: fileType,
    ACL: 'public-read', // Or 'private'
  };
  
  const uploadURL = await s3.getSignedUrlPromise('putObject', params);
  
  res.json({ uploadURL, key: params.Key });
});

// Frontend: Upload directly to S3
async function uploadToS3(file) {
  // 1. Get presigned URL from your server
  const response = await fetch('/api/get-upload-url', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fileName: file.name,
      fileType: file.type,
    }),
  });
  
  const { uploadURL, key } = await response.json();
  
  // 2. Upload directly to S3 using presigned URL
  await fetch(uploadURL, {
    method: 'PUT',
    body: file,
    headers: {
      'Content-Type': file.type,
    },
  });
  
  // 3. File is now on S3!
  const publicURL = `https://my-bucket.s3.amazonaws.com/${key}`;
  console.log('File uploaded:', publicURL);
  
  // 4. Save publicURL to your database
  await fetch('/api/save-file-url', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ url: publicURL }),
  });
}</div>

            <div class="metaphor-box">
                <h4>Direct Upload = Bypassing the Post Office</h4>
                <p><strong>Normal upload:</strong> You â†’ Post Office (your server) â†’ Warehouse (S3)<br>
                The post office becomes a bottleneck!<br><br>
                <strong>Direct upload:</strong> Post office gives you a special delivery pass. You drive straight to the warehouse and drop off the package yourself!<br><br>
                Your server's job is just to generate the pass (presigned URL). The actual file transfer happens directly between user and S3, saving your server's bandwidth!</p>
            </div>

            <h4>Video Processing Pipeline</h4>
            
            <p>For video uploads, you typically want to transcode them to multiple formats/qualities:</p>

            <div class="code">// 1. User uploads video to S3
// 2. S3 triggers Lambda function
// 3. Lambda starts AWS MediaConvert job
// 4. MediaConvert creates multiple versions (1080p, 720p, 480p)
// 5. Lambda updates database with video URLs
// 6. Frontend plays adaptive video (HLS or DASH)

// Backend: Trigger processing after upload
app.post('/api/process-video', async (req, res) => {
  const { videoKey } = req.body; // S3 key of uploaded video
  
  // Send message to SQS queue (worker will process it)
  await sqs.sendMessage({
    QueueUrl: process.env.QUEUE_URL,
    MessageBody: JSON.stringify({
      videoKey,
      userId: req.user.id,
    }),
  }).promise();
  
  res.json({ message: 'Processing started' });
});

// Worker (separate process)
async function processVideo(videoKey, userId) {
  // 1. Download from S3
  const video = await s3.getObject({
    Bucket: 'my-bucket',
    Key: videoKey,
  }).promise();
  
  // 2. Generate thumbnail
  const thumbnail = await ffmpeg(video.Body)
    .screenshots({
      timestamps: ['00:00:01'],
      size: '320x240',
    });
  
  // 3. Upload thumbnail
  await s3.putObject({
    Bucket: 'my-bucket',
    Key: `thumbnails/${videoKey}.jpg`,
    Body: thumbnail,
  }).promise();
  
  // 4. Start transcoding job
  await mediaconvert.createJob({
    Role: process.env.MEDIACONVERT_ROLE,
    Settings: {
      Inputs: [{
        FileInput: `s3://my-bucket/${videoKey}`,
      }],
      OutputGroups: [{
        OutputGroupSettings: {
          Type: 'HLS_GROUP_SETTINGS',
          Destination: `s3://my-bucket/videos/${userId}/`,
        },
        Outputs: [
          { NameModifier: '-1080p', VideoDescription: { Height: 1080 } },
          { NameModifier: '-720p', VideoDescription: { Height: 720 } },
          { NameModifier: '-480p', VideoDescription: { Height: 480 } },
        ],
      }],
    },
  }).promise();
  
  // 5. Update database
  await db.query(
    'UPDATE videos SET status = ? WHERE key = ?',
    ['processing', videoKey]
  );
}</div>

            <div class="info-box">
                <h4>Video Upload Best Practices</h4>
                <p><strong>1.</strong> Use chunked uploads for files > 100MB<br>
                <strong>2.</strong> Process videos asynchronously (don't make users wait)<br>
                <strong>3.</strong> Generate thumbnails automatically<br>
                <strong>4.</strong> Create multiple quality versions (adaptive streaming)<br>
                <strong>5.</strong> Use CDN (CloudFront, CloudFlare) for delivery<br>
                <strong>6.</strong> Store original file for re-processing later<br><br>
                Services like Mux, Cloudflare Stream, or AWS MediaConvert handle this complexity for you!</p>
            </div>

            <div class="metaphor-box">
                <h4>ğŸ‰ You're a File Upload EXPERT!</h4>
                <p>You now know:<br><br>
                âœ… Basic uploads (FormData, Multer)<br>
                âœ… Preview images and multiple files<br>
                âœ… Progress tracking (XMLHttpRequest.upload)<br>
                âœ… Drag and drop interfaces<br>
                âœ… Cloud storage (Cloudinary, AWS S3)<br>
                âœ… Resumable uploads for large files<br>
                âœ… Security (file type validation, magic bytes)<br>
                âœ… Image compression (reduce bandwidth)<br>
                âœ… Direct S3 uploads (presigned URLs)<br>
                âœ… Video processing pipelines<br><br>
                File handling is critical for modern apps - profile pictures, documents, media files. You can now build production-grade upload systems!<br><br>
                <strong>Real-world tip:</strong> For simple use cases, start with Cloudinary (handles everything). For high scale or custom needs, use S3 with presigned URLs. Always validate on the backend. Never trust the client!<br><br>
                <strong>Next challenge:</strong> Build an Instagram-like app with image uploads, filters, cropping, and cloud storage. Apply all these patterns!</p>
            </div>
        </section>

        <!-- SECTION 8: PWA Features -->
        <section id="pwa-features" class="section">
            <h2 class="section-title">Progressive Web Apps</h2>
            <p class="section-intro">What if your website could work offline? What if users could install it like a real app? That's what Progressive Web Apps (PWAs) doâ€”they're websites that feel like native apps!</p>

            <h3>What is a PWA?</h3>
            
            <div class="metaphor-box">
                <h4>Regular Website vs PWA</h4>
                <p><strong>Regular Website:</strong> Like a newspaperâ€”needs internet, can't be installed<br><br>
                <strong>PWA:</strong> Like a magazine you downloadâ€”works offline, installs to home screen, feels like an app<br><br>
                Examples: Twitter Lite, Pinterest, Starbucks web app</p>
            </div>

            <h4>PWA Features</h4>
            
            <div class="code">âœ… Works offline (caches content)
âœ… Installable (add to home screen)
âœ… Push notifications
âœ… Fast loading (pre-cached resources)
âœ… Works on any device
âœ… No app store needed</div>

            <h3>Basic PWA Setup</h3>
            
            <p>Two files make your site a PWA:</p>

            <div class="code">// 1. manifest.json - App metadata
{
  "name": "My Awesome App",
  "short_name": "MyApp",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

// 2. service-worker.js - Offline functionality
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll(['/index.html', '/styles.css', '/app.js']);
    })
  );
});</div>

            <div class="metaphor-box">
                <h4>PWAs: The Future of Web Apps</h4>
                <p>PWAs bridge the gap between websites and native apps. They're easier to build than native apps but offer similar experiences. As you advance, explore PWA capabilities!</p>
            </div>

            <h3>Part 2: Service Workers - The Heart of PWAs</h3>
            
            <p>Service workers are JavaScript files that run in the background, separate from your web page. They enable offline functionality, background sync, and push notifications.</p>

            <div class="metaphor-box">
                <h4>Service Worker = Security Guard</h4>
                <p>Think of a service worker like a security guard at a building:<br><br>
                <strong>Regular website:</strong> Every request goes directly from your apartment to the outside world<br>
                <strong>With service worker:</strong> All requests go through the security guard first. The guard can:<br>
                â€¢ Let the request through normally<br>
                â€¢ Answer from cache ("I have that package already")<br>
                â€¢ Block the request<br>
                â€¢ Modify the request or response<br><br>
                This lets your app work offlineâ€”the guard serves cached content when there's no internet!</p>
            </div>

            <h4>Registering a Service Worker</h4>
            
            <p>First, register your service worker in your main JavaScript file:</p>

            <div class="code">// In your main app.js or index.js
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('Service Worker registered!', registration);
      })
      .catch(error => {
        console.log('Service Worker registration failed:', error);
      });
  });
} else {
  console.log('Service Workers not supported in this browser');
}</div>

            <h4>Creating a Service Worker File</h4>
            
            <p>Create a file called <code>service-worker.js</code> in your public folder:</p>

            <div class="code">// service-worker.js
const CACHE_NAME = 'my-app-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js',
  '/logo.png',
];

// Install event - cache files
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Caching files');
        return cache.addAll(urlsToCache);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch event - serve from cache or network
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return cached response
        if (response) {
          console.log('Serving from cache:', event.request.url);
          return response;
        }
        
        // Cache miss - fetch from network
        console.log('Fetching from network:', event.request.url);
        return fetch(event.request);
      })
  );
});</div>

            <div class="info-box">
                <h4>Service Worker Lifecycle</h4>
                <p><strong>1. Register:</strong> Tell browser about service worker<br>
                <strong>2. Install:</strong> Download service worker file, cache assets<br>
                <strong>3. Activate:</strong> Service worker takes control, clean up old caches<br>
                <strong>4. Fetch:</strong> Intercept network requests, serve from cache or network<br><br>
                <strong>Important:</strong> Service workers only work on HTTPS (or localhost for testing)!</p>
            </div>

            <h4>Caching Strategies</h4>
            
            <p>There are different strategies for caching:</p>

            <div class="code">// 1. Cache First (fastest, but might show stale data)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});

// 2. Network First (always fresh, but requires internet)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => caches.match(event.request))  // Fallback to cache if network fails
  );
});

// 3. Stale While Revalidate (show cached, update in background)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(event.request).then(cachedResponse => {
        const fetchPromise = fetch(event.request).then(networkResponse => {
          // Update cache with fresh response
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
        
        // Return cached immediately, fetch updates in background
        return cachedResponse || fetchPromise;
      });
    })
  );
});

// 4. Network Only (always fetch, no caching)
self.addEventListener('fetch', (event) => {
  event.respondWith(fetch(event.request));
});

// 5. Cache Only (only serve cached, never fetch)
self.addEventListener('fetch', (event) => {
  event.respondWith(caches.match(event.request));
});</div>

            <div class="metaphor-box">
                <h4>Which Strategy to Use?</h4>
                <p><strong>Cache First:</strong> Static assets (CSS, JS, images) - rarely change<br>
                <strong>Network First:</strong> API calls, dynamic content - freshness is important<br>
                <strong>Stale While Revalidate:</strong> User profiles, news feeds - show old, update in background<br>
                <strong>Network Only:</strong> Sensitive data, payments - never cache<br>
                <strong>Cache Only:</strong> Core app shell - always available offline<br><br>
                Mix strategies! Use cache first for CSS, network first for API calls.</p>
            </div>

            <h3>Part 3: Web App Manifest</h3>
            
            <p>The manifest.json tells the browser how your app should behave when "installed" on a device:</p>

            <div class="code">// public/manifest.json
{
  "name": "My Awesome App",
  "short_name": "MyApp",
  "description": "An awesome progressive web app",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#0066cc",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}</div>

            <p>Link it in your HTML:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;My PWA&lt;/title&gt;
  
  &lt;!-- Manifest --&gt;
  &lt;link rel="manifest" href="/manifest.json"&gt;
  
  &lt;!-- Theme color for browser UI --&gt;
  &lt;meta name="theme-color" content="#0066cc"&gt;
  
  &lt;!-- Apple-specific meta tags --&gt;
  &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;
  &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt;
  &lt;meta name="apple-mobile-web-app-title" content="MyApp"&gt;
  &lt;link rel="apple-touch-icon" href="/icons/icon-152x152.png"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- Your app --&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="info-box">
                <h4>Manifest Properties Explained</h4>
                <p><strong>name:</strong> Full name shown in install prompt<br>
                <strong>short_name:</strong> Name shown on home screen (under icon)<br>
                <strong>start_url:</strong> Which page to open when app launches<br>
                <strong>display:</strong> "standalone" (looks like native app), "fullscreen", "minimal-ui", "browser"<br>
                <strong>theme_color:</strong> Color of browser UI (toolbar, status bar)<br>
                <strong>background_color:</strong> Splash screen background<br>
                <strong>icons:</strong> Different sizes for different devices<br><br>
                You need icons in multiple sizes for different devices!</p>
            </div>

            <h3>Part 4: Making Your App Installable</h3>
            
            <p>To make your PWA installable, you need:</p>

            <div class="code">// Checklist for installable PWA:
âœ… HTTPS (or localhost for testing)
âœ… manifest.json with name, icons, start_url
âœ… Service worker registered
âœ… Service worker has fetch handler
âœ… At least one icon (192x192 and 512x512 recommended)</div>

            <p>Add an install prompt to your app:</p>

            <div class="code">// Detect install prompt
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent default prompt
  e.preventDefault();
  
  // Store event for later
  deferredPrompt = e;
  
  // Show your custom install button
  document.getElementById('install-button').style.display = 'block';
});

// When user clicks your install button
document.getElementById('install-button').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  // Show install prompt
  deferredPrompt.prompt();
  
  // Wait for user choice
  const { outcome } = await deferredPrompt.userChoice;
  
  if (outcome === 'accepted') {
    console.log('User accepted install');
  } else {
    console.log('User dismissed install');
  }
  
  // Clear the prompt
  deferredPrompt = null;
  document.getElementById('install-button').style.display = 'none';
});

// Detect when app was successfully installed
window.addEventListener('appinstalled', () => {
  console.log('PWA was installed!');
  // Hide install button, show thank you message, etc.
});</div>

            <h3>Part 5: Push Notifications (Advanced)</h3>
            
            <p>PWAs can send push notifications even when the app is closed! This requires a backend service:</p>

            <div class="code">// Request notification permission
async function requestNotificationPermission() {
  const permission = await Notification.requestPermission();
  
  if (permission === 'granted') {
    console.log('Notification permission granted!');
    // Subscribe to push notifications
    await subscribeToPush();
  } else {
    console.log('Notification permission denied');
  }
}

// Subscribe to push notifications
async function subscribeToPush() {
  const registration = await navigator.serviceWorker.ready;
  
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: 'YOUR_PUBLIC_VAPID_KEY',  // From backend
  });
  
  // Send subscription to your backend
  await fetch('/api/subscribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(subscription),
  });
}

// In service-worker.js
self.addEventListener('push', (event) => {
  const data = event.data.json();
  
  const options = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [200, 100, 200],
    data: {
      url: data.url || '/',
    },
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  event.waitUntil(
    clients.openWindow(event.notification.data.url)
  );
});</div>

            <div class="warning-box">
                <h4>Push Notifications Require Backend</h4>
                <p>Push notifications need a server to send them. You can't send push notifications from the client side alone. Popular services:<br><br>
                â€¢ Firebase Cloud Messaging (FCM) - Free, easy to use<br>
                â€¢ OneSignal - Free tier available<br>
                â€¢ Web Push libraries for Node.js<br><br>
                Start with simple notifications, add push notifications later when you're comfortable!</p>
            </div>

            <h3>Part 6: Testing Your PWA</h3>
            
            <p>Use Chrome DevTools to test your PWA:</p>

            <div class="code">// Chrome DevTools PWA Testing:
1. Open DevTools (F12)
2. Go to "Application" tab
3. Check:
   â€¢ Manifest: Is it loading correctly?
   â€¢ Service Workers: Is it registered and active?
   â€¢ Cache Storage: Are files cached?
4. Use "Lighthouse" tab:
   â€¢ Run PWA audit
   â€¢ Get score and recommendations
5. Test offline:
   â€¢ Service Workers â†’ Check "Offline"
   â€¢ Reload page - should still work!
6. Test install:
   â€¢ Application â†’ Manifest â†’ "Add to homescreen" link</div>

            <div class="metaphor-box">
                <h4>PWAs: You're Ready! ğŸ“±</h4>
                <p>You now understand:<br><br>
                âœ… What PWAs are and why they're powerful<br>
                âœ… Service workers for offline functionality<br>
                âœ… Caching strategies (cache first, network first, etc.)<br>
                âœ… Web app manifest for installability<br>
                âœ… Install prompts and app installation<br>
                âœ… Push notifications basics<br><br>
                PWAs are the future! They're easier than native apps but offer similar experiences. Start with service workers and manifest, then add advanced features like push notifications. Every major website is becoming a PWAâ€”you're learning cutting-edge technology!</p>
            </div>
        </section>

        <!-- SECTION 9: Testing Integration -->
        <section id="testing-integration" class="section">
            <h2 class="section-title">Testing Full-Stack Apps</h2>
            <p class="section-intro">How do you know your app actually works? Testing! Let's learn why testing matters and how to write simple tests for your frontend and backend.</p>

            <h3>Why Test?</h3>
            
            <div class="metaphor-box">
                <h4>Testing as Safety Net</h4>
                <p>Imagine walking a tightrope:<br><br>
                <strong>No tests:</strong> No safety netâ€”one mistake and everything breaks<br>
                <strong>With tests:</strong> Safety net catches errors before users see them<br><br>
                Tests ensure your code works NOW and KEEPS working when you make changes.</p>
            </div>

            <h4>Types of Tests (Simple Explanation)</h4>
            
            <div class="code">1. Unit Tests - Test one function in isolation
   Example: "Does the `add(2, 3)` function return 5?"

2. Integration Tests - Test components working together
   Example: "Does clicking login button call the API?"

3. End-to-End Tests - Test entire user flows
   Example: "Can a user sign up, log in, and make a purchase?"</div>

            <h3>Simple React Component Test</h3>
            
            <div class="code">// Component
function Greeting({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
}

// Test (using Jest + React Testing Library)
import { render, screen } from '@testing-library/react';

test('displays greeting with name', () => {
  render(&lt;Greeting name="Alice" /&gt;);
  expect(screen.getByText('Hello, Alice!')).toBeInTheDocument();
});</div>

            <div class="info-box">
                <h4>Testing Benefits</h4>
                <p>âœ… Catch bugs before users do<br>
                âœ… Confidence when refactoring<br>
                âœ… Documentation (tests show how code should work)<br>
                âœ… Faster development (find bugs instantly)</p>
            </div>

            <div class="metaphor-box">
                <h4>You're Test-Aware!</h4>
                <p>Testing is a huge topic, but now you understand WHY it matters. Start with simple tests for critical features, then expand as you grow!</p>
            </div>

            <h3>Part 2: Jest Setup and Unit Testing</h3>
            
            <p>Jest is the most popular JavaScript testing framework. Let's set it up:</p>

            <div class="code">// Install Jest
npm install --save-dev jest

// Or with React Testing Library
npm install --save-dev jest @testing-library/react @testing-library/jest-dom

// Add to package.json:
"scripts": {
  "test": "jest",
  "test:watch": "jest --watch",
  "test:coverage": "jest --coverage"
}</div>

            <h4>Writing Your First Test</h4>
            
            <div class="code">// src/utils/math.js
export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

export function divide(a, b) {
  if (b === 0) throw new Error('Cannot divide by zero');
  return a / b;
}

// src/utils/math.test.js
import { add, multiply, divide } from './math';

// Test suite (group of related tests)
describe('Math utilities', () => {
  
  // Individual test
  test('add() should add two numbers correctly', () => {
    expect(add(2, 3)).toBe(5);
    expect(add(-1, 1)).toBe(0);
    expect(add(0, 0)).toBe(0);
  });
  
  test('multiply() should multiply two numbers', () => {
    expect(multiply(2, 3)).toBe(6);
    expect(multiply(5, 0)).toBe(0);
    expect(multiply(-2, 3)).toBe(-6);
  });
  
  test('divide() should divide two numbers', () => {
    expect(divide(6, 2)).toBe(3);
    expect(divide(5, 2)).toBe(2.5);
  });
  
  test('divide() should throw error when dividing by zero', () => {
    expect(() => divide(5, 0)).toThrow('Cannot divide by zero');
  });
});</div>

            <div class="info-box">
                <h4>Jest Test Structure</h4>
                <p><strong>describe():</strong> Groups related tests (optional but organized)<br>
                <strong>test() or it():</strong> Individual test case<br>
                <strong>expect():</strong> Makes an assertion about a value<br>
                <strong>.toBe():</strong> Matcher - checks if values are exactly equal<br><br>
                Run tests: <code>npm test</code></p>
            </div>

            <h4>Common Jest Matchers</h4>
            
            <div class="code">// Equality
expect(2 + 2).toBe(4);  // Exact equality (===)
expect({ name: 'Alice' }).toEqual({ name: 'Alice' });  // Deep equality

// Truthiness
expect(true).toBeTruthy();
expect(false).toBeFalsy();
expect(null).toBeNull();
expect(undefined).toBeUndefined();
expect('hello').toBeDefined();

// Numbers
expect(10).toBeGreaterThan(5);
expect(5).toBeLessThan(10);
expect(5).toBeGreaterThanOrEqual(5);
expect(0.1 + 0.2).toBeCloseTo(0.3);  // For floating point

// Strings
expect('hello world').toMatch(/world/);
expect('hello').toContain('ell');

// Arrays
expect([1, 2, 3]).toContain(2);
expect([1, 2, 3]).toHaveLength(3);

// Objects
expect({ name: 'Alice', age: 25 }).toHaveProperty('name');
expect({ name: 'Alice', age: 25 }).toHaveProperty('name', 'Alice');

// Exceptions
expect(() => throwError()).toThrow();
expect(() => throwError()).toThrow('Error message');

// Async
await expect(fetchData()).resolves.toBe('data');
await expect(fetchData()).rejects.toThrow();</div>

            <h3>Part 3: Testing React Components</h3>
            
            <p>Use React Testing Library to test React components:</p>

            <div class="code">// src/components/Counter.jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Count: {count}&lt;/h1&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
      &lt;button onClick={() => setCount(count - 1)}&gt;
        Decrement
      &lt;/button&gt;
      &lt;button onClick={() => setCount(0)}&gt;
        Reset
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;

// src/components/Counter.test.jsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

describe('Counter component', () => {
  
  test('renders with initial count of 0', () => {
    render(&lt;Counter /&gt;);
    
    // Find element by text
    const countElement = screen.getByText(/Count: 0/i);
    expect(countElement).toBeInTheDocument();
  });
  
  test('increments count when Increment button clicked', () => {
    render(&lt;Counter /&gt;);
    
    // Find button by text
    const incrementButton = screen.getByText(/Increment/i);
    
    // Click button
    fireEvent.click(incrementButton);
    
    // Check count increased
    expect(screen.getByText(/Count: 1/i)).toBeInTheDocument();
  });
  
  test('decrements count when Decrement button clicked', () => {
    render(&lt;Counter /&gt;);
    
    const decrementButton = screen.getByText(/Decrement/i);
    fireEvent.click(decrementButton);
    
    expect(screen.getByText(/Count: -1/i)).toBeInTheDocument();
  });
  
  test('resets count to 0 when Reset button clicked', () => {
    render(&lt;Counter /&gt;);
    
    // Increment a few times
    const incrementButton = screen.getByText(/Increment/i);
    fireEvent.click(incrementButton);
    fireEvent.click(incrementButton);
    fireEvent.click(incrementButton);
    
    // Now reset
    const resetButton = screen.getByText(/Reset/i);
    fireEvent.click(resetButton);
    
    expect(screen.getByText(/Count: 0/i)).toBeInTheDocument();
  });
});</div>

            <div class="metaphor-box">
                <h4>Testing Library Philosophy</h4>
                <p>React Testing Library encourages testing your components the way users interact with them:<br><br>
                <strong>âŒ Don't:</strong> Test implementation details (internal state, component methods)<br>
                <strong>âœ… Do:</strong> Test what users see and do (text on screen, clicking buttons)<br><br>
                If you refactor your component but it still works the same way for users, tests should still pass!</p>
            </div>

            <h4>Finding Elements</h4>
            
            <div class="code">// By text
screen.getByText('Hello');
screen.getByText(/hello/i);  // Case insensitive regex

// By role (accessible, recommended!)
screen.getByRole('button', { name: /submit/i });
screen.getByRole('textbox', { name: /username/i });
screen.getByRole('heading', { level: 1 });

// By label
screen.getByLabelText('Email');

// By placeholder
screen.getByPlaceholderText('Enter your name');

// By test ID (last resort)
// In component: &lt;div data-testid="custom-element"&gt;
screen.getByTestId('custom-element');

// Query variants:
getBy - Throws error if not found (use for assertions)
queryBy - Returns null if not found (use for checking absence)
findBy - Returns promise, waits for element (use for async)</div>

            <h3>Part 4: Testing Async Code</h3>
            
            <p>Many components fetch data. Let's test that:</p>

            <div class="code">// src/components/UserProfile.jsx
import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;

// src/components/UserProfile.test.jsx
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import UserProfile from './UserProfile';

// Mock fetch
global.fetch = jest.fn();

describe('UserProfile component', () => {
  
  beforeEach(() => {
    // Clear mock before each test
    fetch.mockClear();
  });
  
  test('shows loading initially', () => {
    // Mock fetch to never resolve (stays loading)
    fetch.mockImplementation(() => new Promise(() => {}));
    
    render(&lt;UserProfile userId={1} /&gt;);
    
    expect(screen.getByText(/Loading/i)).toBeInTheDocument();
  });
  
  test('shows user data after successful fetch', async () => {
    // Mock successful response
    fetch.mockResolvedValueOnce({
      json: async () => ({ name: 'Alice', email: 'alice@example.com' }),
    });
    
    render(&lt;UserProfile userId={1} /&gt;);
    
    // Wait for data to load
    await waitFor(() => {
      expect(screen.getByText('Alice')).toBeInTheDocument();
    });
    
    expect(screen.getByText('alice@example.com')).toBeInTheDocument();
  });
  
  test('shows error message when fetch fails', async () => {
    // Mock failed response
    fetch.mockRejectedValueOnce(new Error('Network error'));
    
    render(&lt;UserProfile userId={1} /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText(/Error: Network error/i)).toBeInTheDocument();
    });
  });
});</div>

            <div class="info-box">
                <h4>Testing Async: Key Points</h4>
                <p><strong>1. Mock external APIs:</strong> Use <code>jest.fn()</code> to mock fetch/axios<br>
                <strong>2. Use waitFor():</strong> Waits for async updates to complete<br>
                <strong>3. Use findBy queries:</strong> Automatically waits for elements<br>
                <strong>4. Clean up mocks:</strong> Use <code>beforeEach()</code> to reset between tests<br><br>
                Never make real API calls in tests - always mock!</p>
            </div>

            <h3>Part 5: Integration Testing</h3>
            
            <p>Integration tests check how multiple components work together:</p>

            <div class="code">// Testing a todo app (integration test)
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import TodoApp from './TodoApp';

describe('TodoApp integration', () => {
  
  test('full user flow: add, complete, delete todos', () => {
    render(&lt;TodoApp /&gt;);
    
    // Find input and button
    const input = screen.getByPlaceholderText(/What needs to be done/i);
    const addButton = screen.getByRole('button', { name: /add/i });
    
    // Add first todo
    fireEvent.change(input, { target: { value: 'Buy milk' } });
    fireEvent.click(addButton);
    
    // Check it appears
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
    
    // Add second todo
    fireEvent.change(input, { target: { value: 'Walk dog' } });
    fireEvent.click(addButton);
    
    expect(screen.getByText('Walk dog')).toBeInTheDocument();
    
    // Complete first todo
    const checkbox = screen.getAllByRole('checkbox')[0];
    fireEvent.click(checkbox);
    
    // Check it's marked complete (has line-through style)
    const completedTodo = screen.getByText('Buy milk');
    expect(completedTodo).toHaveStyle('text-decoration: line-through');
    
    // Delete first todo
    const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
    fireEvent.click(deleteButtons[0]);
    
    // Check it's gone
    expect(screen.queryByText('Buy milk')).not.toBeInTheDocument();
    
    // Second todo still there
    expect(screen.getByText('Walk dog')).toBeInTheDocument();
  });
});</div>

            <div class="metaphor-box">
                <h4>Unit vs Integration Tests</h4>
                <p><strong>Unit tests:</strong> Test one component or function in isolation<br>
                - Fast, focused, easy to debug<br>
                - Example: Test Counter button increments count<br><br>
                <strong>Integration tests:</strong> Test how multiple pieces work together<br>
                - Slower, more complex, test realistic scenarios<br>
                - Example: Test entire todo app workflow<br><br>
                You need BOTH! Start with unit tests, add integration tests for critical flows.</p>
            </div>

            <h3>Part 6: Test Coverage</h3>
            
            <p>Coverage shows what percentage of your code is tested:</p>

            <div class="code">// Run tests with coverage
npm test -- --coverage

// Output shows:
----------------------|---------|----------|---------|---------|
File                  | % Stmts | % Branch | % Funcs | % Lines |
----------------------|---------|----------|---------|---------|
All files             |   85.71 |    75.00 |   90.00 |   85.71 |
 components/          |   87.50 |    80.00 |   85.00 |   87.50 |
  Counter.jsx         |   100.00|    100.00|   100.00|   100.00|
  TodoApp.jsx         |   75.00 |    60.00 |   70.00 |   75.00 |
 utils/               |   80.00 |    66.67 |   100.00|   80.00 |
  math.js             |   100.00|    100.00|   100.00|   100.00|
  validation.js       |   60.00 |    33.33 |   100.00|   60.00 |
----------------------|---------|----------|---------|---------|</div>

            <div class="info-box">
                <h4>Understanding Coverage Metrics</h4>
                <p><strong>% Statements:</strong> How many lines of code were executed<br>
                <strong>% Branch:</strong> How many if/else paths were tested<br>
                <strong>% Functions:</strong> How many functions were called<br>
                <strong>% Lines:</strong> Similar to statements<br><br>
                <strong>Good target:</strong> 70-80% coverage<br>
                <strong>Don't aim for 100%:</strong> Some code isn't worth testing (simple getters, constants)</p>
            </div>

            <h3>Part 7: Test-Driven Development (TDD)</h3>
            
            <p>TDD means writing tests BEFORE writing code:</p>

            <div class="metaphor-box">
                <h4>The TDD Workflow</h4>
                <p><strong>1. Red:</strong> Write a test for feature that doesn't exist yet. Test fails (red).<br>
                <strong>2. Green:</strong> Write minimal code to make test pass (green).<br>
                <strong>3. Refactor:</strong> Improve code quality without changing behavior. Tests still pass!<br><br>
                <strong>Example:</strong><br>
                1. Write test: "add() should add two numbers"<br>
                2. Test fails (function doesn't exist)<br>
                3. Implement add() function<br>
                4. Test passes!<br>
                5. Refactor if needed<br><br>
                Benefits: Better code design, confidence to refactor, documentation through tests</p>
            </div>

            <h3>Part 8: Common Testing Pitfalls</h3>
            
            <div class="warning-box">
                <h4>Testing Mistakes to Avoid</h4>
                <p><strong>1. Testing implementation details:</strong> Don't test internal state or private methods<br>
                <strong>2. Not testing edge cases:</strong> Test empty arrays, null values, boundary conditions<br>
                <strong>3. Tests that depend on each other:</strong> Each test should run independently<br>
                <strong>4. Not cleaning up:</strong> Reset mocks, clear timers, unmount components<br>
                <strong>5. Ignoring async issues:</strong> Use waitFor(), await promises<br>
                <strong>6. Over-mocking:</strong> Don't mock everything - test real interactions when possible<br>
                <strong>7. Brittle tests:</strong> Tests break with small UI changes (use roles, not test IDs)<br>
                <strong>8. No tests for bugs:</strong> When you find a bug, write a test that catches it</p>
            </div>

            <div class="metaphor-box">
                <h4>Testing: You're Ready to Ship with Confidence! âœ…</h4>
                <p>You now know:<br><br>
                âœ… Why testing matters (catch bugs early, confidence to refactor)<br>
                âœ… Jest basics (describe, test, expect, matchers)<br>
                âœ… Testing React components (render, screen, fireEvent)<br>
                âœ… Testing async code (mocking fetch, waitFor)<br>
                âœ… Integration testing (testing full workflows)<br>
                âœ… Test coverage (measuring what's tested)<br>
                âœ… TDD workflow (red-green-refactor)<br>
                âœ… Common pitfalls to avoid<br><br>
                Testing seems boring at first, but it's INVALUABLE for real projects. Start small: test critical features, then expand. When your app has 50 components, tests are the only way to know if changes broke something. You'll thank yourself later!</p>
            </div>
        </section>

        <!-- SECTION 10: Deployment & Scaling -->
        <section id="deployment-scaling" class="section">
            <h2 class="section-title">Deployment & Scaling</h2>
            <p class="section-intro">Your app is built! Now how do you get it online for the world to see? Let's deploy your frontend and backend, and understand what happens when you get LOTS of users.</p>

            <h3>What is Deployment?</h3>
            
            <div class="metaphor-box">
                <h4>Deployment = Moving Day</h4>
                <p><strong>Development (localhost):</strong> Building furniture in your garage<br>
                <strong>Deployment (production):</strong> Moving furniture to your house where guests can see it<br><br>
                Deployment means putting your code on a server that's accessible 24/7 from anywhere.</p>
            </div>

            <h3>Deploying Your Frontend (Free!)</h3>
            
            <h4>Option 1: Vercel (Easiest for React/Next.js)</h4>
            
            <div class="code">// Step 1: Install Vercel CLI
npm install -g vercel

// Step 2: Navigate to your project
cd my-react-app

// Step 3: Deploy!
vercel

// Follow prompts, get live URL instantly:
// https://my-app.vercel.app âœ…</div>

            <h4>Option 2: Netlify (Great for any static site)</h4>
            
            <div class="code">// Method 1: Drag & Drop (easiest!)
1. Go to netlify.com
2. Drag your build folder (npm run build)
3. Done! Live URL given

// Method 2: CLI
npm install -g netlify-cli
netlify deploy</div>

            <h4>Option 3: GitHub Pages (Free, GitHub integration)</h4>
            
            <div class="code">// 1. Install gh-pages package
npm install --save-dev gh-pages

// 2. Add to package.json
"scripts": {
  "predeploy": "npm run build",
  "deploy": "gh-pages -d build"
}

// 3. Deploy!
npm run deploy

// Live at: https://yourusername.github.io/repo-name</div>

            <div class="info-box">
                <h4>All Three Are FREE!</h4>
                <p><strong>Vercel:</strong> Best for Next.js, serverless functions included<br>
                <strong>Netlify:</strong> Great forms, serverless functions, easy custom domains<br>
                <strong>GitHub Pages:</strong> Perfect for static sites, portfolios</p>
            </div>

            <h3>Deploying Your Backend</h3>
            
            <h4>Option 1: Railway (Easiest)</h4>
            
            <div class="code">// 1. Push code to GitHub
// 2. Go to railway.app
// 3. Click "Deploy from GitHub"
// 4. Select your repo
// 5. Railway auto-detects Node.js and deploys!
// 6. Get live API URL

// Example Railway setup for Node.js/Express:
// Railway automatically detects package.json and runs:
// - Build: npm install
// - Start: npm start (or uses "start" script)</div>

            <h4>Option 2: Render (Great free tier)</h4>
            
            <div class="code">// 1. Connect GitHub to Render
// 2. Select your backend repo
// 3. Configure build settings:
Build Command: npm install
Start Command: npm start
Environment: Node

// 4. Add environment variables in dashboard
// 5. Deploy! Get live URL like:
// https://your-app.onrender.com</div>

            <h4>Option 3: Heroku (Classic choice)</h4>
            
            <div class="code">// Install Heroku CLI
npm install -g heroku

// Login
heroku login

// Create Heroku app
heroku create my-app-name

// Push code (deploys automatically)
git push heroku main

// Open app
heroku open

// View logs
heroku logs --tail</div>

            <div class="info-box">
                <h4>Backend Hosting Comparison</h4>
                <p><strong>Railway:</strong> Easiest, generous free tier, auto-deploys from GitHub<br>
                <strong>Render:</strong> Good free tier, supports cron jobs, easy database setup<br>
                <strong>Heroku:</strong> Classic, lots of add-ons, free tier limited<br>
                <strong>Fly.io:</strong> Global edge deployment, Docker-based<br>
                <strong>AWS/GCP/Azure:</strong> Most powerful, complex, pay-as-you-go<br><br>
                For beginners: Start with Railway or Render!</p>
            </div>

            <h3>Part 2: Environment Variables Deep Dive</h3>
            
            <p>NEVER put secrets in code! Use environment variables for sensitive data:</p>

            <div class="code">// .env file (NEVER commit to Git!)
DATABASE_URL=postgresql://user:password@host:5432/dbname
API_KEY=abc123secret
JWT_SECRET=supersecretkey
PORT=3000
NODE_ENV=production

// Add .env to .gitignore
echo ".env" >> .gitignore

// Access in Node.js:
require('dotenv').config();  // Load .env file

const dbUrl = process.env.DATABASE_URL;
const apiKey = process.env.API_KEY;
const port = process.env.PORT || 3000;

if (process.env.NODE_ENV === 'production') {
  // Production-specific code
}</div>

            <div class="warning-box">
                <h4>Environment Variable Security Rules</h4>
                <p><strong>1. NEVER commit .env to Git:</strong> Add to .gitignore immediately<br>
                <strong>2. Use different values for dev/prod:</strong> Development API keys vs production keys<br>
                <strong>3. Rotate secrets regularly:</strong> Change keys periodically<br>
                <strong>4. Limit access:</strong> Only give team members access to prod secrets they need<br>
                <strong>5. Use secret managers:</strong> AWS Secrets Manager, HashiCorp Vault for production<br><br>
                <strong>Common mistake:</strong> Accidentally committing .env, exposing database passwords!</p>
            </div>

            <h4>Setting Environment Variables on Hosting Platforms</h4>
            
            <div class="code">// Vercel (frontend)
// Dashboard â†’ Project Settings â†’ Environment Variables
// Or CLI:
vercel env add DATABASE_URL

// Netlify
// Site Settings â†’ Build & Deploy â†’ Environment Variables

// Railway
// Project â†’ Variables tab â†’ Add variables

// Render
// Dashboard â†’ Environment â†’ Add Environment Variable

// Heroku
heroku config:set DATABASE_URL="postgresql://..."
heroku config:set API_KEY="abc123"

// View all config
heroku config</div>

            <h3>Part 3: Continuous Integration / Continuous Deployment (CI/CD)</h3>
            
            <p>CI/CD automatically tests and deploys your code when you push to Git:</p>

            <div class="metaphor-box">
                <h4>CI/CD = Quality Control Assembly Line</h4>
                <p><strong>Without CI/CD:</strong> You manually test, build, and deploy every change. Tedious and error-prone.<br><br>
                <strong>With CI/CD:</strong> Push code to GitHub â†’ Automated tests run â†’ If tests pass, automatically deploy to production!<br><br>
                It's like a factory assembly line with quality checks at each step. Defective products (broken code) never reach customers!</p>
            </div>

            <h4>GitHub Actions for CI/CD</h4>
            
            <p>GitHub Actions is free for public repos and has generous free tier for private repos:</p>

            <div class="code">// .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]  # Trigger on push to main branch

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: npm install
    
    - name: Run tests
      run: npm test
    
    - name: Check code style
      run: npm run lint
  
  deploy:
    needs: test  # Only deploy if tests pass
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v20
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.ORG_ID }}
        vercel-project-id: ${{ secrets.PROJECT_ID }}
        vercel-args: '--prod'</div>

            <div class="info-box">
                <h4>GitHub Actions Workflow Breakdown</h4>
                <p><strong>on:</strong> When to run (push, pull request, schedule, manual)<br>
                <strong>jobs:</strong> Different tasks (test, build, deploy)<br>
                <strong>runs-on:</strong> What OS to use (ubuntu, windows, macos)<br>
                <strong>steps:</strong> Individual commands to run<br>
                <strong>uses:</strong> Pre-built actions from marketplace<br>
                <strong>secrets:</strong> Encrypted environment variables (set in GitHub repo settings)<br><br>
                This workflow: Tests code â†’ If pass, deploys to Vercel â†’ All automatic!</p>
            </div>

            <h4>More CI/CD Examples</h4>
            
            <div class="code">// Run tests on every pull request
name: Test PR

on: pull_request

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - run: npm install
    - run: npm test
    - run: npm run build  # Make sure it builds

// Deploy backend to Railway
name: Deploy Backend

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Deploy to Railway
      run: |
        npm install -g @railway/cli
        railway up --service ${{ secrets.RAILWAY_SERVICE }}
      env:
        RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

// Run tests on schedule (daily)
name: Nightly Tests

on:
  schedule:
    - cron: '0 2 * * *'  # 2 AM daily

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - run: npm install
    - run: npm test</div>

            <h3>Part 4: Monitoring and Logging</h3>
            
            <p>Once deployed, you need to know if your app is working and catch errors:</p>

            <h4>Error Tracking with Sentry</h4>
            
            <div class="code">// Install Sentry
npm install @sentry/react @sentry/tracing

// Initialize in your app
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

Sentry.init({
  dsn: 'your-sentry-dsn',  // From Sentry dashboard
  integrations: [
    new BrowserTracing(),
  ],
  tracesSampleRate: 1.0,  // Performance monitoring
});

function App() {
  return (
    &lt;Sentry.ErrorBoundary fallback={&lt;ErrorFallback /&gt;}&gt;
      {/* Your app */}
    &lt;/Sentry.ErrorBoundary&gt;
  );
}

// Manually capture errors
try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error);
}

// Add context
Sentry.setUser({ id: '123', email: 'user@example.com' });
Sentry.setTag('page', 'checkout');
Sentry.addBreadcrumb({
  message: 'User clicked buy button',
  level: 'info',
});</div>

            <div class="metaphor-box">
                <h4>Sentry = Security Cameras for Your App</h4>
                <p>Imagine your app is a store. Without monitoring, you don't know when things break. Sentry is like security cameras:<br><br>
                â€¢ Records every error that happens<br>
                â€¢ Shows you stack traces (what code caused it)<br>
                â€¢ Tells you which users were affected<br>
                â€¢ Groups similar errors together<br>
                â€¢ Sends alerts when critical errors happen<br><br>
                You'll know about bugs before users complain!</p>
            </div>

            <h4>Application Performance Monitoring (APM)</h4>
            
            <div class="code">// Use Sentry for performance too
const transaction = Sentry.startTransaction({
  name: 'Checkout Process',
});

try {
  // Your code
  await fetchCart();
  await processPayment();
  await createOrder();
} finally {
  transaction.finish();
}

// Instrument specific spans
const span = transaction.startChild({
  op: 'db.query',
  description: 'Fetch user data',
});

await database.query('SELECT * FROM users');

span.finish();

// Sentry dashboard shows:
// - Average response times
// - Slow transactions
// - Database query performance
// - API call durations</div>

            <h4>Logging Best Practices</h4>
            
            <div class="code">// Use a proper logging library
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// In production, also log to console (for Heroku, Railway logs)
if (process.env.NODE_ENV === 'production') {
  logger.add(new winston.transports.Console());
}

// Different log levels
logger.error('Payment failed', { userId: 123, amount: 50 });
logger.warn('User attempted invalid action', { action: 'delete_admin' });
logger.info('User logged in', { userId: 123 });
logger.debug('Cache hit for user data');  // Only in development

// Structured logging (JSON) is better than plain text:
// âŒ console.log('User 123 logged in')
// âœ… logger.info('User logged in', { userId: 123, timestamp: Date.now() })</div>

            <div class="info-box">
                <h4>Log Aggregation Services</h4>
                <p><strong>Papertrail:</strong> Free tier, simple log viewing and search<br>
                <strong>Loggly:</strong> Advanced search, alerting<br>
                <strong>Datadog:</strong> Full monitoring suite (logs + metrics + APM)<br>
                <strong>LogRocket:</strong> Session replay + logs (see exactly what user did)<br><br>
                For small projects: Use built-in platform logs (Heroku logs, Railway logs)<br>
                For medium projects: Add Sentry for errors<br>
                For large projects: Full monitoring stack (Datadog, New Relic)</p>
            </div>

            <h3>Part 5: Database Scaling and Optimization</h3>
            
            <h4>Connection Pooling</h4>
            
            <p>Don't create a new database connection for every request - use a pool:</p>

            <div class="code">// âŒ Bad: New connection each time
app.get('/users', async (req, res) => {
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();
  const result = await client.query('SELECT * FROM users');
  await client.end();
  res.json(result.rows);
});

// âœ… Good: Connection pool
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,  // Maximum 20 connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

app.get('/users', async (req, res) => {
  // Reuses existing connection from pool
  const result = await pool.query('SELECT * FROM users');
  res.json(result.rows);
});</div>

            <h4>Database Indexing</h4>
            
            <div class="code">// Slow query without index (searches entire table)
SELECT * FROM users WHERE email = 'alice@example.com';
-- Takes 500ms with 1 million users

// Add index on email column
CREATE INDEX idx_users_email ON users(email);

// Now same query is instant
SELECT * FROM users WHERE email = 'alice@example.com';
-- Takes 5ms!

// Composite index for common queries
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);

// Check if indexes are being used
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'alice@example.com';</div>

            <div class="warning-box">
                <h4>Index Wisely</h4>
                <p><strong>âœ… Index columns used in WHERE, JOIN, ORDER BY</strong><br>
                <strong>âœ… Index foreign keys</strong><br>
                <strong>âŒ Don't index every column (slows down writes)</strong><br>
                <strong>âŒ Don't index small tables (< 1000 rows)</strong><br><br>
                Indexes speed up reads but slow down writes. Use them strategically!</p>
            </div>

            <h4>Caching Strategies</h4>
            
            <div class="code">// Redis for caching
const redis = require('redis');
const client = redis.createClient(process.env.REDIS_URL);

app.get('/products', async (req, res) => {
  // Try cache first
  const cached = await client.get('products');
  
  if (cached) {
    console.log('Cache hit!');
    return res.json(JSON.parse(cached));
  }
  
  // Cache miss - fetch from database
  console.log('Cache miss - querying database');
  const products = await db.query('SELECT * FROM products');
  
  // Store in cache for 5 minutes
  await client.setEx('products', 300, JSON.stringify(products.rows));
  
  res.json(products.rows);
});

// Invalidate cache when data changes
app.post('/products', async (req, res) => {
  const newProduct = await db.query(
    'INSERT INTO products (name, price) VALUES ($1, $2)',
    [req.body.name, req.body.price]
  );
  
  // Clear cache so next request gets fresh data
  await client.del('products');
  
  res.json(newProduct);
});</div>

            <div class="metaphor-box">
                <h4>Caching Layers</h4>
                <p><strong>Level 1 - Browser Cache:</strong> Static assets (CSS, JS, images)<br>
                <strong>Level 2 - CDN Cache:</strong> Cached at edge locations worldwide<br>
                <strong>Level 3 - Application Cache (Redis):</strong> Database query results<br>
                <strong>Level 4 - Database Query Cache:</strong> Built into database<br><br>
                Think of it like a library:<br>
                â€¢ Level 1: Book on your desk (instant access)<br>
                â€¢ Level 2: Book in your room (5 seconds)<br>
                â€¢ Level 3: Book in library (5 minutes)<br>
                â€¢ Level 4: Order book from another library (1 week)<br><br>
                Cache hot data at multiple levels for maximum speed!</p>
            </div>

            <h3>Part 6: Horizontal Scaling</h3>
            
            <p>When one server isn't enough, add more servers (horizontal scaling):</p>

            <div class="code">// Load balancer distributes requests across multiple servers

User Request â†’ Load Balancer â†’ Server 1
                             â†’ Server 2
                             â†’ Server 3
                             â†’ Server 4

// Popular load balancers:
- Nginx (self-hosted)
- AWS Application Load Balancer
- Cloudflare Load Balancing
- Railway/Render (automatic scaling)

// Your app must be stateless for horizontal scaling!
// âŒ Bad: Storing data in memory
const sessions = {};  // Lost when server restarts!

// âœ… Good: Store in database or Redis
const session = await redis.get(`session:${sessionId}`);</div>

            <div class="info-box">
                <h4>When Do You Need Scaling?</h4>
                <p><strong>1-1,000 users:</strong> One small server (1 CPU, 1GB RAM) is fine<br>
                <strong>1,000-10,000 users:</strong> Upgrade to medium server (2 CPU, 4GB RAM)<br>
                <strong>10,000-100,000 users:</strong> Start horizontal scaling (2-5 servers) + CDN<br>
                <strong>100,000-1M users:</strong> Load balancer + 10+ servers + Redis + database replica<br>
                <strong>1M+ users:</strong> Multi-region deployment, microservices, advanced caching<br><br>
                <strong>Most beginners never need to worry about scaling!</strong> Build first, scale later.</p>
            </div>

            <div class="metaphor-box">
                <h4>ğŸ‰ Congratulations! You're a FULL-STACK DEVELOPER!</h4>
                <p>You've completed this MASSIVE chapter! You now know:<br><br>
                âœ… <strong>Frontend:</strong> HTML/CSS/JS, React, Vue, state management<br>
                âœ… <strong>Backend:</strong> Node.js, Express, APIs, databases<br>
                âœ… <strong>Integration:</strong> Fetch, authentication, real-time features<br>
                âœ… <strong>Deployment:</strong> Vercel, Railway, Render, environment variables<br>
                âœ… <strong>CI/CD:</strong> GitHub Actions, automated testing and deployment<br>
                âœ… <strong>Monitoring:</strong> Sentry, logging, error tracking<br>
                âœ… <strong>Scaling:</strong> Caching, database optimization, load balancing<br><br>
                <strong>What now?</strong><br><br>
                <strong>1. Build Projects:</strong> Todo app with auth â†’ Chat app â†’ E-commerce site<br>
                <strong>2. Learn More:</strong> TypeScript, Next.js, GraphQL, Docker, AWS<br>
                <strong>3. Contribute to Open Source:</strong> Find projects on GitHub, submit PRs<br>
                <strong>4. Get a Job:</strong> Portfolio of 3-5 projects + resume â†’ apply<br><br>
                You have the foundation to build ANYTHING. The only limit is your imagination. Every app you build makes you better. Every bug you fix teaches you something.<br><br>
                <strong>Welcome to the world of full-stack development. Now go build something incredible! ğŸš€</strong></p>
            </div>
        </section>

            <h3>Environment Variables</h3>
            
            <p>NEVER put secrets in code! Use environment variables:</p>

            <div class="code">// Local: .env file
DATABASE_URL=postgres://...
API_KEY=secret123

// In code:
const dbUrl = process.env.DATABASE_URL;

// On hosting platform:
// Add env vars in dashboard settings</div>

            <div class="warning-box">
                <h4>Production Checklist</h4>
                <p>âœ… Environment variables set<br>
                âœ… HTTPS enabled (automatic on Vercel/Netlify)<br>
                âœ… Database has backups<br>
                âœ… Error logging enabled<br>
                âœ… .env file in .gitignore</p>
            </div>

            <h3>What is Scaling?</h3>
            
            <div class="metaphor-box">
                <h4>Scaling = Handling Growth</h4>
                <p><strong>10 users:</strong> One cashier at a coffee shopâ€”easy<br>
                <strong>10,000 users:</strong> Need more cashiers, bigger kitchen, more supplies<br><br>
                Scaling means your app can handle increasing users without slowing down or crashing.</p>
            </div>

            <h4>Two Types of Scaling</h4>
            
            <div class="code">// Vertical Scaling ("Scale Up")
Upgrade server:
Small server â†’ Bigger server (more CPU/RAM)
Like: Getting a faster computer

// Horizontal Scaling ("Scale Out")
Add more servers:
1 server â†’ 10 servers working together
Like: Hiring more cashiers</div>

            <div class="info-box">
                <h4>When to Worry About Scaling</h4>
                <p><strong>Don't worry yet if you have:</strong> < 1,000 users<br>
                <strong>Start optimizing at:</strong> 10,000+ users<br>
                <strong>Need serious scaling at:</strong> 100,000+ users<br><br>
                Most beginners over-optimize too early. Focus on BUILDING first!</p>
            </div>

            <h3>Quick Performance Wins</h3>
            
            <div class="code">// 1. Image optimization
&lt;img src="photo.jpg" loading="lazy" /&gt;  {/* Lazy load */}
Use WebP format (smaller size)

// 2. Code splitting (React)
import React, { lazy, Suspense } from 'react';
const HeavyComponent = lazy(() => import('./Heavy'));

// 3. Caching
Cache-Control: max-age=3600  {/* Cache for 1 hour */}

// 4. Minimize bundle size
npm run build  {/* Minifies code automatically */}</div>

            <h3>Part 6: Monitoring & Observability</h3>
            
            <p>Once your app is live, you need to know when things break. Monitoring helps you catch issues before users complain:</p>

            <h4>Error Tracking with Sentry</h4>
            
            <div class="code">// Install Sentry
npm install @sentry/react

// src/index.jsx
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: "YOUR_SENTRY_DSN",
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0, // 100% of transactions for performance monitoring
});

function App() {
  return (
    &lt;Sentry.ErrorBoundary fallback={&lt;p&gt;Something went wrong&lt;/p&gt;}&gt;
      {/* Your app */}
    &lt;/Sentry.ErrorBoundary&gt;
  );
}

// Sentry automatically catches:
// - JavaScript errors
// - Unhandled promise rejections
// - Network failures
// - Performance issues

// You can also manually log errors:
try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error);
  console.error(error);
}</div>

            <h4>Application Performance Monitoring (APM)</h4>
            
            <div class="code">// Backend: Use APM tools like New Relic, Datadog, or built-in services

// Example with Express
const newrelic = require('newrelic');

app.get('/api/slow-endpoint', async (req, res) => {
  // New Relic automatically tracks:
  // - Response times
  // - Error rates
  // - Database query performance
  // - External API calls
  
  const data = await db.query('SELECT * FROM users');
  res.json(data);
});

// Metrics you should track:
// 1. Response time (p50, p95, p99)
// 2. Error rate (% of 5xx responses)
// 3. Throughput (requests per second)
// 4. Database query performance
// 5. Memory/CPU usage
// 6. Uptime</div>

            <h4>Log Aggregation</h4>
            
            <div class="code">// Don't just console.log in production!
// Use structured logging:

const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// Log with context
logger.info('User logged in', {
  userId: user.id,
  email: user.email,
  ip: req.ip,
});

logger.error('Database connection failed', {
  error: error.message,
  stack: error.stack,
});

// In production, send logs to:
// - CloudWatch (AWS)
// - Stackdriver (Google Cloud)
// - Papertrail
// - Loggly
// - Datadog</div>

            <h4>Uptime Monitoring</h4>
            
            <div class="code">// Use services that ping your site every few minutes:
// - UptimeRobot (free, simple)
// - Pingdom
// - StatusCake

// They'll alert you via email/SMS if your site goes down

// You can also build your own:
const axios = require('axios');

async function checkUptime() {
  try {
    const response = await axios.get('https://myapp.com/health');
    
    if (response.status === 200) {
      console.log('âœ… Site is up');
    }
  } catch (error) {
    // Site is down! Send alert
    sendSlackAlert('ğŸ”¥ Site is down!');
    sendEmail('admin@myapp.com', 'Site Down Alert');
  }
}

// Run every 5 minutes
setInterval(checkUptime, 5 * 60 * 1000);</div>

            <h3>Part 7: CI/CD Best Practices</h3>
            
            <h4>Automated Testing in CI</h4>
            
            <div class="code">// .github/workflows/test.yml
name: Run Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run unit tests
        run: npm test
      
      - name: Run integration tests
        run: npm run test:integration
      
      - name: Check code coverage
        run: npm run test:coverage
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v2</div>

            <h4>Preview Deployments (Staging)</h4>
            
            <div class="code">// Vercel and Netlify automatically create preview deployments
// for every pull request!

// Example workflow:
// 1. Developer creates PR
// 2. CI runs tests
// 3. If tests pass, Vercel deploys to temporary URL
//    https://my-app-pr-42.vercel.app
// 4. Team reviews changes on preview URL
// 5. If approved, merge to main
// 6. Auto-deploys to production

// This lets you test changes in production-like environment
// before they go live!</div>

            <h4>Database Migrations in CI/CD</h4>
            
            <div class="code">// .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Run database migrations
        run: |
          npm run migrate:up
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
      
      - name: Deploy backend
        run: |
          flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      
      - name: Deploy frontend
        run: |
          vercel --prod --token=${{ secrets.VERCEL_TOKEN }}
      
      - name: Run smoke tests
        run: npm run test:smoke
      
      - name: Notify team
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment successful! ğŸ‰'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}</div>

            <h4>Rollback Strategy</h4>
            
            <div class="code">// Always have a way to rollback if deployment fails!

// Option 1: Git revert
git revert HEAD
git push origin main  // Triggers CI/CD to deploy previous version

// Option 2: Vercel rollback
vercel rollback

// Option 3: Docker image tags
docker pull myapp:v1.2.3  // Previous version
docker stop myapp
docker run --name myapp myapp:v1.2.3

// Option 4: Blue-green deployment
// - Run old version (blue) and new version (green) simultaneously
// - Switch traffic to green
// - If issues, instantly switch back to blue</div>

            <div class="metaphor-box">
                <h4>ğŸ‰ Congratulations! You're a Full-Stack Developer!</h4>
                <p>You've learned:<br><br>
                âœ… <strong>Frontend:</strong> React/Vue components, state, routing<br>
                âœ… <strong>Backend:</strong> APIs, databases, authentication<br>
                âœ… <strong>Integration:</strong> Connecting frontend to backend<br>
                âœ… <strong>Real-time:</strong> WebSockets for live features<br>
                âœ… <strong>Files:</strong> Handling uploads<br>
                âœ… <strong>Deployment:</strong> Getting your app online<br>
                âœ… <strong>CI/CD:</strong> Automated testing and deployment<br>
                âœ… <strong>Monitoring:</strong> Tracking errors and performance<br>
                âœ… <strong>Scaling:</strong> Handling growth<br><br>
                <strong>What's next?</strong> BUILD! Start with a todo app with authentication, then a chat app, then your dream project. Every app you build makes you better. The learning never stops, but you now have the foundation to build ANYTHING.<br><br>
                Welcome to the world of full-stack development. Now go build something amazing! ğŸš€</p>
            </div>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>

