<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 08: Full-Stack Integration - Part I - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: var(--bg2); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(255,255,255,0.05); color: var(--text); transform: translateX(4px); }
        .sidebar-link.active { background: rgba(255,255,255,0.1); color: var(--text); font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: var(--text3); margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.2); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: var(--bg3); border-left: 3px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-left: 3px solid #ff6b6b; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #ff6b6b; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; white-space: nowrap; }
        .metaphor-box { background: rgba(255,255,255,0.03); border-left: 4px solid var(--text); padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "ğŸ’¡"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg2); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, var(--text) 0%, var(--text2) 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">â–¼</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#what-is-fullstack" class="sidebar-link">1. What Even IS Full-Stack?</a>
            <a href="#first-react-app" class="sidebar-link">2. Building Your First React App</a>
            <a href="#first-vue-app" class="sidebar-link">3. Building Your First Vue App</a>
            <a href="#understanding-state" class="sidebar-link">4. Understanding State</a>
            <a href="#state-management" class="sidebar-link">5. State Management</a>
            <a href="#api-integration" class="sidebar-link">6. API Integration</a>
            <a href="#realtime-features" class="sidebar-link">7. Real-Time Features</a>
            <a href="#authentication" class="sidebar-link">8. Authentication & Authorization</a>
            <a href="#file-uploads" class="sidebar-link">9. File Uploads & Media</a>
            <a href="#pwa-features" class="sidebar-link">10. Progressive Web Apps</a>
            <a href="#testing-integration" class="sidebar-link">11. Testing Full-Stack Apps</a>
            <a href="#deployment-scaling" class="sidebar-link">12. Deployment & Scaling</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="programming-ch07.html" class="sidebar-link">â† Previous: Ch07 Databases</a>
            <a href="programming-ch09.html" class="sidebar-link">Next: Ch09 Professional Practices â†’</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="chapter-label">Chapter 08</div>
            <h1 class="page-title">Full-Stack Integration - Part I</h1>
            <p class="page-subtitle">Start from absolute zero. Learn what full-stack means, how websites actually work, why we need frameworks, and build your first complete application that connects a beautiful frontend to a powerful backend. No prior knowledge needed - we explain EVERYTHING.</p>
        </div>

        <!-- SECTION 1: What Even IS Full-Stack? -->
        <section id="what-is-fullstack" class="section">
            <h2 class="section-title">What Even IS Full-Stack?</h2>
            <p class="section-intro">Welcome! If you're reading this, you might have heard terms like "full-stack developer," "React," "frontend," "backend," and felt completely lost. That's okay! We're starting from ABSOLUTE ZERO. Imagine you know nothing about web development - we'll build up from there, step by step, with tons of analogies and examples.</p>

            <h3>Part 1: What Even IS a Website?</h3>
            
            <h4>The Big Picture: Computers Talking to Each Other</h4>
            <p>Before we dive into fancy terms, let's start with the absolute basics. When you open a website like Facebook, YouTube, or Amazon, what's actually happening?</p>

            <div class="metaphor-box">
                <h4>The Restaurant Metaphor</h4>
                <p>Think of a website like a restaurant:<br><br>
                <strong>You (the customer)</strong> = Your web browser (Chrome, Firefox, Safari)<br>
                <strong>The dining area</strong> = The website you see on your screen<br>
                <strong>The kitchen</strong> = The server (a powerful computer somewhere in the world)<br>
                <strong>The waiter</strong> = The internet<br><br>
                When you click a link, it's like ordering food. Your browser sends a request through the internet (the waiter) to a server (the kitchen). The server prepares your order (fetches data from databases, processes it) and sends it back through the internet to your browser, which displays it beautifully on your screen.</p>
            </div>

            <p>Let's break that down even further. A website is made of THREE main technologies working together:</p>

            <h4>1. HTML - The Skeleton/Structure</h4>
            <p>HTML stands for HyperText Markup Language. Big scary name, simple concept: HTML defines WHAT is on the page. It's like the skeleton of a body or the frame of a house.</p>

            <div class="code">&lt;!-- This is HTML --&gt;
&lt;h1&gt;Welcome to My Website&lt;/h1&gt;
&lt;p&gt;This is a paragraph of text.&lt;/p&gt;
&lt;button&gt;Click Me&lt;/button&gt;
&lt;img src="cat.jpg" alt="A cute cat"&gt;</div>

            <p>Each of those things in angle brackets (<span class="inline-code">&lt;&gt;</span>) is called an <strong>element</strong> or <strong>tag</strong>. They tell the browser: "Put a heading here," "Put a paragraph here," "Put a button here."</p>

            <div class="info-box">
                <h4>HTML Elements Explained</h4>
                <p><span class="inline-code">&lt;h1&gt;</span> = Heading (big title text)<br>
                <span class="inline-code">&lt;p&gt;</span> = Paragraph (normal text)<br>
                <span class="inline-code">&lt;button&gt;</span> = A clickable button<br>
                <span class="inline-code">&lt;img&gt;</span> = An image<br>
                <span class="inline-code">&lt;div&gt;</span> = A container (holds other elements)<br>
                <span class="inline-code">&lt;a&gt;</span> = A link to another page<br><br>
                Notice: Most tags come in pairs: <span class="inline-code">&lt;p&gt;text&lt;/p&gt;</span><br>
                Some are self-closing: <span class="inline-code">&lt;img /&gt;</span><br><br>
                That's it! HTML is just telling the browser what content to display.</p>
            </div>

            <h4>2. CSS - The Styling/Makeup</h4>
            <p>CSS stands for Cascading Style Sheets. It makes your website look pretty. If HTML is the skeleton, CSS is the skin, hair, clothes, and makeup.</p>

            <div class="code">/* This is CSS */
h1 {
  color: blue;
  font-size: 48px;
  text-align: center;
}

button {
  background-color: green;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
}</div>

            <p>CSS says: "Take that heading and make it blue, 48 pixels big, and centered." "Take that button and make it green with white text and rounded corners."</p>

            <div class="metaphor-box">
                <h4>The Blueprint Metaphor</h4>
                <p>HTML is like a blueprint that says "put a door here, a window there."<br><br>
                CSS is like the interior designer who says "paint the door red, put curtains on the window, add a fancy doorknob."<br><br>
                Same structure, but now it looks beautiful!</p>
            </div>

            <h4>3. JavaScript - The Behavior/Brain</h4>
            <p>JavaScript makes your website DO stuff. It's the brain that makes things interactive.</p>

            <div class="code">// This is JavaScript
const button = document.querySelector('button');

button.addEventListener('click', function() {
  alert('Button was clicked!');
  console.log('User clicked the button');
});</div>

            <p>This code says: "Find the button on the page. When someone clicks it, show a popup message and log something to the console."</p>

            <div class="info-box">
                <h4>Putting It All Together</h4>
                <p><strong>HTML:</strong> "There's a button on the page."<br>
                <strong>CSS:</strong> "The button is green and rounded."<br>
                <strong>JavaScript:</strong> "When you click the button, something happens!"<br><br>
                Every website you've ever visited uses these three technologies. Facebook, Google, YouTube - they all use HTML for structure, CSS for styling, and JavaScript for interactivity.</p>
            </div>

            <h4>A Complete Mini Example</h4>
            <p>Let's see all three working together in a simple counter:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Counter&lt;/title&gt;
  &lt;style&gt;
    /* CSS - Make it pretty */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 50px;
    }
    
    h1 {
      color: #333;
    }
    
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    
    button:hover {
      background: #0056b3;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- HTML - Structure --&gt;
  &lt;h1&gt;Simple Counter&lt;/h1&gt;
  &lt;p&gt;Count: &lt;span id="count"&gt;0&lt;/span&gt;&lt;/p&gt;
  &lt;button id="increment"&gt;Add 1&lt;/button&gt;
  &lt;button id="reset"&gt;Reset&lt;/button&gt;
  
  &lt;script&gt;
    // JavaScript - Make it work
    let count = 0;
    
    const countDisplay = document.getElementById('count');
    const incrementBtn = document.getElementById('increment');
    const resetBtn = document.getElementById('reset');
    
    incrementBtn.addEventListener('click', function() {
      count = count + 1;
      countDisplay.textContent = count;
    });
    
    resetBtn.addEventListener('click', function() {
      count = 0;
      countDisplay.textContent = count;
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <p>Save this as <span class="inline-code">counter.html</span>, open it in a browser, and you have a working counter! You can click the button and watch the number go up.</p>

            <h3>Part 2: What is "Frontend" vs "Backend"?</h3>

            <h4>The Restaurant Metaphor (Again, Because It's Perfect)</h4>
            <p>Remember our restaurant analogy? Let's expand on it:</p>

            <div class="metaphor-box">
                <h4>Frontend = What Customers See</h4>
                <p><strong>The Frontend</strong> is everything in the dining area:<br>
                â€¢ The menu (layout and design)<br>
                â€¢ The tables and chairs (UI elements like buttons and forms)<br>
                â€¢ The decorations (colors, fonts, animations)<br>
                â€¢ The waiter taking your order (handling user interactions)<br><br>
                It's everything you SEE and INTERACT with. In web terms, this is the HTML, CSS, and JavaScript that runs IN YOUR BROWSER on YOUR COMPUTER.</p>
            </div>

            <div class="metaphor-box">
                <h4>Backend = What Customers Don't See</h4>
                <p><strong>The Backend</strong> is everything in the kitchen:<br>
                â€¢ The chefs cooking food (processing data)<br>
                â€¢ The pantry storing ingredients (databases)<br>
                â€¢ The recipes (business logic)<br>
                â€¢ The dishwashers and food prep (background tasks)<br><br>
                It's everything that happens BEHIND THE SCENES. In web terms, this is code running on a SERVER (a computer somewhere else), working with databases, processing payments, sending emails, etc.</p>
            </div>

            <h4>A Real Example: Logging Into Facebook</h4>
            <p>Let's trace what happens when you log into Facebook to see frontend and backend working together:</p>

            <ol>
                <li><strong>Frontend:</strong> You see a login page (HTML/CSS) with two text boxes and a button.</li>
                <li><strong>Frontend:</strong> You type your email and password. JavaScript captures what you typed.</li>
                <li><strong>Frontend:</strong> You click "Log In." JavaScript sends your credentials to Facebook's server.</li>
                <li><strong>Backend:</strong> Facebook's server receives your email/password.</li>
                <li><strong>Backend:</strong> It checks the database: "Does this email exist? Does the password match?"</li>
                <li><strong>Backend:</strong> If yes, it creates a session token (like a temporary ticket) and sends it back.</li>
                <li><strong>Frontend:</strong> Your browser receives the token and stores it.</li>
                <li><strong>Frontend:</strong> JavaScript updates the page to show your feed instead of the login screen.</li>
            </ol>

            <div class="info-box">
                <h4>Why Have a Backend?</h4>
                <p><strong>Security:</strong> You can't check passwords in the frontend - anyone could read your JavaScript code! The backend keeps sensitive operations hidden.<br><br>
                <strong>Data Storage:</strong> Browsers can't store millions of user posts. The backend has databases for that.<br><br>
                <strong>Shared Data:</strong> Your friends see YOUR posts because the backend stores them in one place everyone can access.<br><br>
                <strong>Processing Power:</strong> Heavy computations (like video encoding) happen on powerful servers, not your phone.</p>
            </div>

            <h4>What is "Full-Stack"?</h4>
            <p>Now we can finally answer the original question! A <strong>full-stack developer</strong> is someone who can work on BOTH the frontend (the dining area) AND the backend (the kitchen).</p>

            <div class="code">// Full-Stack Developer Can Do:

FRONTEND (Browser):
- Build beautiful UIs with HTML/CSS
- Make interactive pages with JavaScript
- Use frameworks like React or Vue
- Handle user interactions

BACKEND (Server):
- Write server code (Node.js, Python, etc.)
- Design databases
- Create APIs (ways for frontend to talk to backend)
- Handle authentication, payments, emails</div>

            <p>Think of it like being both a chef AND a waiter. You understand the whole restaurant, not just one part.</p>

            <h3>Part 3: Why Regular JavaScript Gets Messy</h3>

            <h4>Let's Build Something Simple (The Wrong Way First)</h4>
            <p>Remember that counter we built? Let's look at it again and understand the problems:</p>

            <div class="code">&lt;!-- Your HTML --&gt;
&lt;div id="counter-app"&gt;
  &lt;h1&gt;Click Counter&lt;/h1&gt;
  &lt;p&gt;You clicked &lt;span id="count"&gt;0&lt;/span&gt; times&lt;/p&gt;
  &lt;button id="increment-btn"&gt;Click Me!&lt;/button&gt;
  &lt;button id="reset-btn"&gt;Reset&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
// Your JavaScript
let count = 0;  // Store the count

// Step 1: Find HTML elements
const countDisplay = document.getElementById('count');
const incrementBtn = document.getElementById('increment-btn');
const resetBtn = document.getElementById('reset-btn');

// Step 2: Add event listeners
incrementBtn.addEventListener('click', function() {
  count = count + 1;
  countDisplay.textContent = count;  // Step 3: Update display
});

resetBtn.addEventListener('click', function() {
  count = 0;
  countDisplay.textContent = count;  // Step 3: Update display
});
&lt;/script&gt;</div>

            <p>This works for a simple counter. But notice the problems:</p>

            <div class="warning-box">
                <h4>âš ï¸ Problems with Vanilla JavaScript</h4>
                <p><strong>1. Manual DOM manipulation:</strong> You have to manually find every element with <span class="inline-code">getElementById</span>. What if you have 100 elements?<br><br>
                <strong>2. Manual updates:</strong> Every time <span class="inline-code">count</span> changes, YOU must remember to update <span class="inline-code">countDisplay.textContent</span>. Forget once = bug.<br><br>
                <strong>3. Scattered logic:</strong> Your data (<span class="inline-code">count</span>) is separate from your HTML. They can get out of sync.<br><br>
                <strong>4. No reusability:</strong> Want another counter? Copy-paste all this code and change IDs. Want 10 counters? Good luck.<br><br>
                <strong>5. Hard to maintain:</strong> As your app grows, you have spaghetti code everywhere.</p>
            </div>

            <h4>What Happens When Your App Grows?</h4>
            <p>Let's imagine you're building a TODO list app. Not with frameworks - just vanilla JavaScript. Here's what you'd need:</p>

            <div class="code">// Imagine all this in vanilla JavaScript:

1. Create todo HTML
   - Find the input field
   - Get the text user typed
   - Create a new &lt;li&gt; element
   - Set its text
   - Create a delete button
   - Add it to the list
   - Clear the input field

2. Delete a todo
   - Find which todo was clicked
   - Remove it from the DOM
   - Update the count display

3. Mark todo as complete
   - Find the checkbox
   - Add event listener
   - Update the styling
   - Move it to "completed" section
   - Update the count

4. Filter todos (all, active, completed)
   - Loop through ALL todos
   - Hide/show based on filter
   - Update which filter button is active

5. Save to localStorage
   - Convert todos to JSON
   - Save when anything changes
   - Load when page refreshes
   - Parse JSON back to todos

// That's HUNDREDS of lines of:
// - document.getElementById()
// - element.addEventListener()
// - element.textContent = ...
// - element.style.something = ...
// And you have to remember to update EVERYTHING
// when ANYTHING changes!</div>

            <p>Every interaction requires you to:</p>
            <ol>
                <li>Update your data (JavaScript variables)</li>
                <li>Find the right HTML elements</li>
                <li>Update those elements to match your data</li>
                <li>Make sure you didn't forget to update something</li>
            </ol>

            <div class="metaphor-box">
                <h4>The Spreadsheet Metaphor</h4>
                <p>Imagine a spreadsheet where formulas DON'T auto-calculate.<br><br>
                <strong>Without frameworks (manual):</strong> You have a column showing prices, a column showing quantities, and a total. When you change a price, you have to MANUALLY recalculate the total. Change 10 prices? Recalculate 10 times. Miss one? Your total is wrong.<br><br>
                <strong>With frameworks (automatic):</strong> Excel automatically updates the total when anything changes. You change a price - boom, total updates instantly. You never think about HOW it updates, it just DOES.<br><br>
                Frameworks are like Excel formulas for your website!</p>
            </div>

            <h4>The DOM: What You're Actually Manipulating</h4>
            <p>Before we go further, let's understand what the "DOM" is, because frameworks help you NOT have to work with it directly.</p>

            <div class="info-box">
                <h4>What is the DOM?</h4>
                <p>DOM stands for <strong>Document Object Model</strong>. Scary name, simple concept:<br><br>
                When your browser loads HTML, it converts it into a JavaScript object structure - a tree of elements that JavaScript can manipulate.<br><br>
                Your HTML is like a family tree:<br>
                <span class="inline-code">&lt;html&gt;</span> is the grandparent<br>
                <span class="inline-code">&lt;body&gt;</span> is a parent<br>
                <span class="inline-code">&lt;div&gt;</span> is a child<br>
                <span class="inline-code">&lt;p&gt;</span> inside <span class="inline-code">&lt;div&gt;</span> is a grandchild<br><br>
                The DOM lets JavaScript say "find the second child of the third div" or "change the text of this paragraph."</p>
            </div>

            <p>Working with the DOM directly is SLOW and TEDIOUS:</p>

            <div class="code">// All these DOM operations are SLOW:
const element = document.getElementById('my-div');
element.textContent = 'New text';
element.style.color = 'blue';
element.classList.add('active');

// Create new element
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello';
newDiv.className = 'card';
document.body.appendChild(newDiv);

// Remove element
const oldElement = document.getElementById('old-div');
oldElement.parentNode.removeChild(oldElement);

// Update a list of 100 items?
// Loop 100 times, update each one manually...
// SLOW and PAINFUL!</div>

            <h3>Part 4: Frontend vs Backend - Understanding the Full Picture</h3>

            <h4>The Iceberg Metaphor</h4>
            <p>Before we dive into frameworks, let's make sure you truly understand the difference between frontend and backend, because this is FUNDAMENTAL to everything you'll build.</p>

            <div class="metaphor-box">
                <h4>ğŸ§Š Websites Are Like Icebergs</h4>
                <p>When you see an iceberg, you only see the tip - about 10% of it. The other 90% is underwater, invisible but absolutely crucial.<br><br>
                <strong>The Tip (Frontend):</strong> Everything you see and interact with<br>
                â€¢ The beautiful design<br>
                â€¢ The buttons you click<br>
                â€¢ The animations<br>
                â€¢ The forms you fill out<br>
                â€¢ The images and text<br><br>
                <strong>The Underwater Part (Backend):</strong> Everything you DON'T see<br>
                â€¢ Databases storing millions of user accounts<br>
                â€¢ Servers processing thousands of requests per second<br>
                â€¢ Security systems protecting your data<br>
                â€¢ Business logic making decisions<br>
                â€¢ Payment processors handling transactions<br>
                â€¢ Email systems sending notifications<br><br>
                Both parts are EQUALLY important. The tip looks pretty, but without the underwater foundation, it would melt and disappear!</p>
            </div>

            <h4>What "Frontend" Really Means</h4>
            <p>Let's get crystal clear on this. The <strong>frontend</strong> (also called "client-side") is EVERYTHING that happens in YOUR browser, on YOUR device.</p>

            <div class="info-box">
                <h4>Frontend In Plain English</h4>
                <p><strong>Where it runs:</strong> In your web browser (Chrome, Firefox, Safari, Edge) on your computer/phone/tablet<br><br>
                <strong>What it does:</strong><br>
                â€¢ Displays the user interface (what you see)<br>
                â€¢ Handles user interactions (clicks, typing, scrolling)<br>
                â€¢ Makes things look pretty (colors, layouts, animations)<br>
                â€¢ Shows/hides elements dynamically<br>
                â€¢ Validates your input (e.g., "Please enter a valid email")<br>
                â€¢ Communicates with the backend when needed<br><br>
                <strong>Technologies used:</strong><br>
                â€¢ HTML (structure)<br>
                â€¢ CSS (styling)<br>
                â€¢ JavaScript (interactivity)<br>
                â€¢ Frameworks like React, Vue, Angular<br><br>
                <strong>Think of it as:</strong> The storefront of a shop - it's what customers see and interact with!</p>
            </div>

            <h4>What "Backend" Really Means</h4>
            <p>The <strong>backend</strong> (also called "server-side") is everything that happens on a SERVER - a powerful computer (or many computers!) somewhere in a data center.</p>

            <div class="info-box">
                <h4>Backend In Plain English</h4>
                <p><strong>Where it runs:</strong> On servers in data centers (Amazon's servers, Google's servers, your company's servers, etc.)<br><br>
                <strong>What it does:</strong><br>
                â€¢ Stores and retrieves data from databases<br>
                â€¢ Processes business logic ("Is this user allowed to delete that post?")<br>
                â€¢ Handles authentication ("Is this password correct?")<br>
                â€¢ Processes payments<br>
                â€¢ Sends emails<br>
                â€¢ Generates reports<br>
                â€¢ Performs complex calculations<br>
                â€¢ Keeps secrets safe (API keys, passwords, etc.)<br><br>
                <strong>Technologies used:</strong><br>
                â€¢ Node.js (JavaScript on the server)<br>
                â€¢ Python (Django, Flask)<br>
                â€¢ Java, C#, Ruby, PHP, Go, etc.<br>
                â€¢ Databases (PostgreSQL, MongoDB, MySQL)<br><br>
                <strong>Think of it as:</strong> The warehouse and office behind the shop - customers never see it, but it's where all the real work happens!</p>
            </div>

            <h4>The Restaurant Metaphor - COMPLETE Edition</h4>
            <p>Let's use the restaurant analogy one more time, but make it comprehensive so you'll never forget:</p>

            <div class="metaphor-box">
                <h4>ğŸ½ï¸ The Complete Restaurant Breakdown</h4>
                <p><strong>FRONTEND (Dining Area):</strong><br><br>
                <strong>The Menu:</strong> Your website's layout and navigation. It shows you what's available.<br><br>
                <strong>The Tables and Chairs:</strong> UI elements like buttons, forms, input fields - things you interact with.<br><br>
                <strong>The Decorations:</strong> CSS styling - colors, fonts, spacing that make it look nice.<br><br>
                <strong>The Lighting:</strong> Visual effects, animations, transitions that create atmosphere.<br><br>
                <strong>Your Server/Waiter:</strong> JavaScript - takes your order (input), brings you food (displays data), responds to your requests.<br><br>
                <strong>The Dining Experience:</strong> Everything you SEE, TOUCH, and EXPERIENCE as a customer.<br><br>
                <hr>
                <strong>BACKEND (Kitchen & Office):</strong><br><br>
                <strong>The Kitchen:</strong> Where the real processing happens - cooking (computing), preparing orders (processing requests).<br><br>
                <strong>The Pantry/Freezer:</strong> The database - stores ingredients (data) for long-term. Thousands of items organized and preserved.<br><br>
                <strong>The Head Chef:</strong> Business logic - makes decisions about recipes, checks quality, manages the operation.<br><br>
                <strong>The Recipe Book:</strong> Your code/algorithms - instructions for how to prepare each dish correctly.<br><br>
                <strong>The Dishwasher:</strong> Background jobs - cleanup tasks that happen behind the scenes.<br><br>
                <strong>The Cash Register/Accounting:</strong> Payment processing, financial records, secure transactions.<br><br>
                <strong>The Manager's Office:</strong> Admin tools, analytics, monitoring systems.<br><br>
                <strong>The Security System:</strong> Authentication, authorization, data protection - making sure only authorized people access certain areas.<br><br>
                <hr>
                <strong>THE COMMUNICATION:</strong><br><br>
                <strong>The Ticket System:</strong> When the waiter takes your order, they write a ticket and send it to the kitchen. That's like an HTTP request!<br><br>
                <strong>The Ready Bell:</strong> When food is ready, kitchen rings a bell. That's like an HTTP response!<br><br>
                You (customer) never enter the kitchen. You don't see the recipes or the pantry. You just enjoy the result!</p>
            </div>

            <h4>The Client-Server Model</h4>
            <p>This is the formal name for how frontend and backend communicate. It's simpler than it sounds!</p>

            <div class="info-box">
                <h4>Client-Server Model Explained</h4>
                <p><strong>CLIENT:</strong> The thing making requests (your browser, your phone app)<br><br>
                <strong>SERVER:</strong> The thing responding to requests (the backend computer)<br><br>
                <strong>REQUEST:</strong> "Hey server, I need some data!" or "Hey server, save this information!"<br><br>
                <strong>RESPONSE:</strong> "Here's your data!" or "OK, I saved it!" or "Sorry, error occurred."<br><br>
                It's a conversation. The client asks, the server answers. Every time!</p>
            </div>

            <h4>Key Terms You MUST Know</h4>
            <p>Let's define the essential vocabulary that you'll hear constantly:</p>

            <div class="code">ğŸ“˜ GLOSSARY OF ESSENTIAL TERMS:

CLIENT:
  Definition: The user's device/browser making requests
  Example: Your laptop running Chrome
  Think: The customer in the restaurant

SERVER:
  Definition: A computer that responds to requests
  Example: Amazon's computers running your favorite shopping site
  Think: The kitchen in the restaurant

REQUEST:
  Definition: A message from client asking for something
  Example: "Give me the user profile for user ID 12345"
  Think: The customer ordering food

RESPONSE:
  Definition: The server's answer to a request
  Example: "Here's the user profile data: {name: 'John', age: 30}"
  Think: The waiter bringing your food

HTTP/HTTPS:
  Definition: The protocol (set of rules) for web communication
  Example: Like saying "please" and "thank you" - a standard way to communicate
  Think: The formal etiquette between waiter and customer

API (Application Programming Interface):
  Definition: A menu of what you can request from a server
  Example: "GET /users/123" means "get user with ID 123"
  Think: The actual menu showing what dishes you can order

DATABASE:
  Definition: Organized storage for data
  Example: PostgreSQL storing millions of user accounts
  Think: The pantry/freezer storing all ingredients

FULL-STACK:
  Definition: Can work on both frontend AND backend
  Example: A developer who knows React AND Node.js
  Think: Someone who can work as both waiter AND chef</div>

            <h4>How They Communicate: The HTTP Request/Response Cycle</h4>
            <p>Every interaction between frontend and backend follows this pattern. Let's break it down step by step:</p>

            <div class="code">THE CYCLE:

1. USER ACTION (Frontend)
   â””â”€&gt; You click "Load Posts" button

2. JAVASCRIPT CAPTURES IT (Frontend)
   â””â”€&gt; Event listener says: "Button was clicked!"

3. MAKE HTTP REQUEST (Frontend)
   â””â”€&gt; Send message to server: "GET /api/posts"
   
4. REQUEST TRAVELS THROUGH INTERNET
   â””â”€&gt; Your computer â†’ ISP â†’ Internet â†’ Server's ISP â†’ Server
   
5. SERVER RECEIVES REQUEST (Backend)
   â””â”€&gt; "Someone wants posts!"
   
6. SERVER PROCESSES (Backend)
   â””â”€&gt; Query database: "SELECT * FROM posts"
   â””â”€&gt; Get results: [{id:1, title:"Hi"}, {id:2, title:"Hello"}]
   â””â”€&gt; Format as JSON
   
7. SERVER SENDS RESPONSE (Backend)
   â””â”€&gt; Status: 200 OK
   â””â”€&gt; Data: JSON array of posts
   
8. RESPONSE TRAVELS BACK
   â””â”€&gt; Server â†’ Internet â†’ Your computer
   
9. JAVASCRIPT RECEIVES RESPONSE (Frontend)
   â””â”€&gt; "Got the data!"
   
10. UPDATE UI (Frontend)
    â””â”€&gt; Loop through posts and display them on page
    â””â”€&gt; User sees the posts appear!

This entire cycle happens in MILLISECONDS!</div>

            <h4>Visual Representation: The Architecture</h4>
            <p>Here's an ASCII diagram showing how everything connects:</p>

            <div class="code">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          USER'S DEVICE (Client)             â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      WEB BROWSER (Chrome/etc)       â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚    FRONTEND (Your Code)      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ HTML (structure)         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ CSS (styling)            â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ JavaScript (behavior)    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ React/Vue components     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Renders UI, handles input  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Makes HTTP requests        â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†• HTTP
            (Request/Response)
                    â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       DATA CENTER (Server)                  â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      WEB SERVER (Node.js/etc)       â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚    BACKEND (Your Code)       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ API Routes/Endpoints     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Business Logic           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Authentication           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   â€¢ Data Processing          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Receives requests          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Processes data             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   Sends responses            â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                    â†•                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚        DATABASE                     â”‚   â”‚
â”‚  â”‚                                     â”‚   â”‚
â”‚  â”‚   â€¢ User data                       â”‚   â”‚
â”‚  â”‚   â€¢ Posts, comments                 â”‚   â”‚
â”‚  â”‚   â€¢ Product catalog                 â”‚   â”‚
â”‚  â”‚   â€¢ Everything stored permanently   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</div>

            <h4>Real Code Example: Frontend Making a Request</h4>
            <p>Let's see actual code showing how frontend talks to backend:</p>

            <div class="code">// FRONTEND CODE (JavaScript in the browser)

// User clicks "Load Users" button
document.getElementById('load-users-btn').addEventListener('click', async function() {
  
  console.log('User clicked button!');
  
  // Step 1: Show loading message
  document.getElementById('status').textContent = 'Loading...';
  
  try {
    // Step 2: Make HTTP request to backend
    const response = await fetch('https://api.mywebsite.com/users');
    //                            â†‘
    //                      This is your backend URL!
    
    // Step 3: Wait for response and parse it
    const users = await response.json();
    //    â†‘
    //  This will be data like: [{id:1, name:"Alice"}, {id:2, name:"Bob"}]
    
    // Step 4: Update the UI with the data
    const userList = document.getElementById('user-list');
    userList.innerHTML = ''; // Clear old content
    
    users.forEach(user => {
      const li = document.createElement('li');
      li.textContent = `${user.name} (ID: ${user.id})`;
      userList.appendChild(li);
    });
    
    // Step 5: Update status
    document.getElementById('status').textContent = `Loaded ${users.length} users!`;
    
  } catch (error) {
    // If something went wrong
    console.error('Error:', error);
    document.getElementById('status').textContent = 'Error loading users!';
  }
});

// What happened:
// 1. User clicked button (Frontend)
// 2. JavaScript sent HTTP request to server (Frontend â†’ Backend)
// 3. Server processed request and sent back data (Backend â†’ Frontend)
// 4. JavaScript received data and updated page (Frontend)
// User sees the result!</div>

            <h4>Real Code Example: Backend Handling the Request</h4>
            <p>Now let's see what happens on the backend when that request arrives:</p>

            <div class="code">// BACKEND CODE (Node.js running on a server)

const express = require('express'); // Popular Node.js framework
const app = express();

// This is an API ENDPOINT - a URL the frontend can call
app.get('/users', async function(request, response) {
  //       â†‘                       â†‘          â†‘
  //       |                       |          |
  //    The URL path          Request from    Response we'll
  //                          frontend        send back
  
  console.log('Received request for users!');
  
  try {
    // Step 1: Query the database
    const users = await database.query('SELECT id, name, email FROM users');
    //    â†‘
    //  This fetches data from database (SQL query)
    
    // Step 2: Do some processing if needed
    // (e.g., remove sensitive data, format data, etc.)
    const safeUsers = users.map(user => ({
      id: user.id,
      name: user.name,
      // Note: We're NOT sending passwords or sensitive data!
    }));
    
    // Step 3: Send response back to frontend
    response.status(200).json(safeUsers);
    //        â†‘      â†‘       â†‘
    //        |      |       |
    //     Status   Format   The data
    //     (200 =   as JSON
    //      OK)
    
    console.log(`Sent ${safeUsers.length} users to frontend`);
    
  } catch (error) {
    // If something went wrong
    console.error('Database error:', error);
    response.status(500).json({ error: 'Internal server error' });
    //        â†‘
    //     500 = Server Error
  }
});

// Start the server
app.listen(3000, () => {
  console.log('Backend server running on port 3000');
});

// What happened:
// 1. Server received request at /users endpoint
// 2. Queried database for user data
// 3. Processed/formatted the data
// 4. Sent response back to frontend
// Frontend receives it and displays it!</div>

            <h4>What Happens When You Click "Login"?</h4>
            <p>Let's trace a complete real-world example: logging into a website. This uses BOTH frontend and backend:</p>

            <div class="code">ğŸ” THE LOGIN FLOW - Step by Step:

STEP 1: USER SEES LOGIN FORM (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: HTML form with email and password fields
Where: Your browser
Code: &lt;input type="email"&gt; &lt;input type="password"&gt; &lt;button&gt;Login&lt;/button&gt;


STEP 2: USER TYPES CREDENTIALS (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript captures what you type
Where: Your browser
Data: email = "alice@example.com", password = "secret123"


STEP 3: USER CLICKS LOGIN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript intercepts form submission
Where: Your browser
Action: Prevent default form behavior, prepare to send data


STEP 4: FRONTEND MAKES HTTP REQUEST (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Send credentials to backend
Where: Your browser sends request over internet
Request:
  Method: POST
  URL: https://api.mywebsite.com/auth/login
  Body: { email: "alice@example.com", password: "secret123" }


STEP 5: BACKEND RECEIVES REQUEST (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Server gets login request
Where: Server in data center
Action: Extract email and password from request body


STEP 6: BACKEND CHECKS DATABASE (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Query database for this user
Where: Database server
Query: SELECT * FROM users WHERE email = 'alice@example.com'
Result: User found! Now check password...


STEP 7: BACKEND VERIFIES PASSWORD (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Compare provided password with stored hash
Where: Server memory
Process:
  - Stored hash: "$2b$10$xyzabc123..." (encrypted)
  - Provided: "secret123"
  - Hash "secret123" and compare
  - Match? YES! âœ“


STEP 8: BACKEND CREATES SESSION (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Generate authentication token
Where: Server
Token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." (JWT)
Meaning: "This user is logged in, valid for 24 hours"


STEP 9: BACKEND SENDS RESPONSE (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Send success message and token
Where: Server sends over internet
Response:
  Status: 200 OK
  Body: { success: true, token: "eyJhb...", user: { name: "Alice" } }


STEP 10: FRONTEND RECEIVES RESPONSE (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: JavaScript receives the success response
Where: Your browser
Action: Parse the JSON data


STEP 11: FRONTEND STORES TOKEN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Save token for future requests
Where: Browser localStorage or cookie
Code: localStorage.setItem('authToken', response.token);


STEP 12: FRONTEND UPDATES UI (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Show logged-in state
Where: Your browser
Changes:
  - Hide login form
  - Show "Welcome, Alice!"
  - Display user dashboard
  - Update navigation menu


STEP 13: FUTURE REQUESTS INCLUDE TOKEN (Frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
What: Every subsequent request sends token
Where: Your browser
Headers: { Authorization: "Bearer eyJhb..." }
Meaning: "I'm Alice, and here's proof!"


THE RESULT:
You're logged in! Frontend and backend worked together:
- Frontend collected your input and displayed results
- Backend verified credentials and issued a token
- Both sides communicated via HTTP
- Your browser remembers you're logged in</div>

            <div class="warning-box">
                <h4>âš ï¸ Security Note: Why Backend Matters!</h4>
                <p><strong>Never trust the frontend!</strong> Anyone can open browser dev tools and modify JavaScript. That's why:<br><br>
                âŒ NEVER check passwords on frontend<br>
                âŒ NEVER store sensitive API keys in frontend code<br>
                âŒ NEVER trust user input without backend validation<br><br>
                âœ… ALWAYS verify credentials on backend<br>
                âœ… ALWAYS validate data on backend<br>
                âœ… ALWAYS keep secrets on backend<br><br>
                Think: The frontend is a public space (the dining area). Anyone can see and manipulate it. The backend is private (the kitchen) - only authorized code runs there!</p>
            </div>

            <h4>Why You Need BOTH Frontend and Backend</h4>
            <p>Some beginners ask: "Can't I just use frontend?" or "Why not put everything in the backend?" Let's address this:</p>

            <div class="info-box">
                <h4>Frontend Alone: What You CAN'T Do</h4>
                <p>Without a backend, you can't:<br><br>
                âŒ Save data permanently (browser refresh = data lost)<br>
                âŒ Share data between users (everyone sees their own version)<br>
                âŒ Keep secrets secure (all code is visible)<br>
                âŒ Process payments (security risk!)<br>
                âŒ Send emails<br>
                âŒ Do heavy computations (would freeze the browser)<br>
                âŒ Access other APIs requiring secret keys<br><br>
                <strong>Frontend-only apps are limited to:</strong><br>
                â€¢ Simple calculators<br>
                â€¢ Static informational websites<br>
                â€¢ Games that don't save progress<br>
                â€¢ Demos and prototypes</p>
            </div>

            <div class="info-box">
                <h4>Backend Alone: What You CAN'T Do</h4>
                <p>Without a frontend, you can't:<br><br>
                âŒ Show a nice user interface (backend returns raw data)<br>
                âŒ Handle user interactions smoothly<br>
                âŒ Create responsive, animated experiences<br>
                âŒ Work offline (backend needs internet)<br>
                âŒ Provide instant feedback (every action requires server round-trip)<br><br>
                <strong>Backend-only services are:</strong><br>
                â€¢ APIs for other developers<br>
                â€¢ Command-line tools<br>
                â€¢ Server-to-server communication<br>
                â€¢ Background job processors</p>
            </div>

            <div class="metaphor-box">
                <h4>The Marriage Metaphor</h4>
                <p>Frontend and backend are like a married couple:<br><br>
                <strong>Frontend (the face of the relationship):</strong><br>
                â€¢ Presents things beautifully<br>
                â€¢ Communicates with the outside world<br>
                â€¢ Creates first impressions<br>
                â€¢ Handles social interactions<br><br>
                <strong>Backend (the foundation of the relationship):</strong><br>
                â€¢ Handles the serious work behind the scenes<br>
                â€¢ Manages resources and planning<br>
                â€¢ Makes important decisions<br>
                â€¢ Keeps everything organized and secure<br><br>
                They're DIFFERENT, but they NEED each other. The best relationships (and websites!) have both working in harmony!</p>
            </div>

            <h4>Putting It All Together: The Big Picture</h4>
            <p>Let's summarize everything with a complete example - a simple todo app:</p>

            <div class="code">ğŸ“ TODO APP - Complete Frontend/Backend Interaction:

SCENARIO: User adds a new todo item

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FRONTEND (What user sees)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  [Todo App]                                            â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Add new todo:                    â”‚                 â”‚
â”‚  â”‚ [Buy groceries____________] [Add]â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                        â”‚
â”‚  Your Todos:                                           â”‚
â”‚  â˜ Finish homework                                     â”‚
â”‚  â˜ Call mom                                            â”‚
â”‚  â˜ Buy groceries  â† Just added!                       â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHAT HAPPENED BEHIND THE SCENES:

1. User types "Buy groceries" in input box
   â†’ Frontend: JavaScript tracks every keystroke

2. User clicks "Add" button
   â†’ Frontend: Event listener fires
   â†’ Frontend: Validate input (not empty? not too long?)

3. Frontend makes HTTP request:
   â†’ POST /api/todos
   â†’ Body: { text: "Buy groceries", completed: false }
   â†’ Headers: { Authorization: "Bearer user_token_123" }

4. Request travels over internet to server
   â†’ Through WiFi â†’ ISP â†’ Internet â†’ Server ISP â†’ Server

5. Backend receives request:
   â†’ "POST request to /api/todos"
   â†’ Extract data from request body
   â†’ Verify authentication token (is this a real user?)

6. Backend validates data:
   â†’ Is text provided? âœ“
   â†’ Is text reasonable length? âœ“
   â†’ Is user authorized? âœ“

7. Backend interacts with database:
   â†’ SQL: INSERT INTO todos (user_id, text, completed) 
           VALUES (123, 'Buy groceries', false)
   â†’ Database saves it permanently
   â†’ Database returns: { id: 789, user_id: 123, text: "Buy groceries", completed: false }

8. Backend sends response:
   â†’ Status: 201 Created
   â†’ Body: { id: 789, text: "Buy groceries", completed: false }

9. Response travels back to frontend:
   â†’ Server â†’ Internet â†’ User's computer

10. Frontend receives response:
    â†’ Parse JSON data
    â†’ Create new todo element in DOM
    â†’ Append to todo list
    â†’ Clear input box
    â†’ Show success message
    â†’ User sees new todo appear!

TOTAL TIME: Usually 50-200 milliseconds!

WHAT EACH SIDE DID:

FRONTEND:
âœ“ Displayed the UI
âœ“ Captured user input
âœ“ Validated input
âœ“ Made HTTP request
âœ“ Updated UI with response
âœ“ Provided instant feedback

BACKEND:
âœ“ Received request
âœ“ Authenticated user
âœ“ Validated data (again! double-check)
âœ“ Saved to database
âœ“ Sent response

BOTH WORKED TOGETHER TO CREATE A SEAMLESS EXPERIENCE!</div>

            <h4>The Key Takeaway</h4>
            <p>Here's what you absolutely MUST remember:</p>

            <div class="info-box">
                <h4>ğŸ¯ Core Concepts to Master</h4>
                <p><strong>1. Frontend = User Interface</strong><br>
                Runs in browser. Shows things. Handles interactions. Temporary.<br><br>
                <strong>2. Backend = Business Logic + Data</strong><br>
                Runs on servers. Processes data. Stores information. Permanent.<br><br>
                <strong>3. They Communicate via HTTP</strong><br>
                Frontend makes requests. Backend sends responses. It's a conversation.<br><br>
                <strong>4. Client-Server Model</strong><br>
                Client (your browser) asks. Server (backend) answers. Every single time.<br><br>
                <strong>5. Security Lives in Backend</strong><br>
                Never trust frontend. Always verify on backend. Frontend is public, backend is private.<br><br>
                <strong>6. Full-Stack = Both Skills</strong><br>
                Understand frontend AND backend. See the complete picture. Build entire applications.<br><br>
                <strong>7. They Need Each Other</strong><br>
                Frontend without backend = pretty but useless.<br>
                Backend without frontend = powerful but invisible.<br>
                Together = magic! âœ¨</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Mental Model</h4>
                <p>When you visit ANY website, remember this:<br><br>
                1. Your browser (frontend) sends a request<br>
                2. The server (backend) processes it<br>
                3. The response travels back<br>
                4. Your browser displays it<br><br>
                <strong>Every. Single. Interaction.</strong><br><br>
                Click a button? Request â†’ Response.<br>
                Load a page? Request â†’ Response.<br>
                Submit a form? Request â†’ Response.<br>
                Like a post? Request â†’ Response.<br><br>
                It's ALWAYS frontend (you) talking to backend (server).<br><br>
                Now that you understand this, frameworks will make SO much more sense - because frameworks help you build better frontends that communicate with backends more easily!</p>
            </div>

            <h3>Part 5: Enter Frameworks - The Solution</h3>

            <h4>What Frameworks Actually Do</h4>
            <p>A framework (or library - we'll explain the difference soon) like React or Vue solves all these problems. Here's what they do:</p>

            <div class="info-box">
                <h4>What Frameworks Give You</h4>
                <p><strong>1. Automatic Updates:</strong> Change your data, and the UI updates automatically. No manual DOM manipulation.<br><br>
                <strong>2. Components:</strong> Build reusable pieces. Create a Button component once, use it 1000 times.<br><br>
                <strong>3. State Management:</strong> A smart way to store data that automatically triggers UI updates when it changes.<br><br>
                <strong>4. Declarative Code:</strong> You describe WHAT the UI should look like, not HOW to build it step-by-step.<br><br>
                <strong>5. Ecosystem:</strong> Thousands of pre-built components and tools you can use.<br><br>
                <strong>6. Performance:</strong> Frameworks are SMART about updating only what changed, not redrawing everything.</p>
            </div>

            <h4>The Declarative vs Imperative Mindset</h4>
            <p>This is THE most important mental shift when learning frameworks:</p>

            <div class="metaphor-box">
                <h4>Ordering at a Restaurant (Again!)</h4>
                <p><strong>Imperative (Vanilla JS):</strong><br>
                "Go to the kitchen. Open the fridge. Take out 3 eggs. Get a bowl from the cabinet. Crack each egg into the bowl. Whisk for 30 seconds. Get a pan from the drawer. Put it on the stove. Turn heat to medium. Wait 1 minute. Add butter. Wait for it to melt. Pour in eggs. Stir constantly with a spatula. After 2 minutes, add salt and pepper. Stir 30 more seconds. Transfer to a plate. Bring it to table 5."<br><br>
                You tell the chef EVERY SINGLE STEP. That's imperative programming.<br><br>
                <strong>Declarative (React/Vue):</strong><br>
                "I'd like scrambled eggs, please."<br><br>
                You describe WHAT you want. The chef figures out HOW to make it. That's declarative programming!</p>
            </div>

            <p>In code terms:</p>

            <div class="code">// IMPERATIVE (Vanilla JS):
// Tell the computer HOW to do everything
let count = 0;
const display = document.getElementById('count');

function increment() {
  count = count + 1;              // Step 1: Update data
  display.textContent = count;    // Step 2: Find element and update it
  
  if (count > 10) {               // Step 3: Check condition
    display.style.color = 'red';  // Step 4: Update styling
  } else {
    display.style.color = 'black';
  }
}

// DECLARATIVE (React):
// Describe WHAT you want the UI to look like
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p style={{ color: count &gt; 10 ? 'red' : 'black' }}&gt;
        Count: {count}
      &lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
// React figures out WHEN and HOW to update the DOM!</div>

            <p>See the difference? In React, you just say "when count is over 10, make it red." React handles the rest!</p>

            <h4>Why This Matters So Much</h4>
            <p>Let's compare building a shopping cart in vanilla JS vs React:</p>

            <div class="code">// VANILLA JS - YOU MUST DO EVERYTHING:
let cart = [];
const cartDisplay = document.getElementById('cart');
const totalDisplay = document.getElementById('total');
const countDisplay = document.getElementById('cart-count');

function addToCart(item) {
  // Step 1: Update data
  cart.push(item);
  
  // Step 2: Update cart display
  const li = document.createElement('li');
  li.textContent = item.name;
  cartDisplay.appendChild(li);
  
  // Step 3: Update total
  const total = cart.reduce((sum, i) => sum + i.price, 0);
  totalDisplay.textContent = '$' + total;
  
  // Step 4: Update count badge
  countDisplay.textContent = cart.length;
  
  // Step 5: Update localStorage
  localStorage.setItem('cart', JSON.stringify(cart));
  
  // Did you forget something? That's a bug!
}

// REACT - DESCRIBE WHAT YOU WANT:
function ShoppingCart() {
  const [cart, setCart] = useState([]);
  
  const addToCart = (item) => {
    setCart([...cart, item]);
    // That's IT! React updates EVERYTHING automatically:
    // - The cart list
    // - The total
    // - The count badge
    // No manual DOM manipulation!
  };
  
  const total = cart.reduce((sum, item) => sum + item.price, 0);
  
  return (
    &lt;div&gt;
      &lt;div&gt;Items: {cart.length}&lt;/div&gt;
      &lt;ul&gt;
        {cart.map(item => &lt;li&gt;{item.name}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;div&gt;Total: ${total}&lt;/div&gt;
    &lt;/div&gt;
  );
}
// React sees cart changed and re-renders EVERYTHING that uses it!</div>

            <div class="warning-box">
                <h4>âš ï¸ The Mental Shift</h4>
                <p>The hardest part of learning React/Vue isn't the syntax - it's changing how you THINK about code.<br><br>
                <strong>Stop thinking:</strong> "When this button is clicked, find this element and change its text, then find that element and update its style, then..."<br><br>
                <strong>Start thinking:</strong> "Here's what my data looks like. Here's what my UI should look like for that data. When data changes, React figures out what to update."<br><br>
                Once this clicks, everything becomes easier!</p>
            </div>

            <h4>Component-Based Architecture</h4>
            <p>Frameworks let you build your UI from small, reusable pieces called <strong>components</strong>. This is HUGE for organization:</p>

            <div class="metaphor-box">
                <h4>LEGO Blocks Metaphor</h4>
                <p>Think of components like LEGO blocks:<br><br>
                <strong>Without components (vanilla JS):</strong> You're carving one giant sculpture from a single block of marble. Want to change the left arm? You have to carefully chisel, hoping you don't break the leg.<br><br>
                <strong>With components (React/Vue):</strong> You're building with LEGO. Create an Arm component. Use it for both arms! Need to change it? Rebuild just that block. Everything else stays intact. Want to build a whole LEGO person? Combine Head + Torso + 2 Arms + 2 Legs. Each piece is independent!</p>
            </div>

            <p>Here's how you might break down a website into components:</p>

            <div class="code">// A typical website structure:

App
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ Logo
â”‚   â”œâ”€â”€ Navigation
â”‚   â”‚   â”œâ”€â”€ NavLink
â”‚   â”‚   â”œâ”€â”€ NavLink
â”‚   â”‚   â””â”€â”€ NavLink
â”‚   â””â”€â”€ UserMenu
â”‚       â”œâ”€â”€ Avatar
â”‚       â””â”€â”€ Dropdown
â”œâ”€â”€ Main
â”‚   â”œâ”€â”€ Sidebar
â”‚   â”‚   â”œâ”€â”€ SearchBox
â”‚   â”‚   â””â”€â”€ FilterList
â”‚   â”‚       â”œâ”€â”€ FilterOption
â”‚   â”‚       â””â”€â”€ FilterOption
â”‚   â””â”€â”€ Content
â”‚       â”œâ”€â”€ ProductCard
â”‚       â”œâ”€â”€ ProductCard
â”‚       â””â”€â”€ ProductCard
â”‚           â”œâ”€â”€ Image
â”‚           â”œâ”€â”€ Title
â”‚           â”œâ”€â”€ Price
â”‚           â””â”€â”€ AddToCartButton
â””â”€â”€ Footer
    â”œâ”€â”€ SocialLinks
    â””â”€â”€ Copyright

// Each of these is a COMPONENT - a reusable piece!
// Build ProductCard once, use it 1000 times for 1000 products!</div>

            <h4>Why Components Are a Game-Changer</h4>

            <div class="info-box">
                <h4>The Power of Components</h4>
                <p><strong>Reusability:</strong> Build a Button component with all your styling and logic. Use it everywhere. Change it once, it updates everywhere.<br><br>
                <strong>Maintainability:</strong> Bug in the header? You know exactly where to look - the Header component. Not searching through 5000 lines of HTML.<br><br>
                <strong>Testability:</strong> Test each component individually. Button works? Great! Header works? Perfect! Combine them with confidence.<br><br>
                <strong>Team Work:</strong> Person A builds the header, Person B builds the footer. They work in separate files and merge easily.<br><br>
                <strong>Mental Model:</strong> Think about one small piece at a time, not the entire application at once.</p>
            </div>

            <h3>Part 6: React and Vue - What's the Difference?</h3>

            <h4>Library vs Framework (Again)</h4>
            <p>You'll hear React called a "library" and Vue called a "framework" (though Vue calls itself "progressive framework"). What's the difference?</p>

            <div class="metaphor-box">
                <h4>The Toolbox vs Construction Kit Metaphor</h4>
                <p><strong>React (Library):</strong> Like a toolbox. Here are some great tools (components, hooks, JSX). YOU decide how to structure your app. Want routing? Pick a library (React Router). Want global state? Pick one (Redux, MobX, Zustand). You're the architect.<br><br>
                <strong>Vue (Framework):</strong> Like a construction kit with instructions. Vue gives you tools AND tells you the "Vue way" of doing things. It includes routing (Vue Router), state management (Pinia/Vuex), and opinions on how to structure code. Still flexible, but more guided.<br><br>
                <strong>Angular (Full Framework):</strong> Like building with a pre-designed kit. Everything is included and there's ONE way to do things. Very opinionated.</p>
            </div>

            <p>In practice, for beginners, this distinction doesn't matter much! Both React and Vue solve the same problems:</p>

            <div class="code">// What React and Vue BOTH do:
âœ… Component-based architecture
âœ… Reactive state management (data changes = UI updates)
âœ… Virtual DOM for performance
âœ… Rich ecosystem of tools and libraries
âœ… Large communities with tons of tutorials
âœ… Can build anything from simple pages to huge apps

// Differences:
React:
- Uses JSX (HTML-in-JavaScript)
- More JavaScript-heavy
- More flexible (pick your own tools)
- Bigger job market

Vue:
- Uses templates (HTML-like)
- Easier for beginners
- More batteries-included
- Growing rapidly in popularity</div>

            <h4>Which One Should You Learn?</h4>
            <p>Honest answer: EITHER! They're both excellent. Learning one makes learning the other easy because the CONCEPTS are the same.</p>

            <div class="info-box">
                <h4>Pick Based On</h4>
                <p><strong>Choose React if:</strong><br>
                â€¢ You want maximum job opportunities (React is more common in job listings)<br>
                â€¢ You like JavaScript-heavy syntax<br>
                â€¢ You want to learn the most popular library<br>
                â€¢ You're okay piecing together your own toolset<br><br>
                <strong>Choose Vue if:</strong><br>
                â€¢ You're a complete beginner (Vue is often considered easier to start with)<br>
                â€¢ You prefer HTML-like templates<br>
                â€¢ You want more built-in features<br>
                â€¢ You like clear, official documentation<br><br>
                <strong>Best advice:</strong> Flip a coin! You can't go wrong. Learn one well, then learn the other later - it'll take you a weekend because you already understand the concepts.</p>
            </div>

            <h3>Part 7: State - The Most Important Concept</h3>

            <h4>What Even IS "State"?</h4>
            <p>You'll hear "state" mentioned constantly in framework tutorials. Let's break it down to the simplest possible explanation:</p>

            <div class="info-box">
                <h4>State in Plain English</h4>
                <p><strong>State</strong> = Data that can change over time.<br><br>
                That's it! Seriously!<br><br>
                Examples of state:<br>
                â€¢ A counter value (starts at 0, changes when you click)<br>
                â€¢ Whether a user is logged in (true or false)<br>
                â€¢ Items in a shopping cart (an array that grows/shrinks)<br>
                â€¢ The current page you're on<br>
                â€¢ Form input values<br>
                â€¢ Whether a modal is open or closed<br><br>
                State is just variables that, when they change, should update what the user sees.</p>
            </div>

            <div class="metaphor-box">
                <h4>The Light Switch Metaphor</h4>
                <p>Think of state like a light switch:<br><br>
                <strong>State value:</strong> ON or OFF (true or false)<br>
                <strong>UI:</strong> The light bulb (bright or dark)<br>
                <strong>State change:</strong> Flipping the switch<br><br>
                When you flip the switch (change state), the light automatically updates. You don't manually turn the bulb on - it's CONNECTED to the switch. That's how state works! Change state, UI automatically updates.</p>
            </div>

            <h4>State vs Regular Variables</h4>
            <p>Why not just use regular variables? Great question!</p>

            <div class="code">// Regular variable (doesn't work in React/Vue):
function Counter() {
  let count = 0;  // Regular variable
  
  function increment() {
    count = count + 1;
    console.log(count);  // This works! Logs 1, 2, 3...
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Problem: The UI shows "Count: 0" FOREVER
// Even though count IS changing, React doesn't know to re-render!</div>

            <p>React doesn't automatically watch all your variables. It would be too slow! Instead, you explicitly tell React "this variable is special - when it changes, update the UI":</p>

            <div class="code">// State variable (works!):
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);  // Special state variable
  
  function increment() {
    setCount(count + 1);
    // React sees count changed and automatically re-renders the component!
  }
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Now it works! UI updates when count changes!</div>

            <h4>Breaking Down useState</h4>
            <p>Let's understand that weird syntax:</p>

            <div class="code">const [count, setCount] = useState(0);
//     ^       ^          ^         ^
//     |       |          |         |
//     |       |          |         Initial value (count starts at 0)
//     |       |          A React function that creates state
//     |       Function to UPDATE the state
//     The STATE VALUE itself</div>

            <div class="info-box">
                <h4>Understanding Array Destructuring</h4>
                <p><span class="inline-code">useState(0)</span> returns an array with TWO things: <span class="inline-code">[value, setterFunction]</span><br><br>
                We use <strong>array destructuring</strong> to unpack them:<br><br>
                <span class="inline-code">const [count, setCount] = useState(0);</span><br><br>
                Is the same as:<br><br>
                <span class="inline-code">const stateArray = useState(0);</span><br>
                <span class="inline-code">const count = stateArray[0];  // The value</span><br>
                <span class="inline-code">const setCount = stateArray[1];  // The setter</span><br><br>
                Destructuring is just shorter! You can name them whatever you want:<br>
                <span class="inline-code">const [user, setUser] = useState(null);</span><br>
                <span class="inline-code">const [isOpen, setIsOpen] = useState(false);</span><br>
                <span class="inline-code">const [items, setItems] = useState([]);</span></p>
            </div>

            <h4>Multiple State Variables</h4>
            <p>You can have as many state variables as you want:</p>

            <div class="code">function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  
  // Each one updates independently!
  
  return (
    &lt;form&gt;
      &lt;input 
        value={email} 
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input 
        type="password"
        value={password} 
        onChange={(e) =&gt; setPassword(e.target.value)}
      /&gt;
      &lt;input 
        type="checkbox"
        checked={rememberMe}
        onChange={(e) =&gt; setRememberMe(e.target.checked)}
      /&gt;
      {error && &lt;p&gt;{error}&lt;/p&gt;}
      {loading && &lt;p&gt;Loading...&lt;/p&gt;}
      &lt;button type="submit"&gt;Log In&lt;/button&gt;
    &lt;/form&gt;
  );
}</div>

            <h3>Part 8: Recap - Where We Are Now</h3>

            <h4>What You Now Understand</h4>
            <p>Let's recap this journey from absolute zero:</p>

            <div class="info-box">
                <h4>Your Mental Model So Far</h4>
                <p><strong>1. Websites are made of three things:</strong><br>
                â€¢ HTML (structure) - what's on the page<br>
                â€¢ CSS (styling) - how it looks<br>
                â€¢ JavaScript (behavior) - what it does<br><br>
                <strong>2. Frontend vs Backend:</strong><br>
                â€¢ Frontend = what users see and interact with (runs in browser)<br>
                â€¢ Backend = hidden server code that processes data (runs on server)<br>
                â€¢ Full-stack = both!<br><br>
                <strong>3. The problem with vanilla JavaScript:</strong><br>
                â€¢ You manually manipulate the DOM (slow and tedious)<br>
                â€¢ You must remember to update the UI when data changes<br>
                â€¢ Code becomes messy as apps grow<br><br>
                <strong>4. Frameworks solve this:</strong><br>
                â€¢ Declarative (describe what, not how)<br>
                â€¢ Components (reusable pieces)<br>
                â€¢ Automatic UI updates when state changes<br>
                â€¢ Much cleaner, more maintainable code<br><br>
                <strong>5. State is the key concept:</strong><br>
                â€¢ State = data that changes<br>
                â€¢ When state changes, UI updates automatically<br>
                â€¢ React uses useState() to create state<br>
                â€¢ Vue has ref() and reactive()<br><br>
                <strong>6. React and Vue both:</strong><br>
                â€¢ Use components<br>
                â€¢ Have reactive state<br>
                â€¢ Make building UIs much easier<br>
                â€¢ Are excellent choices for beginners</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Restaurant Metaphor</h4>
                <p>Let's bring it all together with our restaurant analogy:<br><br>
                <strong>HTML:</strong> The blueprint of the restaurant (where things are)<br>
                <strong>CSS:</strong> The interior design (how it looks)<br>
                <strong>JavaScript:</strong> The staff and operations (what happens)<br>
                <strong>Frontend:</strong> The dining area (what customers experience)<br>
                <strong>Backend:</strong> The kitchen (where the real work happens)<br>
                <strong>API:</strong> The waiter (carries requests and responses between dining area and kitchen)<br>
                <strong>State:</strong> The current situation (how many tables are occupied, what's cooking, who's waiting for food)<br>
                <strong>React/Vue:</strong> An automated system that updates menus, bills, and displays automatically when orders change - instead of staff manually rewriting everything!<br><br>
                Full-stack = understanding and being able to work in EVERY part of the restaurant!</p>
            </div>

            <h4>What's Next?</h4>
            <p>Now that you understand the foundations, the rest of this chapter will teach you:</p>

            <ul>
                <li><strong>Section 2:</strong> Building actual React apps from scratch (not just theory anymore!)</li>
                <li><strong>Section 3:</strong> Building actual Vue apps from scratch</li>
                <li><strong>Section 4:</strong> Connecting frontend to backend (full-stack!)</li>
                <li><strong>Section 5:</strong> Deploying your app so the world can see it</li>
            </ul>

            <div class="warning-box">
                <h4>ğŸ¯ Your Learning Strategy</h4>
                <p><strong>Don't rush!</strong> Seriously. These concepts take time to sink in.<br><br>
                <strong>Build as you learn:</strong> Type out every code example. Change things. Break things. Fix them.<br><br>
                <strong>Expect confusion:</strong> It's NORMAL to feel lost at first. Your brain is building new neural pathways. Keep going!<br><br>
                <strong>Focus on concepts, not syntax:</strong> The syntax of React vs Vue is different, but the CONCEPTS (components, state, props) are the same. Master concepts first.<br><br>
                <strong>One thing at a time:</strong> Don't try to learn React + TypeScript + Next.js + Redux all at once. Start simple!<br><br>
                <strong>Build tiny projects:</strong> A counter. A todo list. A weather app. Each one teaches you more than reading 100 tutorials.<br><br>
                Ready? Let's build something real!</p>
            </div>

            <h3>Part 7: Building Your First Dynamic Web Page</h3>

            <h4>The Real Challenge: A Complete Todo List in Vanilla JavaScript</h4>
            <p>Before we dive into frameworks, let's build something REAL with vanilla JavaScript. You need to experience the pain points yourself to truly appreciate why frameworks exist. We're going to build a complete, working todo list app. Not a toy - something functional with add, delete, edit, and mark-as-complete features.</p>

            <div class="info-box">
                <h4>What We're Building</h4>
                <p><strong>Features:</strong><br>
                â€¢ Add new todos<br>
                â€¢ Mark todos as complete (with strikethrough)<br>
                â€¢ Delete todos<br>
                â€¢ Edit existing todos<br>
                â€¢ Filter (show all, active, or completed)<br>
                â€¢ Count remaining tasks<br>
                â€¢ Clear all completed<br><br>
                <strong>What you'll learn:</strong><br>
                â€¢ How to manipulate the DOM manually<br>
                â€¢ Event handling at scale<br>
                â€¢ Managing application state<br>
                â€¢ Where bugs hide in vanilla JS<br>
                â€¢ Why this gets messy FAST</p>
            </div>

            <h4>The Complete Code (HTML + CSS + JavaScript)</h4>
            <p>Here's the ENTIRE app. We'll walk through every line after. Type this out, save it as <span class="inline-code">todo.html</span>, and open it in your browser:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Vanilla JS Todo App&lt;/title&gt;
    &lt;style&gt;
        /* STYLING - Makes it look nice */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            width: 100%;
            max-width: 500px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        #todoInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        
        #todoInput:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #addBtn {
            background: #667eea;
            color: white;
        }
        
        #addBtn:hover {
            background: #5568d3;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .filter-btn {
            padding: 8px 16px;
            background: #f0f0f0;
            font-size: 14px;
        }
        
        .filter-btn.active {
            background: #667eea;
            color: white;
        }
        
        .filter-btn:hover {
            background: #e0e0e0;
        }
        
        .filter-btn.active:hover {
            background: #5568d3;
        }
        
        #todoList {
            list-style: none;
            margin-bottom: 20px;
        }
        
        .todo-item {
            background: #f9f9f9;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .todo-item:hover {
            background: #f0f0f0;
        }
        
        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: #999;
        }
        
        .todo-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .todo-text {
            flex: 1;
            font-size: 16px;
            word-break: break-word;
        }
        
        .todo-item.editing .todo-text {
            display: none;
        }
        
        .edit-input {
            flex: 1;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 16px;
            display: none;
        }
        
        .todo-item.editing .edit-input {
            display: block;
        }
        
        .todo-actions {
            display: flex;
            gap: 5px;
        }
        
        .edit-btn, .delete-btn, .save-btn, .cancel-btn {
            padding: 6px 12px;
            font-size: 14px;
        }
        
        .edit-btn {
            background: #4CAF50;
            color: white;
        }
        
        .delete-btn, .cancel-btn {
            background: #f44336;
            color: white;
        }
        
        .save-btn {
            background: #2196F3;
            color: white;
        }
        
        .edit-btn:hover {
            background: #45a049;
        }
        
        .delete-btn:hover, .cancel-btn:hover {
            background: #da190b;
        }
        
        .save-btn:hover {
            background: #0b7dda;
        }
        
        .todo-item.editing .edit-btn,
        .todo-item.editing .delete-btn {
            display: none;
        }
        
        .save-btn, .cancel-btn {
            display: none;
        }
        
        .todo-item.editing .save-btn,
        .todo-item.editing .cancel-btn {
            display: inline-block;
        }
        
        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .item-count {
            color: #666;
            font-size: 14px;
        }
        
        #clearCompleted {
            background: #ff6b6b;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        #clearCompleted:hover {
            background: #ee5a52;
        }
        
        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;ğŸ“ My Todo List&lt;/h1&gt;
        
        &lt;!-- Input area --&gt;
        &lt;div class="input-container"&gt;
            &lt;input type="text" id="todoInput" placeholder="What needs to be done?"&gt;
            &lt;button id="addBtn"&gt;Add&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;!-- Filter buttons --&gt;
        &lt;div class="filters"&gt;
            &lt;button class="filter-btn active" data-filter="all"&gt;All&lt;/button&gt;
            &lt;button class="filter-btn" data-filter="active"&gt;Active&lt;/button&gt;
            &lt;button class="filter-btn" data-filter="completed"&gt;Completed&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;!-- Todo list --&gt;
        &lt;ul id="todoList"&gt;&lt;/ul&gt;
        
        &lt;!-- Footer --&gt;
        &lt;div class="footer"&gt;
            &lt;span class="item-count"&gt;&lt;span id="itemCount"&gt;0&lt;/span&gt; items left&lt;/span&gt;
            &lt;button id="clearCompleted"&gt;Clear Completed&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // ========================================
        // STATE - This is our "single source of truth"
        // ========================================
        let todos = [];
        let currentFilter = 'all';
        let nextId = 1;

        // ========================================
        // DOM ELEMENTS - Cache these for performance
        // ========================================
        const todoInput = document.getElementById('todoInput');
        const addBtn = document.getElementById('addBtn');
        const todoList = document.getElementById('todoList');
        const itemCount = document.getElementById('itemCount');
        const clearCompletedBtn = document.getElementById('clearCompleted');
        const filterBtns = document.querySelectorAll('.filter-btn');

        // ========================================
        // FUNCTIONS - Each does ONE thing
        // ========================================

        // Add a new todo
        function addTodo() {
            const text = todoInput.value.trim();
            
            // Validation
            if (text === '') {
                alert('Please enter a todo!');
                return;
            }
            
            // Create todo object
            const todo = {
                id: nextId++,
                text: text,
                completed: false
            };
            
            // Add to state
            todos.push(todo);
            
            // Clear input
            todoInput.value = '';
            
            // Re-render
            render();
        }

        // Toggle todo completion
        function toggleTodo(id) {
            // Find the todo
            const todo = todos.find(t =&gt; t.id === id);
            
            // Toggle its completed status
            if (todo) {
                todo.completed = !todo.completed;
            }
            
            // Re-render
            render();
        }

        // Delete a todo
        function deleteTodo(id) {
            // Filter out the todo with this id
            todos = todos.filter(t =&gt; t.id !== id);
            
            // Re-render
            render();
        }

        // Start editing a todo
        function startEdit(id) {
            // Find the list item
            const listItem = document.querySelector(`[data-id="${id}"]`);
            
            // Add editing class
            listItem.classList.add('editing');
            
            // Focus the input
            const editInput = listItem.querySelector('.edit-input');
            editInput.focus();
            editInput.select();
        }

        // Save edited todo
        function saveEdit(id) {
            // Find the list item and input
            const listItem = document.querySelector(`[data-id="${id}"]`);
            const editInput = listItem.querySelector('.edit-input');
            const newText = editInput.value.trim();
            
            // Validation
            if (newText === '') {
                alert('Todo cannot be empty!');
                return;
            }
            
            // Find and update the todo
            const todo = todos.find(t =&gt; t.id === id);
            if (todo) {
                todo.text = newText;
            }
            
            // Re-render
            render();
        }

        // Cancel editing
        function cancelEdit(id) {
            // Find the list item
            const listItem = document.querySelector(`[data-id="${id}"]`);
            
            // Remove editing class
            listItem.classList.remove('editing');
        }

        // Clear all completed todos
        function clearCompleted() {
            todos = todos.filter(t =&gt; !t.completed);
            render();
        }

        // Change filter
        function setFilter(filter) {
            currentFilter = filter;
            
            // Update active button
            filterBtns.forEach(btn =&gt; {
                btn.classList.remove('active');
                if (btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
            
            // Re-render
            render();
        }

        // Get filtered todos
        function getFilteredTodos() {
            if (currentFilter === 'active') {
                return todos.filter(t =&gt; !t.completed);
            } else if (currentFilter === 'completed') {
                return todos.filter(t =&gt; t.completed);
            }
            return todos; // 'all'
        }

        // ========================================
        // RENDER - The most important function
        // ========================================
        function render() {
            // Get todos to display based on filter
            const filteredTodos = getFilteredTodos();
            
            // Clear the list
            todoList.innerHTML = '';
            
            // If no todos, show empty state
            if (filteredTodos.length === 0) {
                todoList.innerHTML = '&lt;div class="empty-state"&gt;No todos to show&lt;/div&gt;';
            } else {
                // Create a list item for each todo
                filteredTodos.forEach(todo =&gt; {
                    // Create elements
                    const li = document.createElement('li');
                    li.className = 'todo-item';
                    li.dataset.id = todo.id;
                    if (todo.completed) {
                        li.classList.add('completed');
                    }
                    
                    // Checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = todo.completed;
                    checkbox.addEventListener('change', () =&gt; toggleTodo(todo.id));
                    
                    // Text span
                    const textSpan = document.createElement('span');
                    textSpan.className = 'todo-text';
                    textSpan.textContent = todo.text;
                    
                    // Edit input (hidden by default)
                    const editInput = document.createElement('input');
                    editInput.type = 'text';
                    editInput.className = 'edit-input';
                    editInput.value = todo.text;
                    
                    // Actions container
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'todo-actions';
                    
                    // Edit button
                    const editBtn = document.createElement('button');
                    editBtn.className = 'edit-btn';
                    editBtn.textContent = 'Edit';
                    editBtn.addEventListener('click', () =&gt; startEdit(todo.id));
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.addEventListener('click', () =&gt; deleteTodo(todo.id));
                    
                    // Save button (shown during edit)
                    const saveBtn = document.createElement('button');
                    saveBtn.className = 'save-btn';
                    saveBtn.textContent = 'Save';
                    saveBtn.addEventListener('click', () =&gt; saveEdit(todo.id));
                    
                    // Cancel button (shown during edit)
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'cancel-btn';
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.addEventListener('click', () =&gt; cancelEdit(todo.id));
                    
                    // Assemble everything
                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);
                    actionsDiv.appendChild(saveBtn);
                    actionsDiv.appendChild(cancelBtn);
                    
                    li.appendChild(checkbox);
                    li.appendChild(textSpan);
                    li.appendChild(editInput);
                    li.appendChild(actionsDiv);
                    
                    todoList.appendChild(li);
                });
            }
            
            // Update count
            const activeCount = todos.filter(t =&gt; !t.completed).length;
            itemCount.textContent = activeCount;
        }

        // ========================================
        // EVENT LISTENERS - Wire up the UI
        // ========================================

        // Add button
        addBtn.addEventListener('click', addTodo);

        // Enter key in input
        todoInput.addEventListener('keypress', (e) =&gt; {
            if (e.key === 'Enter') {
                addTodo();
            }
        });

        // Filter buttons
        filterBtns.forEach(btn =&gt; {
            btn.addEventListener('click', () =&gt; {
                setFilter(btn.dataset.filter);
            });
        });

        // Clear completed button
        clearCompletedBtn.addEventListener('click', clearCompleted);

        // Initial render
        render();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="warning-box">
                <h4>ğŸ˜… That's A LOT of Code!</h4>
                <p>Yes! This is about 400 lines of code for a simple todo app. And we haven't even added features like:<br><br>
                â€¢ Saving to localStorage (so todos persist on refresh)<br>
                â€¢ Drag and drop reordering<br>
                â€¢ Due dates<br>
                â€¢ Categories/tags<br>
                â€¢ Search/filter by keyword<br><br>
                Each feature would add MANY more lines. This is the pain we're trying to solve!</p>
            </div>

            <h4>Walking Through the Code</h4>
            <p>Let's break down what's happening section by section:</p>

            <div class="info-box">
                <h4>1. The State (Lines 246-248)</h4>
                <p><span class="inline-code">let todos = [];</span> - This array holds ALL our todos. It's our "single source of truth."<br>
                <span class="inline-code">let currentFilter = 'all';</span> - Tracks which filter is active.<br>
                <span class="inline-code">let nextId = 1;</span> - Counter to give each todo a unique ID.<br><br>
                <strong>Key concept:</strong> All our data lives in these variables. When they change, we need to update the UI to match.</p>
            </div>

            <div class="info-box">
                <h4>2. Caching DOM Elements (Lines 253-258)</h4>
                <p>We grab references to all the HTML elements we'll need:<br>
                <span class="inline-code">const todoInput = document.getElementById('todoInput');</span><br><br>
                <strong>Why cache?</strong> Finding elements in the DOM is slow. By saving references, we avoid searching every time.</p>
            </div>

            <div class="info-box">
                <h4>3. The addTodo Function (Lines 265-284)</h4>
                <p>This function:<br>
                1. Gets the input value: <span class="inline-code">todoInput.value.trim()</span><br>
                2. Validates it's not empty<br>
                3. Creates a todo object: <span class="inline-code">{ id, text, completed }</span><br>
                4. Adds it to the <span class="inline-code">todos</span> array<br>
                5. Clears the input<br>
                6. Calls <span class="inline-code">render()</span> to update the UI<br><br>
                <strong>Notice:</strong> We update the data first, THEN call render to update the UI. This pattern repeats everywhere.</p>
            </div>

            <div class="info-box">
                <h4>4. The render Function (Lines 350-440) - THE MOST IMPORTANT!</h4>
                <p>This is where the magic (and pain) happens. Every time data changes, we call <span class="inline-code">render()</span> which:<br><br>
                1. <strong>Clears everything:</strong> <span class="inline-code">todoList.innerHTML = '';</span><br>
                2. <strong>Gets filtered todos:</strong> Based on current filter (all/active/completed)<br>
                3. <strong>Creates elements for each todo:</strong><br>
                   â€¢ <span class="inline-code">document.createElement('li')</span><br>
                   â€¢ <span class="inline-code">document.createElement('input')</span> for checkbox<br>
                   â€¢ <span class="inline-code">document.createElement('span')</span> for text<br>
                   â€¢ <span class="inline-code">document.createElement('button')</span> for edit/delete<br>
                4. <strong>Adds event listeners to each element</strong><br>
                5. <strong>Appends everything to the DOM</strong><br>
                6. <strong>Updates the count</strong><br><br>
                <strong>The problem:</strong> We're recreating and re-attaching EVERYTHING every single time, even if only one todo changed!</p>
            </div>

            <h4>The Pain Points (Where Bugs Live)</h4>
            <p>Now that you see the code, let's identify the problems:</p>

            <div class="warning-box">
                <h4>Problem #1: Manual DOM Manipulation Everywhere</h4>
                <p>Look at the <span class="inline-code">render()</span> function. We're manually:<br>
                â€¢ Creating every element<br>
                â€¢ Setting every property<br>
                â€¢ Adding every event listener<br>
                â€¢ Appending every child<br><br>
                <strong>What could go wrong?</strong><br>
                â€¢ Forget to add a class? The styling breaks.<br>
                â€¢ Forget to add an event listener? The button doesn't work.<br>
                â€¢ Typo in a class name? CSS doesn't apply.<br>
                â€¢ Wrong parent? Element appears in the wrong place.<br><br>
                There are DOZENS of places where one tiny mistake breaks everything.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #2: State Synchronization</h4>
                <p>We have to manually keep the UI in sync with our state. Look at this pattern:<br><br>
                1. User clicks a button<br>
                2. Event handler updates <span class="inline-code">todos</span> array<br>
                3. Event handler calls <span class="inline-code">render()</span><br>
                4. <span class="inline-code">render()</span> rebuilds the entire UI from <span class="inline-code">todos</span><br><br>
                <strong>What could go wrong?</strong><br>
                â€¢ Forget to call <span class="inline-code">render()</span>? UI doesn't update.<br>
                â€¢ Call <span class="inline-code">render()</span> too early? UI shows stale data.<br>
                â€¢ Update the UI directly without updating state? Now state and UI are out of sync!<br><br>
                This is called the "state synchronization problem" and it's a NIGHTMARE at scale.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #3: Performance</h4>
                <p>Our <span class="inline-code">render()</span> function is BRUTAL:<br><br>
                â€¢ <span class="inline-code">todoList.innerHTML = '';</span> - Destroys ALL elements<br>
                â€¢ Then we recreate ALL elements<br>
                â€¢ Then we add event listeners to ALL elements<br>
                â€¢ Then we append ALL elements<br><br>
                <strong>Even if we only changed ONE todo, we rebuild EVERYTHING!</strong><br><br>
                With 5 todos, this is fine. With 500 todos, your app will lag. With 5000 todos, it'll freeze.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #4: Event Listener Memory Leaks</h4>
                <p>Every time we call <span class="inline-code">render()</span>, we:<br>
                1. Delete all the old elements (with their event listeners)<br>
                2. Create new elements<br>
                3. Add new event listeners<br><br>
                The browser is smart enough to clean up most of this, but in complex apps, you can leak memory if you're not careful. Leaked event listeners pile up and slow down your app.</p>
            </div>

            <div class="warning-box">
                <h4>Problem #5: Code Organization</h4>
                <p>Look at how spread out everything is:<br>
                â€¢ State is at the top<br>
                â€¢ DOM elements are cached in the middle<br>
                â€¢ Functions are scattered<br>
                â€¢ Event listeners are at the bottom<br>
                â€¢ The render logic is 90 lines long<br><br>
                To understand what happens when you click "Edit," you have to trace through:<br>
                1. Event listener (line 448)<br>
                2. <span class="inline-code">startEdit()</span> function (line 309)<br>
                3. DOM manipulation (line 313-317)<br>
                4. Then clicking "Save" goes through a different path...<br><br>
                It's manageable for a todo app. But imagine an app with 50 features!</p>
            </div>

            <div class="metaphor-box">
                <h4>The LEGO Analogy</h4>
                <p>Building with vanilla JavaScript is like:<br><br>
                <strong>Making each LEGO brick from scratch:</strong><br>
                â€¢ Get plastic<br>
                â€¢ Melt it<br>
                â€¢ Pour into mold<br>
                â€¢ Wait for it to cool<br>
                â€¢ Remove from mold<br>
                â€¢ Paint it<br>
                â€¢ Repeat for EVERY SINGLE BRICK<br><br>
                Then, every time you want to change your LEGO creation, you melt down ALL the bricks and recreate them from scratch!<br><br>
                Frameworks give you pre-made bricks that snap together easily. And when you want to change something, you just swap out the bricks you need - you don't rebuild everything!</p>
            </div>

            <h4>Try This Exercise</h4>
            <p>To really feel the pain, try adding these features to the vanilla JS todo app:</p>

            <div class="code">// Feature 1: Add due dates
// You'll need to:
// - Add a date input to the HTML
// - Update the todo object to include a date
// - Modify render() to display the date
// - Add sorting by date
// - Add visual indicator for overdue todos
// Pain level: ğŸ¤¯ High - You'll touch MANY functions

// Feature 2: Add categories/tags
// You'll need to:
// - Add category selection dropdown
// - Update todo object
// - Modify render() to show categories
// - Add filter by category
// - Update the filter buttons UI
// Pain level: ğŸ¤¯ğŸ¤¯ Very High - State management becomes complex

// Feature 3: Save to localStorage
// You'll need to:
// - Save todos array to localStorage on every change
// - Load todos from localStorage on page load
// - Handle JSON serialization
// - Add error handling for corrupted data
// Pain level: ğŸ¤¯ğŸ¤¯ğŸ¤¯ Extreme - Easy to create bugs</div>

            <p>Each feature multiplies the complexity. The codebase becomes harder to maintain, bugs become harder to find, and new developers struggle to understand how it all fits together.</p>

            <div class="info-box">
                <h4>ğŸ¯ Key Takeaway</h4>
                <p>This vanilla JavaScript approach works, and understanding it is CRUCIAL. But now you've felt the pain:<br><br>
                â€¢ Too much manual DOM manipulation<br>
                â€¢ State synchronization is error-prone<br>
                â€¢ Performance suffers<br>
                â€¢ Code organization is messy<br>
                â€¢ Scaling is hard<br><br>
                This is exactly why frameworks were invented. They solve these problems so you can focus on building features instead of wrestling with the DOM.</p>
            </div>

            <h3>Part 8: Why Frameworks Save Your Life</h3>

            <h4>Let's Recap the Problems</h4>
            <p>From our vanilla JavaScript todo app, we identified five major pain points:</p>

            <div class="code">// Problem 1: Manual DOM Manipulation
const li = document.createElement('li');
li.className = 'todo-item';
const span = document.createElement('span');
span.textContent = todo.text;
li.appendChild(span);
// ... 20 more lines for one todo item

// Problem 2: State Synchronization
todos.push(newTodo);  // Update state
render();             // Don't forget this or UI breaks!

// Problem 3: Performance
todoList.innerHTML = '';  // Delete EVERYTHING
todos.forEach(createTodoElement);  // Rebuild EVERYTHING

// Problem 4: Event Listeners
// Added every render, need to be cleaned up

// Problem 5: Code Organization
// State, functions, event listeners all scattered</div>

            <p>Now imagine you're building not a simple todo app, but Facebook, or Twitter, or Amazon. The complexity would be UNMANAGEABLE. You'd spend 90% of your time managing DOM updates and hunting bugs, and only 10% actually building features.</p>

            <div class="metaphor-box">
                <h4>Frameworks as Helpers</h4>
                <p>Think of a framework as hiring a really smart assistant:<br><br>
                <strong>Without a framework (vanilla JS):</strong><br>
                You: "Hey, I need to show this list of todos on the page."<br>
                You: *Spends 2 hours writing createElement, appendChild, event listeners, etc.*<br><br>
                <strong>With a framework:</strong><br>
                You: "Hey, here's a list of todos. Please display them."<br>
                Framework: "Done! And if the list changes, I'll automatically update the page for you."<br>
                You: "Thanks! Now I can focus on building features."<br><br>
                The framework handles all the tedious, error-prone DOM manipulation. You just describe what you want, and it makes it happen.</p>
            </div>

            <h4>What Frameworks Actually Do</h4>
            <p>Let's break down the specific problems frameworks solve:</p>

            <div class="info-box">
                <h4>1. Automatic State Management</h4>
                <p><strong>The problem:</strong> You have to manually call <span class="inline-code">render()</span> every time data changes.<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks track your data (called "state"). When state changes, they automatically update the UI. You don't call render yourself - it just happens!<br><br>
                <strong>In React:</strong><br>
                <span class="inline-code">const [count, setCount] = useState(0);</span><br>
                When you call <span class="inline-code">setCount(1)</span>, React automatically re-renders the component.<br><br>
                <strong>In Vue:</strong><br>
                <span class="inline-code">const count = ref(0);</span><br>
                When you change <span class="inline-code">count.value = 1</span>, Vue automatically updates the DOM.<br><br>
                No more forgetting to call render. No more state/UI sync bugs!</p>
            </div>

            <div class="info-box">
                <h4>2. Declarative Programming</h4>
                <p><strong>The problem:</strong> You have to tell the browser HOW to create every element (imperative).<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks let you declare WHAT you want, not HOW to create it (declarative).<br><br>
                <strong>Imperative (vanilla JS):</strong><br>
                "Create a div. Set its class to 'todo'. Create a span. Set its text to the todo text. Append the span to the div. Append the div to the list."<br><br>
                <strong>Declarative (framework):</strong><br>
                "Here's what a todo should look like. Show all of them."<br><br>
                The framework figures out the HOW. You just describe the WHAT.</p>
            </div>

            <div class="info-box">
                <h4>3. Component-Based Architecture</h4>
                <p><strong>The problem:</strong> Code is scattered everywhere and hard to organize.<br><br>
                <strong>How frameworks fix it:</strong><br>
                Everything is organized into <strong>components</strong> - self-contained pieces that include:<br>
                â€¢ The UI (HTML)<br>
                â€¢ The logic (JavaScript)<br>
                â€¢ The styling (CSS, optionally)<br><br>
                Instead of one giant 400-line file, you have:<br>
                â€¢ <span class="inline-code">TodoApp.js</span> - The main app<br>
                â€¢ <span class="inline-code">TodoInput.js</span> - Just the input area<br>
                â€¢ <span class="inline-code">TodoItem.js</span> - Just one todo item<br>
                â€¢ <span class="inline-code">TodoFilters.js</span> - Just the filter buttons<br><br>
                Each component is 20-50 lines, easy to understand, easy to test, easy to reuse!</p>
            </div>

            <div class="info-box">
                <h4>4. Efficient Updates (Virtual DOM)</h4>
                <p><strong>The problem:</strong> We delete and recreate everything on every change (slow!).<br><br>
                <strong>How frameworks fix it:</strong><br>
                Frameworks use a "virtual DOM" - a lightweight copy of the real DOM in memory.<br><br>
                <strong>The process:</strong><br>
                1. You change state<br>
                2. Framework creates a new virtual DOM with the changes<br>
                3. Framework compares (diffs) new virtual DOM vs old virtual DOM<br>
                4. Framework calculates the MINIMUM changes needed<br>
                5. Framework applies ONLY those changes to the real DOM<br><br>
                <strong>Result:</strong> If you change one todo, only that one element updates. Not the entire list!</p>
            </div>

            <div class="metaphor-box">
                <h4>The Virtual DOM Explained</h4>
                <p>Imagine you're editing a document:<br><br>
                <strong>Without Virtual DOM (vanilla JS):</strong><br>
                Every time you change one word, you delete the entire document and retype everything from scratch. Slow and wasteful!<br><br>
                <strong>With Virtual DOM:</strong><br>
                You type changes in a draft (virtual DOM). When you're done, a smart assistant compares your draft to the original, highlights exactly what changed (just one word), and updates only that word in the real document. Fast and efficient!<br><br>
                That's what React and Vue do. They work on a virtual copy, figure out the minimal changes, then update the real DOM efficiently.</p>
            </div>

            <h4>The Same Todo App, But With Framework Pseudocode</h4>
            <p>Let's see how our 400-line todo app would look with framework thinking. This isn't real React or Vue yet - just the concept:</p>

            <div class="code">// Pseudocode for framework approach
// (Not real code - just showing the concept!)

// STATE - Just declare your data
state = {
  todos: [],
  filter: 'all'
}

// COMPONENT - Describe what the UI should look like
function TodoApp() {
  // UI is a FUNCTION of state
  return (
    &lt;div&gt;
      &lt;h1&gt;My Todo List&lt;/h1&gt;
      
      &lt;TodoInput /&gt;
      &lt;TodoFilters /&gt;
      
      {state.todos
        .filter(matchesCurrentFilter)
        .map(todo =&gt; &lt;TodoItem todo={todo} /&gt;)
      }
      
      &lt;TodoFooter /&gt;
    &lt;/div&gt;
  )
}

// When state changes, framework automatically re-renders
function addTodo(text) {
  state.todos.push({ id: nextId++, text, completed: false })
  // That's it! Framework handles the rest
}

function toggleTodo(id) {
  const todo = state.todos.find(t =&gt; t.id === id)
  todo.completed = !todo.completed
  // Framework automatically updates just this one todo in the UI!
}</div>

            <div class="info-box">
                <h4>Compare the Approach</h4>
                <p><strong>Vanilla JS (400 lines):</strong><br>
                â€¢ Manual createElement for everything<br>
                â€¢ Manual event listener attachment<br>
                â€¢ Manual render() function that rebuilds everything<br>
                â€¢ Manual state synchronization<br>
                â€¢ State and UI code completely separated<br><br>
                <strong>Framework (~50 lines):</strong><br>
                â€¢ Declare components with JSX/templates<br>
                â€¢ State and UI logic together in one place<br>
                â€¢ Automatic rendering when state changes<br>
                â€¢ Automatic efficient updates<br>
                â€¢ Much easier to read and maintain!</p>
            </div>

            <h4>Components as LEGO Blocks</h4>
            <p>The component model is one of the most powerful concepts in modern web development. Let's understand it deeply:</p>

            <div class="metaphor-box">
                <h4>The LEGO Metaphor (Again!)</h4>
                <p>Remember when we compared vanilla JS to making each LEGO brick from scratch? Frameworks give you pre-made bricks!<br><br>
                <strong>Components are like LEGO blocks:</strong><br><br>
                â€¢ <strong>Self-contained:</strong> Each block knows its shape, color, and how it connects<br>
                â€¢ <strong>Reusable:</strong> Use the same block type many times<br>
                â€¢ <strong>Composable:</strong> Combine simple blocks to make complex structures<br>
                â€¢ <strong>Interchangeable:</strong> Swap out blocks without affecting others<br><br>
                Just like you can build a house, a car, or a spaceship from the same LEGO blocks, you can build any web app from components!</p>
            </div>

            <div class="code">// Component thinking example

// A Button component (reusable!)
function Button(props) {
  return &lt;button onClick={props.onClick}&gt;{props.text}&lt;/button&gt;
}

// Use it everywhere
&lt;Button text="Save" onClick={save} /&gt;
&lt;Button text="Delete" onClick={del} /&gt;
&lt;Button text="Cancel" onClick={cancel} /&gt;

// Each button looks the same but does different things
// Change the Button component once, all buttons update!

// TodoItem component (reusable!)
function TodoItem(props) {
  return (
    &lt;div className="todo"&gt;
      &lt;Checkbox checked={props.todo.completed} /&gt;
      &lt;Text&gt;{props.todo.text}&lt;/Text&gt;
      &lt;Button text="Edit" onClick={props.onEdit} /&gt;
      &lt;Button text="Delete" onClick={props.onDelete} /&gt;
    &lt;/div&gt;
  )
}

// Use it for every todo
{todos.map(todo =&gt; 
  &lt;TodoItem 
    todo={todo} 
    onEdit={() =&gt; editTodo(todo.id)}
    onDelete={() =&gt; deleteTodo(todo.id)}
  /&gt;
)}</div>

            <div class="info-box">
                <h4>Component Benefits</h4>
                <p><strong>1. Reusability:</strong> Write once, use everywhere<br>
                <strong>2. Maintainability:</strong> Fix a bug in one place, fixed everywhere<br>
                <strong>3. Testability:</strong> Test each component independently<br>
                <strong>4. Collaboration:</strong> Different devs work on different components<br>
                <strong>5. Mental model:</strong> Think in building blocks, not giant monolithic code<br><br>
                Components change how you think about building UIs!</p>
            </div>

            <h4>Declarative vs Imperative - The Fundamental Shift</h4>
            <p>This is THE key concept that makes frameworks so powerful:</p>

            <div class="info-box">
                <h4>Imperative Programming (Vanilla JS)</h4>
                <p>You tell the computer exactly HOW to do every step:<br><br>
                <span class="inline-code">const div = document.createElement('div');</span><br>
                <span class="inline-code">div.className = 'container';</span><br>
                <span class="inline-code">const p = document.createElement('p');</span><br>
                <span class="inline-code">p.textContent = 'Hello!';</span><br>
                <span class="inline-code">div.appendChild(p);</span><br>
                <span class="inline-code">document.body.appendChild(div);</span><br><br>
                It's like giving someone directions: "Walk 3 blocks, turn left, walk 2 more blocks, turn right..."</p>
            </div>

            <div class="info-box">
                <h4>Declarative Programming (Frameworks)</h4>
                <p>You declare WHAT you want, framework figures out HOW:<br><br>
                <span class="inline-code">&lt;div className="container"&gt;</span><br>
                <span class="inline-code">  &lt;p&gt;Hello!&lt;/p&gt;</span><br>
                <span class="inline-code">&lt;/div&gt;</span><br><br>
                It's like giving someone an address: "123 Main Street." They figure out how to get there!<br><br>
                <strong>The magic:</strong> When state changes, you don't tell the framework HOW to update. You just declare what the UI should look like NOW, and the framework figures out the updates!</p>
            </div>

            <div class="code">// Imperative: You control every step
if (user.loggedIn) {
  // Remove login button
  const loginBtn = document.getElementById('login');
  loginBtn.remove();
  
  // Add logout button
  const logoutBtn = document.createElement('button');
  logoutBtn.textContent = 'Logout';
  logoutBtn.addEventListener('click', logout);
  document.body.appendChild(logoutBtn);
  
  // Show user name
  const userName = document.createElement('span');
  userName.textContent = user.name;
  document.body.appendChild(userName);
} else {
  // Remove logout button and user name
  // Add login button
  // ...tons more code
}

// Declarative: Just describe the current state
function Header() {
  return (
    &lt;div&gt;
      {user.loggedIn ? (
        &lt;&gt;
          &lt;span&gt;{user.name}&lt;/span&gt;
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/&gt;
      ) : (
        &lt;button onClick={showLogin}&gt;Login&lt;/button&gt;
      )}
    &lt;/div&gt;
  )
}
// Framework handles all the adding/removing/updating!</div>

            <div class="metaphor-box">
                <h4>The Light Switch Metaphor</h4>
                <p><strong>Imperative (vanilla JS):</strong><br>
                "Go to the light switch. Extend your arm. Move your hand to the switch. Push the switch down. Retract your arm. Walk away."<br><br>
                <strong>Declarative (framework):</strong><br>
                "The light should be on." The framework handles all the steps.<br><br>
                You focus on WHAT (light on/off), not HOW (arm movement, switch mechanics)!</p>
            </div>

            <h4>Recap: Why Frameworks Matter</h4>

            <div class="info-box">
                <h4>Frameworks Give You:</h4>
                <p>âœ… <strong>Automatic state management</strong> - UI updates when data changes<br>
                âœ… <strong>Declarative syntax</strong> - Describe what, not how<br>
                âœ… <strong>Component architecture</strong> - Organized, reusable code<br>
                âœ… <strong>Efficient updates</strong> - Virtual DOM minimizes changes<br>
                âœ… <strong>Less boilerplate</strong> - Write less code<br>
                âœ… <strong>Fewer bugs</strong> - No manual DOM sync<br>
                âœ… <strong>Better performance</strong> - Optimized updates<br>
                âœ… <strong>Easier collaboration</strong> - Clear code structure<br>
                âœ… <strong>Massive ecosystem</strong> - Libraries, tools, community<br><br>
                Result: You spend time building features, not wrestling with DOM manipulation!</p>
            </div>

            <h3>Part 9: What You're About to Learn</h3>

            <h4>The Journey Ahead</h4>
            <p>Congratulations! You've made it through the hardest part - understanding WHY frameworks exist and WHAT problems they solve. You've seen the pain of vanilla JavaScript, and you understand the concepts that make frameworks powerful. Now it's time to learn HOW to actually use them!</p>

            <div class="metaphor-box">
                <h4>You've Built the Foundation!</h4>
                <p>Think of what we've covered so far as building a solid foundation for a house:<br><br>
                âœ… You understand what websites are (HTML, CSS, JavaScript)<br>
                âœ… You understand how client-server communication works<br>
                âœ… You understand frontend vs backend<br>
                âœ… You understand state and reactivity<br>
                âœ… You've built something real in vanilla JS<br>
                âœ… You understand why frameworks exist<br>
                âœ… You understand components and declarative programming<br><br>
                Now we're ready to build the house! And because you understand the foundation, learning React and Vue will be SO much easier.</p>
            </div>

            <h4>Roadmap for the Rest of Chapter 8</h4>
            <p>Here's exactly what you'll learn in the remaining sections:</p>

            <div class="info-box">
                <h4>Section 2: React Fundamentals</h4>
                <p><strong>What you'll build:</strong> Real React applications from scratch<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Setting up a React project (Create React App)<br>
                â€¢ JSX - React's HTML-in-JavaScript syntax<br>
                â€¢ Components - Building blocks of React<br>
                â€¢ Props - Passing data between components<br>
                â€¢ State - Managing data that changes<br>
                â€¢ Events - Handling user interactions<br>
                â€¢ Lists and keys - Rendering dynamic data<br>
                â€¢ Forms - Handling user input<br>
                â€¢ Lifecycle - What happens when components mount/update/unmount<br>
                â€¢ Hooks - useState, useEffect, and more<br><br>
                <strong>Projects:</strong><br>
                â€¢ Counter app (React basics)<br>
                â€¢ Todo list (the one we built, but in React!)<br>
                â€¢ Weather app (fetching real API data)<br>
                â€¢ User profile manager (forms and validation)</p>
            </div>

            <div class="info-box">
                <h4>Section 3: Vue Fundamentals</h4>
                <p><strong>What you'll build:</strong> Real Vue applications from scratch<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Setting up a Vue project (Vite + Vue)<br>
                â€¢ Templates - Vue's HTML-based syntax<br>
                â€¢ Components - Single File Components (.vue files)<br>
                â€¢ Props and emits - Parent-child communication<br>
                â€¢ Reactive data - ref() and reactive()<br>
                â€¢ Computed properties - Derived state<br>
                â€¢ Watchers - Responding to data changes<br>
                â€¢ Directives - v-if, v-for, v-model, etc.<br>
                â€¢ Events - @click and event modifiers<br>
                â€¢ Composition API - Modern Vue approach<br><br>
                <strong>Projects:</strong><br>
                â€¢ Counter app (Vue basics)<br>
                â€¢ Todo list (same app, different framework!)<br>
                â€¢ Shopping cart (reactivity and computed properties)<br>
                â€¢ Blog reader (components and data flow)</p>
            </div>

            <div class="info-box">
                <h4>Section 4: Connecting Frontend to Backend</h4>
                <p><strong>What you'll build:</strong> Full-stack applications!<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ What is an API? (REST, JSON, HTTP methods)<br>
                â€¢ Using fetch() to get data from servers<br>
                â€¢ Sending data to servers (POST, PUT, DELETE)<br>
                â€¢ Handling loading states<br>
                â€¢ Error handling<br>
                â€¢ Authentication (login/logout)<br>
                â€¢ JWT tokens<br>
                â€¢ Protected routes<br>
                â€¢ CORS - What it is and how to fix it<br><br>
                <strong>Projects:</strong><br>
                â€¢ Weather dashboard (fetch data from weather API)<br>
                â€¢ User authentication system (register, login, protected pages)<br>
                â€¢ Blog with comments (CRUD operations)<br>
                â€¢ Real-time chat (WebSockets intro)</p>
            </div>

            <div class="info-box">
                <h4>Section 5: Advanced Patterns & State Management</h4>
                <p><strong>What you'll build:</strong> Complex, production-ready apps<br><br>
                <strong>Topics covered:</strong><br>
                â€¢ Context API (React) / Provide/Inject (Vue)<br>
                â€¢ Redux (React) / Pinia (Vue)<br>
                â€¢ Global state management<br>
                â€¢ Routing (React Router / Vue Router)<br>
                â€¢ Code splitting and lazy loading<br>
                â€¢ Performance optimization<br>
                â€¢ Testing basics<br>
                â€¢ Deployment (Vercel, Netlify)<br><br>
                <strong>Projects:</strong><br>
                â€¢ E-commerce site (cart, checkout, routing)<br>
                â€¢ Social media feed (infinite scroll, optimization)<br>
                â€¢ Dashboard app (complex state, charts)<br>
                â€¢ Your final project (you choose!)</p>
            </div>

            <h4>How to Approach Learning</h4>
            <p>Before we dive in, let's set you up for success with a solid learning strategy:</p>

            <div class="warning-box">
                <h4>ğŸ¯ Learning Strategy for Maximum Success</h4>
                <p><strong>1. Type EVERY code example yourself</strong><br>
                Don't copy-paste. Type it out. Your fingers need to learn the patterns. When you make typos, you learn. When you fix errors, you learn even more!<br><br>
                <strong>2. Experiment and break things</strong><br>
                After typing an example, change things:<br>
                â€¢ Change variable names<br>
                â€¢ Add features<br>
                â€¢ Remove code and see what breaks<br>
                This is how you TRULY learn what each piece does!<br><br>
                <strong>3. Build the same project in BOTH React and Vue</strong><br>
                This chapter teaches both frameworks because seeing the SAME app built two ways solidifies the concepts. You'll realize the frameworks are more similar than different!<br><br>
                <strong>4. Focus on concepts, not memorization</strong><br>
                You don't need to memorize syntax. You need to understand:<br>
                â€¢ What is a component?<br>
                â€¢ How does state work?<br>
                â€¢ How do props flow?<br>
                â€¢ How do events work?<br>
                The syntax is easy to look up!<br><br>
                <strong>5. Use the browser console</strong><br>
                Add console.log() EVERYWHERE at first. See what's in your props. See when your component renders. See what events fire. This is debugging and learning simultaneously!<br><br>
                <strong>6. Read error messages carefully</strong><br>
                React and Vue have EXCELLENT error messages. They tell you exactly what's wrong and often how to fix it. Don't panic - read the error!<br><br>
                <strong>7. Build tiny projects constantly</strong><br>
                After each section, build something small:<br>
                â€¢ Finished learning state? Build a color picker<br>
                â€¢ Finished learning lists? Build a shopping list<br>
                â€¢ Finished learning forms? Build a survey<br>
                Tiny projects = huge learning!<br><br>
                <strong>8. Don't rush to "advanced" topics</strong><br>
                Master the basics FIRST. You don't need Redux, TypeScript, Next.js, or any "advanced" stuff yet. Get comfortable with basic React/Vue first. Seriously!<br><br>
                <strong>9. Expect to feel confused</strong><br>
                You will feel lost sometimes. THIS IS NORMAL. Your brain is creating new neural pathways. Confusion means you're learning! Keep going. It WILL click!<br><br>
                <strong>10. Teach someone else</strong><br>
                After each section, explain what you learned to someone (or even your rubber duck). If you can teach it, you know it!</p>
            </div>

            <div class="metaphor-box">
                <h4>Learning to Code is Like Learning a Language</h4>
                <p>When you learned to speak as a child, you didn't:<br>
                â€¢ Memorize grammar rules first<br>
                â€¢ Read textbooks about sentence structure<br>
                â€¢ Study vocabulary lists<br><br>
                You:<br>
                â€¢ Heard words repeatedly<br>
                â€¢ Tried to say them (made mistakes!)<br>
                â€¢ Got corrections<br>
                â€¢ Practiced constantly<br>
                â€¢ Gradually understood patterns<br><br>
                Learning React/Vue is the SAME! Type code, make mistakes, get errors, fix them, see patterns emerge. This is the natural way to learn!</p>
            </div>

            <h4>React vs Vue - Which Should You Learn?</h4>
            <p>You might be wondering: "Should I learn React or Vue?" Great question!</p>

            <div class="info-box">
                <h4>The Answer: Learn BOTH (kind of)</h4>
                <p><strong>Here's what I recommend:</strong><br><br>
                1. <strong>Go through Section 2 (React) completely</strong><br>
                   Build all the projects, understand all the concepts<br><br>
                2. <strong>Then go through Section 3 (Vue)</strong><br>
                   You'll be AMAZED how fast you learn it because you already know the concepts from React!<br><br>
                3. <strong>Then pick ONE to specialize in</strong><br>
                   Based on job market in your area, personal preference, or project needs<br><br>
                <strong>Why learn both?</strong><br>
                â€¢ Understanding both makes you DEEPLY understand the concepts<br>
                â€¢ You'll see multiple approaches to the same problems<br>
                â€¢ You'll be hireable for more jobs<br>
                â€¢ Switching between them becomes easy<br>
                â€¢ You'll understand the "why" not just the "how"<br><br>
                <strong>But I only have time for one!</strong><br>
                If you truly can only learn one:<br>
                â€¢ <strong>Learn React</strong> if you want maximum job opportunities (React is more popular)<br>
                â€¢ <strong>Learn Vue</strong> if you want gentler learning curve and cleaner syntax<br><br>
                Honestly though? Both are excellent. You can't go wrong!</p>
            </div>

            <div class="info-box">
                <h4>Quick Comparison</h4>
                <p><strong>React:</strong><br>
                âœ… More job opportunities<br>
                âœ… Larger ecosystem<br>
                âœ… Backed by Meta (Facebook)<br>
                âœ… JSX (HTML in JavaScript)<br>
                âœ… More flexible (also more overwhelming)<br>
                âŒ Steeper learning curve<br>
                âŒ More decisions to make<br><br>
                <strong>Vue:</strong><br>
                âœ… Easier to learn<br>
                âœ… Cleaner syntax<br>
                âœ… Great documentation<br>
                âœ… Templates (HTML-based)<br>
                âœ… More opinionated (guides you)<br>
                âŒ Fewer jobs than React<br>
                âŒ Smaller ecosystem<br><br>
                <strong>Truth:</strong> Both are fantastic. Both can build anything. The differences matter less than you think!</p>
            </div>

            <h4>What Success Looks Like</h4>
            <p>By the end of this chapter, you will be able to:</p>

            <div class="code">// Build a full-stack todo app from scratch
// Frontend:
- [ ] Create a React/Vue app
- [ ] Build multiple components
- [ ] Manage state (add, edit, delete todos)
- [ ] Handle forms and validation
- [ ] Make it look beautiful with CSS
- [ ] Deploy it online

// Backend:
- [ ] Create a simple REST API
- [ ] Connect to a database
- [ ] Handle authentication
- [ ] Secure routes

// Full-Stack:
- [ ] Connect frontend to backend
- [ ] Fetch data from API
- [ ] Send data to API
- [ ] Handle errors gracefully
- [ ] Add loading states
- [ ] Make it production-ready</div>

            <div class="warning-box">
                <h4>ğŸš€ You CAN Do This!</h4>
                <p>I know this seems like a LOT. It is! But remember:<br><br>
                <strong>You're not learning everything at once.</strong> We're taking it step by step, concept by concept, project by project.<br><br>
                <strong>Thousands of people have done this before you.</strong> Many started knowing LESS than you do now. If they can do it, you absolutely can too!<br><br>
                <strong>It's normal to struggle.</strong> Every professional developer struggled when they were learning. The difference between them and people who gave up? They kept going!<br><br>
                <strong>You'll surprise yourself.</strong> In a few weeks, you'll look back at this section and think "wow, I can't believe I thought that was hard!" You're about to level up MASSIVELY!<br><br>
                <strong>We're in this together.</strong> This book is designed to guide you every step of the way. You're not alone!<br><br>
                Ready? Take a deep breath. Get a coffee or tea. Let's build something amazing! ğŸ‰</p>
            </div>

            <div class="metaphor-box">
                <h4>The Final Metaphor: You're Learning to Fly</h4>
                <p>Right now, you're in ground school. You understand how planes work (HTML, CSS, JS), why we need autopilot (frameworks), and what all the instruments do (components, state, props).<br><br>
                In Section 2, you'll take your first flight with an instructor (React).<br><br>
                In Section 3, you'll fly a different plane (Vue) and realize flying is flying, regardless of the aircraft.<br><br>
                In Section 4, you'll learn to navigate (connect to backends).<br><br>
                By the end, you'll be a licensed pilot, capable of flying solo! âœˆï¸<br><br>
                The sky is the limit. Let's go!</p>
            </div>
        </section>
            <p>What happens if you add a third button that doubles the count? You'd need to add another event listener. What if you want to show the count in multiple places? You'd need to update multiple elements. What if you want to add a feature that changes the button text when count is high? More code, more places to update, more chances for bugs.</p>

            <div class="metaphor-box">
                <h4>The Recipe Metaphor</h4>
                <p>Think about cooking without a recipe versus following one:<br><br>
                <strong>Without a recipe (Vanilla JS):</strong> "Go to the stove. Turn the heat to medium. Get a pan. Add oil. Wait 30 seconds. Crack eggs. Stir constantly. After 2 minutes, add salt..." You have to remember every step, in order, and do each one manually.<br><br>
                <strong>With a recipe (React):</strong> "I want scrambled eggs with salt." The recipe handles the steps. You just describe the end result you want.<br><br>
                React lets you describe WHAT you want, not HOW to create it. This is called "declarative programming."</p>
            </div>

            <h3>Part 2: What Even IS React?</h3>

            <h4>The Absolute Basics (No Jargon)</h4>
            <p>React is a JavaScript library that solves the exact problem we just saw. Instead of you manually updating the page every time data changes, React does it for you automatically. Let me break that down:</p>

            <div class="info-box">
                <h4>React in Simple Terms</h4>
                <p><strong>What it is:</strong> A tool that helps you build websites where things change and update automatically.<br><br>
                <strong>What it does:</strong> You tell React what the page should look like based on your data, and React handles all the complicated DOM manipulation for you.<br><br>
                <strong>Why it's useful:</strong> Instead of writing "when this button is clicked, find this element and change it," you write "here's what the page looks like when count is 0, here's what it looks like when count is 5." React figures out how to update everything.</p>
            </div>

            <h4>Library vs Framework - What's the Difference?</h4>
            <p>You'll hear React called both a "library" and a "framework." Here's the difference (and why it matters):</p>

            <div class="metaphor-box">
                <h4>Library vs Framework</h4>
                <p><strong>A Library (like React):</strong> It's like a toolbox. You pick which tools you want to use, when you want to use them, and how. React gives you tools for building UIs, but YOU decide the structure of your app. Want to add routing? Pick a library. Want to manage global state? Pick another library. You're in control.<br><br>
                <strong>A Framework (like Angular):</strong> It's like building with a construction kit that comes with instructions. The framework decides the structure, the rules, and how everything fits together. You work within its system.<br><br>
                Think of it this way: A library is a cookbook - you choose recipes. A framework is a meal kit - everything is pre-planned, you just follow steps.</p>
            </div>

            <p>React technically calls itself a "library," but many people casually call it a "framework." For our purposes, it doesn't matter much - what matters is understanding what React DOES.</p>

            <h4>The Big Concept: Components</h4>
            <p>Everything in React is built from <strong>components</strong>. But what's a component? Let's build up to it:</p>

            <p>Remember functions from Chapter 2? A function is a reusable piece of code:</p>

            <div class="code">// A simple function
function greet(name) {
  return "Hello, " + name + "!";
}

// Use it multiple times
console.log(greet("Alice"));  // "Hello, Alice!"
console.log(greet("Bob"));    // "Hello, Bob!"

            <p>A React component is just like that, but instead of returning text, it returns HTML!</p>

            <div class="code">// A React component (we'll explain the syntax soon)
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// Use it multiple times in your page
&lt;Greeting name="Alice" /&gt;   // Shows: Hello, Alice!
&lt;Greeting name="Bob" /&gt;     // Shows: Hello, Bob!</div>

            <p>That's it! A component is a function that returns HTML. You can use it like a custom HTML tag.</p>

            <div class="info-box">
                <h4>Why Components Are Awesome</h4>
                <p><strong>Reusability:</strong> Write once, use everywhere. Like a button component you use 100 times.<br><br>
                <strong>Organization:</strong> Instead of one giant 5000-line HTML file, you have small, focused pieces.<br><br>
                <strong>Maintainability:</strong> If you need to fix a bug in your button, you fix it in ONE place.<br><br>
                <strong>Thinking in pieces:</strong> Your brain can focus on one small thing at a time instead of the whole app.</p>
            </div>

            <h4>Declarative vs Imperative (The React Way of Thinking)</h4>
            <p>This is THE most important concept to understand about React. Let's use an analogy:</p>

            <div class="metaphor-box">
                <h4>Ordering at a Restaurant</h4>
                <p><strong>Imperative (Vanilla JS):</strong> "Go to the kitchen. Get a pan. Turn on the stove to medium heat. Get 3 eggs from the fridge. Crack them into a bowl. Whisk them. Pour into pan. Stir for 2 minutes. Add salt. Serve on a plate."<br><br>
                You tell the chef every single step, in order, exactly how to do it.<br><br>
                <strong>Declarative (React):</strong> "I'd like scrambled eggs, please."<br><br>
                You describe WHAT you want, not HOW to make it. The chef (React) handles all the steps.</p>
            </div>

            <p>In code terms:</p>

            <div class="code">// IMPERATIVE (Vanilla JS) - Tell HOW to do everything
let count = 0;
const display = document.getElementById('count');

function increment() {
  count = count + 1;           // Step 1: Change the data
  display.textContent = count; // Step 2: Update the display
}

// DECLARATIVE (React) - Tell WHAT you want
function Counter() {
  const [count, setCount] = useState(0);
  
  // Just describe what the UI looks like for the current count
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
// React figures out HOW to update the display!

            <p>See the difference? In React, you just describe what the UI should look like. When <span class="inline-code">count</span> changes, React automatically updates the display. You don't tell it HOW - it figures that out.</p>

            <h4>Setting Up React (Two Ways)</h4>
            <p>Before we write React code, we need to set it up. There are two main ways beginners can start:</p>

            <h4>Method 1: Create React App (The Traditional Way)</h4>
            <p>Create React App is a tool that sets up everything you need with one command. It's like getting a fully furnished apartment - everything works out of the box.</p>

            <div class="code">// In your terminal (you need Node.js installed - see Chapter 4)
npx create-react-app my-first-app

// This creates a folder with:
// - React installed
// - A development server
// - Build tools configured
// - Sample code to get started

// Go into the folder
cd my-first-app

// Start the development server
npm start

// Your browser opens to http://localhost:3000
// You'll see a spinning React logo!</div>

            <div class="info-box">
                <h4>What Just Happened?</h4>
                <p><span class="inline-code">npx</span> is a tool that comes with Node.js. It runs <span class="inline-code">create-react-app</span> which:<br><br>
                â€¢ Downloads React and related tools<br>
                â€¢ Sets up a project structure<br>
                â€¢ Configures a development server with hot reloading (your changes appear instantly)<br>
                â€¢ Sets up build tools (Webpack, Babel) that convert your React code to regular JavaScript browsers understand</p>
            </div>

            <h4>Method 2: Vite (The Modern, Faster Way)</h4>
            <p>Vite (pronounced "veet" - French for "fast") is a newer tool that's becoming more popular because it's MUCH faster than Create React App.</p>

            <div class="code">// In your terminal
npm create vite@latest my-first-app

// It asks what framework: Choose "React"
// It asks variant: Choose "JavaScript" (not TypeScript yet)

// Go into the folder
cd my-first-app

// Install dependencies
npm install

// Start the development server
npm run dev

// Your browser opens and you see the Vite + React demo!

            <div class="warning-box">
                <h4>Which One Should I Use?</h4>
                <p>For learning: Either is fine! Both work great.<br><br>
                <strong>Create React App:</strong> More established, tons of tutorials online use it.<br>
                <strong>Vite:</strong> Faster, more modern, becoming the standard for new projects.<br><br>
                If you're just starting, go with Vite. It's faster and you'll see changes instantly.</p>
            </div>

            <h3>Part 3: Your First React Component (Let's Actually Code!)</h3>

            <h4>The Absolute Simplest Component</h4>
            <p>Let's start with literally the simplest React component possible. Open your project (either Create React App or Vite) and look for a file called <span class="inline-code">App.jsx</span> or <span class="inline-code">App.js</span>. Clear everything in it and type:</p>

            <div class="code">function App() {
  return &lt;h1&gt;Hello World&lt;/h1&gt;;
}

export default App;</div>

            <p>That's it! Save the file. If your dev server is running (<span class="inline-code">npm start</span> or <span class="inline-code">npm run dev</span>), your browser will instantly show "Hello World" in big letters.</p>

            <h4>Breaking Down Every Single Piece</h4>
            <p>Let's analyze this code line by line, assuming you know NOTHING:</p>

            <div class="code">function App() {      // 1. A function named "App"
                             //    Component names MUST start with capital letter!
  
  return &lt;h1&gt;Hello World&lt;/h1&gt;;  // 2. Return some HTML
                                      //    This looks like HTML but it's JSX
}

export default App;  // 3. Make this component available to other files

            <div class="info-box">
                <h4>Why Capital Letters Matter</h4>
                <p>React treats lowercase components as regular HTML tags. So <span class="inline-code">&lt;div&gt;</span> is HTML, but <span class="inline-code">&lt;App&gt;</span> is a component.<br><br>
                <span class="inline-code">&lt;button&gt;</span> = HTML button<br>
                <span class="inline-code">&lt;Button&gt;</span> = Your custom Button component<br><br>
                Always name components with PascalCase (capital first letter)!</p>
            </div>

            <h4>What is JSX?</h4>
            <p>That <span class="inline-code">&lt;h1&gt;Hello World&lt;/h1&gt;</span> looks like HTML, but it's in a JavaScript file! This is JSX - JavaScript XML. It's a special syntax that lets you write HTML-looking code in JavaScript.</p>

            <div class="code">// This is JSX:
return &lt;h1&gt;Hello World&lt;/h1&gt;;

// Behind the scenes, it gets converted to regular JavaScript:
return React.createElement('h1', null, 'Hello World');

// JSX is just EASIER TO READ than the converted version!</div>

            <h4>Putting JavaScript Inside JSX</h4>
            <p>The power of JSX is that you can mix JavaScript right into your HTML using curly braces <span class="inline-code">{ }</span>:</p>

            <div class="code">function App() {
  const name = "Alice";
  const age = 25;
  const hobbies = ["coding", "gaming", "reading"];
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
      &lt;p&gt;You are {age} years old&lt;/p&gt;
      &lt;p&gt;Next year you'll be {age + 1}&lt;/p&gt;
      &lt;p&gt;2 + 2 = {2 + 2}&lt;/p&gt;
      &lt;p&gt;Random number: {Math.random()}&lt;/p&gt;
      &lt;p&gt;Your hobbies: {hobbies.join(", ")}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default App;</div>

            <p>Anything inside <span class="inline-code">{ }</span> is regular JavaScript! You can do math, call functions, access variables, anything.</p>

            <div class="warning-box">
                <h4>âš ï¸ Common Beginner Mistakes with JSX</h4>
                <p><strong>1. Use className not class:</strong> Because "class" is a reserved word in JavaScript, React uses <span class="inline-code">className</span> for CSS classes.<br><br>
                <strong>Wrong:</strong> <span class="inline-code">&lt;div class="container"&gt;</span><br>
                <strong>Right:</strong> <span class="inline-code">&lt;div className="container"&gt;</span><br><br>
                <strong>2. Close all tags:</strong> HTML lets you write <span class="inline-code">&lt;img&gt;</span> or <span class="inline-code">&lt;br&gt;</span>, but JSX requires <span class="inline-code">&lt;img /&gt;</span> and <span class="inline-code">&lt;br /&gt;</span>.<br><br>
                <strong>3. Return ONE root element:</strong> You can't return multiple elements directly. Wrap them in a <span class="inline-code">&lt;div&gt;</span> or use a Fragment <span class="inline-code">&lt;&gt;&lt;/&gt;</span>.</p>
            </div>

            <div class="code">// âŒ WRONG - Multiple root elements
function App() {
  return (
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Paragraph&lt;/p&gt;
  );
}

// âœ… RIGHT - Wrapped in div
function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Title&lt;/h1&gt;
      &lt;p&gt;Paragraph&lt;/p&gt;
    &lt;/div&gt;
  );
}

// âœ… ALSO RIGHT - Using Fragment (doesn't add extra HTML)
function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;Title&lt;/h1&gt;
      &lt;p&gt;Paragraph&lt;/p&gt;
    &lt;/&gt;
  );
}

            <h4>Complete Working Example</h4>
            <p>Here's a real, complete component that demonstrates everything we've learned so far:</p>

            <div class="code">function App() {
  // JavaScript variables
  const userName = "Alice";
  const userAge = 25;
  const isLoggedIn = true;
  const skills = ["JavaScript", "React", "CSS"];
  
  return (
    &lt;div className="app-container"&gt;
      {/* This is a comment in JSX - must be in curly braces! */}
      
      &lt;h1&gt;Welcome to My App&lt;/h1&gt;
      
      {/* Using variables in JSX */}
      &lt;p&gt;Hello, {userName}!&lt;/p&gt;
      &lt;p&gt;Age: {userAge}&lt;/p&gt;
      
      {/* Conditional rendering - shows different content based on condition */}
      {isLoggedIn ? (
        &lt;p&gt;You are logged in! âœ…&lt;/p&gt;
      ) : (
        &lt;p&gt;Please log in&lt;/p&gt;
      )}
      
      {/* Rendering a list */}
      &lt;h2&gt;My Skills:&lt;/h2&gt;
      &lt;ul&gt;
        {skills.map((skill) =&gt; (
          &lt;li key={skill}&gt;{skill}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      
      {/* Self-closing tags */}
      &lt;img src="/avatar.jpg" alt="Avatar" /&gt;
      &lt;br /&gt;
      
      {/* camelCase for event handlers */}
      &lt;button onClick={() =&gt; alert('Button clicked!')}&gt;
        Click Me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;</div>

            <h3>Hooks Mastery</h3>
            <p>Hooks are functions that let you "hook into" React features from functional components. They revolutionized React development by making functional components as powerful as class components.</p>

            <h4>useState - State Management</h4>
            <p>The most commonly used hook for managing component state.</p>

            <div class="code">import { useState } from 'react';

// Basic usage
function Example() {
  const [count, setCount] = useState(0);
  
  return <button onClick={() => setCount(count + 1)}>
    Clicked {count} times
  </button>;
}

// Functional updates (when new state depends on old state)
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    // BAD - can cause bugs with multiple updates
    setCount(count + 1);
    
    // GOOD - uses previous state
    setCount(prev => prev + 1);
  };
  
  const incrementMultiple = () => {
    // This works correctly because of functional updates
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };
  
  return <button onClick={incrementMultiple}>+3</button>;
}

// Lazy initialization (expensive computation)
function ExpensiveComponent() {
  // BAD - runs every render
  const [state, setState] = useState(expensiveFunction());
  
  // GOOD - runs only on initial render
  const [state, setState] = useState(() => expensiveFunction());
  
  return <div>{state}</div>;
}

// Multiple state variables
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [errors, setErrors] = useState({});
  
  // OR use a single state object
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  return null;
}</div>

            <h4>useEffect - Side Effects</h4>
            <p>useEffect handles side effects like data fetching, subscriptions, and manual DOM manipulation.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Basic usage - runs after every render
function Example() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `Count: ${count}`;
  });
  
  return <button onClick={() => setCount(count + 1)}>
    Increment
  </button>;
}

// With dependency array - runs only when dependencies change
function User({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    setLoading(true);
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        console.error(err);
        setLoading(false);
      });
  }, [userId]); // Re-run when userId changes
  
  if (loading) return <div>Loading...</div>;
  return <div>{user?.name}</div>;
}

// Cleanup function - prevents memory leaks
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // Cleanup function runs before component unmounts
    // and before the effect runs again
    return () => {
      clearInterval(interval);
      console.log('Timer cleaned up');
    };
  }, []); // Empty array = run once on mount
  
  return <div>Seconds: {seconds}</div>;
}

// Real-world example - WebSocket connection
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://api.com/rooms/${roomId}`);
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    // Cleanup: close connection when component unmounts
    // or when roomId changes
    return () => {
      ws.close();
    };
  }, [roomId]);
  
  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useEffect Pitfalls</h4>
                <p><strong>Missing dependencies:</strong> Always include all values from component scope that are used in effect.<br><br>
                <strong>Infinite loops:</strong> Be careful with dependency arrays - updating state that's in dependencies causes loops.<br><br>
                <strong>Async functions:</strong> Can't make useEffect callback async directly. Create async function inside instead.<br><br>
                <strong>Cleanup is crucial:</strong> Always cleanup subscriptions, timers, and listeners to prevent memory leaks.</p>
            </div>

            <h4>useContext - Global State</h4>
            <p>useContext provides a way to pass data through the component tree without passing props down manually at every level.</p>

            <div class="code">import { createContext, useContext, useState } from 'react';

// 1. Create a context
const ThemeContext = createContext();

// 2. Create a provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create a custom hook for easy access
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 4. Use in components
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={`header-${theme}`}>
      <h1>My App</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}

// Real-world example - Auth context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('token');
    if (token) {
      fetch('/api/auth/me', {
        headers: { Authorization: `Bearer ${token}` }
      })
        .then(res => res.json())
        .then(data => {
          setUser(data);
          setLoading(false);
        })
        .catch(() => {
          localStorage.removeItem('token');
          setLoading(false);
        });
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    const data = await res.json();
    localStorage.setItem('token', data.token);
    setUser(data.user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}</div>

            <h4>useRef - Persistent Values & DOM Access</h4>
            <p>useRef creates a mutable reference that persists across renders without causing re-renders when changed.</p>

            <div class="code">import { useRef, useEffect } from 'react';

// Accessing DOM elements
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  useEffect(() => {
    // Auto-focus on mount
    inputRef.current.focus();
  }, []);
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

// Storing previous values
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();
  
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  const prevCount = prevCountRef.current;
  
  return (
    <div>
      <h2>Current: {count}</h2>
      <h3>Previous: {prevCount}</h3>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// Storing interval/timeout IDs
function StopWatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  
  const start = () => {
    setIsRunning(true);
    intervalRef.current = setInterval(() => {
      setTime(t => t + 1);
    }, 1000);
  };
  
  const stop = () => {
    setIsRunning(false);
    clearInterval(intervalRef.current);
  };
  
  const reset = () => {
    stop();
    setTime(0);
  };
  
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <div>
      <h2>Time: {time}s</h2>
      {!isRunning ? (
        <button onClick={start}>Start</button>
      ) : (
        <button onClick={stop}>Stop</button>
      )}
      <button onClick={reset}>Reset</button>
    </div>
  );
}

// Preventing unnecessary API calls
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const abortControllerRef = useRef(null);
  
  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }
    
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // Create new abort controller
    abortControllerRef.current = new AbortController();
    
    fetch(`/api/search?q=${query}`, {
      signal: abortControllerRef.current.signal
    })
      .then(res => res.json())
      .then(data => setResults(data))
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      });
  }, [query]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}</div>

            <h4>useMemo - Expensive Computations</h4>
            <p>useMemo memoizes computed values, recalculating only when dependencies change.</p>

            <div class="code">import { useMemo, useState } from 'react';

function ProductList({ products, searchTerm, sortBy }) {
  // Expensive filtering and sorting
  const processedProducts = useMemo(() => {
    console.log('Processing products...');
    
    let result = products.filter(product =>
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    result.sort((a, b) => {
      if (sortBy === 'price') {
        return a.price - b.price;
      }
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      return 0;
    });
    
    return result;
  }, [products, searchTerm, sortBy]);
  // Only recalculate when these change
  
  return (
    <div>
      {processedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// When NOT to use useMemo
function SimpleComponent({ a, b }) {
  // BAD - premature optimization
  const sum = useMemo(() => a + b, [a, b]);
  
  // GOOD - simple calculation, no memoization needed
  const sum = a + b;
  
  return <div>Sum: {sum}</div>;
}

// Memoizing object creation for dependencies
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  // WITHOUT useMemo - creates new object every render
  // causes useEffect to run every time
  const requestOptions = {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  };
  
  // WITH useMemo - stable reference
  const requestOptions = useMemo(() => ({
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  }), [token]);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`, requestOptions)
      .then(res => res.json())
      .then(setUser);
  }, [userId, requestOptions]); // Now only runs when actually needed
  
  return <div>{user?.name}</div>;
}</div>

            <h4>useCallback - Memoized Functions</h4>
            <p>useCallback memoizes function definitions, preventing unnecessary re-creations.</p>

            <div class="code">import { useCallback, useState, memo } from 'react';

// Child component - expensive to render
const ExpensiveChild = memo(({ onClick, data }) => {
  console.log('ExpensiveChild rendered');
  return (
    <button onClick={onClick}>
      Click me - {data}
    </button>
  );
});

function Parent() {
  const [count, setCount] = useState(0);
  const [other, setOther] = useState(0);
  
  // WITHOUT useCallback - new function every render
  // ExpensiveChild re-renders unnecessarily
  const handleClick = () => {
    setCount(c => c + 1);
  };
  
  // WITH useCallback - stable function reference
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []); // No dependencies - function never changes
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => setOther(other + 1)}>
        Other: {other}
      </button>
      <ExpensiveChild onClick={handleClick} data={count} />
    </div>
  );
}

// Real-world example - event handlers with parameters
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  // Memoize the remove function
  const removeTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []); // No dependencies because we use functional update
  
  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  }, []);
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onRemove={removeTodo}
          onToggle={toggleTodo}
        />
      ))}
    </div>
  );
}

// useCallback with dependencies
function SearchBox({ onSearch, filters }) {
  const [query, setQuery] = useState('');
  
  const handleSearch = useCallback(() => {
    // Function recreated when filters change
    onSearch(query, filters);
  }, [query, filters, onSearch]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useMemo vs useCallback</h4>
                <p><strong>useMemo:</strong> Memoizes the RESULT of a function - <span class="inline-code">useMemo(() => value, deps)</span><br><br>
                <strong>useCallback:</strong> Memoizes the FUNCTION itself - <span class="inline-code">useCallback(fn, deps)</span><br><br>
                <strong>Remember:</strong> <span class="inline-code">useCallback(fn, deps)</span> is equivalent to <span class="inline-code">useMemo(() => fn, deps)</span><br><br>
                <strong>Don't overuse:</strong> These optimizations have a cost. Only use when profiling shows a performance issue.</p>
            </div>

            <h4>Custom Hooks - Reusable Logic</h4>
            <p>Custom hooks let you extract component logic into reusable functions. They're just JavaScript functions that use React hooks.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Custom hook for fetching data
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
          setData(null);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url, JSON.stringify(options)]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(
    `/api/users/${userId}`
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
}

// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function
        ? value(storedValue)
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}

// Custom hook for window dimensions
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Custom hook for debounced value
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage - search with debounce
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  const { data: results } = useFetch(
    `/api/search?q=${debouncedSearchTerm}`
  );
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {results && results.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}</div>

            <h3>Advanced Component Patterns</h3>

            <h4>Higher-Order Components (HOCs)</h4>
            <p>A higher-order component is a function that takes a component and returns a new component with additional props or behavior.</p>

            <div class="code">// Basic HOC pattern
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...props} />;
  };
}

// Usage
const UserListWithLoading = withLoading(UserList);

// With authentication
function withAuth(Component) {
  return function WithAuthComponent(props) {
    const { user, loading } = useAuth();
    
    if (loading) {
      return <div>Checking authentication...</div>;
    }
    
    if (!user) {
      return <Navigate to="/login" />;
    }
    
    return <Component {...props} user={user} />;
  };
}

// Usage
const ProtectedDashboard = withAuth(Dashboard);

// With data fetching
function withData(url) {
  return function (Component) {
    return function WithDataComponent(props) {
      const { data, loading, error } = useFetch(url);
      
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error}</div>;
      
      return <Component {...props} data={data} />;
    };
  };
}

// Usage
const UserListWithData = withData('/api/users')(UserList);

// Composing multiple HOCs
const EnhancedComponent = withAuth(
  withLoading(
    withData('/api/users')(UserList)
  )
);</div>

            <div class="info-box">
                <h4>HOC Best Practices</h4>
                <p><strong>Don't mutate:</strong> Create new components, don't modify the original.<br><br>
                <strong>Pass through props:</strong> Forward all props that aren't consumed by the HOC.<br><br>
                <strong>Display name:</strong> Set displayName for better debugging.<br><br>
                <strong>Static methods:</strong> Copy static methods from wrapped component.<br><br>
                <strong>Refs:</strong> Use React.forwardRef to forward refs through HOCs.</p>
            </div>

            <h4>Render Props Pattern</h4>
            <p>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</p>

            <div class="code">// Mouse tracker with render props
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return render(position);
}

// Usage
function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <div>
          Mouse position: {x}, {y}
        </div>
      )}
    />
  );
}

// Using children as a function (common pattern)
function DataProvider({ url, children }) {
  const { data, loading, error } = useFetch(url);
  
  return children({ data, loading, error });
}

// Usage
function App() {
  return (
    <DataProvider url="/api/users">
      {({ data, loading, error }) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error}</div>;
        return (
          <ul>
            {data.map(user => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>
        );
      }}
    </DataProvider>
  );
}

// Toggle component with render props
function Toggle({ initial = false, children }) {
  const [on, setOn] = useState(initial);
  
  const toggle = () => setOn(prev => !prev);
  const setOff = () => setOn(false);
  const setOn = () => setOn(true);
  
  return children({
    on,
    toggle,
    setOff,
    setOn
  });
}

// Usage
<Toggle initial={false}>
  {({ on, toggle }) => (
    <div>
      <button onClick={toggle}>
        {on ? 'ON' : 'OFF'}
      </button>
      {on && <div>Content visible!</div>}
    </div>
  )}
</Toggle></div>

            <h4>Compound Components Pattern</h4>
            <p>Compound components work together to form a complete UI. They share implicit state without prop drilling.</p>

            <div class="code">// Tabs compound component
const TabsContext = createContext();

function Tabs({ children, defaultValue }) {
  const [activeTab, setActiveTab] = useState(defaultValue);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === value;
  
  return (
    <button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== value) return null;
  
  return <div className="tab-panel">{children}</div>;
}

// Attach sub-components
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage - beautiful API!
function App() {
  return (
    <Tabs defaultValue="profile">
      <Tabs.List>
        <Tabs.Tab value="profile">Profile</Tabs.Tab>
        <Tabs.Tab value="settings">Settings</Tabs.Tab>
        <Tabs.Tab value="notifications">Notifications</Tabs.Tab>
      </Tabs.List>
      
      <Tabs.Panel value="profile">
        <h2>Profile Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="settings">
        <h2>Settings Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="notifications">
        <h2>Notifications Content</h2>
      </Tabs.Panel>
    </Tabs>
  );
}</div>

            <h3>Performance Optimization</h3>

            <h4>React.memo - Component Memoization</h4>
            <p>React.memo prevents unnecessary re-renders by memoizing component output.</p>

            <div class="code">import { memo } from 'react';

// Without memo - re-renders every time parent renders
function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  // Expensive computation
  return <div>{data}</div>;
}

// With memo - only re-renders when props change
const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  return <div>{data}</div>;
});

// Custom comparison function
const ExpensiveComponent = memo(
  function ExpensiveComponent({ user, settings }) {
    return (
      <div>
        <h2>{user.name}</h2>
        <p>{settings.theme}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    // Return false if props changed (re-render)
    return (
      prevProps.user.id === nextProps.user.id &&
      prevProps.settings.theme === nextProps.settings.theme
    );
  }
);

// Real-world example
const ProductCard = memo(function ProductCard({ product, onAddToCart }) {
  console.log(`Rendering product: ${product.name}`);
  
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => onAddToCart(product.id)}>
        Add to Cart
      </button>
    </div>
  );
});

function ProductList({ products }) {
  const [cart, setCart] = useState([]);
  
  // Memoize callback to prevent ProductCard re-renders
  const handleAddToCart = useCallback((productId) => {
    setCart(prev => [...prev, productId]);
  }, []);
  
  return (
    <div className="product-list">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
}</div>

            <h4>Code Splitting & Lazy Loading</h4>
            <p>Split your code into smaller chunks that load on demand, reducing initial bundle size.</p>

            <div class="code">import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Dashboard />
      </Suspense>
    </div>
  );
}

// With React Router
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Custom loading component
function LoadingSpinner() {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  );
}

// Error boundary for lazy loading
class LazyLoadErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Failed to load component</h2>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage with error boundary
<LazyLoadErrorBoundary>
  <Suspense fallback={<LoadingSpinner />}>
    <Dashboard />
  </Suspense>
</LazyLoadErrorBoundary></div>

            <div class="info-box">
                <h4>Performance Tips</h4>
                <p><strong>List virtualization:</strong> Use libraries like react-window for long lists.<br><br>
                <strong>Debounce expensive operations:</strong> Delay API calls and computations.<br><br>
                <strong>Avoid inline functions:</strong> Extract to useCallback when passing to memoized components.<br><br>
                <strong>Profile before optimizing:</strong> Use React DevTools Profiler to find real bottlenecks.<br><br>
                <strong>Bundle analysis:</strong> Use webpack-bundle-analyzer to find large dependencies.</p>
            </div>

            <h3>Error Boundaries</h3>
            <p>Error boundaries catch JavaScript errors anywhere in the component tree and display a fallback UI.</p>

            <div class="code">import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error to error reporting service
    console.error('Error caught by boundary:', error, errorInfo);
    
    // You can also log to external services
    // logErrorToService(error, errorInfo);
    
    this.setState({
      error,
      errorInfo
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <ErrorBoundary>
        <Sidebar />
      </ErrorBoundary>
      <ErrorBoundary>
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}

// Component that might error
function BuggyComponent() {
  const [count, setCount] = useState(0);
  
  if (count === 5) {
    // Simulate an error
    throw new Error('Crashed at count 5!');
  }
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}</div>

            <div class="warning-box">
                <h4>Error Boundary Limitations</h4>
                <p>Error boundaries do NOT catch errors in:<br><br>
                â€¢ Event handlers (use try-catch instead)<br>
                â€¢ Asynchronous code (setTimeout, fetch)<br>
                â€¢ Server-side rendering<br>
                â€¢ Errors thrown in the error boundary itself<br><br>
                For event handlers, wrap in try-catch and update state to show error UI.</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered React!</h4>
                <p>Congratulations! You now understand React from the ground up - from the Virtual DOM to advanced patterns, performance optimization, and error handling. You're equipped to build production-ready React applications with confidence. Remember: the best way to solidify this knowledge is to build real projects. Start small, iterate, and gradually tackle more complex challenges.</p>
            </div>
        </section>

        <!-- SECTION 2: Building Your First React App -->
        <section id="first-react-app" class="section">
            <h2 class="section-title">Building Your First React App</h2>
            <p class="section-intro">Now that you understand what React is, let's actually BUILD something! In this section, we'll create real, working React applications from scratch. No build tools, no complexityâ€”just you, React, and a web browser. By the end, you'll have built a counter app and a todo list app, and you'll understand exactly how React works.</p>

            <div class="metaphor-box">
                <h4>Learning by Building</h4>
                <p>Think of this like learning to ride a bike. Reading about balance and pedaling is useful, but you only REALLY learn when you actually get on the bike and try it yourself. That's what we're doing hereâ€”we're getting on the React bike and riding!</p>
            </div>

            <h3>Setting Up React (The Easy Way)</h3>

            <p>There are two ways to use React: the complex way (with build tools, npm, webpack, etc.) and the simple way (just including React from a CDN). We're starting with the simple way so you can focus on learning React, not fighting with configuration files.</p>

            <div class="info-box">
                <h4>What's a CDN?</h4>
                <p><strong>CDN stands for Content Delivery Network.</strong> It's basically a way to include libraries from the internet directly in your HTML file. Think of it like checking out a book from a library instead of buying itâ€”you get to use React without downloading or installing anything!</p>
            </div>

            <h4>Your First React HTML File</h4>

            <p>Create a new file called <span class="inline-code">react-app.html</span> and add this code:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;My First React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- This is where React will put our app --&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;!-- Include React from CDN --&gt;
    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    
    &lt;!-- Include Babel to transform JSX --&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;!-- Our React code goes here --&gt;
    &lt;script type="text/babel"&gt;
        // React code coming soon!
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="warning-box">
                <h4>About Those Script Tags</h4>
                <p><strong>Three script tags, three jobs:</strong><br><br>
                1. <span class="inline-code">react.development.js</span> - The React library itself<br>
                2. <span class="inline-code">react-dom.development.js</span> - Connects React to the browser's DOM<br>
                3. <span class="inline-code">babel.min.js</span> - Transforms JSX (that HTML-like syntax) into regular JavaScript<br><br>
                The <span class="inline-code">type="text/babel"</span> tells Babel to process this script.</p>
            </div>

            <h3>Creating Your First Component</h3>

            <p>Let's create the simplest possible React componentâ€”a "Hello World" message.</p>

            <div class="code">&lt;script type="text/babel"&gt;
    // This is a React component - just a function that returns JSX
    function HelloWorld() {
        return &lt;h1&gt;Hello, World! I'm using React!&lt;/h1&gt;;
    }

    // Get the root div
    const root = ReactDOM.createRoot(document.getElementById('root'));
    
    // Render our component
    root.render(&lt;HelloWorld /&gt;);
&lt;/script&gt;</div>

            <p>Save your file and open it in a browser. You should see "Hello, World! I'm using React!" on the screen. Congratulationsâ€”you just created your first React component!</p>

            <div class="metaphor-box">
                <h4>What Just Happened?</h4>
                <p>Think of React components like LEGO blocks. The <span class="inline-code">HelloWorld</span> function is a block you created. The <span class="inline-code">root.render()</span> command takes your block and puts it on the page. The <span class="inline-code">&lt;HelloWorld /&gt;</span> syntax is how you "use" your block.</p>
            </div>

            <h3>Understanding JSX</h3>

            <p>JSX is that HTML-looking code inside your JavaScript. It's not actually HTMLâ€”it's a special syntax that React uses to describe what the UI should look like.</p>

            <div class="code">// JSX looks like HTML
const element = &lt;h1&gt;Hello!&lt;/h1&gt;;

// But it's actually JavaScript! Babel transforms it to:
const element = React.createElement('h1', null, 'Hello!');

// You can use JavaScript expressions in JSX with curly braces {}
const name = "Alice";
const greeting = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;

// You can do math
const math = &lt;p&gt;2 + 2 = {2 + 2}&lt;/p&gt;;

// You can call functions
function getGreeting() {
    return "Good morning";
}
const message = &lt;p&gt;{getGreeting()}&lt;/p&gt;;</div>

            <div class="info-box">
                <h4>JSX Rules</h4>
                <p>â€¢ Must have ONE parent element (wrap multiple elements in a <span class="inline-code">&lt;div&gt;</span> or <span class="inline-code">&lt;&gt;...&lt;/&gt;</span>)<br>
                â€¢ Use <span class="inline-code">className</span> instead of <span class="inline-code">class</span> (class is a JavaScript keyword)<br>
                â€¢ Close all tags, even self-closing ones: <span class="inline-code">&lt;img /&gt;</span>, <span class="inline-code">&lt;br /&gt;</span><br>
                â€¢ Use camelCase for attributes: <span class="inline-code">onClick</span>, not <span class="inline-code">onclick</span></p>
            </div>

            <h3>Props: Passing Data to Components</h3>

            <p>Props (short for "properties") are how you pass data from one component to another. Think of props like function arguments.</p>

            <div class="code">// Component that accepts props
function Greeting(props) {
    return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// Using the component with different props
root.render(
    &lt;div&gt;
        &lt;Greeting name="Alice" /&gt;
        &lt;Greeting name="Bob" /&gt;
        &lt;Greeting name="Charlie" /&gt;
    &lt;/div&gt;
);

// More complex props
function UserCard(props) {
    return (
        &lt;div style={{border: '1px solid black', padding: '10px', margin: '10px'}}&gt;
            &lt;h2&gt;{props.name}&lt;/h2&gt;
            &lt;p&gt;Age: {props.age}&lt;/p&gt;
            &lt;p&gt;Email: {props.email}&lt;/p&gt;
        &lt;/div&gt;
    );
}

root.render(
    &lt;UserCard 
        name="Alice" 
        age={25} 
        email="alice@example.com" 
    /&gt;
);</div>

            <div class="metaphor-box">
                <h4>Props Are Like Recipe Ingredients</h4>
                <p>Imagine a component is a recipe for making a sandwich. Props are the ingredients you pass in. The same "sandwich recipe" can make different sandwiches depending on what ingredients (props) you give itâ€”turkey sandwich, veggie sandwich, etc.</p>
            </div>

            <h3>State: Data That Changes</h3>

            <p>State is data that can change over time. When state changes, React automatically re-renders the component to show the new data. This is where React gets really powerful!</p>

            <div class="code">function Counter() {
    // useState creates a piece of state
    // count is the current value
    // setCount is the function to update it
    const [count, setCount] = React.useState(0);

    return (
        &lt;div&gt;
            &lt;h2&gt;Counter: {count}&lt;/h2&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
                Click to Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</div>

            <p>Let me break down what's happening:</p>

            <ul>
                <li><span class="inline-code">React.useState(0)</span> - Creates state with initial value of 0</li>
                <li><span class="inline-code">count</span> - The current value (starts at 0)</li>
                <li><span class="inline-code">setCount</span> - Function to update the count</li>
                <li><span class="inline-code">onClick</span> - Run code when button is clicked</li>
                <li>When <span class="inline-code">setCount</span> is called, React re-renders the component with the new count</li>
            </ul>

            <h3>Event Handling</h3>

            <p>React uses camelCase event names (<span class="inline-code">onClick</span>, not <span class="inline-code">onclick</span>) and you pass functions as event handlers.</p>

            <div class="code">function EventExamples() {
    const [text, setText] = React.useState('');
    const [clicks, setClicks] = React.useState(0);

    // Handle button click
    function handleClick() {
        alert('Button clicked!');
        setClicks(clicks + 1);
    }

    // Handle input change
    function handleChange(event) {
        setText(event.target.value);
    }

    // Handle form submit
    function handleSubmit(event) {
        event.preventDefault(); // Prevent page reload
        alert(`You typed: ${text}`);
    }

    return (
        &lt;div&gt;
            &lt;h2&gt;Event Handling Examples&lt;/h2&gt;
            
            &lt;button onClick={handleClick}&gt;
                Click me! (Clicks: {clicks})
            &lt;/button&gt;

            &lt;form onSubmit={handleSubmit}&gt;
                &lt;input 
                    type="text" 
                    value={text} 
                    onChange={handleChange}
                    placeholder="Type something..."
                /&gt;
                &lt;button type="submit"&gt;Submit&lt;/button&gt;
            &lt;/form&gt;

            &lt;p&gt;You typed: {text}&lt;/p&gt;
        &lt;/div&gt;
    );
}</div>

            <h3>Complete Counter App</h3>

            <p>Let's build a complete counter app with increment, decrement, and reset buttons:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;React Counter App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f0f0f0;
        }
        .counter-app {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }
        .count-display {
            font-size: 72px;
            font-weight: bold;
            margin: 20px 0;
            color: #333;
        }
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover {
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
        }
        .btn-increment {
            background: #4CAF50;
            color: white;
        }
        .btn-decrement {
            background: #f44336;
            color: white;
        }
        .btn-reset {
            background: #2196F3;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;script type="text/babel"&gt;
        function CounterApp() {
            const [count, setCount] = React.useState(0);

            function increment() {
                setCount(count + 1);
            }

            function decrement() {
                setCount(count - 1);
            }

            function reset() {
                setCount(0);
            }

            return (
                &lt;div className="counter-app"&gt;
                    &lt;h1&gt;React Counter&lt;/h1&gt;
                    &lt;div className="count-display"&gt;{count}&lt;/div&gt;
                    &lt;div className="buttons"&gt;
                        &lt;button className="btn-decrement" onClick={decrement}&gt;
                            - Decrement
                        &lt;/button&gt;
                        &lt;button className="btn-reset" onClick={reset}&gt;
                            Reset
                        &lt;/button&gt;
                        &lt;button className="btn-increment" onClick={increment}&gt;
                            + Increment
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(&lt;CounterApp /&gt;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Complete Todo List App</h3>

            <p>Now let's build something more complexâ€”a todo list where you can add, complete, and delete tasks. This is a COMPLETE, working app you can copy and use!</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;React Todo App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .todo-app {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .add-todo {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .add-todo input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .add-todo button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            transition: background 0.3s;
        }
        .todo-item:hover {
            background: #f0f0f0;
        }
        .todo-item.completed {
            opacity: 0.6;
        }
        .todo-item.completed .todo-text {
            text-decoration: line-through;
        }
        .todo-checkbox {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .todo-text {
            flex: 1;
            font-size: 16px;
        }
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-stats {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;

    &lt;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;
    &lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;

    &lt;script type="text/babel"&gt;
        function TodoApp() {
            const [todos, setTodos] = React.useState([]);
            const [inputText, setInputText] = React.useState('');

            // Add a new todo
            function addTodo() {
                if (inputText.trim() === '') return; // Don't add empty todos

                const newTodo = {
                    id: Date.now(), // Simple unique ID
                    text: inputText,
                    completed: false
                };

                setTodos([...todos, newTodo]);
                setInputText(''); // Clear input
            }

            // Toggle todo completion
            function toggleTodo(id) {
                setTodos(todos.map(todo => 
                    todo.id === id 
                        ? { ...todo, completed: !todo.completed }
                        : todo
                ));
            }

            // Delete a todo
            function deleteTodo(id) {
                setTodos(todos.filter(todo => todo.id !== id));
            }

            // Handle Enter key in input
            function handleKeyPress(event) {
                if (event.key === 'Enter') {
                    addTodo();
                }
            }

            // Calculate stats
            const totalTodos = todos.length;
            const completedTodos = todos.filter(todo => todo.completed).length;
            const remainingTodos = totalTodos - completedTodos;

            return (
                &lt;div className="todo-app"&gt;
                    &lt;h1&gt;ğŸ“ My Todo List&lt;/h1&gt;
                    
                    &lt;div className="add-todo"&gt;
                        &lt;input
                            type="text"
                            value={inputText}
                            onChange={(e) =&gt; setInputText(e.target.value)}
                            onKeyPress={handleKeyPress}
                            placeholder="What do you need to do?"
                        /&gt;
                        &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
                    &lt;/div&gt;

                    &lt;div className="todo-list"&gt;
                        {todos.map(todo =&gt; (
                            &lt;div 
                                key={todo.id} 
                                className={`todo-item ${todo.completed ? 'completed' : ''}`}
                            &gt;
                                &lt;input
                                    type="checkbox"
                                    className="todo-checkbox"
                                    checked={todo.completed}
                                    onChange={() =&gt; toggleTodo(todo.id)}
                                /&gt;
                                &lt;div className="todo-text"&gt;{todo.text}&lt;/div&gt;
                                &lt;button 
                                    className="delete-btn"
                                    onClick={() =&gt; deleteTodo(todo.id)}
                                &gt;
                                    Delete
                                &lt;/button&gt;
                            &lt;/div&gt;
                        ))}
                    &lt;/div&gt;

                    {todos.length &gt; 0 && (
                        &lt;div className="todo-stats"&gt;
                            {totalTodos} total â€¢ {completedTodos} completed â€¢ {remainingTodos} remaining
                        &lt;/div&gt;
                    )}

                    {todos.length === 0 && (
                        &lt;div className="todo-stats"&gt;
                            No todos yet. Add one above! ğŸ‘†
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(&lt;TodoApp /&gt;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Deep Dive: useState Hook</h3>
            
            <p>We've used <span class="inline-code">useState</span> in our apps, but let's really understand it. What IS a hook? Why does React need them?</p>

            <div class="metaphor-box">
                <h4>Hooks as Power Outlets</h4>
                <p>Imagine React features (state, effects, context) as electricity flowing through your app. <strong>Hooks are like power outlets</strong>â€”they let you "plug in" and access that electricity from your components.<br><br>
                Before hooks (old React), only class components could access state. Hooks let ANY component access React features!</p>
            </div>

            <h4>useState Patterns</h4>
            
            <p>Let's explore different ways to use useState with complete examples:</p>

            <div class="code">// Pattern 1: Simple boolean toggle
function ToggleExample() {
  const [isOn, setIsOn] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;p&gt;The light is {isOn ? 'ON' : 'OFF'}&lt;/p&gt;
      &lt;button onClick={() =&gt; setIsOn(!isOn)}&gt;
        Toggle
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Pattern 2: Number increment/decrement
function CounterExample() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Pattern 3: Text input
function InputExample() {
  const [text, setText] = useState('');
  
  return (
    &lt;div&gt;
      &lt;input 
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder="Type something..."
      /&gt;
      &lt;p&gt;You typed: {text}&lt;/p&gt;
      &lt;p&gt;Length: {text.length} characters&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Pattern 4: Object state
function UserExample() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: ''
  });
  
  const updateField = (field, value) =&gt; {
    setUser({
      ...user,  // Copy existing fields
      [field]: value  // Update specific field
    });
  };
  
  return (
    &lt;div&gt;
      &lt;input 
        value={user.name}
        onChange={(e) =&gt; updateField('name', e.target.value)}
        placeholder="Name"
      /&gt;
      &lt;input 
        value={user.email}
        onChange={(e) =&gt; updateField('email', e.target.value)}
        placeholder="Email"
      /&gt;
      &lt;input 
        value={user.age}
        onChange={(e) =&gt; updateField('age', e.target.value)}
        placeholder="Age"
      /&gt;
      &lt;p&gt;Name: {user.name}&lt;/p&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Age: {user.age}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Pattern 5: Array state
function ListExample() {
  const [items, setItems] = useState(['Apple', 'Banana']);
  const [newItem, setNewItem] = useState('');
  
  const addItem = () =&gt; {
    if (newItem.trim()) {
      setItems([...items, newItem]);
      setNewItem('');
    }
  };
  
  const removeItem = (index) =&gt; {
    setItems(items.filter((_, i) =&gt; i !== index));
  };
  
  return (
    &lt;div&gt;
      &lt;input 
        value={newItem}
        onChange={(e) =&gt; setNewItem(e.target.value)}
        placeholder="Add item"
      /&gt;
      &lt;button onClick={addItem}&gt;Add&lt;/button&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt;
            {item}
            &lt;button onClick={() =&gt; removeItem(index)}&gt;Remove&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Common useState Mistakes</h4>
                <p><strong>Mistake 1: Mutating state directly</strong><br>
                <span class="inline-code">âŒ user.name = 'Alice'; // WRONG - React won't detect this change</span><br>
                <span class="inline-code">âœ… setUser({...user, name: 'Alice'}); // RIGHT - create new object</span><br><br>
                
                <strong>Mistake 2: Using stale state</strong><br>
                <span class="inline-code">âŒ setCount(count + 1); setCount(count + 1); // Only adds 1!</span><br>
                <span class="inline-code">âœ… setCount(prev =&gt; prev + 1); setCount(prev =&gt; prev + 1); // Adds 2!</span><br><br>
                
                <strong>Mistake 3: Too many state variables</strong><br>
                Instead of 10 separate useState calls, group related data into objects.</p>
            </div>

            <h3>Deep Dive: useEffect Hook</h3>
            
            <p>The second most important hook! <span class="inline-code">useEffect</span> lets you perform "side effects" - things that reach outside your component like fetching data, setting up subscriptions, or manually changing the DOM.</p>

            <div class="metaphor-box">
                <h4>useEffect as a News Alert</h4>
                <p>Imagine you want to know when something changes:<br><br>
                <strong>Without useEffect:</strong> You have to constantly check: "Did it change? How about now? Now?"<br>
                <strong>With useEffect:</strong> You set up an alert: "Tell me when X changes, and I'll do Y."<br><br>
                useEffect says: "React, watch these values. When they change, run this function."</p>
            </div>

            <h4>useEffect Patterns</h4>

            <div class="code">// Pattern 1: Run once on mount (like componentDidMount)
function MountExample() {
  const [data, setData] = useState(null);
  
  useEffect(() =&gt; {
    console.log('Component mounted!');
    // Good for: initial data fetch, setup
    
    fetch('https://api.example.com/data')
      .then(res =&gt; res.json())
      .then(data =&gt; setData(data));
  }, []); // Empty array = run once
  
  return &lt;div&gt;{data ? data.message : 'Loading...'}&lt;/div&gt;;
}

// Pattern 2: Run when specific value changes
function WatchExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() =&gt; {
    document.title = `Count: ${count}`;
    console.log('Count changed to:', count);
  }, [count]); // Runs when count changes
  
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;
}

// Pattern 3: Cleanup (important!)
function TimerExample() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(prev =&gt; prev + 1);
    }, 1000);
    
    // Cleanup function - runs when component unmounts
    return () =&gt; {
      console.log('Cleaning up timer');
      clearInterval(interval);
    };
  }, []);
  
  return &lt;div&gt;Seconds: {seconds}&lt;/div&gt;;
}

// Pattern 4: Multiple useEffects (separate concerns)
function MultiEffectExample() {
  const [userId, setUserId] = useState(1);
  const [theme, setTheme] = useState('light');
  
  // Effect 1: Fetch user data
  useEffect(() =&gt; {
    fetch(`https://api.example.com/users/${userId}`)
      .then(res =&gt; res.json())
      .then(data =&gt; console.log('User:', data));
  }, [userId]);
  
  // Effect 2: Update body class
  useEffect(() =&gt; {
    document.body.className = theme;
  }, [theme]);
  
  return &lt;div&gt;User {userId} with {theme} theme&lt;/div&gt;;
}</div>

            <div class="info-box">
                <h4>useEffect Dependency Array Rules</h4>
                <p><strong>Empty array []:</strong> Run once on mount<br>
                <strong>No array:</strong> Run after EVERY render (usually too much!)<br>
                <strong>[var1, var2]:</strong> Run when var1 OR var2 changes<br><br>
                React will warn you if you forget to include dependencies. Listen to those warnings!</p>
            </div>

            <h3>Complete Example: Weather App with API</h3>
            
            <p>Let's build a real app that fetches data from an API and updates based on user input:</p>

            <div class="code">function WeatherApp() {
  const [city, setCity] = useState('London');
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [inputValue, setInputValue] = useState('');
  
  useEffect(() =&gt; {
    setLoading(true);
    setError(null);
    
    // Simulated API call (replace with real API)
    fetch(`https://api.weatherapi.com/v1/current.json?key=YOUR_KEY&q=${city}`)
      .then(response =&gt; {
        if (!response.ok) throw new Error('City not found');
        return response.json();
      })
      .then(data =&gt; {
        setWeather({
          temp: data.current.temp_c,
          condition: data.current.condition.text,
          icon: data.current.condition.icon
        });
        setLoading(false);
      })
      .catch(err =&gt; {
        setError(err.message);
        setLoading(false);
      });
  }, [city]);
  
  const handleSearch = (e) =&gt; {
    e.preventDefault();
    if (inputValue.trim()) {
      setCity(inputValue);
    }
  };
  
  return (
    &lt;div style={{ padding: '20px', fontFamily: 'Arial' }}&gt;
      &lt;h1&gt;Weather App&lt;/h1&gt;
      
      &lt;form onSubmit={handleSearch}&gt;
        &lt;input
          value={inputValue}
          onChange={(e) =&gt; setInputValue(e.target.value)}
          placeholder="Enter city name"
          style={{ padding: '10px', fontSize: '16px', marginRight: '10px' }}
        /&gt;
        &lt;button type="submit" style={{ padding: '10px 20px', fontSize: '16px' }}&gt;
          Search
        &lt;/button&gt;
      &lt;/form&gt;
      
      {loading && &lt;p&gt;Loading weather for {city}...&lt;/p&gt;}
      
      {error && &lt;p style={{ color: 'red' }}&gt;Error: {error}&lt;/p&gt;}
      
      {weather && !loading && !error && (
        &lt;div style={{ marginTop: '20px', padding: '20px', border: '1px solid #ddd', borderRadius: '8px' }}&gt;
          &lt;h2&gt;{city}&lt;/h2&gt;
          &lt;img src={weather.icon} alt={weather.condition} /&gt;
          &lt;p style={{ fontSize: '32px', margin: '10px 0' }}&gt;{weather.temp}Â°C&lt;/p&gt;
          &lt;p&gt;{weather.condition}&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>What This App Demonstrates</h4>
                <p>âœ… <strong>State management:</strong> Multiple pieces of state (city, weather, loading, error)<br>
                âœ… <strong>Side effects:</strong> Fetching data with useEffect<br>
                âœ… <strong>Conditional rendering:</strong> Loading states, error states, success states<br>
                âœ… <strong>Form handling:</strong> Controlled input and submission<br>
                âœ… <strong>Real-world pattern:</strong> This is how actual production apps handle API calls!</p>
            </div>

            <h3>React Router: Multi-Page Apps</h3>
            
            <p>So far, our apps have been single-page. But what if you want multiple pages like Home, About, Contact? Enter React Router!</p>

            <div class="code">// First, include React Router from CDN (add to HTML head)
// &lt;script src="https://unpkg.com/react-router-dom@6/dist/umd/react-router-dom.production.min.js"&gt;&lt;/script&gt;

const { BrowserRouter, Routes, Route, Link, useParams } = window.ReactRouterDOM;

function Home() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Home Page&lt;/h1&gt;
      &lt;p&gt;Welcome to my app!&lt;/p&gt;
    &lt;/div&gt;
  );
}

function About() {
  return (
    &lt;div&gt;
      &lt;h1&gt;About Page&lt;/h1&gt;
      &lt;p&gt;This app was built with React!&lt;/p&gt;
    &lt;/div&gt;
  );
}

function UserProfile() {
  const { userId } = useParams(); // Get URL parameter
  return (
    &lt;div&gt;
      &lt;h1&gt;User Profile&lt;/h1&gt;
      &lt;p&gt;Viewing user: {userId}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;nav&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt; | 
        &lt;Link to="/about"&gt;About&lt;/Link&gt; | 
        &lt;Link to="/user/123"&gt;User 123&lt;/Link&gt;
      &lt;/nav&gt;
      
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/user/:userId" element={&lt;UserProfile /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>You're Now a Legit React Developer!</h4>
                <p>Look at what you've mastered:<br><br>
                âœ… Components and JSX<br>
                âœ… Props and children<br>
                âœ… useState for state management<br>
                âœ… useEffect for side effects<br>
                âœ… Event handling<br>
                âœ… Conditional rendering<br>
                âœ… Lists and keys<br>
                âœ… Forms and controlled inputs<br>
                âœ… API calls and loading states<br>
                âœ… Routing and navigation<br><br>
                These are the CORE skills. Everything else in React builds on this foundation. You're ready to build real applications!</p>
            </div>

            <h3>Practice Exercises</h3>

            <div class="info-box">
                <h4>Try These Challenges</h4>
                <p><strong>Challenge 1: Color Picker</strong><br>
                Create a component with three buttons (Red, Green, Blue). When clicked, change the background color of a div.<br><br>
                
                <strong>Challenge 2: Simple Calculator</strong><br>
                Create a calculator with two number inputs and buttons for +, -, Ã—, Ã·. Display the result.<br><br>
                
                <strong>Challenge 3: Shopping Cart</strong><br>
                Create a simple shopping cart. Add items with names and prices. Show the total cost. Add "Remove" buttons.<br><br>
                
                <strong>Challenge 4: Text Character Counter</strong><br>
                Create a textarea that shows how many characters the user has typed (like Twitter's character counter).</p>
            </div>

            <div class="metaphor-box">
                <h4>You Just Built Real React Apps!</h4>
                <p>Think about what you just did: You built actual, working applications without any fancy build tools or setup. You understand components, props, state, and eventsâ€”the core concepts of React. Everything else in React is just building on these fundamentals. You're not a beginner anymoreâ€”you're a React developer!</p>
            </div>
        </section>

        <!-- SECTION 3: Building Your First Vue App -->
        <section id="first-vue-app" class="section">
            <h2 class="section-title">Building Your First Vue App</h2>
            <p class="section-intro">Vue is React's friendly cousinâ€”it does similar things but with a different approach. Many beginners actually find Vue easier to learn because it uses familiar HTML templates instead of JSX. Let's build the same counter and todo apps in Vue so you can see the differences and decide which you prefer!</p>

            <div class="metaphor-box">
                <h4>React vs Vue: Two Paths, Same Destination</h4>
                <p>Think of React and Vue like automatic vs manual transmission cars. Both get you where you need to go. React (manual) gives you more control but has a steeper learning curve. Vue (automatic) is easier to pick up and handles more stuff automatically. Neither is "better"â€”it depends on what you prefer!</p>
            </div>

            <h3>Setting Up Vue (CDN Method)</h3>

            <p>Just like React, we can use Vue from a CDN. Vue setup is actually simplerâ€”we only need ONE script tag!</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;My First Vue App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Vue app goes here --&gt;
    &lt;div id="app"&gt;&lt;/div&gt;

    &lt;!-- Include Vue from CDN --&gt;
    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        // Vue code coming soon!
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <div class="info-box">
                <h4>Vue vs React Setup</h4>
                <p><strong>React needs:</strong> 3 script tags (React, ReactDOM, Babel)<br>
                <strong>Vue needs:</strong> Just 1 script tag!<br><br>
                Why? Vue doesn't need JSX transformationâ€”it uses regular HTML templates that the browser already understands.</p>
            </div>

            <h3>Creating Your First Vue Component</h3>
            
            <p>Let's create the simplest possible Vue appâ€”a "Hello World" message.</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My First Vue App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;!-- Vue template goes here --&gt;
        &lt;h1&gt;{{ message }}&lt;/h1&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    message: 'Hello, World! I\'m using Vue!'
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <p>Open this in a browser and you'll see "Hello, World! I'm using Vue!" That's your first Vue app!</p>

            <div class="metaphor-box">
                <h4>What's Different from React?</h4>
                <p>Notice how the template is just regular HTML? The <span class="inline-code">{{ message }}</span> syntax is how Vue puts JavaScript data into your HTML. It's simpler than JSXâ€”no need to learn new syntax rules, it's just HTML with little placeholders for your data!</p>
            </div>

            <h3>Understanding Vue's Template Syntax</h3>

            <p>Vue uses double curly braces <span class="inline-code">{{ }}</span> to insert data into your HTML. This is called "text interpolation."</p>

            <div class="code">&lt;div id="app"&gt;
    &lt;!-- Display a variable --&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    
    &lt;!-- Do math --&gt;
    &lt;p&gt;2 + 2 = {{ 2 + 2 }}&lt;/p&gt;
    
    &lt;!-- Use ternary operator --&gt;
    &lt;p&gt;{{ isLoggedIn ? 'Welcome!' : 'Please log in' }}&lt;/p&gt;
    
    &lt;!-- Call methods --&gt;
    &lt;p&gt;{{ getMessage() }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
createApp({
    data() {
        return {
            message: 'Hello Vue!',
            isLoggedIn: true
        }
    },
    methods: {
        getMessage() {
            return this.message.toUpperCase();
        }
    }
}).mount('#app');
&lt;/script&gt;</div>

            <h4>Vue Directives</h4>

            <p>Directives are special attributes that start with <span class="inline-code">v-</span>. They add special behavior to your HTML.</p>

            <div class="code">&lt;div id="app"&gt;
    &lt;!-- v-if: Show/hide based on condition --&gt;
    &lt;p v-if="isVisible"&gt;You can see me!&lt;/p&gt;
    
    &lt;!-- v-else: Show when v-if is false --&gt;
    &lt;p v-if="isLoggedIn"&gt;Welcome back!&lt;/p&gt;
    &lt;p v-else&gt;Please log in&lt;/p&gt;
    
    &lt;!-- v-show: Toggle CSS display (element stays in DOM) --&gt;
    &lt;p v-show="showMessage"&gt;Toggle me!&lt;/p&gt;
    
    &lt;!-- v-for: Loop through arrays --&gt;
    &lt;ul&gt;
        &lt;li v-for="item in items" :key="item"&gt;{{ item }}&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;!-- v-on: Listen to events (shorthand: @) --&gt;
    &lt;button v-on:click="handleClick"&gt;Click Me&lt;/button&gt;
    &lt;button @click="count++"&gt;Increment: {{ count }}&lt;/button&gt;
    
    &lt;!-- v-bind: Bind attributes (shorthand: :) --&gt;
    &lt;img v-bind:src="imageSrc"&gt;
    &lt;img :src="imageSrc"&gt;
    
    &lt;!-- v-model: Two-way data binding --&gt;
    &lt;input v-model="textInput"&gt;
    &lt;p&gt;You typed: {{ textInput }}&lt;/p&gt;
&lt;/div&gt;</div>

            <div class="info-box">
                <h4>Quick Reference: Vue Directives</h4>
                <p><strong>v-if / v-else:</strong> Conditional rendering (removes from DOM)<br>
                <strong>v-show:</strong> Toggle visibility (hides with CSS)<br>
                <strong>v-for:</strong> Loop through arrays/objects<br>
                <strong>v-on (or @):</strong> Listen to events<br>
                <strong>v-bind (or :):</strong> Bind attributes<br>
                <strong>v-model:</strong> Two-way data binding for forms</p>
            </div>

            <h3>Complete Vue Counter App</h3>

            <p>Let's build the same counter we made in React, but with Vue:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue Counter App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f0f0f0;
        }
        .counter-app {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }
        .count-display {
            font-size: 72px;
            font-weight: bold;
            margin: 20px 0;
            color: #333;
        }
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); }
        button:active { transform: scale(0.95); }
        .btn-increment { background: #42b883; color: white; }
        .btn-decrement { background: #f44336; color: white; }
        .btn-reset { background: #2196F3; color: white; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;div class="counter-app"&gt;
            &lt;h1&gt;Vue Counter&lt;/h1&gt;
            &lt;div class="count-display"&gt;{{ count }}&lt;/div&gt;
            &lt;div class="buttons"&gt;
                &lt;button class="btn-decrement" @click="decrement"&gt;- Decrement&lt;/button&gt;
                &lt;button class="btn-reset" @click="reset"&gt;Reset&lt;/button&gt;
                &lt;button class="btn-increment" @click="increment"&gt;+ Increment&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    count: 0
                };
            },
            methods: {
                increment() {
                    this.count++;
                },
                decrement() {
                    this.count--;
                },
                reset() {
                    this.count = 0;
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Complete Vue Todo App</h3>

            <p>Now the full todo list in Vue:</p>

            <div class="code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue Todo App&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .todo-app {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 { text-align: center; color: #333; }
        .add-todo { display: flex; gap: 10px; margin-bottom: 20px; }
        .add-todo input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .add-todo button {
            padding: 10px 20px;
            font-size: 16px;
            background: #42b883;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .todo-item:hover { background: #f0f0f0; }
        .todo-item.completed { opacity: 0.6; }
        .todo-item.completed .todo-text { text-decoration: line-through; }
        .todo-checkbox {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .todo-text { flex: 1; font-size: 16px; }
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .todo-stats {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;div class="todo-app"&gt;
            &lt;h1&gt;ğŸ“ My Vue Todo List&lt;/h1&gt;
            
            &lt;div class="add-todo"&gt;
                &lt;input 
                    v-model="newTodoText"
                    @keyup.enter="addTodo"
                    placeholder="What do you need to do?"
                &gt;
                &lt;button @click="addTodo"&gt;Add&lt;/button&gt;
            &lt;/div&gt;

            &lt;div class="todo-list"&gt;
                &lt;div 
                    v-for="todo in todos" 
                    :key="todo.id"
                    :class="['todo-item', { completed: todo.completed }]"
                &gt;
                    &lt;input
                        type="checkbox"
                        class="todo-checkbox"
                        v-model="todo.completed"
                    &gt;
                    &lt;div class="todo-text"&gt;{{ todo.text }}&lt;/div&gt;
                    &lt;button class="delete-btn" @click="deleteTodo(todo.id)"&gt;
                        Delete
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div v-if="todos.length &gt; 0" class="todo-stats"&gt;
                {{ todos.length }} total â€¢ {{ completedCount }} completed â€¢ {{ remainingCount }} remaining
            &lt;/div&gt;

            &lt;div v-else class="todo-stats"&gt;
                No todos yet. Add one above! ğŸ‘†
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    newTodoText: '',
                    todos: []
                };
            },
            computed: {
                completedCount() {
                    return this.todos.filter(todo =&gt; todo.completed).length;
                },
                remainingCount() {
                    return this.todos.length - this.completedCount;
                }
            },
            methods: {
                addTodo() {
                    if (this.newTodoText.trim() === '') return;
                    
                    this.todos.push({
                        id: Date.now(),
                        text: this.newTodoText,
                        completed: false
                    });
                    
                    this.newTodoText = '';
                },
                deleteTodo(id) {
                    this.todos = this.todos.filter(todo =&gt; todo.id !== id);
                }
            }
        }).mount('#app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</div>

            <h3>Vue vs React: Which Should You Choose?</h3>

            <div class="card-grid">
                <div class="card">
                    <h4>Choose React if...</h4>
                    <p>â€¢ You prefer JavaScript-first approach<br>
                    â€¢ You want maximum flexibility<br>
                    â€¢ You like a large ecosystem<br>
                    â€¢ You're building complex SPAs<br>
                    â€¢ Job market demands React skills</p>
                </div>
                <div class="card">
                    <h4>Choose Vue if...</h4>
                    <p>â€¢ You prefer template-based HTML<br>
                    â€¢ You want easier learning curve<br>
                    â€¢ You like comprehensive official tools<br>
                    â€¢ You want great documentation<br>
                    â€¢ You value simplicity</p>
                </div>
            </div>

            <div class="metaphor-box">
                <h4>The Truth: Both Are Great!</h4>
                <p>Honestly? Both React and Vue are excellent choices. The "best" framework is the one YOU understand and can be productive with. Many developers know both! Don't stress too much about this decisionâ€”what matters most is understanding the core concepts (components, state, props, events) which work similarly in both.</p>
            </div>
        </section>

        <!-- SECTION 4: Understanding State Management -->
        <section id="understanding-state" class="section">
            <h2 class="section-title">Understanding State Management</h2>
            <p class="section-intro">As your apps grow, managing data across multiple components becomes tricky. This is where state management comes in. Don't worryâ€”we'll explain it with simple examples and show you when (and when NOT) to use it!</p>

            <h3>What IS State?</h3>
            
            <p>Vue was created by Evan You after working with Angular at Google. He wanted to extract the parts he really liked about Angular and build something lighter and more flexible. The result is a framework that prioritizes:</p>

            <ul>
                <li><strong>Approachability:</strong> Gentle learning curve, especially if you know HTML, CSS, and basic JavaScript</li>
                <li><strong>Versatility:</strong> Works for projects of any size, from progressive enhancement to full SPAs</li>
                <li><strong>Performance:</strong> Fast virtual DOM implementation with automatic optimization</li>
                <li><strong>Developer Experience:</strong> Excellent tooling, clear error messages, and comprehensive documentation</li>
            </ul>

            <h4>Vue vs React: Key Differences</h4>

            <p>If you're familiar with React, here are the main philosophical differences:</p>

            <div class="code">// REACT: JavaScript-centric, JSX everywhere
function Counter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

// VUE: Template-based, HTML-centric approach
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
    &lt;button @click="count++"&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
const count = ref(0);
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Template vs JSX</h4>
                <p><strong>Vue templates</strong> are easier to read and write for most developers, especially those with HTML/CSS backgrounds. <strong>React JSX</strong> offers more JavaScript flexibility but has a steeper learning curve. Vue supports both approaches - you can use templates OR JSX render functions.</p>
            </div>

            <h3>2. Vue Fundamentals: Template Syntax & Directives</h3>

            <p>Vue's template syntax extends HTML with powerful directives that make building dynamic interfaces intuitive. Let's master each directive with practical examples.</p>

            <h4>Text Interpolation & Expressions</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Basic interpolation --&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  
  &lt;!-- JavaScript expressions work! --&gt;
  &lt;p&gt;{{ message.toUpperCase() }}&lt;/p&gt;
  &lt;p&gt;{{ number + 1 }}&lt;/p&gt;
  &lt;p&gt;{{ isActive ? 'Yes' : 'No' }}&lt;/p&gt;
  
  &lt;!-- Ternary operators, method calls --&gt;
  &lt;p&gt;{{ reversedMessage() }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, computed } from 'vue';

const message = ref('Hello Vue!');
const number = ref(41);
const isActive = ref(true);

function reversedMessage() {
  return message.value.split('').reverse().join('');
}
&lt;/script&gt;</div>

            <h4>v-bind: Dynamic Attributes</h4>

            <p>The <span class="inline-code">v-bind</span> directive dynamically binds attributes to expressions. The shorthand <span class="inline-code">:</span> is commonly used.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;img v-bind:src="imageSrc" v-bind:alt="imageAlt"&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;img :src="imageSrc" :alt="imageAlt"&gt;
  
  &lt;!-- Binding classes --&gt;
  &lt;div :class="{ active: isActive, 'text-danger': hasError }"&gt;&lt;/div&gt;
  &lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;
  
  &lt;!-- Binding styles --&gt;
  &lt;div :style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
  
  &lt;!-- Binding multiple attributes --&gt;
  &lt;div v-bind="objectOfAttrs"&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const imageSrc = ref('https://vuejs.org/logo.svg');
const imageAlt = ref('Vue Logo');
const isActive = ref(true);
const hasError = ref(false);
const activeColor = ref('#42b883');
const fontSize = ref(16);
const objectOfAttrs = ref({
  id: 'container',
  class: 'wrapper'
});
&lt;/script&gt;</div>

            <h4>v-on: Event Handling</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;button v-on:click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Method handler --&gt;
  &lt;button @click="handleClick"&gt;Click Me&lt;/button&gt;
  
  &lt;!-- Inline handler with parameters --&gt;
  &lt;button @click="say('hello')"&gt;Say Hello&lt;/button&gt;
  
  &lt;!-- Event modifiers --&gt;
  &lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;
  &lt;button @click.stop="doThis"&gt;&lt;/button&gt;
  &lt;button @click.once="doThisOnce"&gt;&lt;/button&gt;
  
  &lt;!-- Key modifiers --&gt;
  &lt;input @keyup.enter="submit"&gt;
  &lt;input @keyup.esc="clearInput"&gt;
&lt;/template&gt;

&lt;script setup&gt;
const count = ref(0);

function handleClick(event) {
  console.log('Button clicked!', event);
}

function say(message) {
  alert(message);
}
&lt;/script&gt;</div>

            <h4>v-model: Two-Way Binding</h4>

            <p>The <span class="inline-code">v-model</span> directive creates two-way data binding on form inputs, perfect for handling user input.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Text input --&gt;
  &lt;input v-model="text" placeholder="Type something"&gt;
  &lt;p&gt;You typed: {{ text }}&lt;/p&gt;
  
  &lt;!-- Textarea --&gt;
  &lt;textarea v-model="message"&gt;&lt;/textarea&gt;
  
  &lt;!-- Checkbox --&gt;
  &lt;input type="checkbox" v-model="checked" id="checkbox"&gt;
  &lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;
  
  &lt;!-- Multiple checkboxes --&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Alice"&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Bob"&gt;
  &lt;p&gt;Checked: {{ checkedNames }}&lt;/p&gt;
  
  &lt;!-- Radio buttons --&gt;
  &lt;input type="radio" v-model="picked" value="One"&gt;
  &lt;input type="radio" v-model="picked" value="Two"&gt;
  
  &lt;!-- Select --&gt;
  &lt;select v-model="selected"&gt;
    &lt;option disabled value=""&gt;Choose one&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  
  &lt;!-- v-model modifiers --&gt;
  &lt;input v-model.lazy="msg"&gt;        &lt;!-- Update on change, not input --&gt;
  &lt;input v-model.number="age"&gt;      &lt;!-- Auto-typecast to number --&gt;
  &lt;input v-model.trim="username"&gt;   &lt;!-- Auto-trim whitespace --&gt;
&lt;/template&gt;

&lt;script setup&gt;
const text = ref('');
const message = ref('');
const checked = ref(false);
const checkedNames = ref([]);
const picked = ref('');
const selected = ref('');
const msg = ref('');
const age = ref(0);
const username = ref('');
&lt;/script&gt;</div>

            <h4>v-if, v-else-if, v-else: Conditional Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;div v-if="type === 'A'"&gt;
    Type A content
  &lt;/div&gt;
  &lt;div v-else-if="type === 'B'"&gt;
    Type B content
  &lt;/div&gt;
  &lt;div v-else&gt;
    Not A or B
  &lt;/div&gt;
  
  &lt;!-- Using template for grouping --&gt;
  &lt;template v-if="loginStatus === 'loggedIn'"&gt;
    &lt;h1&gt;Welcome back!&lt;/h1&gt;
    &lt;p&gt;Your dashboard&lt;/p&gt;
  &lt;/template&gt;
&lt;/template&gt;</div>

            <div class="warning-box">
                <h4>v-if vs v-show</h4>
                <p><strong>v-if:</strong> Conditionally renders the element (truly removes/adds to DOM). Higher toggle cost, lazy rendering.<br><br>
                <strong>v-show:</strong> Always renders but toggles CSS display. Lower toggle cost, immediate rendering.<br><br>
                <strong>Use v-if</strong> when the condition rarely changes. <strong>Use v-show</strong> for frequent toggling.</p>
            </div>

            <h4>v-for: List Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Array iteration --&gt;
  &lt;ul&gt;
    &lt;li v-for="(item, index) in items" :key="item.id"&gt;
      {{ index }}: {{ item.text }}
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;!-- Object iteration --&gt;
  &lt;div v-for="(value, key, index) in userObject" :key="key"&gt;
    {{ index }}. {{ key }}: {{ value }}
  &lt;/div&gt;
  
  &lt;!-- Range --&gt;
  &lt;span v-for="n in 10" :key="n"&gt;{{ n }}&lt;/span&gt;
  
  &lt;!-- v-for with v-if (not recommended on same element) --&gt;
  &lt;template v-for="item in items" :key="item.id"&gt;
    &lt;li v-if="!item.hidden"&gt;{{ item.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/template&gt;

&lt;script setup&gt;
const items = ref([
  { id: 1, text: 'Learn Vue', hidden: false },
  { id: 2, text: 'Build App', hidden: false },
  { id: 3, text: 'Deploy', hidden: true }
]);

const userObject = ref({
  name: 'Alice',
  age: 28,
  email: 'alice@example.com'
});
&lt;/script&gt;</div>

            <div class="warning-box">
                <h4>Always Use :key with v-for</h4>
                <p>Vue needs keys to track each node's identity for efficient DOM updates. Without keys, Vue uses an "in-place patch" strategy that can cause issues with stateful components or animations. Always provide unique, stable keys!</p>
            </div>

            <h3>3. Composition API Deep Dive</h3>

            <p>The Composition API is Vue 3's revolutionary approach to organizing component logic. It provides better code reusability, type inference, and logical organization compared to the Options API.</p>

            <h4>Why Composition API?</h4>

            <div class="metaphor-box">
                <h4>Organization by Concern</h4>
                <p>The Options API organizes code by option type (data, methods, computed, etc.) - like organizing books by size. The Composition API organizes by logical concern - like organizing books by topic. When you need to understand the "user authentication" feature, all related code is together rather than scattered across multiple options.</p>
            </div>

            <h4>setup() and &lt;script setup&gt;</h4>

            <div class="code">&lt;!-- Traditional setup() function --&gt;
&lt;script&gt;
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const double = computed(() =&gt; count.value * 2);
    
    function increment() {
      count.value++;
    }
    
    // Must return everything you want to expose to template
    return {
      count,
      double,
      increment
    };
  }
};
&lt;/script&gt;

&lt;!-- Modern &lt;script setup&gt; (preferred!) --&gt;
&lt;script setup&gt;
import { ref, computed } from 'vue';

// Everything defined here is automatically exposed to template
const count = ref(0);
const double = computed(() =&gt; count.value * 2);

function increment() {
  count.value++;
}
// No need to return anything!
&lt;/script&gt;</div>

            <h4>ref() vs reactive()</h4>

            <p>Understanding the difference between <span class="inline-code">ref</span> and <span class="inline-code">reactive</span> is crucial for mastering Vue's reactivity system.</p>

            <div class="code">&lt;script setup&gt;
import { ref, reactive } from 'vue';

// ref: For primitives and single values
const count = ref(0);
const message = ref('Hello');
const user = ref({ name: 'Alice' });

// Access via .value in script, automatic unwrap in template
count.value++;                    // In script: need .value
console.log(user.value.name);     // In script: need .value

// reactive: For objects only
const state = reactive({
  count: 0,
  message: 'Hello',
  nested: {
    value: 42
  }
});

// Direct access, no .value needed
state.count++;
state.nested.value = 100;

// GOTCHA: Destructuring loses reactivity with reactive()
const { count, message } = state;  // âŒ NOT reactive anymore!

// Use toRefs() to maintain reactivity
import { toRefs } from 'vue';
const { count, message } = toRefs(state);  // âœ… Still reactive!
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>When to Use ref vs reactive</h4>
                <p><strong>Use ref():</strong> For primitive values, single objects, or when you need to replace the entire object reference.<br><br>
                <strong>Use reactive():</strong> For complex objects with many properties that you'll mutate in place.<br><br>
                <strong>Common pattern:</strong> Many developers use <span class="inline-code">ref()</span> for everything for consistency, even for objects.</p>
            </div>

            <h4>computed(): Derived State</h4>

            <div class="code">&lt;script setup&gt;
import { ref, computed } from 'vue';

const firstName = ref('John');
const lastName = ref('Doe');

// Read-only computed
const fullName = computed(() =&gt; {
  return `${firstName.value} ${lastName.value}`;
});

// Writable computed (getter + setter)
const fullNameWritable = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ');
  }
});

// Computed with complex logic
const items = ref([
  { id: 1, name: 'Apple', price: 1.5, quantity: 3 },
  { id: 2, name: 'Banana', price: 0.8, quantity: 5 }
]);

const totalPrice = computed(() =&gt; {
  return items.value.reduce((total, item) =&gt; {
    return total + (item.price * item.quantity);
  }, 0).toFixed(2);
});

const expensiveItems = computed(() =&gt; {
  return items.value.filter(item =&gt; item.price &gt; 1);
});
&lt;/script&gt;</div>

            <h4>watch() and watchEffect()</h4>

            <p>Vue provides two ways to react to reactive state changes: <span class="inline-code">watch()</span> and <span class="inline-code">watchEffect()</span>.</p>

            <div class="code">&lt;script setup&gt;
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);
const user = ref({ name: 'Alice', age: 25 });

// watch: Explicit source, access old and new values
watch(count, (newValue, oldValue) =&gt; {
  console.log(`Count changed from ${oldValue} to ${newValue}`);
});

// watch multiple sources
watch([count, user], ([newCount, newUser], [oldCount, oldUser]) =&gt; {
  console.log('Count or user changed');
});

// watch with options
watch(user, (newUser) =&gt; {
  console.log('User changed:', newUser);
}, {
  deep: true,       // Watch nested properties
  immediate: true   // Run immediately on mount
});

// watchEffect: Automatic dependency tracking
watchEffect(() =&gt; {
  // Automatically tracks count and user.name as dependencies
  console.log(`${user.value.name} has count: ${count.value}`);
});

// watchEffect with cleanup
watchEffect((onCleanup) =&gt; {
  const timer = setTimeout(() =&gt; {
    console.log('Delayed log:', count.value);
  }, 1000);
  
  // Cleanup function runs before next execution and on unmount
  onCleanup(() =&gt; {
    clearTimeout(timer);
  });
});
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>watch vs watchEffect</h4>
                <p><strong>Use watch()</strong> when you need to access previous values, watch specific sources, or perform side effects only when certain dependencies change.<br><br>
                <strong>Use watchEffect()</strong> for simpler cases where you want automatic dependency tracking and don't need old values.</p>
            </div>

            <h3>4. Component Communication</h3>

            <h4>Props: Parent to Child</h4>

            <div class="code">&lt;!-- Child Component: UserCard.vue --&gt;
&lt;template&gt;
  &lt;div class="user-card"&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
    &lt;p&gt;Role: {{ role }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define props with TypeScript-style type annotation
const props = defineProps({
  user: {
    type: Object,
    required: true
  },
  role: {
    type: String,
    default: 'Guest'
  },
  age: {
    type: Number,
    validator: (value) =&gt; value &gt;= 0
  }
});

// Access props
console.log(props.user.name);
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;UserCard :user="currentUser" role="Admin" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import UserCard from './UserCard.vue';
const currentUser = ref({ name: 'Alice', age: 28 });
&lt;/script&gt;</div>

            <h4>Emits: Child to Parent</h4>

            <div class="code">&lt;!-- Child Component: CustomButton.vue --&gt;
&lt;template&gt;
  &lt;button @click="handleClick"&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define emits
const emit = defineEmits(['click', 'custom-event']);

function handleClick(event) {
  // Emit with data
  emit('click', { timestamp: Date.now(), event });
  emit('custom-event', 'some data');
}
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;CustomButton @click="onButtonClick" @custom-event="onCustom"&gt;
    Click Me
  &lt;/CustomButton&gt;
&lt;/template&gt;

&lt;script setup&gt;
function onButtonClick(data) {
  console.log('Button clicked at:', data.timestamp);
}

function onCustom(data) {
  console.log('Custom event:', data);
}
&lt;/script&gt;</div>

            <h4>provide/inject: Deep Component Communication</h4>

            <div class="code">&lt;!-- Grandparent Component --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue';

const theme = ref('dark');
const user = ref({ name: 'Alice', role: 'admin' });

// Provide to all descendants
provide('theme', theme);
provide('user', user);

// Provide with read-only access
import { readonly } from 'vue';
provide('config', readonly({
  apiUrl: 'https://api.example.com'
}));
&lt;/script&gt;

&lt;!-- Deep Child Component (any level deep) --&gt;
&lt;script setup&gt;
import { inject } from 'vue';

// Inject provided values
const theme = inject('theme');
const user = inject('user');

// Inject with default value
const config = inject('config', { apiUrl: 'fallback' });

// Now you can use theme, user, config
console.log(theme.value);  // 'dark'
&lt;/script&gt;</div>

            <h4>Slots: Content Distribution</h4>

            <div class="code">&lt;!-- Card Component with Slots --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;div class="card-header"&gt;
      &lt;slot name="header"&gt;Default Header&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-body"&gt;
      &lt;slot&gt;Default Content&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-footer"&gt;
      &lt;slot name="footer" :data="footerData"&gt;
        Default Footer
      &lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const footerData = ref({ timestamp: new Date() });
&lt;/script&gt;

&lt;!-- Using the Card --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;template #header&gt;
      &lt;h2&gt;My Custom Header&lt;/h2&gt;
    &lt;/template&gt;
    
    &lt;!-- Default slot --&gt;
    &lt;p&gt;This is the main content&lt;/p&gt;
    
    &lt;!-- Scoped slot receiving data --&gt;
    &lt;template #footer="{ data }"&gt;
      &lt;small&gt;Last updated: {{ data.timestamp }}&lt;/small&gt;
    &lt;/template&gt;
  &lt;/Card&gt;
&lt;/template&gt;</div>

            <h3>5. Pinia State Management</h3>

            <p>Pinia is the official state management solution for Vue 3, replacing Vuex. It offers a simpler API, better TypeScript support, and modular design.</p>

            <h4>Creating a Store</h4>

            <div class="code">// stores/counter.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

// Composition API style (recommended)
export const useCounterStore = defineStore('counter', () =&gt; {
  // State
  const count = ref(0);
  const name = ref('Counter Store');
  
  // Getters (computed)
  const doubleCount = computed(() =&gt; count.value * 2);
  const isEven = computed(() =&gt; count.value % 2 === 0);
  
  // Actions (functions)
  function increment() {
    count.value++;
  }
  
  function incrementBy(amount) {
    count.value += amount;
  }
  
  async function fetchCount() {
    const response = await fetch('/api/count');
    const data = await response.json();
    count.value = data.count;
  }
  
  return {
    count,
    name,
    doubleCount,
    isEven,
    increment,
    incrementBy,
    fetchCount
  };
});

// Options API style (alternative)
export const useCounterStore = defineStore('counter', {
  state: () =&gt; ({
    count: 0,
    name: 'Counter Store'
  }),
  getters: {
    doubleCount: (state) =&gt; state.count * 2,
    isEven: (state) =&gt; state.count % 2 === 0
  },
  actions: {
    increment() {
      this.count++;
    },
    incrementBy(amount) {
      this.count += amount;
    }
  }
});</div>

            <h4>Using Stores in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ counter.count }}&lt;/p&gt;
    &lt;p&gt;Double: {{ counter.doubleCount }}&lt;/p&gt;
    &lt;p&gt;Is Even: {{ counter.isEven }}&lt;/p&gt;
    &lt;button @click="counter.increment"&gt;Increment&lt;/button&gt;
    &lt;button @click="counter.incrementBy(5)"&gt;Add 5&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useCounterStore } from '@/stores/counter';

// Get store instance
const counter = useCounterStore();

// Destructure with reactivity (use storeToRefs!)
import { storeToRefs } from 'pinia';
const { count, doubleCount, isEven } = storeToRefs(counter);
const { increment, incrementBy } = counter;  // Actions don't need storeToRefs

// Watch store state
watch(() =&gt; counter.count, (newCount) =&gt; {
  console.log('Count changed:', newCount);
});
&lt;/script&gt;</div>

            <h4>Complex Store Example: User Authentication</h4>

            <div class="code">// stores/auth.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () =&gt; {
  // State
  const user = ref(null);
  const token = ref(localStorage.getItem('token') || null);
  const loading = ref(false);
  const error = ref(null);
  
  // Getters
  const isAuthenticated = computed(() =&gt; !!token.value);
  const userRole = computed(() =&gt; user.value?.role || 'guest');
  const isAdmin = computed(() =&gt; userRole.value === 'admin');
  
  // Actions
  async function login(email, password) {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      token.value = data.token;
      user.value = data.user;
      
      localStorage.setItem('token', data.token);
      
      return true;
    } catch (err) {
      error.value = err.message;
      return false;
    } finally {
      loading.value = false;
    }
  }
  
  function logout() {
    user.value = null;
    token.value = null;
    localStorage.removeItem('token');
  }
  
  async function fetchUser() {
    if (!token.value) return;
    
    try {
      const response = await fetch('/api/user', {
        headers: { Authorization: `Bearer ${token.value}` }
      });
      
      const data = await response.json();
      user.value = data;
    } catch (err) {
      // Token invalid, logout
      logout();
    }
  }
  
  return {
    user,
    token,
    loading,
    error,
    isAuthenticated,
    userRole,
    isAdmin,
    login,
    logout,
    fetchUser
  };
});</div>

            <h3>6. Vue Router Deep Dive</h3>

            <h4>Router Setup</h4>

            <div class="code">// router/index.js
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

const routes = [
  {
    path: '/',
    name: 'home',
    component: Home
  },
  {
    path: '/about',
    name: 'about',
    component: About
  },
  {
    path: '/user/:id',
    name: 'user',
    component: () =&gt; import('@/views/User.vue'),  // Lazy loading
    props: true  // Pass route params as props
  },
  {
    path: '/dashboard',
    component: () =&gt; import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: '',
        name: 'dashboard-home',
        component: () =&gt; import('@/views/DashboardHome.vue')
      },
      {
        path: 'profile',
        name: 'profile',
        component: () =&gt; import('@/views/Profile.vue')
      }
    ]
  },
  {
    // Catch all 404
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () =&gt; import('@/views/NotFound.vue')
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;</div>

            <h4>Navigation Guards</h4>

            <div class="code">// Global navigation guard
router.beforeEach(async (to, from) =&gt; {
  const authStore = useAuthStore();
  
  // Check authentication
  if (to.meta.requiresAuth &amp;&amp; !authStore.isAuthenticated) {
    return { name: 'login' };
  }
  
  // Check admin access
  if (to.meta.requiresAdmin &amp;&amp; !authStore.isAdmin) {
    return { name: 'forbidden' };
  }
  
  // Allow navigation
  return true;
});

// Per-route guard
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from) =&gt; {
      if (!isAdmin()) {
        return { name: 'home' };
      }
    }
  }
];</div>

            <h4>Using Router in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- Declarative navigation --&gt;
    &lt;router-link to="/"&gt;Home&lt;/router-link&gt;
    &lt;router-link :to="{ name: 'user', params: { id: 123 } }"&gt;
      User 123
    &lt;/router-link&gt;
    
    &lt;!-- Router view --&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRouter, useRoute } from 'vue-router';

const router = useRouter();
const route = useRoute();

// Programmatic navigation
function goToUser(id) {
  router.push({ name: 'user', params: { id } });
}

function goBack() {
  router.go(-1);
}

// Access route params/query
const userId = computed(() =&gt; route.params.id);
const searchQuery = computed(() =&gt; route.query.search);

// Watch route changes
watch(() =&gt; route.params.id, (newId) =&gt; {
  console.log('User ID changed:', newId);
});
&lt;/script&gt;</div>

            <h3>7. Composables: Reusable Logic</h3>

            <p>Composables are the Vue equivalent of React hooks - reusable functions that encapsulate stateful logic.</p>

            <div class="code">// composables/useFetch.js
import { ref } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);
  const loading = ref(false);
  
  async function fetchData() {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  }
  
  fetchData();
  
  return { data, error, loading, refetch: fetchData };
}

// Usage in component
&lt;script setup&gt;
import { useFetch } from '@/composables/useFetch';

const { data: users, loading, error } = useFetch('/api/users');
&lt;/script&gt;

// composables/useLocalStorage.js
import { ref, watch } from 'vue';

export function useLocalStorage(key, defaultValue) {
  const storedValue = localStorage.getItem(key);
  const data = ref(storedValue ? JSON.parse(storedValue) : defaultValue);
  
  watch(data, (newValue) =&gt; {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return data;
}

// Usage
const user = useLocalStorage('user', { name: 'Guest' });

// composables/useMousePosition.js
export function useMousePosition() {
  const x = ref(0);
  const y = ref(0);
  
  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }
  
  onMounted(() =&gt; {
    window.addEventListener('mousemove', update);
  });
  
  onUnmounted(() =&gt; {
    window.removeEventListener('mousemove', update);
  });
  
  return { x, y };
}</div>

            <h3>8. Lifecycle Hooks</h3>

            <div class="code">&lt;script setup&gt;
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted
} from 'vue';

// Before component is mounted to DOM
onBeforeMount(() =&gt; {
  console.log('Before mount');
});

// After component is mounted (DOM available)
onMounted(() =&gt; {
  console.log('Mounted - DOM ready');
  // Perfect for:
  // - API calls
  // - DOM manipulation
  // - Setting up listeners
});

// Before reactive data changes trigger re-render
onBeforeUpdate(() =&gt; {
  console.log('Before update');
});

// After reactive data changes and DOM updates
onUpdated(() =&gt; {
  console.log('Updated - DOM has changed');
});

// Before component is unmounted
onBeforeUnmount(() =&gt; {
  console.log('Before unmount');
  // Cleanup here
});

// After component is unmounted
onUnmounted(() =&gt; {
  console.log('Unmounted');
  // Final cleanup
});
&lt;/script&gt;</div>

            <h3>9. Form Handling & Validation</h3>

            <h4>Advanced v-model</h4>

            <div class="code">&lt;!-- Custom component with v-model --&gt;
&lt;!-- CustomInput.vue --&gt;
&lt;template&gt;
  &lt;input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  &gt;
&lt;/template&gt;

&lt;script setup&gt;
defineProps(['modelValue']);
defineEmits(['update:modelValue']);
&lt;/script&gt;

&lt;!-- Usage --&gt;
&lt;CustomInput v-model="text" /&gt;

&lt;!-- Multiple v-models --&gt;
&lt;UserForm
  v-model:firstName="firstName"
  v-model:lastName="lastName"
/&gt;</div>

            <h4>Form Validation with Vuelidate</h4>

            <div class="code">&lt;script setup&gt;
import { useVuelidate } from '@vuelidate/core';
import { required, email, minLength } from '@vuelidate/validators';

const formData = reactive({
  email: '',
  password: '',
  confirmPassword: ''
});

const rules = {
  email: { required, email },
  password: { required, minLength: minLength(8) },
  confirmPassword: {
    required,
    sameAs: (value) =&gt; value === formData.password
  }
};

const v$ = useVuelidate(rules, formData);

async function submitForm() {
  const isValid = await v$.value.$validate();
  
  if (!isValid) {
    console.log('Validation errors:', v$.value.$errors);
    return;
  }
  
  // Submit form
  console.log('Form valid, submitting...');
}
&lt;/script&gt;

&lt;template&gt;
  &lt;form @submit.prevent="submitForm"&gt;
    &lt;div&gt;
      &lt;input v-model="formData.email" placeholder="Email"&gt;
      &lt;span v-if="v$.email.$error"&gt;
        {{ v$.email.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;input v-model="formData.password" type="password"&gt;
      &lt;span v-if="v$.password.$error"&gt;
        {{ v$.password.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;</div>

            <h3>10. Performance Optimization</h3>

            <div class="code">&lt;template&gt;
  &lt;!-- v-once: Render once, never update --&gt;
  &lt;p v-once&gt;{{ staticContent }}&lt;/p&gt;
  
  &lt;!-- v-memo: Skip re-render if dependencies unchanged --&gt;
  &lt;div v-memo="[user.id, user.name]"&gt;
    &lt;UserCard :user="user" /&gt;
  &lt;/div&gt;
  
  &lt;!-- Lazy load components --&gt;
  &lt;component :is="AsyncComponent" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue';

// Lazy load heavy component
const AsyncComponent = defineAsyncComponent(() =&gt;
  import('./HeavyComponent.vue')
);

// Computed caching (automatically memoized)
const expensiveComputation = computed(() =&gt; {
  return items.value.reduce((sum, item) =&gt; sum + item.price, 0);
});

// Use shallowRef for large objects you rarely mutate
import { shallowRef } from 'vue';
const bigDataset = shallowRef({ /* thousands of items */ });
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Vue Performance Tips</h4>
                <p>
                â€¢ Use <span class="inline-code">v-show</span> for frequently toggled elements<br>
                â€¢ Use <span class="inline-code">v-if</span> for rarely changed conditions<br>
                â€¢ Always provide keys for v-for<br>
                â€¢ Lazy load route components<br>
                â€¢ Use computed for expensive calculations<br>
                â€¢ Use shallowRef/shallowReactive for large data structures<br>
                â€¢ Implement virtual scrolling for large lists (vue-virtual-scroller)<br>
                â€¢ Debounce expensive operations (user input, API calls)
                </p>
            </div>

            <div class="metaphor-box">
                <h4>Vue's Philosophy: Progressive Simplicity</h4>
                <p>Vue is designed to be incrementally adoptable - you start simple and add complexity only when needed. It's like learning to drive: you start with the basics (turning, braking), then gradually add advanced skills (parallel parking, highway merging). You don't need to know everything to be productive, but the advanced features are there when you're ready.</p>
            </div>
        </section>

        <!-- SECTION 3: State Management (Redux, Zustand, Recoil, Context) -->
        <section id="state-management" class="section">
            <h2 class="section-title">State Management</h2>
            <p class="section-intro">As your apps grow bigger, you'll notice something: passing data between components gets messy FAST. You end up passing props through 5 layers of components just to get data where it needs to go. That's where state management comes in. Let's understand why it exists and when you actually need it.</p>

            <h3>What Even IS State Management?</h3>
            
            <p>Let's start with a simple question: what is "state"?</p>

            <div class="metaphor-box">
                <h4>State is Just Data That Changes</h4>
                <p>Think of state like the current "status" of your app:<br><br>
                â€¢ Is the user logged in? (state: <span class="inline-code">isLoggedIn = true</span>)<br>
                â€¢ What's in the shopping cart? (state: <span class="inline-code">cartItems = [...]</span>)<br>
                â€¢ Is the modal open? (state: <span class="inline-code">modalOpen = false</span>)<br>
                â€¢ What page are we on? (state: <span class="inline-code">currentPage = 'home'</span>)<br><br>
                State is literally just variables that your app cares about. When state changes, your UI updates to match.</p>
            </div>

            <h4>The Problem: Prop Drilling Hell</h4>
            
            <p>Imagine you have this component structure:</p>

            <div class="code">App
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ UserMenu
â”‚   â”‚   â””â”€â”€ Avatar (needs user data!)
â”‚   â””â”€â”€ Notifications
â”œâ”€â”€ Sidebar
â”‚   â””â”€â”€ Profile (needs user data!)
â””â”€â”€ MainContent
    â””â”€â”€ Dashboard (needs user data!)</div>

            <p>The user data lives in <span class="inline-code">App</span>, but three components deep down need it. In regular React, you'd have to do this:</p>

            <div class="code">// App.jsx
function App() {
  const [user, setUser] = useState({name: 'Alice', email: 'alice@example.com'});
  
  return (
    &lt;div&gt;
      &lt;Header user={user} /&gt;  {/* Pass it down */}
      &lt;Sidebar user={user} /&gt;  {/* Pass it again */}
      &lt;MainContent user={user} /&gt;  {/* And again! */}
    &lt;/div&gt;
  );
}

// Header.jsx
function Header({ user }) {
  return (
    &lt;header&gt;
      &lt;UserMenu user={user} /&gt;  {/* Pass it down more! */}
    &lt;/header&gt;
  );
}

// UserMenu.jsx
function UserMenu({ user }) {
  return (
    &lt;div&gt;
      &lt;Avatar user={user} /&gt;  {/* FINALLY! */}
    &lt;/div&gt;
  );
}

// Avatar.jsx
function Avatar({ user }) {
  return &lt;img src={user.avatar} alt={user.name} /&gt;;
}</div>

            <div class="warning-box">
                <h4>The Prop Drilling Problem</h4>
                <p>This is called <strong>"prop drilling"</strong> - passing props through components that don't even use them, just to get data to deeply nested children. Problems:<br><br>
                â€¢ Components in the middle don't need the data but must pass it<br>
                â€¢ Adding/removing props means changing many files<br>
                â€¢ It's annoying and error-prone<br>
                â€¢ Your code becomes a mess of prop passing</p>
            </div>

            <h3>The Solution: Global State</h3>
            
            <p>What if instead of passing data through every component, you could put it in a "global store" that ANY component can access?</p>

            <div class="metaphor-box">
                <h4>The Billboard Metaphor</h4>
                <p><strong>Prop Drilling:</strong> Like whispering a message from person to person down a line. Each person has to remember and pass it along.<br><br>
                <strong>Global State:</strong> Like putting the message on a billboard. Everyone can just look up and see it whenever they need it. No passing required!</p>
            </div>

            <h4>React Context: Built-in Solution</h4>
            
            <p>React has a built-in way to share state globally: <strong>Context</strong>.</p>

            <div class="code">// 1. Create a context
import { createContext, useContext, useState } from 'react';

const UserContext = createContext();

// 2. Provide the data at the top level
function App() {
  const [user, setUser] = useState({name: 'Alice', email: 'alice@example.com'});
  
  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      &lt;Header /&gt;
      &lt;Sidebar /&gt;
      &lt;MainContent /&gt;
    &lt;/UserContext.Provider&gt;
  );
}

// 3. Use the data anywhere (no prop drilling!)
function Avatar() {
  const { user } = useContext(UserContext);
  
  return &lt;img src={user.avatar} alt={user.name} /&gt;;
}

// No need to pass user through Header or UserMenu anymore!</div>

            <div class="info-box">
                <h4>How Context Works</h4>
                <p><strong>Provider:</strong> Wraps your app and makes data available<br>
                <strong>Consumer:</strong> Any component that needs the data can "consume" it with <span class="inline-code">useContext</span><br><br>
                Think of Provider as the billboard owner, and consumers as people reading the billboard.</p>
            </div>

            <h4>When Do You Actually Need State Management?</h4>
            
            <p>Not every app needs global state! Here's when you DO and DON'T need it:</p>

            <div class="code">// DON'T need global state - simple component state is fine
function Counter() {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() => setCount(count + 1)}&gt;{count}&lt;/button&gt;
}

// DON'T need global state - just passing one level down
function ParentComponent() {
  const [data, setData] = useState('hello');
  return &lt;ChildComponent data={data} /&gt;
}

// DO need global state - many components need this data
function App() {
  // User info, theme, shopping cart, auth status
  // Used by Header, Sidebar, Footer, Dashboard, Profile...
  // DON'T want to prop drill through everything!
}</div>

            <div class="info-box">
                <h4>Simple Rule</h4>
                <p><strong>Use local state (useState)</strong> when:<br>
                â€¢ Only one component needs the data<br>
                â€¢ Data doesn't need to be shared<br><br>
                <strong>Use global state (Context/Redux)</strong> when:<br>
                â€¢ Multiple unrelated components need the same data<br>
                â€¢ You're passing props through 3+ levels<br>
                â€¢ Data needs to persist across page navigation</p>
            </div>

            <h3>Introduction to Redux (Advanced Option)</h3>
            
            <p>Context is great for small apps. For big apps with LOTS of global state, developers often use <strong>Redux</strong>.</p>

            <div class="metaphor-box">
                <h4>Context vs Redux</h4>
                <p><strong>Context:</strong> Like a bulletin board in your house. Good for a few messages.<br><br>
                <strong>Redux:</strong> Like a filing cabinet system with organized drawers and labels. Better when you have LOTS of data to manage.<br><br>
                For beginners: Start with Context. Graduate to Redux when you feel Context getting messy.</p>
            </div>

            <h4>Complete Shopping Cart Example</h4>
            
            <p>Let's build a shopping cart with Context to see state management in action:</p>

            <div class="code">// CartContext.jsx
import { createContext, useContext, useState } from 'react';

const CartContext = createContext();

export function CartProvider({ children }) {
  const [cart, setCart] = useState([]);
  
  const addToCart = (item) => {
    setCart([...cart, item]);
  };
  
  const removeFromCart = (itemId) => {
    setCart(cart.filter(item => item.id !== itemId));
  };
  
  const totalPrice = cart.reduce((sum, item) => sum + item.price, 0);
  
  return (
    &lt;CartContext.Provider value={{ cart, addToCart, removeFromCart, totalPrice }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

export function useCart() {
  return useContext(CartContext);
}

// App.jsx
function App() {
  return (
    &lt;CartProvider&gt;
      &lt;Header /&gt;
      &lt;ProductList /&gt;
      &lt;Cart /&gt;
    &lt;/CartProvider&gt;
  );
}

// Header.jsx (shows cart count)
function Header() {
  const { cart } = useCart();
  
  return (
    &lt;header&gt;
      &lt;h1&gt;My Shop&lt;/h1&gt;
      &lt;div&gt;Cart: {cart.length} items&lt;/div&gt;
    &lt;/header&gt;
  );
}

// ProductList.jsx (adds items)
function ProductList() {
  const { addToCart } = useCart();
  const products = [
    { id: 1, name: 'Laptop', price: 999 },
    { id: 2, name: 'Mouse', price: 29 }
  ];
  
  return (
    &lt;div&gt;
      {products.map(product => (
        &lt;div key={product.id}&gt;
          &lt;h3&gt;{product.name}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;button onClick={() => addToCart(product)}&gt;
            Add to Cart
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Cart.jsx (displays cart)
function Cart() {
  const { cart, removeFromCart, totalPrice } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Your Cart&lt;/h2&gt;
      {cart.map(item => (
        &lt;div key={item.id}&gt;
          &lt;span&gt;{item.name} - ${item.price}&lt;/span&gt;
          &lt;button onClick={() => removeFromCart(item.id)}&gt;
            Remove
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
      &lt;h3&gt;Total: ${totalPrice}&lt;/h3&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>What Just Happened?</h4>
                <p><strong>1. CartProvider:</strong> Wraps the app and holds cart state<br>
                <strong>2. useCart hook:</strong> Makes it easy to access cart anywhere<br>
                <strong>3. Multiple components:</strong> Header, ProductList, and Cart all use the same cart data<br>
                <strong>4. No prop drilling:</strong> Each component directly accesses what it needs</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered State Management Basics!</h4>
                <p>You now understand when and why to use state management. For most beginner projects, Context is more than enough. As you build bigger apps, you'll naturally feel when you need something more powerful like Redux. Don't overcomplicateâ€”use the simplest solution that works!</p>
            </div>
        </section>

        <!-- SECTION 4: API Integration -->
        <section id="api-integration" class="section">
            <h2 class="section-title">API Integration</h2>
            <p class="section-intro">Your frontend is looking good! But right now it's like a beautiful restaurant with no kitchenâ€”it has no data. Real apps need to talk to servers to get data, save user info, fetch products, etc. That's where APIs come in. Let's learn how to connect your frontend to the backend!</p>

            <h3>What is an API? (Review from Section 1)</h3>
            
            <p>Quick recap: API stands for Application Programming Interface. In simple terms, it's a menu of actions your app can request from a server.</p>

            <div class="metaphor-box">
                <h4>The Restaurant Menu Metaphor</h4>
                <p>An API is like a restaurant menu:<br><br>
                <strong>Menu:</strong> "You can order: burger, pizza, salad"<br>
                <strong>API:</strong> "You can request: user data, product list, weather info"<br><br>
                You (frontend) look at the menu, place an order, and the kitchen (backend) prepares it and sends it back.</p>
            </div>

            <h4>HTTP Methods: The Basic Actions</h4>
            
            <p>When talking to APIs, you use different "methods" depending on what you want to do:</p>

            <div class="code">GET    - Read/Fetch data ("Give me the user info")
POST   - Create new data ("Create a new user account")
PUT    - Update existing data ("Update user email")
DELETE - Remove data ("Delete this post")

// Think of it like:
GET    = Read a book
POST   = Write a new book
PUT    = Edit an existing book
DELETE = Throw away a book</div>

            <h3>Making Your First API Request</h3>
            
            <p>JavaScript has a built-in function called <span class="inline-code">fetch()</span> that lets you talk to APIs:</p>

            <div class="code">// Basic fetch syntax
fetch('https://api.example.com/users')
  .then(response => response.json())  // Convert to JavaScript object
  .then(data => {
    console.log(data);  // Do something with the data
  })
  .catch(error => {
    console.error('Error:', error);  // Handle errors
  });</div>

            <p>Let's break this down step by step:</p>

            <div class="info-box">
                <h4>How fetch() Works</h4>
                <p><strong>1. fetch(url):</strong> Makes a request to the URL<br>
                <strong>2. .then(response => ...):</strong> Waits for server response<br>
                <strong>3. response.json():</strong> Converts response to usable JavaScript<br>
                <strong>4. .then(data => ...):</strong> Now you have the data!<br>
                <strong>5. .catch(error => ...):</strong> Handles errors if something goes wrong</p>
            </div>

            <h4>Modern Way: async/await (Easier to Read!)</h4>
            
            <p>There's a cleaner way to write fetch requests:</p>

            <div class="code">// Modern async/await syntax (preferred!)
async function getUsers() {
  try {
    const response = await fetch('https://api.example.com/users');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

getUsers();</div>

            <div class="metaphor-box">
                <h4>Why async/await is Better</h4>
                <p>Think of <span class="inline-code">.then().then().then()</span> like nested Russian dolls - you keep opening one to get to the next.<br><br>
                <span class="inline-code">async/await</span> is like laying everything out in a line - much easier to read and understand!</p>
            </div>

            <h3>Complete React Example: Fetching User Data</h3>
            
            <div class="code">import React, { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);  // Store users
  const [loading, setLoading] = useState(true);  // Track loading state
  const [error, setError] = useState(null);  // Track errors
  
  useEffect(() => {
    // Fetch users when component mounts
    async function fetchUsers() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        
        if (!response.ok) {
          throw new Error('Failed to fetch');
        }
        
        const data = await response.json();
        setUsers(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    
    fetchUsers();
  }, []);  // Empty array = run once when component loads
  
  // Show loading
  if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;
  
  // Show error
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;
  
  // Show users
  return (
    &lt;div&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
      &lt;ul&gt;
        {users.map(user => (
          &lt;li key={user.id}&gt;{user.name} - {user.email}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>The Three States Pattern</h4>
                <p>When fetching data, always track:<br><br>
                <strong>1. Loading:</strong> Waiting for data<br>
                <strong>2. Error:</strong> Something went wrong<br>
                <strong>3. Success:</strong> Got the data!<br><br>
                This gives users feedback instead of a blank screen.</p>
            </div>

            <h3>Sending Data: POST Requests</h3>
            
            <p>GET requests fetch data. POST requests send data to create something new:</p>

            <div class="code">async function createUser(userData) {
  try {
    const response = await fetch('https://api.example.com/users', {
      method: 'POST',  // Specify POST method
      headers: {
        'Content-Type': 'application/json'  // Tell server we're sending JSON
      },
      body: JSON.stringify(userData)  // Convert JavaScript object to JSON string
    });
    
    const data = await response.json();
    console.log('User created:', data);
  } catch (error) {
    console.error('Error creating user:', error);
  }
}

// Usage
createUser({
  name: 'Alice',
  email: 'alice@example.com',
  age: 28
});</div>

            <h4>Complete Form Submission Example</h4>
            
            <div class="code">function SignupForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  const [message, setMessage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();  // Prevent page reload
    setIsSubmitting(true);
    setMessage('');
    
    try {
      const response = await fetch('https://api.example.com/signup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (!response.ok) {
        throw new Error('Signup failed');
      }
      
      const data = await response.json();
      setMessage('Signup successful! Welcome ' + data.username);
    } catch (error) {
      setMessage('Error: ' + error.message);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        placeholder="Username"
        value={formData.username}
        onChange={(e) => setFormData({...formData, username: e.target.value})}
      /&gt;
      &lt;input
        type="email"
        placeholder="Email"
        value={formData.email}
        onChange={(e) => setFormData({...formData, email: e.target.value})}
      /&gt;
      &lt;input
        type="password"
        placeholder="Password"
        value={formData.password}
        onChange={(e) => setFormData({...formData, password: e.target.value})}
      /&gt;
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Signing up...' : 'Sign Up'}
      &lt;/button&gt;
      {message && &lt;p&gt;{message}&lt;/p&gt;}
    &lt;/form&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Common API Mistakes</h4>
                <p><strong>1. Forgetting await:</strong> Without await, you get a Promise, not the data<br>
                <strong>2. Not handling errors:</strong> Always use try/catch<br>
                <strong>3. Not showing loading state:</strong> Users see blank screen<br>
                <strong>4. Forgetting headers:</strong> Server needs to know you're sending JSON<br>
                <strong>5. CORS errors:</strong> Your backend needs to allow requests from your frontend domain</p>
            </div>

            <div class="metaphor-box">
                <h4>You're Now Full-Stack Ready!</h4>
                <p>Congratulations! You now know how to connect a frontend to a backend. Your components can fetch data, submit forms, and create a complete user experience. This is THE skill that makes you a full-stack developerâ€”you can build the beautiful frontend AND connect it to real data!</p>
            </div>
        </section>

        <!-- SECTION 5: Real-Time Features -->
        <section id="realtime-features" class="section">
            <h2 class="section-title">Real-Time Features</h2>
            <p class="section-intro">So far, your app fetches data when a page loads. But what if you want LIVE updatesâ€”like a chat app where messages appear instantly, or a stock ticker that updates prices in real-time? That's where WebSockets come in. Let's learn how to make your app "live"!</p>

            <h3>The Problem with Regular HTTP</h3>
            
            <p>Remember our restaurant metaphor? Regular HTTP (fetch requests) works like this:</p>

            <div class="metaphor-box">
                <h4>HTTP: One-Time Orders</h4>
                <p><strong>You:</strong> "Can I have a burger?" (GET request)<br>
                <strong>Kitchen:</strong> "Here's your burger!" (Response)<br>
                <strong>Connection closes.</strong><br><br>
                If you want updates, you have to keep asking: "Any new messages? How about now? Now?" This is called <strong>polling</strong> and it's inefficient.</p>
            </div>

            <h4>The Solution: WebSockets (Two-Way Connection)</h4>
            
            <div class="metaphor-box">
                <h4>WebSockets: Open Phone Line</h4>
                <p>Instead of placing separate orders, imagine having an open phone line with the kitchen:<br><br>
                <strong>You:</strong> "Keep me updated on order status"<br>
                <strong>Kitchen:</strong> "Will do! I'll call you when things change"<br>
                <strong>Connection stays open.</strong><br><br>
                The kitchen can now send you updates INSTANTLY without you asking each time.</p>
            </div>

            <h3>When Do You Need Real-Time?</h3>
            
            <p>Real-time features are POWERFUL but add complexity. Use them when:</p>

            <div class="code">// DO use real-time for:
â€¢ Chat applications (messages appear instantly)
â€¢ Live notifications ("John liked your post!")
â€¢ Multiplayer games (player positions update)
â€¢ Live dashboards (stock prices, analytics)
â€¢ Collaborative editing (Google Docs style)

// DON'T use real-time for:
â€¢ Static content (blog posts, product listings)
â€¢ Data that rarely changes (user profiles)
â€¢ One-time actions (form submissions)</div>

            <div class="info-box">
                <h4>Simple Rule</h4>
                <p>If data changes <strong>every few seconds and users need immediate updates</strong>, use real-time. Otherwise, regular fetch requests are simpler and perfectly fine!</p>
            </div>

            <h3>Simple WebSocket Example</h3>
            
            <p>Here's how to create a WebSocket connection in JavaScript:</p>

            <div class="code">// 1. Connect to WebSocket server
const socket = new WebSocket('ws://localhost:3000');

// 2. Listen for connection open
socket.onopen = () => {
  console.log('Connected to server!');
  socket.send('Hello server!');  // Send a message
};

// 3. Listen for messages from server
socket.onmessage = (event) => {
  console.log('Message from server:', event.data);
};

// 4. Listen for errors
socket.onerror = (error) => {
  console.error('WebSocket error:', error);
};

// 5. Listen for connection close
socket.onclose = () => {
  console.log('Disconnected from server');
};</div>

            <div class="info-box">
                <h4>WebSocket Events</h4>
                <p><strong>onopen:</strong> Connection established<br>
                <strong>onmessage:</strong> Received data from server<br>
                <strong>onerror:</strong> Something went wrong<br>
                <strong>onclose:</strong> Connection closed<br><br>
                Think of these like notification settingsâ€”you're telling the app what to do when each event happens.</p>
            </div>

            <h4>Complete React Chat Example</h4>
            
            <div class="code">import React, { useState, useEffect, useRef } from 'react';

function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef(null);
  
  useEffect(() => {
    // Connect to WebSocket server when component mounts
    socketRef.current = new WebSocket('ws://localhost:3000');
    
    socketRef.current.onopen = () => {
      console.log('Connected!');
      setIsConnected(true);
    };
    
    socketRef.current.onmessage = (event) => {
      // Add new message to list
      const newMessage = JSON.parse(event.data);
      setMessages(prev => [...prev, newMessage]);
    };
    
    socketRef.current.onclose = () => {
      console.log('Disconnected');
      setIsConnected(false);
    };
    
    // Cleanup: close connection when component unmounts
    return () => {
      socketRef.current.close();
    };
  }, []);  // Empty array = run once when component loads
  
  const sendMessage = (e) => {
    e.preventDefault();
    
    if (!inputValue.trim()) return;  // Don't send empty messages
    
    const message = {
      text: inputValue,
      timestamp: new Date().toISOString(),
      username: 'You'
    };
    
    // Send to server
    socketRef.current.send(JSON.stringify(message));
    
    // Clear input
    setInputValue('');
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Chat Room&lt;/h2&gt;
      &lt;div&gt;Status: {isConnected ? 'âœ… Connected' : 'âŒ Disconnected'}&lt;/div&gt;
      
      &lt;div style={{ border: '1px solid #ccc', padding: '10px', height: '300px', overflowY: 'scroll' }}&gt;
        {messages.map((msg, index) => (
          &lt;div key={index}&gt;
            &lt;strong&gt;{msg.username}:&lt;/strong&gt; {msg.text}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      &lt;form onSubmit={sendMessage}&gt;
        &lt;input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Type a message..."
          disabled={!isConnected}
        /&gt;
        &lt;button type="submit" disabled={!isConnected}&gt;
          Send
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="warning-box">
                <h4>Important: useRef for WebSockets</h4>
                <p>Notice we used <span class="inline-code">useRef</span> instead of <span class="inline-code">useState</span> for the socket? That's because:<br><br>
                â€¢ We don't want React re-rendering when socket changes<br>
                â€¢ We need the SAME socket instance across re-renders<br>
                â€¢ <span class="inline-code">useRef</span> persists values without causing re-renders</p>
            </div>

            <h3>Simple Backend Example (Node.js)</h3>
            
            <p>To test your WebSocket frontend, you need a simple backend. Here's a basic Node.js WebSocket server:</p>

            <div class="code">// Install: npm install ws
const WebSocket = require('ws');

const server = new WebSocket.Server({ port: 3000 });

const clients = new Set();

server.on('connection', (socket) => {
  console.log('Client connected');
  clients.add(socket);
  
  // When client sends message, broadcast to all clients
  socket.on('message', (message) => {
    console.log('Received:', message);
    
    // Send to all connected clients
    clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  socket.on('close', () => {
    console.log('Client disconnected');
    clients.delete(socket);
  });
});

console.log('WebSocket server running on ws://localhost:3000');</div>

            <div class="info-box">
                <h4>What This Server Does</h4>
                <p><strong>1. Creates WebSocket server</strong> on port 3000<br>
                <strong>2. Tracks connected clients</strong> in a Set<br>
                <strong>3. Receives messages</strong> and broadcasts to all clients<br>
                <strong>4. Handles disconnections</strong> by removing from Set<br><br>
                This creates a simple chat room where everyone sees everyone's messages!</p>
            </div>

            <h4>Socket.io: The Easy Way</h4>
            
            <p>Raw WebSockets are powerful but basic. Most developers use <strong>Socket.io</strong> libraryâ€”it adds automatic reconnection, rooms, and easier APIs:</p>

            <div class="code">// Backend with Socket.io (easier!)
const io = require('socket.io')(3000);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  socket.on('chat-message', (message) => {
    // Broadcast to everyone except sender
    socket.broadcast.emit('chat-message', message);
  });
  
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

// Frontend with Socket.io
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

// Send message
socket.emit('chat-message', { text: 'Hello!' });

// Receive messages
socket.on('chat-message', (message) => {
  console.log('New message:', message);
});</div>

            <div class="metaphor-box">
                <h4>You've Unlocked Real-Time!</h4>
                <p>Real-time features make apps feel alive and responsive. Chat apps, live notifications, collaborative toolsâ€”they all use WebSockets or Socket.io. You now have the foundation to build interactive, live experiences. Start with simple chat, then expand to more complex features as you grow!</p>
            </div>
        </section>

        <!-- SECTION 6: Authentication -->
        <section id="authentication" class="section">
            <h2 class="section-title">Authentication & Authorization</h2>
            <p class="section-intro">Almost every real app needs users to log in. But how does a website "remember" you're logged in? How does it prevent others from accessing your account? Let's demystify authenticationâ€”it's simpler than you think!</p>

            <h3>Authentication vs Authorization (What's the Difference?)</h3>
            
            <div class="metaphor-box">
                <h4>The Concert Venue Metaphor</h4>
                <p><strong>Authentication:</strong> Proving WHO you are<br>
                â†’ Showing your ID at the door: "Yes, you are Alice"<br><br>
                <strong>Authorization:</strong> Proving WHAT you can access<br>
                â†’ Checking your ticket type: "VIP ticket = backstage access"<br><br>
                <strong>Authentication = Identity</strong><br>
                <strong>Authorization = Permissions</strong></p>
            </div>

            <h4>How Login Actually Works (Step-by-Step)</h4>
            
            <p>Let's walk through what happens when you log in to a website:</p>

            <div class="code">1. User enters username + password
2. Frontend sends credentials to backend (POST /login)
3. Backend checks database: "Does this user exist?"
4. Backend checks password: "Does it match the stored hash?"
5. If valid: Backend generates a TOKEN (like a temporary badge)
6. Backend sends token back to frontend
7. Frontend stores token (usually in localStorage)
8. For future requests, frontend includes token in headers
9. Backend validates token: "Is this token valid?"
10. If valid: Backend processes request
11. If invalid/expired: Backend returns 401 Unauthorized

Logout = Delete the token</div>

            <div class="info-box">
                <h4>What's a Token?</h4>
                <p>A token is a long random string that proves you're logged in. Think of it like a temporary ID badge:<br><br>
                <strong>Example token:</strong> <span class="inline-code">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</span><br><br>
                The token contains encoded info (user ID, expiration time) that the backend can decode and verify. Most apps use <strong>JWT (JSON Web Tokens)</strong>.</p>
            </div>

            <h3>Complete Login Flow (Frontend)</h3>
            
            <div class="code">import React, { useState } from 'react';

function LoginPage() {
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);
    
    try {
      const response = await fetch('https://api.example.com/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Invalid credentials');
      }
      
      const data = await response.json();
      
      // Store token in localStorage
      localStorage.setItem('authToken', data.token);
      
      // Redirect to dashboard or home
      window.location.href = '/dashboard';
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Login&lt;/h2&gt;
      &lt;form onSubmit={handleLogin}&gt;
        &lt;input
          type="email"
          placeholder="Email"
          value={credentials.email}
          onChange={(e) => setCredentials({...credentials, email: e.target.value})}
          required
        /&gt;
        &lt;input
          type="password"
          placeholder="Password"
          value={credentials.password}
          onChange={(e) => setCredentials({...credentials, password: e.target.value})}
          required
        /&gt;
        &lt;button type="submit" disabled={isLoading}&gt;
          {isLoading ? 'Logging in...' : 'Login'}
        &lt;/button&gt;
        {error && &lt;p style={{color: 'red'}}&gt;{error}&lt;/p&gt;}
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</div>

            <h4>Making Authenticated Requests</h4>
            
            <p>Once logged in, include the token in ALL requests to protected endpoints:</p>

            <div class="code">// Get user profile (protected route)
async function getUserProfile() {
  const token = localStorage.getItem('authToken');
  
  const response = await fetch('https://api.example.com/profile', {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`  // Include token!
    }
  });
  
  if (response.status === 401) {
    // Token invalid/expired - redirect to login
    localStorage.removeItem('authToken');
    window.location.href = '/login';
    return;
  }
  
  const data = await response.json();
  return data;
}</div>

            <div class="warning-box">
                <h4>Security: Bearer Token Format</h4>
                <p>The <span class="inline-code">Authorization: Bearer TOKEN</span> format is standard. The backend expects this exact format. "Bearer" means "whoever holds (bears) this token has access."</p>
            </div>

            <h3>Protected Routes in React</h3>
            
            <p>How do you prevent users from accessing pages unless they're logged in? Use a <strong>ProtectedRoute</strong> component:</p>

            <div class="code">import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const token = localStorage.getItem('authToken');
  
  // If no token, redirect to login
  if (!token) {
    return &lt;Navigate to="/login" /&gt;;
  }
  
  // If token exists, show the page
  return children;
}

// Usage in your routes
function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;Route path="/signup" element={&lt;SignupPage /&gt;} /&gt;
      
      {/* Protected routes */}
      &lt;Route path="/dashboard" element={
        &lt;ProtectedRoute&gt;
          &lt;Dashboard /&gt;
        &lt;/ProtectedRoute&gt;
      } /&gt;
      
      &lt;Route path="/profile" element={
        &lt;ProtectedRoute&gt;
          &lt;Profile /&gt;
        &lt;/ProtectedRoute&gt;
      } /&gt;
    &lt;/Routes&gt;
  );
}</div>

            <div class="info-box">
                <h4>How ProtectedRoute Works</h4>
                <p><strong>1. Check for token:</strong> Does user have authToken in localStorage?<br>
                <strong>2. If NO:</strong> Redirect to /login<br>
                <strong>3. If YES:</strong> Render the protected page<br><br>
                This ensures users can't access pages by typing the URL directly.</p>
            </div>

            <h4>Complete Auth Context (Global State)</h4>
            
            <p>For a real app, you'll want authentication state available everywhere:</p>

            <div class="code">import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Check if user is logged in on mount
  useEffect(() => {
    const token = localStorage.getItem('authToken');
    if (token) {
      // Fetch user data from backend
      fetchUserProfile(token)
        .then(userData => setUser(userData))
        .catch(() => {
          // Token invalid
          localStorage.removeItem('authToken');
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    const data = await response.json();
    localStorage.setItem('authToken', data.token);
    setUser(data.user);
  };
  
  const logout = () => {
    localStorage.removeItem('authToken');
    setUser(null);
    window.location.href = '/login';
  };
  
  return (
    &lt;AuthContext.Provider value={{ user, login, logout, loading }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

export function useAuth() {
  return useContext(AuthContext);
}

// Usage in any component
function Dashboard() {
  const { user, logout } = useAuth();
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
    &lt;/div&gt;
  );
}</div>

            <div class="metaphor-box">
                <h4>You're Now Security-Aware!</h4>
                <p>Authentication is fundamental to almost every app. You now understand tokens, protected routes, and global auth state. Remember: NEVER store passwords in frontend, ALWAYS use HTTPS in production, and tokens should expire (typically 1-7 days). You're ready to build secure, user-based applications!</p>
            </div>
        </section>

        <!-- SECTION 7: File Uploads -->
        <section id="file-uploads" class="section">
            <h2 class="section-title">File Uploads & Media</h2>
            <p class="section-intro">Users need to upload profile pictures, documents, videosâ€”how do you handle files in your web app? Let's learn how to accept file uploads, validate them, preview images, and send them to your backend!</p>

            <h3>The HTML File Input</h3>
            
            <p>The simplest way to let users select files is the HTML file input:</p>

            <div class="code">&lt;input type="file" /&gt;

// With restrictions:
&lt;input type="file" accept="image/*" /&gt;  {/* Only images */}
&lt;input type="file" accept=".pdf,.doc,.docx" /&gt;  {/* Only documents */}
&lt;input type="file" multiple /&gt;  {/* Allow multiple files */}</div>

            <h3>Complete React File Upload Example</h3>
            
            <div class="code">import React, { useState } from 'react';

function ImageUpload() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [preview, setPreview] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [message, setMessage] = useState('');
  
  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    
    if (!file) return;
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
      setMessage('Please select an image file');
      return;
    }
    
    // Validate file size (e.g., max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      setMessage('File too large (max 5MB)');
      return;
    }
    
    setSelectedFile(file);
    
    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result);
    };
    reader.readAsDataURL(file);
  };
  
  const handleUpload = async () => {
    if (!selectedFile) return;
    
    setUploading(true);
    setMessage('');
    
    // Create FormData (special format for file uploads)
    const formData = new FormData();
    formData.append('image', selectedFile);
    
    try {
      const response = await fetch('https://api.example.com/upload', {
        method: 'POST',
        body: formData  // Don't set Content-Type - browser does it automatically
      });
      
      if (!response.ok) throw new Error('Upload failed');
      
      const data = await response.json();
      setMessage('Upload successful! URL: ' + data.url);
    } catch (error) {
      setMessage('Error: ' + error.message);
    } finally {
      setUploading(false);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Upload Image&lt;/h2&gt;
      
      &lt;input type="file" accept="image/*" onChange={handleFileSelect} /&gt;
      
      {preview && (
        &lt;div&gt;
          &lt;h3&gt;Preview:&lt;/h3&gt;
          &lt;img src={preview} alt="Preview" style={{ maxWidth: '300px' }} /&gt;
        &lt;/div&gt;
      )}
      
      &lt;button onClick={handleUpload} disabled={!selectedFile || uploading}&gt;
        {uploading ? 'Uploading...' : 'Upload'}
      &lt;/button&gt;
      
      {message && &lt;p&gt;{message}&lt;/p&gt;}
    &lt;/div&gt;
  );
}</div>

            <div class="info-box">
                <h4>Key File Upload Concepts</h4>
                <p><strong>1. FormData:</strong> Special object for sending files (can mix files + text data)<br>
                <strong>2. FileReader:</strong> Reads file contents for preview<br>
                <strong>3. Validation:</strong> Check type and size before uploading<br>
                <strong>4. No Content-Type header:</strong> Browser sets it automatically with boundary</p>
            </div>

            <div class="metaphor-box">
                <h4>You Can Now Handle File Uploads!</h4>
                <p>File uploads are essential for modern apps. Whether it's profile pictures, documents, or media filesâ€”you now have the foundation to handle them securely and efficiently!</p>
            </div>
        </section>

        <!-- SECTION 8: PWA Features -->
        <section id="pwa-features" class="section">
            <h2 class="section-title">Progressive Web Apps</h2>
            <p class="section-intro">What if your website could work offline? What if users could install it like a real app? That's what Progressive Web Apps (PWAs) doâ€”they're websites that feel like native apps!</p>

            <h3>What is a PWA?</h3>
            
            <div class="metaphor-box">
                <h4>Regular Website vs PWA</h4>
                <p><strong>Regular Website:</strong> Like a newspaperâ€”needs internet, can't be installed<br><br>
                <strong>PWA:</strong> Like a magazine you downloadâ€”works offline, installs to home screen, feels like an app<br><br>
                Examples: Twitter Lite, Pinterest, Starbucks web app</p>
            </div>

            <h4>PWA Features</h4>
            
            <div class="code">âœ… Works offline (caches content)
âœ… Installable (add to home screen)
âœ… Push notifications
âœ… Fast loading (pre-cached resources)
âœ… Works on any device
âœ… No app store needed</div>

            <h3>Basic PWA Setup</h3>
            
            <p>Two files make your site a PWA:</p>

            <div class="code">// 1. manifest.json - App metadata
{
  "name": "My Awesome App",
  "short_name": "MyApp",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

// 2. service-worker.js - Offline functionality
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll(['/index.html', '/styles.css', '/app.js']);
    })
  );
});</div>

            <div class="metaphor-box">
                <h4>PWAs: The Future of Web Apps</h4>
                <p>PWAs bridge the gap between websites and native apps. They're easier to build than native apps but offer similar experiences. As you advance, explore PWA capabilities!</p>
            </div>
        </section>

        <!-- SECTION 9: Testing Integration -->
        <section id="testing-integration" class="section">
            <h2 class="section-title">Testing Full-Stack Apps</h2>
            <p class="section-intro">How do you know your app actually works? Testing! Let's learn why testing matters and how to write simple tests for your frontend and backend.</p>

            <h3>Why Test?</h3>
            
            <div class="metaphor-box">
                <h4>Testing as Safety Net</h4>
                <p>Imagine walking a tightrope:<br><br>
                <strong>No tests:</strong> No safety netâ€”one mistake and everything breaks<br>
                <strong>With tests:</strong> Safety net catches errors before users see them<br><br>
                Tests ensure your code works NOW and KEEPS working when you make changes.</p>
            </div>

            <h4>Types of Tests (Simple Explanation)</h4>
            
            <div class="code">1. Unit Tests - Test one function in isolation
   Example: "Does the `add(2, 3)` function return 5?"

2. Integration Tests - Test components working together
   Example: "Does clicking login button call the API?"

3. End-to-End Tests - Test entire user flows
   Example: "Can a user sign up, log in, and make a purchase?"</div>

            <h3>Simple React Component Test</h3>
            
            <div class="code">// Component
function Greeting({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
}

// Test (using Jest + React Testing Library)
import { render, screen } from '@testing-library/react';

test('displays greeting with name', () => {
  render(&lt;Greeting name="Alice" /&gt;);
  expect(screen.getByText('Hello, Alice!')).toBeInTheDocument();
});</div>

            <div class="info-box">
                <h4>Testing Benefits</h4>
                <p>âœ… Catch bugs before users do<br>
                âœ… Confidence when refactoring<br>
                âœ… Documentation (tests show how code should work)<br>
                âœ… Faster development (find bugs instantly)</p>
            </div>

            <div class="metaphor-box">
                <h4>You're Test-Aware!</h4>
                <p>Testing is a huge topic, but now you understand WHY it matters. Start with simple tests for critical features, then expand as you grow!</p>
            </div>
        </section>

        <!-- SECTION 10: Deployment & Scaling -->
        <section id="deployment-scaling" class="section">
            <h2 class="section-title">Deployment & Scaling</h2>
            <p class="section-intro">Your app is built! Now how do you get it online for the world to see? Let's deploy your frontend and backend, and understand what happens when you get LOTS of users.</p>

            <h3>What is Deployment?</h3>
            
            <div class="metaphor-box">
                <h4>Deployment = Moving Day</h4>
                <p><strong>Development (localhost):</strong> Building furniture in your garage<br>
                <strong>Deployment (production):</strong> Moving furniture to your house where guests can see it<br><br>
                Deployment means putting your code on a server that's accessible 24/7 from anywhere.</p>
            </div>

            <h3>Deploying Your Frontend (Free!)</h3>
            
            <h4>Option 1: Vercel (Easiest for React/Next.js)</h4>
            
            <div class="code">// Step 1: Install Vercel CLI
npm install -g vercel

// Step 2: Navigate to your project
cd my-react-app

// Step 3: Deploy!
vercel

// Follow prompts, get live URL instantly:
// https://my-app.vercel.app âœ…</div>

            <h4>Option 2: Netlify (Great for any static site)</h4>
            
            <div class="code">// Method 1: Drag & Drop (easiest!)
1. Go to netlify.com
2. Drag your build folder (npm run build)
3. Done! Live URL given

// Method 2: CLI
npm install -g netlify-cli
netlify deploy</div>

            <h4>Option 3: GitHub Pages (Free, GitHub integration)</h4>
            
            <div class="code">// 1. Install gh-pages package
npm install --save-dev gh-pages

// 2. Add to package.json
"scripts": {
  "predeploy": "npm run build",
  "deploy": "gh-pages -d build"
}

// 3. Deploy!
npm run deploy

// Live at: https://yourusername.github.io/repo-name</div>

            <div class="info-box">
                <h4>All Three Are FREE!</h4>
                <p><strong>Vercel:</strong> Best for Next.js, serverless functions included<br>
                <strong>Netlify:</strong> Great forms, serverless functions, easy custom domains<br>
                <strong>GitHub Pages:</strong> Perfect for static sites, portfolios</p>
            </div>

            <h3>Deploying Your Backend</h3>
            
            <h4>Option 1: Railway (Easiest)</h4>
            
            <div class="code">// 1. Push code to GitHub
// 2. Go to railway.app
// 3. Click "Deploy from GitHub"
// 4. Select your repo
// 5. Railway auto-detects Node.js and deploys!
// 6. Get live API URL</div>

            <h4>Option 2: Render (Great free tier)</h4>
            
            <div class="code">// Similar to Railway:
1. Connect GitHub
2. Select repo
3. Configure:
   - Build: npm install
   - Start: npm start
4. Deploy!</div>

            <h3>Environment Variables</h3>
            
            <p>NEVER put secrets in code! Use environment variables:</p>

            <div class="code">// Local: .env file
DATABASE_URL=postgres://...
API_KEY=secret123

// In code:
const dbUrl = process.env.DATABASE_URL;

// On hosting platform:
// Add env vars in dashboard settings</div>

            <div class="warning-box">
                <h4>Production Checklist</h4>
                <p>âœ… Environment variables set<br>
                âœ… HTTPS enabled (automatic on Vercel/Netlify)<br>
                âœ… Database has backups<br>
                âœ… Error logging enabled<br>
                âœ… .env file in .gitignore</p>
            </div>

            <h3>What is Scaling?</h3>
            
            <div class="metaphor-box">
                <h4>Scaling = Handling Growth</h4>
                <p><strong>10 users:</strong> One cashier at a coffee shopâ€”easy<br>
                <strong>10,000 users:</strong> Need more cashiers, bigger kitchen, more supplies<br><br>
                Scaling means your app can handle increasing users without slowing down or crashing.</p>
            </div>

            <h4>Two Types of Scaling</h4>
            
            <div class="code">// Vertical Scaling ("Scale Up")
Upgrade server:
Small server â†’ Bigger server (more CPU/RAM)
Like: Getting a faster computer

// Horizontal Scaling ("Scale Out")
Add more servers:
1 server â†’ 10 servers working together
Like: Hiring more cashiers</div>

            <div class="info-box">
                <h4>When to Worry About Scaling</h4>
                <p><strong>Don't worry yet if you have:</strong> < 1,000 users<br>
                <strong>Start optimizing at:</strong> 10,000+ users<br>
                <strong>Need serious scaling at:</strong> 100,000+ users<br><br>
                Most beginners over-optimize too early. Focus on BUILDING first!</p>
            </div>

            <h3>Quick Performance Wins</h3>
            
            <div class="code">// 1. Image optimization
&lt;img src="photo.jpg" loading="lazy" /&gt;  {/* Lazy load */}
Use WebP format (smaller size)

// 2. Code splitting (React)
import React, { lazy, Suspense } from 'react';
const HeavyComponent = lazy(() => import('./Heavy'));

// 3. Caching
Cache-Control: max-age=3600  {/* Cache for 1 hour */}

// 4. Minimize bundle size
npm run build  {/* Minifies code automatically */}</div>

            <div class="metaphor-box">
                <h4>ğŸ‰ Congratulations! You're a Full-Stack Developer!</h4>
                <p>You've learned:<br><br>
                âœ… <strong>Frontend:</strong> React/Vue components, state, routing<br>
                âœ… <strong>Backend:</strong> APIs, databases, authentication<br>
                âœ… <strong>Integration:</strong> Connecting frontend to backend<br>
                âœ… <strong>Real-time:</strong> WebSockets for live features<br>
                âœ… <strong>Files:</strong> Handling uploads<br>
                âœ… <strong>Deployment:</strong> Getting your app online<br><br>
                <strong>What's next?</strong> BUILD! Start with a todo app with authentication, then a chat app, then your dream project. Every app you build makes you better. The learning never stops, but you now have the foundation to build ANYTHING.<br><br>
                Welcome to the world of full-stack development. Now go build something amazing! ğŸš€</p>
            </div>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>

