<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 08: Full-Stack Integration - Part I - NullSector</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #0a0a0a; --bg3: #111;
            --text: #fff; --text2: #888; --text3: #555;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; overflow-x: hidden; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; padding: 0 2rem; }
        .header-content { width: 100%; max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .brand { display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav { display: flex; gap: 2rem; align-items: center; }
        .nav a { color: var(--text2); text-decoration: none; font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .nav a:hover { color: var(--text); }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-toggle { cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: var(--text2); font-size: 0.95rem; font-weight: 500; transition: color 0.3s; }
        .dropdown-toggle:hover { color: var(--text); }
        .dropdown-menu { position: absolute; top: 100%; left: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 8px; margin-top: 0.5rem; min-width: 200px; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.3s cubic-bezier(0.16,1,0.3,1); z-index: 1001; }
        .dropdown:hover .dropdown-menu { opacity: 1; visibility: visible; transform: translateY(0); }
        .dropdown-menu a { display: block; padding: 1rem 1.5rem; color: var(--text2); text-decoration: none; transition: all 0.2s; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .dropdown-menu a:last-child { border-bottom: none; }
        .dropdown-menu a:hover { background: rgba(255,255,255,0.05); color: var(--text); padding-left: 2rem; }
        .dropdown-arrow { font-size: 0.7rem; transition: transform 0.3s; }
        .dropdown:hover .dropdown-arrow { transform: rotate(180deg); }
        .sidebar { position: fixed; left: 0; top: 70px; width: 280px; height: calc(100vh - 70px); background: var(--bg2); border-right: 1px solid var(--border); overflow-y: auto; padding: 2rem 0; z-index: 100; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        .sidebar-section { padding: 0 1.5rem; margin-bottom: 2rem; }
        .sidebar-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); margin-bottom: 1rem; }
        .sidebar-link { display: block; color: var(--text2); text-decoration: none; padding: 0.6rem 1rem; margin: 0.25rem 0; border-radius: 6px; font-size: 0.9rem; transition: all 0.3s; }
        .sidebar-link:hover { background: rgba(255,255,255,0.05); color: var(--text); transform: translateX(4px); }
        .sidebar-link.active { background: rgba(255,255,255,0.1); color: var(--text); font-weight: 600; }
        .main { margin-left: 280px; margin-top: 70px; padding: 4rem 3rem; max-width: 1100px; }
        .page-header { margin-bottom: 4rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border); }
        .chapter-label { font-size: 0.875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: var(--text3); margin-bottom: 1rem; }
        .page-title { font-size: 3.5rem; font-weight: 800; line-height: 1.2; margin-bottom: 1rem; letter-spacing: -1px; }
        .page-subtitle { font-size: 1.25rem; color: var(--text2); font-weight: 400; line-height: 1.6; }
        .section { margin-bottom: 6rem; scroll-margin-top: 100px; }
        .section-title { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .section-intro { font-size: 1.125rem; color: var(--text2); margin-bottom: 2rem; line-height: 1.8; }
        h3 { font-size: 1.75rem; font-weight: 600; margin: 3rem 0 1.5rem; }
        h4 { font-size: 1.375rem; font-weight: 600; margin: 2.5rem 0 1.25rem; }
        p { font-size: 1.0625rem; line-height: 1.8; margin-bottom: 1.5rem; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0; }
        .card { background: var(--bg3); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; transition: all 0.3s; }
        .card:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.2); }
        .card h4 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; }
        .card p { color: var(--text2); font-size: 0.9375rem; margin-bottom: 0; }
        .info-box { background: var(--bg3); border-left: 3px solid var(--text); padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .info-box h4 { font-weight: 600; margin-bottom: 0.75rem; margin-top: 0; }
        .info-box p { color: var(--text2); margin-bottom: 0; }
        .warning-box { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-left: 3px solid #ff6b6b; padding: 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; word-wrap: break-word; overflow-wrap: break-word; }
        .warning-box h4 { font-weight: 600; margin-bottom: 0.75rem; color: #ff6b6b; margin-top: 0; }
        .code { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; line-height: 1.7; white-space: pre-wrap; word-wrap: break-word; max-width: 100%; }
        .inline-code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.875em; white-space: nowrap; }
        .metaphor-box { background: rgba(255,255,255,0.03); border-left: 4px solid var(--text); padding: 1.5rem 2.5rem 1.5rem 1.5rem; margin: 2rem 0; border-radius: 0 8px 8px 0; position: relative; word-wrap: break-word; overflow-wrap: break-word; }
        .metaphor-box::before { content: "üí°"; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; }
        .metaphor-box h4 { margin-bottom: 0.75rem; font-weight: 600; margin-top: 0; }
        ul, ol { margin: 1.5rem 0; padding-left: 2rem; }
        li { margin: 0.75rem 0; color: var(--text2); }
        table { width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg2); font-weight: 600; font-size: 0.875rem; text-transform: uppercase; }
        td { color: var(--text2); font-size: 0.9375rem; }
        .progress { position: fixed; top: 70px; left: 0; height: 3px; background: linear-gradient(90deg, var(--text) 0%, var(--text2) 100%); transition: width 0.1s; z-index: 1001; }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); } .main { margin-left: 0; padding: 3rem 2rem; } .page-title { font-size: 2.5rem; } }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="brand">
                <img src="logo.svg" alt="NullSector" width="36" height="36">
                <span>NullSector</span>
            </a>
            <nav class="nav">
                <a href="roadmap-hacking.html">Hacking</a>
                <a href="roadmap-programming.html">Programming</a>
                <a href="resources.html">Resources</a>
                <div class="dropdown">
                    <span class="dropdown-toggle">
                        Null Tools
                        <span class="dropdown-arrow">‚ñº</span>
                    </span>
                    <div class="dropdown-menu">
                        <a href="https://github.com/4fqr/null-cli" target="_blank">Null CLI</a>
                        <a href="https://nullheadline.vercel.app/" target="_blank">Null Hacker's Headlines</a>
                        <a href="https://github.com/4fqr/nullmysteryorg" target="_blank">Null: Mystery Organisation</a>
                        <a href="https://github.com/4fqr/null-ide/" target="_blank">Null IDE</a>
                    </div>
                </div>
                <a href="null-terminal.html">Null Terminal</a>
                <a href="faq.html">FAQs</a>
                <a href="https://discord.gg/cMvWkxFbbX" target="_blank">Discord</a>
            </nav>
        </div>
    </header>

    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">On This Page</div>
            <a href="#react-deep-dive" class="sidebar-link">React Deep Dive</a>
            <a href="#vue-mastery" class="sidebar-link">Vue Mastery</a>
            <a href="#state-management" class="sidebar-link">State Management</a>
            <a href="#api-integration" class="sidebar-link">API Integration</a>
            <a href="#realtime-features" class="sidebar-link">Real-Time Features</a>
            <a href="#authentication" class="sidebar-link">Authentication & Authorization</a>
            <a href="#file-uploads" class="sidebar-link">File Uploads & Media</a>
            <a href="#pwa-features" class="sidebar-link">Progressive Web Apps</a>
            <a href="#testing-integration" class="sidebar-link">Testing Full-Stack Apps</a>
            <a href="#deployment-scaling" class="sidebar-link">Deployment & Scaling</a>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-title">Navigation</div>
            <a href="programming-bonus-reading-code.html" class="sidebar-link">‚Üê Previous: Reading Code</a>
            <a href="programming-ch07.html" class="sidebar-link">Chapter 07: Databases</a>
            <a href="programming-bonus-how-to-code.html" class="sidebar-link">Bonus B1: How To Code</a>
            <a href="programming-ch09.html" class="sidebar-link">Next: Professional Practices ‚Üí</a>
        </div>
    </aside>

    <main class="main">
        <div class="page-header">
            <div class="chapter-label">Chapter 08</div>
            <h1 class="page-title">Full-Stack Integration - Part I</h1>
            <p class="page-subtitle">Master modern frontend frameworks, state management, real-time features, authentication, and seamless backend integration. Build production-ready full-stack applications from scratch.</p>
        </div>

        <!-- SECTION 1: React Deep Dive -->
        <section id="react-deep-dive" class="section">
            <h2 class="section-title">React Deep Dive</h2>
            <p class="section-intro">Master React from fundamentals to advanced patterns. This comprehensive guide covers everything from basic concepts to production-ready patterns, performance optimization, and architectural decisions that will make you a confident React developer.</p>

            <h3>Introduction to React</h3>
            <p>React is a JavaScript library for building user interfaces, developed and maintained by Facebook (Meta). It has revolutionized how we think about building web applications by introducing a component-based architecture and a declarative programming paradigm.</p>

            <div class="metaphor-box">
                <h4>The React Philosophy</h4>
                <p>Think of React like building with LEGO blocks. Instead of painting a mural (traditional DOM manipulation), you're assembling pre-made blocks (components) that you can reuse, rearrange, and combine in different ways. Each block is self-contained, but they work together to create something amazing.</p>
            </div>

            <h4>Why React?</h4>
            <p>React solved several fundamental problems that plagued web development:</p>
            <ul>
                <li><strong>DOM Manipulation Complexity:</strong> Traditional jQuery-style DOM manipulation becomes unmanageable as applications grow. React abstracts this complexity.</li>
                <li><strong>State Synchronization:</strong> Keeping the UI in sync with data is error-prone. React's declarative approach makes this natural and predictable.</li>
                <li><strong>Component Reusability:</strong> React encourages creating reusable components, reducing code duplication and bugs.</li>
                <li><strong>Developer Experience:</strong> With tools like React DevTools, hot reloading, and a massive ecosystem, React offers an exceptional development experience.</li>
                <li><strong>Performance:</strong> The Virtual DOM enables React to make intelligent decisions about when and how to update the actual DOM.</li>
            </ul>

            <h4>The Virtual DOM</h4>
            <p>The Virtual DOM is React's secret weapon for performance. Here's how it works:</p>

            <div class="metaphor-box">
                <h4>Virtual DOM Explained</h4>
                <p>Imagine you're writing a book and need to make edits. Instead of erasing and rewriting directly on the final published copy (expensive and slow), you make changes on a draft copy, compare it with the published version, and only update the specific pages that changed. That's exactly what the Virtual DOM does!</p>
            </div>

            <div class="code">// How Virtual DOM works behind the scenes

// 1. You update state
setState({ count: count + 1 });

// 2. React creates a NEW virtual DOM tree
const newVirtualDOM = render();

// 3. React compares (diffs) new vs old virtual DOM
const differences = diff(oldVirtualDOM, newVirtualDOM);

// 4. React updates ONLY the changed parts in real DOM
patch(realDOM, differences);

// This is MUCH faster than re-rendering everything!</div>

            <div class="info-box">
                <h4>Virtual DOM Benefits</h4>
                <p><strong>Batching:</strong> React batches multiple state updates together, performing a single DOM update instead of many.<br><br>
                <strong>Minimal Updates:</strong> Only changed elements are updated in the real DOM.<br><br>
                <strong>Cross-Platform:</strong> The same virtual DOM concept enables React Native for mobile development.</p>
            </div>

            <h4>Component-Based Architecture</h4>
            <p>React applications are built using components - self-contained, reusable pieces of UI. This architecture provides:</p>

            <div class="code">// Component hierarchy example

App
‚îú‚îÄ‚îÄ Header
‚îÇ   ‚îú‚îÄ‚îÄ Logo
‚îÇ   ‚îú‚îÄ‚îÄ Navigation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavLink
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavLink
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NavLink
‚îÇ   ‚îî‚îÄ‚îÄ UserMenu
‚îú‚îÄ‚îÄ Main
‚îÇ   ‚îú‚îÄ‚îÄ Sidebar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FilterPanel
‚îÇ   ‚îî‚îÄ‚îÄ Content
‚îÇ       ‚îú‚îÄ‚îÄ ProductList
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ProductCard
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ProductCard
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ProductCard
‚îÇ       ‚îî‚îÄ‚îÄ Pagination
‚îî‚îÄ‚îÄ Footer

// Each component is independent, testable, and reusable</div>

            <h3>React Fundamentals Refresher</h3>

            <h4>JSX - JavaScript XML</h4>
            <p>JSX is a syntax extension that allows you to write HTML-like code in JavaScript. It's not required but makes React code more readable and expressive.</p>

            <div class="code">// JSX makes React intuitive
const element = <h1>Hello, World!</h1>;

// Behind the scenes, JSX compiles to:
const element = React.createElement('h1', null, 'Hello, World!');

// JSX can embed expressions
const name = 'Alice';
const greeting = <h1>Hello, {name}!</h1>;

// JSX can use JavaScript expressions
const result = (
  <div>
    <h2>2 + 2 = {2 + 2}</h2>
    <p>Random: {Math.random()}</p>
    <button onClick={() => console.log('Clicked!')}>
      Click Me
    </button>
  </div>
);

// JSX attributes use camelCase
const input = (
  <input
    type="text"
    className="form-control"  // not 'class'
    onChange={handleChange}   // not 'onchange'
    autoFocus                 // boolean attribute
  />
);</div>

            <div class="warning-box">
                <h4>Common JSX Pitfalls</h4>
                <p><strong>className not class:</strong> Use <span class="inline-code">className</span> instead of <span class="inline-code">class</span> for CSS classes.<br><br>
                <strong>htmlFor not for:</strong> Use <span class="inline-code">htmlFor</span> in label elements.<br><br>
                <strong>Self-closing tags:</strong> All tags must be closed: <span class="inline-code">&lt;img /&gt;</span> not <span class="inline-code">&lt;img&gt;</span>.<br><br>
                <strong>Return single element:</strong> JSX must return a single root element (or use Fragments).</p>
            </div>

            <h4>Components - Functional vs Class</h4>
            <p>Modern React uses functional components with hooks, but understanding class components is still valuable for legacy codebases.</p>

            <div class="code">// FUNCTIONAL COMPONENT (Modern approach)
function Welcome({ name, greeting = 'Hello' }) {
  return (
    <div className="welcome">
      <h1>{greeting}, {name}!</h1>
      <p>Welcome to React</p>
    </div>
  );
}

// Arrow function syntax
const Welcome = ({ name, greeting = 'Hello' }) => (
  <div className="welcome">
    <h1>{greeting}, {name}!</h1>
  </div>
);

// CLASS COMPONENT (Legacy, but still used)
class Welcome extends React.Component {
  render() {
    const { name, greeting = 'Hello' } = this.props;
    return (
      <div className="welcome">
        <h1>{greeting}, {name}!</h1>
        <p>Welcome to React</p>
      </div>
    );
  }
}</div>

            <h4>Props - Passing Data Down</h4>
            <p>Props (properties) are how components communicate. They flow down from parent to child components.</p>

            <div class="code">// Passing props
function App() {
  const user = {
    name: 'Alice',
    age: 28,
    email: 'alice@example.com'
  };

  return (
    <div>
      <UserProfile 
        user={user}
        isActive={true}
        onUpdate={(data) => console.log('Updated:', data)}
      />
    </div>
  );
}

// Receiving props - destructuring is cleaner
function UserProfile({ user, isActive, onUpdate }) {
  return (
    <div className={`profile ${isActive ? 'active' : ''}`}>
      <h2>{user.name}</h2>
      <p>Age: {user.age}</p>
      <p>Email: {user.email}</p>
      <button onClick={() => onUpdate(user)}>
        Update Profile
      </button>
    </div>
  );
}

// Props with children
function Card({ title, children }) {
  return (
    <div className="card">
      <h3>{title}</h3>
      <div className="card-body">
        {children}
      </div>
    </div>
  );
}

// Usage
<Card title="My Card">
  <p>This is the card content</p>
  <button>Action</button>
</Card></div>

            <div class="info-box">
                <h4>Props Best Practices</h4>
                <p><strong>Props are immutable:</strong> Never modify props inside a component. They're read-only.<br><br>
                <strong>Destructure early:</strong> Destructure props in the function signature for cleaner code.<br><br>
                <strong>Default values:</strong> Use default parameters for optional props.<br><br>
                <strong>PropTypes:</strong> Consider using PropTypes or TypeScript for type checking.</p>
            </div>

            <h4>State - Managing Component Data</h4>
            <p>State is data that changes over time. When state changes, React re-renders the component.</p>

            <div class="code">import { useState } from 'react';

function Counter() {
  // useState returns [currentValue, setterFunction]
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
      <button onClick={() => setCount(count - 1)}>
        Decrement
      </button>
      <button onClick={() => setCount(0)}>
        Reset
      </button>
    </div>
  );
}

// Complex state with objects
function UserForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  return (
    <form>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <input
        name="age"
        type="number"
        value={formData.age}
        onChange={handleChange}
        placeholder="Age"
      />
    </form>
  );
}</div>

            <h3>Hooks Mastery</h3>
            <p>Hooks are functions that let you "hook into" React features from functional components. They revolutionized React development by making functional components as powerful as class components.</p>

            <h4>useState - State Management</h4>
            <p>The most commonly used hook for managing component state.</p>

            <div class="code">import { useState } from 'react';

// Basic usage
function Example() {
  const [count, setCount] = useState(0);
  
  return <button onClick={() => setCount(count + 1)}>
    Clicked {count} times
  </button>;
}

// Functional updates (when new state depends on old state)
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    // BAD - can cause bugs with multiple updates
    setCount(count + 1);
    
    // GOOD - uses previous state
    setCount(prev => prev + 1);
  };
  
  const incrementMultiple = () => {
    // This works correctly because of functional updates
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };
  
  return <button onClick={incrementMultiple}>+3</button>;
}

// Lazy initialization (expensive computation)
function ExpensiveComponent() {
  // BAD - runs every render
  const [state, setState] = useState(expensiveFunction());
  
  // GOOD - runs only on initial render
  const [state, setState] = useState(() => expensiveFunction());
  
  return <div>{state}</div>;
}

// Multiple state variables
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [errors, setErrors] = useState({});
  
  // OR use a single state object
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  return null;
}</div>

            <h4>useEffect - Side Effects</h4>
            <p>useEffect handles side effects like data fetching, subscriptions, and manual DOM manipulation.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Basic usage - runs after every render
function Example() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `Count: ${count}`;
  });
  
  return <button onClick={() => setCount(count + 1)}>
    Increment
  </button>;
}

// With dependency array - runs only when dependencies change
function User({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    setLoading(true);
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        console.error(err);
        setLoading(false);
      });
  }, [userId]); // Re-run when userId changes
  
  if (loading) return <div>Loading...</div>;
  return <div>{user?.name}</div>;
}

// Cleanup function - prevents memory leaks
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // Cleanup function runs before component unmounts
    // and before the effect runs again
    return () => {
      clearInterval(interval);
      console.log('Timer cleaned up');
    };
  }, []); // Empty array = run once on mount
  
  return <div>Seconds: {seconds}</div>;
}

// Real-world example - WebSocket connection
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://api.com/rooms/${roomId}`);
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    // Cleanup: close connection when component unmounts
    // or when roomId changes
    return () => {
      ws.close();
    };
  }, [roomId]);
  
  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useEffect Pitfalls</h4>
                <p><strong>Missing dependencies:</strong> Always include all values from component scope that are used in effect.<br><br>
                <strong>Infinite loops:</strong> Be careful with dependency arrays - updating state that's in dependencies causes loops.<br><br>
                <strong>Async functions:</strong> Can't make useEffect callback async directly. Create async function inside instead.<br><br>
                <strong>Cleanup is crucial:</strong> Always cleanup subscriptions, timers, and listeners to prevent memory leaks.</p>
            </div>

            <h4>useContext - Global State</h4>
            <p>useContext provides a way to pass data through the component tree without passing props down manually at every level.</p>

            <div class="code">import { createContext, useContext, useState } from 'react';

// 1. Create a context
const ThemeContext = createContext();

// 2. Create a provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create a custom hook for easy access
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 4. Use in components
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={`header-${theme}`}>
      <h1>My App</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}

// Real-world example - Auth context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('token');
    if (token) {
      fetch('/api/auth/me', {
        headers: { Authorization: `Bearer ${token}` }
      })
        .then(res => res.json())
        .then(data => {
          setUser(data);
          setLoading(false);
        })
        .catch(() => {
          localStorage.removeItem('token');
          setLoading(false);
        });
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    const data = await res.json();
    localStorage.setItem('token', data.token);
    setUser(data.user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}</div>

            <h4>useRef - Persistent Values & DOM Access</h4>
            <p>useRef creates a mutable reference that persists across renders without causing re-renders when changed.</p>

            <div class="code">import { useRef, useEffect } from 'react';

// Accessing DOM elements
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  useEffect(() => {
    // Auto-focus on mount
    inputRef.current.focus();
  }, []);
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

// Storing previous values
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();
  
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  const prevCount = prevCountRef.current;
  
  return (
    <div>
      <h2>Current: {count}</h2>
      <h3>Previous: {prevCount}</h3>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// Storing interval/timeout IDs
function StopWatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  
  const start = () => {
    setIsRunning(true);
    intervalRef.current = setInterval(() => {
      setTime(t => t + 1);
    }, 1000);
  };
  
  const stop = () => {
    setIsRunning(false);
    clearInterval(intervalRef.current);
  };
  
  const reset = () => {
    stop();
    setTime(0);
  };
  
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <div>
      <h2>Time: {time}s</h2>
      {!isRunning ? (
        <button onClick={start}>Start</button>
      ) : (
        <button onClick={stop}>Stop</button>
      )}
      <button onClick={reset}>Reset</button>
    </div>
  );
}

// Preventing unnecessary API calls
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const abortControllerRef = useRef(null);
  
  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }
    
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // Create new abort controller
    abortControllerRef.current = new AbortController();
    
    fetch(`/api/search?q=${query}`, {
      signal: abortControllerRef.current.signal
    })
      .then(res => res.json())
      .then(data => setResults(data))
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      });
  }, [query]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}</div>

            <h4>useMemo - Expensive Computations</h4>
            <p>useMemo memoizes computed values, recalculating only when dependencies change.</p>

            <div class="code">import { useMemo, useState } from 'react';

function ProductList({ products, searchTerm, sortBy }) {
  // Expensive filtering and sorting
  const processedProducts = useMemo(() => {
    console.log('Processing products...');
    
    let result = products.filter(product =>
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    result.sort((a, b) => {
      if (sortBy === 'price') {
        return a.price - b.price;
      }
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      return 0;
    });
    
    return result;
  }, [products, searchTerm, sortBy]);
  // Only recalculate when these change
  
  return (
    <div>
      {processedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// When NOT to use useMemo
function SimpleComponent({ a, b }) {
  // BAD - premature optimization
  const sum = useMemo(() => a + b, [a, b]);
  
  // GOOD - simple calculation, no memoization needed
  const sum = a + b;
  
  return <div>Sum: {sum}</div>;
}

// Memoizing object creation for dependencies
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  // WITHOUT useMemo - creates new object every render
  // causes useEffect to run every time
  const requestOptions = {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  };
  
  // WITH useMemo - stable reference
  const requestOptions = useMemo(() => ({
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  }), [token]);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`, requestOptions)
      .then(res => res.json())
      .then(setUser);
  }, [userId, requestOptions]); // Now only runs when actually needed
  
  return <div>{user?.name}</div>;
}</div>

            <h4>useCallback - Memoized Functions</h4>
            <p>useCallback memoizes function definitions, preventing unnecessary re-creations.</p>

            <div class="code">import { useCallback, useState, memo } from 'react';

// Child component - expensive to render
const ExpensiveChild = memo(({ onClick, data }) => {
  console.log('ExpensiveChild rendered');
  return (
    <button onClick={onClick}>
      Click me - {data}
    </button>
  );
});

function Parent() {
  const [count, setCount] = useState(0);
  const [other, setOther] = useState(0);
  
  // WITHOUT useCallback - new function every render
  // ExpensiveChild re-renders unnecessarily
  const handleClick = () => {
    setCount(c => c + 1);
  };
  
  // WITH useCallback - stable function reference
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []); // No dependencies - function never changes
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => setOther(other + 1)}>
        Other: {other}
      </button>
      <ExpensiveChild onClick={handleClick} data={count} />
    </div>
  );
}

// Real-world example - event handlers with parameters
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  // Memoize the remove function
  const removeTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []); // No dependencies because we use functional update
  
  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  }, []);
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onRemove={removeTodo}
          onToggle={toggleTodo}
        />
      ))}
    </div>
  );
}

// useCallback with dependencies
function SearchBox({ onSearch, filters }) {
  const [query, setQuery] = useState('');
  
  const handleSearch = useCallback(() => {
    // Function recreated when filters change
    onSearch(query, filters);
  }, [query, filters, onSearch]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
    </div>
  );
}</div>

            <div class="warning-box">
                <h4>useMemo vs useCallback</h4>
                <p><strong>useMemo:</strong> Memoizes the RESULT of a function - <span class="inline-code">useMemo(() => value, deps)</span><br><br>
                <strong>useCallback:</strong> Memoizes the FUNCTION itself - <span class="inline-code">useCallback(fn, deps)</span><br><br>
                <strong>Remember:</strong> <span class="inline-code">useCallback(fn, deps)</span> is equivalent to <span class="inline-code">useMemo(() => fn, deps)</span><br><br>
                <strong>Don't overuse:</strong> These optimizations have a cost. Only use when profiling shows a performance issue.</p>
            </div>

            <h4>Custom Hooks - Reusable Logic</h4>
            <p>Custom hooks let you extract component logic into reusable functions. They're just JavaScript functions that use React hooks.</p>

            <div class="code">import { useState, useEffect } from 'react';

// Custom hook for fetching data
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
          setData(null);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url, JSON.stringify(options)]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(
    `/api/users/${userId}`
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
}

// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function
        ? value(storedValue)
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}

// Custom hook for window dimensions
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Custom hook for debounced value
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage - search with debounce
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  const { data: results } = useFetch(
    `/api/search?q=${debouncedSearchTerm}`
  );
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {results && results.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}</div>

            <h3>Advanced Component Patterns</h3>

            <h4>Higher-Order Components (HOCs)</h4>
            <p>A higher-order component is a function that takes a component and returns a new component with additional props or behavior.</p>

            <div class="code">// Basic HOC pattern
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...props} />;
  };
}

// Usage
const UserListWithLoading = withLoading(UserList);

// With authentication
function withAuth(Component) {
  return function WithAuthComponent(props) {
    const { user, loading } = useAuth();
    
    if (loading) {
      return <div>Checking authentication...</div>;
    }
    
    if (!user) {
      return <Navigate to="/login" />;
    }
    
    return <Component {...props} user={user} />;
  };
}

// Usage
const ProtectedDashboard = withAuth(Dashboard);

// With data fetching
function withData(url) {
  return function (Component) {
    return function WithDataComponent(props) {
      const { data, loading, error } = useFetch(url);
      
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error}</div>;
      
      return <Component {...props} data={data} />;
    };
  };
}

// Usage
const UserListWithData = withData('/api/users')(UserList);

// Composing multiple HOCs
const EnhancedComponent = withAuth(
  withLoading(
    withData('/api/users')(UserList)
  )
);</div>

            <div class="info-box">
                <h4>HOC Best Practices</h4>
                <p><strong>Don't mutate:</strong> Create new components, don't modify the original.<br><br>
                <strong>Pass through props:</strong> Forward all props that aren't consumed by the HOC.<br><br>
                <strong>Display name:</strong> Set displayName for better debugging.<br><br>
                <strong>Static methods:</strong> Copy static methods from wrapped component.<br><br>
                <strong>Refs:</strong> Use React.forwardRef to forward refs through HOCs.</p>
            </div>

            <h4>Render Props Pattern</h4>
            <p>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</p>

            <div class="code">// Mouse tracker with render props
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return render(position);
}

// Usage
function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <div>
          Mouse position: {x}, {y}
        </div>
      )}
    />
  );
}

// Using children as a function (common pattern)
function DataProvider({ url, children }) {
  const { data, loading, error } = useFetch(url);
  
  return children({ data, loading, error });
}

// Usage
function App() {
  return (
    <DataProvider url="/api/users">
      {({ data, loading, error }) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error}</div>;
        return (
          <ul>
            {data.map(user => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>
        );
      }}
    </DataProvider>
  );
}

// Toggle component with render props
function Toggle({ initial = false, children }) {
  const [on, setOn] = useState(initial);
  
  const toggle = () => setOn(prev => !prev);
  const setOff = () => setOn(false);
  const setOn = () => setOn(true);
  
  return children({
    on,
    toggle,
    setOff,
    setOn
  });
}

// Usage
<Toggle initial={false}>
  {({ on, toggle }) => (
    <div>
      <button onClick={toggle}>
        {on ? 'ON' : 'OFF'}
      </button>
      {on && <div>Content visible!</div>}
    </div>
  )}
</Toggle></div>

            <h4>Compound Components Pattern</h4>
            <p>Compound components work together to form a complete UI. They share implicit state without prop drilling.</p>

            <div class="code">// Tabs compound component
const TabsContext = createContext();

function Tabs({ children, defaultValue }) {
  const [activeTab, setActiveTab] = useState(defaultValue);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === value;
  
  return (
    <button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== value) return null;
  
  return <div className="tab-panel">{children}</div>;
}

// Attach sub-components
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage - beautiful API!
function App() {
  return (
    <Tabs defaultValue="profile">
      <Tabs.List>
        <Tabs.Tab value="profile">Profile</Tabs.Tab>
        <Tabs.Tab value="settings">Settings</Tabs.Tab>
        <Tabs.Tab value="notifications">Notifications</Tabs.Tab>
      </Tabs.List>
      
      <Tabs.Panel value="profile">
        <h2>Profile Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="settings">
        <h2>Settings Content</h2>
      </Tabs.Panel>
      
      <Tabs.Panel value="notifications">
        <h2>Notifications Content</h2>
      </Tabs.Panel>
    </Tabs>
  );
}</div>

            <h3>Performance Optimization</h3>

            <h4>React.memo - Component Memoization</h4>
            <p>React.memo prevents unnecessary re-renders by memoizing component output.</p>

            <div class="code">import { memo } from 'react';

// Without memo - re-renders every time parent renders
function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  // Expensive computation
  return <div>{data}</div>;
}

// With memo - only re-renders when props change
const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  console.log('ExpensiveComponent rendered');
  return <div>{data}</div>;
});

// Custom comparison function
const ExpensiveComponent = memo(
  function ExpensiveComponent({ user, settings }) {
    return (
      <div>
        <h2>{user.name}</h2>
        <p>{settings.theme}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    // Return false if props changed (re-render)
    return (
      prevProps.user.id === nextProps.user.id &&
      prevProps.settings.theme === nextProps.settings.theme
    );
  }
);

// Real-world example
const ProductCard = memo(function ProductCard({ product, onAddToCart }) {
  console.log(`Rendering product: ${product.name}`);
  
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => onAddToCart(product.id)}>
        Add to Cart
      </button>
    </div>
  );
});

function ProductList({ products }) {
  const [cart, setCart] = useState([]);
  
  // Memoize callback to prevent ProductCard re-renders
  const handleAddToCart = useCallback((productId) => {
    setCart(prev => [...prev, productId]);
  }, []);
  
  return (
    <div className="product-list">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
}</div>

            <h4>Code Splitting & Lazy Loading</h4>
            <p>Split your code into smaller chunks that load on demand, reducing initial bundle size.</p>

            <div class="code">import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Dashboard />
      </Suspense>
    </div>
  );
}

// With React Router
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Custom loading component
function LoadingSpinner() {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  );
}

// Error boundary for lazy loading
class LazyLoadErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Failed to load component</h2>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage with error boundary
<LazyLoadErrorBoundary>
  <Suspense fallback={<LoadingSpinner />}>
    <Dashboard />
  </Suspense>
</LazyLoadErrorBoundary></div>

            <div class="info-box">
                <h4>Performance Tips</h4>
                <p><strong>List virtualization:</strong> Use libraries like react-window for long lists.<br><br>
                <strong>Debounce expensive operations:</strong> Delay API calls and computations.<br><br>
                <strong>Avoid inline functions:</strong> Extract to useCallback when passing to memoized components.<br><br>
                <strong>Profile before optimizing:</strong> Use React DevTools Profiler to find real bottlenecks.<br><br>
                <strong>Bundle analysis:</strong> Use webpack-bundle-analyzer to find large dependencies.</p>
            </div>

            <h3>Error Boundaries</h3>
            <p>Error boundaries catch JavaScript errors anywhere in the component tree and display a fallback UI.</p>

            <div class="code">import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error to error reporting service
    console.error('Error caught by boundary:', error, errorInfo);
    
    // You can also log to external services
    // logErrorToService(error, errorInfo);
    
    this.setState({
      error,
      errorInfo
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <ErrorBoundary>
        <Sidebar />
      </ErrorBoundary>
      <ErrorBoundary>
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}

// Component that might error
function BuggyComponent() {
  const [count, setCount] = useState(0);
  
  if (count === 5) {
    // Simulate an error
    throw new Error('Crashed at count 5!');
  }
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}</div>

            <div class="warning-box">
                <h4>Error Boundary Limitations</h4>
                <p>Error boundaries do NOT catch errors in:<br><br>
                ‚Ä¢ Event handlers (use try-catch instead)<br>
                ‚Ä¢ Asynchronous code (setTimeout, fetch)<br>
                ‚Ä¢ Server-side rendering<br>
                ‚Ä¢ Errors thrown in the error boundary itself<br><br>
                For event handlers, wrap in try-catch and update state to show error UI.</p>
            </div>

            <div class="metaphor-box">
                <h4>You've Mastered React!</h4>
                <p>Congratulations! You now understand React from the ground up - from the Virtual DOM to advanced patterns, performance optimization, and error handling. You're equipped to build production-ready React applications with confidence. Remember: the best way to solidify this knowledge is to build real projects. Start small, iterate, and gradually tackle more complex challenges.</p>
            </div>
        </section>

        <!-- SECTION 2: Vue Mastery -->
        <section id="vue-mastery" class="section">
            <h2 class="section-title">Vue Mastery</h2>
            <p class="section-intro">Vue.js is the approachable, versatile, and performant framework that makes building web interfaces a joy. In this comprehensive section, we'll explore Vue from the ground up - from understanding its reactive philosophy to mastering advanced patterns with Composition API, Pinia state management, and sophisticated routing. Whether you're coming from React or starting fresh, you'll discover why Vue has become one of the most loved frameworks in the JavaScript ecosystem.</p>

            <h3>1. Introduction to Vue: The Progressive Framework</h3>
            
            <p>Vue (pronounced "view") is often described as the "progressive framework" - but what does that actually mean? Unlike all-or-nothing frameworks, Vue is designed to be incrementally adoptable. You can use as little or as much Vue as you need, from enhancing a single section of an existing page to building full-scale single-page applications.</p>

            <div class="metaphor-box">
                <h4>The Swiss Army Knife of Frameworks</h4>
                <p>Think of Vue like a Swiss Army knife. React is like a specialized chef's knife - exceptional at one thing but requires additional tools for a complete toolkit. Angular is like a professional kitchen - everything included but overwhelming if you just want to make a sandwich. Vue gives you the essential tools in one elegant package, and you can add more specialized tools as needed.</p>
            </div>

            <h4>Why Vue? The Philosophy</h4>
            
            <p>Vue was created by Evan You after working with Angular at Google. He wanted to extract the parts he really liked about Angular and build something lighter and more flexible. The result is a framework that prioritizes:</p>

            <ul>
                <li><strong>Approachability:</strong> Gentle learning curve, especially if you know HTML, CSS, and basic JavaScript</li>
                <li><strong>Versatility:</strong> Works for projects of any size, from progressive enhancement to full SPAs</li>
                <li><strong>Performance:</strong> Fast virtual DOM implementation with automatic optimization</li>
                <li><strong>Developer Experience:</strong> Excellent tooling, clear error messages, and comprehensive documentation</li>
            </ul>

            <h4>Vue vs React: Key Differences</h4>

            <p>If you're familiar with React, here are the main philosophical differences:</p>

            <div class="code">// REACT: JavaScript-centric, JSX everywhere
function Counter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

// VUE: Template-based, HTML-centric approach
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
    &lt;button @click="count++"&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
const count = ref(0);
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Template vs JSX</h4>
                <p><strong>Vue templates</strong> are easier to read and write for most developers, especially those with HTML/CSS backgrounds. <strong>React JSX</strong> offers more JavaScript flexibility but has a steeper learning curve. Vue supports both approaches - you can use templates OR JSX render functions.</p>
            </div>

            <h3>2. Vue Fundamentals: Template Syntax & Directives</h3>

            <p>Vue's template syntax extends HTML with powerful directives that make building dynamic interfaces intuitive. Let's master each directive with practical examples.</p>

            <h4>Text Interpolation & Expressions</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Basic interpolation --&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  
  &lt;!-- JavaScript expressions work! --&gt;
  &lt;p&gt;{{ message.toUpperCase() }}&lt;/p&gt;
  &lt;p&gt;{{ number + 1 }}&lt;/p&gt;
  &lt;p&gt;{{ isActive ? 'Yes' : 'No' }}&lt;/p&gt;
  
  &lt;!-- Ternary operators, method calls --&gt;
  &lt;p&gt;{{ reversedMessage() }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, computed } from 'vue';

const message = ref('Hello Vue!');
const number = ref(41);
const isActive = ref(true);

function reversedMessage() {
  return message.value.split('').reverse().join('');
}
&lt;/script&gt;</div>

            <h4>v-bind: Dynamic Attributes</h4>

            <p>The <span class="inline-code">v-bind</span> directive dynamically binds attributes to expressions. The shorthand <span class="inline-code">:</span> is commonly used.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;img v-bind:src="imageSrc" v-bind:alt="imageAlt"&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;img :src="imageSrc" :alt="imageAlt"&gt;
  
  &lt;!-- Binding classes --&gt;
  &lt;div :class="{ active: isActive, 'text-danger': hasError }"&gt;&lt;/div&gt;
  &lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;
  
  &lt;!-- Binding styles --&gt;
  &lt;div :style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
  
  &lt;!-- Binding multiple attributes --&gt;
  &lt;div v-bind="objectOfAttrs"&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const imageSrc = ref('https://vuejs.org/logo.svg');
const imageAlt = ref('Vue Logo');
const isActive = ref(true);
const hasError = ref(false);
const activeColor = ref('#42b883');
const fontSize = ref(16);
const objectOfAttrs = ref({
  id: 'container',
  class: 'wrapper'
});
&lt;/script&gt;</div>

            <h4>v-on: Event Handling</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Full syntax --&gt;
  &lt;button v-on:click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Shorthand (preferred) --&gt;
  &lt;button @click="count++"&gt;{{ count }}&lt;/button&gt;
  
  &lt;!-- Method handler --&gt;
  &lt;button @click="handleClick"&gt;Click Me&lt;/button&gt;
  
  &lt;!-- Inline handler with parameters --&gt;
  &lt;button @click="say('hello')"&gt;Say Hello&lt;/button&gt;
  
  &lt;!-- Event modifiers --&gt;
  &lt;form @submit.prevent="onSubmit"&gt;&lt;/form&gt;
  &lt;button @click.stop="doThis"&gt;&lt;/button&gt;
  &lt;button @click.once="doThisOnce"&gt;&lt;/button&gt;
  
  &lt;!-- Key modifiers --&gt;
  &lt;input @keyup.enter="submit"&gt;
  &lt;input @keyup.esc="clearInput"&gt;
&lt;/template&gt;

&lt;script setup&gt;
const count = ref(0);

function handleClick(event) {
  console.log('Button clicked!', event);
}

function say(message) {
  alert(message);
}
&lt;/script&gt;</div>

            <h4>v-model: Two-Way Binding</h4>

            <p>The <span class="inline-code">v-model</span> directive creates two-way data binding on form inputs, perfect for handling user input.</p>

            <div class="code">&lt;template&gt;
  &lt;!-- Text input --&gt;
  &lt;input v-model="text" placeholder="Type something"&gt;
  &lt;p&gt;You typed: {{ text }}&lt;/p&gt;
  
  &lt;!-- Textarea --&gt;
  &lt;textarea v-model="message"&gt;&lt;/textarea&gt;
  
  &lt;!-- Checkbox --&gt;
  &lt;input type="checkbox" v-model="checked" id="checkbox"&gt;
  &lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;
  
  &lt;!-- Multiple checkboxes --&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Alice"&gt;
  &lt;input type="checkbox" v-model="checkedNames" value="Bob"&gt;
  &lt;p&gt;Checked: {{ checkedNames }}&lt;/p&gt;
  
  &lt;!-- Radio buttons --&gt;
  &lt;input type="radio" v-model="picked" value="One"&gt;
  &lt;input type="radio" v-model="picked" value="Two"&gt;
  
  &lt;!-- Select --&gt;
  &lt;select v-model="selected"&gt;
    &lt;option disabled value=""&gt;Choose one&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  
  &lt;!-- v-model modifiers --&gt;
  &lt;input v-model.lazy="msg"&gt;        &lt;!-- Update on change, not input --&gt;
  &lt;input v-model.number="age"&gt;      &lt;!-- Auto-typecast to number --&gt;
  &lt;input v-model.trim="username"&gt;   &lt;!-- Auto-trim whitespace --&gt;
&lt;/template&gt;

&lt;script setup&gt;
const text = ref('');
const message = ref('');
const checked = ref(false);
const checkedNames = ref([]);
const picked = ref('');
const selected = ref('');
const msg = ref('');
const age = ref(0);
const username = ref('');
&lt;/script&gt;</div>

            <h4>v-if, v-else-if, v-else: Conditional Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;div v-if="type === 'A'"&gt;
    Type A content
  &lt;/div&gt;
  &lt;div v-else-if="type === 'B'"&gt;
    Type B content
  &lt;/div&gt;
  &lt;div v-else&gt;
    Not A or B
  &lt;/div&gt;
  
  &lt;!-- Using template for grouping --&gt;
  &lt;template v-if="loginStatus === 'loggedIn'"&gt;
    &lt;h1&gt;Welcome back!&lt;/h1&gt;
    &lt;p&gt;Your dashboard&lt;/p&gt;
  &lt;/template&gt;
&lt;/template&gt;</div>

            <div class="warning-box">
                <h4>v-if vs v-show</h4>
                <p><strong>v-if:</strong> Conditionally renders the element (truly removes/adds to DOM). Higher toggle cost, lazy rendering.<br><br>
                <strong>v-show:</strong> Always renders but toggles CSS display. Lower toggle cost, immediate rendering.<br><br>
                <strong>Use v-if</strong> when the condition rarely changes. <strong>Use v-show</strong> for frequent toggling.</p>
            </div>

            <h4>v-for: List Rendering</h4>

            <div class="code">&lt;template&gt;
  &lt;!-- Array iteration --&gt;
  &lt;ul&gt;
    &lt;li v-for="(item, index) in items" :key="item.id"&gt;
      {{ index }}: {{ item.text }}
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;!-- Object iteration --&gt;
  &lt;div v-for="(value, key, index) in userObject" :key="key"&gt;
    {{ index }}. {{ key }}: {{ value }}
  &lt;/div&gt;
  
  &lt;!-- Range --&gt;
  &lt;span v-for="n in 10" :key="n"&gt;{{ n }}&lt;/span&gt;
  
  &lt;!-- v-for with v-if (not recommended on same element) --&gt;
  &lt;template v-for="item in items" :key="item.id"&gt;
    &lt;li v-if="!item.hidden"&gt;{{ item.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/template&gt;

&lt;script setup&gt;
const items = ref([
  { id: 1, text: 'Learn Vue', hidden: false },
  { id: 2, text: 'Build App', hidden: false },
  { id: 3, text: 'Deploy', hidden: true }
]);

const userObject = ref({
  name: 'Alice',
  age: 28,
  email: 'alice@example.com'
});
&lt;/script&gt;</div>

            <div class="warning-box">
                <h4>Always Use :key with v-for</h4>
                <p>Vue needs keys to track each node's identity for efficient DOM updates. Without keys, Vue uses an "in-place patch" strategy that can cause issues with stateful components or animations. Always provide unique, stable keys!</p>
            </div>

            <h3>3. Composition API Deep Dive</h3>

            <p>The Composition API is Vue 3's revolutionary approach to organizing component logic. It provides better code reusability, type inference, and logical organization compared to the Options API.</p>

            <h4>Why Composition API?</h4>

            <div class="metaphor-box">
                <h4>Organization by Concern</h4>
                <p>The Options API organizes code by option type (data, methods, computed, etc.) - like organizing books by size. The Composition API organizes by logical concern - like organizing books by topic. When you need to understand the "user authentication" feature, all related code is together rather than scattered across multiple options.</p>
            </div>

            <h4>setup() and &lt;script setup&gt;</h4>

            <div class="code">&lt;!-- Traditional setup() function --&gt;
&lt;script&gt;
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const double = computed(() =&gt; count.value * 2);
    
    function increment() {
      count.value++;
    }
    
    // Must return everything you want to expose to template
    return {
      count,
      double,
      increment
    };
  }
};
&lt;/script&gt;

&lt;!-- Modern &lt;script setup&gt; (preferred!) --&gt;
&lt;script setup&gt;
import { ref, computed } from 'vue';

// Everything defined here is automatically exposed to template
const count = ref(0);
const double = computed(() =&gt; count.value * 2);

function increment() {
  count.value++;
}
// No need to return anything!
&lt;/script&gt;</div>

            <h4>ref() vs reactive()</h4>

            <p>Understanding the difference between <span class="inline-code">ref</span> and <span class="inline-code">reactive</span> is crucial for mastering Vue's reactivity system.</p>

            <div class="code">&lt;script setup&gt;
import { ref, reactive } from 'vue';

// ref: For primitives and single values
const count = ref(0);
const message = ref('Hello');
const user = ref({ name: 'Alice' });

// Access via .value in script, automatic unwrap in template
count.value++;                    // In script: need .value
console.log(user.value.name);     // In script: need .value

// reactive: For objects only
const state = reactive({
  count: 0,
  message: 'Hello',
  nested: {
    value: 42
  }
});

// Direct access, no .value needed
state.count++;
state.nested.value = 100;

// GOTCHA: Destructuring loses reactivity with reactive()
const { count, message } = state;  // ‚ùå NOT reactive anymore!

// Use toRefs() to maintain reactivity
import { toRefs } from 'vue';
const { count, message } = toRefs(state);  // ‚úÖ Still reactive!
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>When to Use ref vs reactive</h4>
                <p><strong>Use ref():</strong> For primitive values, single objects, or when you need to replace the entire object reference.<br><br>
                <strong>Use reactive():</strong> For complex objects with many properties that you'll mutate in place.<br><br>
                <strong>Common pattern:</strong> Many developers use <span class="inline-code">ref()</span> for everything for consistency, even for objects.</p>
            </div>

            <h4>computed(): Derived State</h4>

            <div class="code">&lt;script setup&gt;
import { ref, computed } from 'vue';

const firstName = ref('John');
const lastName = ref('Doe');

// Read-only computed
const fullName = computed(() =&gt; {
  return `${firstName.value} ${lastName.value}`;
});

// Writable computed (getter + setter)
const fullNameWritable = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ');
  }
});

// Computed with complex logic
const items = ref([
  { id: 1, name: 'Apple', price: 1.5, quantity: 3 },
  { id: 2, name: 'Banana', price: 0.8, quantity: 5 }
]);

const totalPrice = computed(() =&gt; {
  return items.value.reduce((total, item) =&gt; {
    return total + (item.price * item.quantity);
  }, 0).toFixed(2);
});

const expensiveItems = computed(() =&gt; {
  return items.value.filter(item =&gt; item.price &gt; 1);
});
&lt;/script&gt;</div>

            <h4>watch() and watchEffect()</h4>

            <p>Vue provides two ways to react to reactive state changes: <span class="inline-code">watch()</span> and <span class="inline-code">watchEffect()</span>.</p>

            <div class="code">&lt;script setup&gt;
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);
const user = ref({ name: 'Alice', age: 25 });

// watch: Explicit source, access old and new values
watch(count, (newValue, oldValue) =&gt; {
  console.log(`Count changed from ${oldValue} to ${newValue}`);
});

// watch multiple sources
watch([count, user], ([newCount, newUser], [oldCount, oldUser]) =&gt; {
  console.log('Count or user changed');
});

// watch with options
watch(user, (newUser) =&gt; {
  console.log('User changed:', newUser);
}, {
  deep: true,       // Watch nested properties
  immediate: true   // Run immediately on mount
});

// watchEffect: Automatic dependency tracking
watchEffect(() =&gt; {
  // Automatically tracks count and user.name as dependencies
  console.log(`${user.value.name} has count: ${count.value}`);
});

// watchEffect with cleanup
watchEffect((onCleanup) =&gt; {
  const timer = setTimeout(() =&gt; {
    console.log('Delayed log:', count.value);
  }, 1000);
  
  // Cleanup function runs before next execution and on unmount
  onCleanup(() =&gt; {
    clearTimeout(timer);
  });
});
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>watch vs watchEffect</h4>
                <p><strong>Use watch()</strong> when you need to access previous values, watch specific sources, or perform side effects only when certain dependencies change.<br><br>
                <strong>Use watchEffect()</strong> for simpler cases where you want automatic dependency tracking and don't need old values.</p>
            </div>

            <h3>4. Component Communication</h3>

            <h4>Props: Parent to Child</h4>

            <div class="code">&lt;!-- Child Component: UserCard.vue --&gt;
&lt;template&gt;
  &lt;div class="user-card"&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;Age: {{ user.age }}&lt;/p&gt;
    &lt;p&gt;Role: {{ role }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define props with TypeScript-style type annotation
const props = defineProps({
  user: {
    type: Object,
    required: true
  },
  role: {
    type: String,
    default: 'Guest'
  },
  age: {
    type: Number,
    validator: (value) =&gt; value &gt;= 0
  }
});

// Access props
console.log(props.user.name);
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;UserCard :user="currentUser" role="Admin" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import UserCard from './UserCard.vue';
const currentUser = ref({ name: 'Alice', age: 28 });
&lt;/script&gt;</div>

            <h4>Emits: Child to Parent</h4>

            <div class="code">&lt;!-- Child Component: CustomButton.vue --&gt;
&lt;template&gt;
  &lt;button @click="handleClick"&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
// Define emits
const emit = defineEmits(['click', 'custom-event']);

function handleClick(event) {
  // Emit with data
  emit('click', { timestamp: Date.now(), event });
  emit('custom-event', 'some data');
}
&lt;/script&gt;

&lt;!-- Parent Component --&gt;
&lt;template&gt;
  &lt;CustomButton @click="onButtonClick" @custom-event="onCustom"&gt;
    Click Me
  &lt;/CustomButton&gt;
&lt;/template&gt;

&lt;script setup&gt;
function onButtonClick(data) {
  console.log('Button clicked at:', data.timestamp);
}

function onCustom(data) {
  console.log('Custom event:', data);
}
&lt;/script&gt;</div>

            <h4>provide/inject: Deep Component Communication</h4>

            <div class="code">&lt;!-- Grandparent Component --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue';

const theme = ref('dark');
const user = ref({ name: 'Alice', role: 'admin' });

// Provide to all descendants
provide('theme', theme);
provide('user', user);

// Provide with read-only access
import { readonly } from 'vue';
provide('config', readonly({
  apiUrl: 'https://api.example.com'
}));
&lt;/script&gt;

&lt;!-- Deep Child Component (any level deep) --&gt;
&lt;script setup&gt;
import { inject } from 'vue';

// Inject provided values
const theme = inject('theme');
const user = inject('user');

// Inject with default value
const config = inject('config', { apiUrl: 'fallback' });

// Now you can use theme, user, config
console.log(theme.value);  // 'dark'
&lt;/script&gt;</div>

            <h4>Slots: Content Distribution</h4>

            <div class="code">&lt;!-- Card Component with Slots --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;div class="card-header"&gt;
      &lt;slot name="header"&gt;Default Header&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-body"&gt;
      &lt;slot&gt;Default Content&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class="card-footer"&gt;
      &lt;slot name="footer" :data="footerData"&gt;
        Default Footer
      &lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const footerData = ref({ timestamp: new Date() });
&lt;/script&gt;

&lt;!-- Using the Card --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;template #header&gt;
      &lt;h2&gt;My Custom Header&lt;/h2&gt;
    &lt;/template&gt;
    
    &lt;!-- Default slot --&gt;
    &lt;p&gt;This is the main content&lt;/p&gt;
    
    &lt;!-- Scoped slot receiving data --&gt;
    &lt;template #footer="{ data }"&gt;
      &lt;small&gt;Last updated: {{ data.timestamp }}&lt;/small&gt;
    &lt;/template&gt;
  &lt;/Card&gt;
&lt;/template&gt;</div>

            <h3>5. Pinia State Management</h3>

            <p>Pinia is the official state management solution for Vue 3, replacing Vuex. It offers a simpler API, better TypeScript support, and modular design.</p>

            <h4>Creating a Store</h4>

            <div class="code">// stores/counter.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

// Composition API style (recommended)
export const useCounterStore = defineStore('counter', () =&gt; {
  // State
  const count = ref(0);
  const name = ref('Counter Store');
  
  // Getters (computed)
  const doubleCount = computed(() =&gt; count.value * 2);
  const isEven = computed(() =&gt; count.value % 2 === 0);
  
  // Actions (functions)
  function increment() {
    count.value++;
  }
  
  function incrementBy(amount) {
    count.value += amount;
  }
  
  async function fetchCount() {
    const response = await fetch('/api/count');
    const data = await response.json();
    count.value = data.count;
  }
  
  return {
    count,
    name,
    doubleCount,
    isEven,
    increment,
    incrementBy,
    fetchCount
  };
});

// Options API style (alternative)
export const useCounterStore = defineStore('counter', {
  state: () =&gt; ({
    count: 0,
    name: 'Counter Store'
  }),
  getters: {
    doubleCount: (state) =&gt; state.count * 2,
    isEven: (state) =&gt; state.count % 2 === 0
  },
  actions: {
    increment() {
      this.count++;
    },
    incrementBy(amount) {
      this.count += amount;
    }
  }
});</div>

            <h4>Using Stores in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ counter.count }}&lt;/p&gt;
    &lt;p&gt;Double: {{ counter.doubleCount }}&lt;/p&gt;
    &lt;p&gt;Is Even: {{ counter.isEven }}&lt;/p&gt;
    &lt;button @click="counter.increment"&gt;Increment&lt;/button&gt;
    &lt;button @click="counter.incrementBy(5)"&gt;Add 5&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useCounterStore } from '@/stores/counter';

// Get store instance
const counter = useCounterStore();

// Destructure with reactivity (use storeToRefs!)
import { storeToRefs } from 'pinia';
const { count, doubleCount, isEven } = storeToRefs(counter);
const { increment, incrementBy } = counter;  // Actions don't need storeToRefs

// Watch store state
watch(() =&gt; counter.count, (newCount) =&gt; {
  console.log('Count changed:', newCount);
});
&lt;/script&gt;</div>

            <h4>Complex Store Example: User Authentication</h4>

            <div class="code">// stores/auth.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () =&gt; {
  // State
  const user = ref(null);
  const token = ref(localStorage.getItem('token') || null);
  const loading = ref(false);
  const error = ref(null);
  
  // Getters
  const isAuthenticated = computed(() =&gt; !!token.value);
  const userRole = computed(() =&gt; user.value?.role || 'guest');
  const isAdmin = computed(() =&gt; userRole.value === 'admin');
  
  // Actions
  async function login(email, password) {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      token.value = data.token;
      user.value = data.user;
      
      localStorage.setItem('token', data.token);
      
      return true;
    } catch (err) {
      error.value = err.message;
      return false;
    } finally {
      loading.value = false;
    }
  }
  
  function logout() {
    user.value = null;
    token.value = null;
    localStorage.removeItem('token');
  }
  
  async function fetchUser() {
    if (!token.value) return;
    
    try {
      const response = await fetch('/api/user', {
        headers: { Authorization: `Bearer ${token.value}` }
      });
      
      const data = await response.json();
      user.value = data;
    } catch (err) {
      // Token invalid, logout
      logout();
    }
  }
  
  return {
    user,
    token,
    loading,
    error,
    isAuthenticated,
    userRole,
    isAdmin,
    login,
    logout,
    fetchUser
  };
});</div>

            <h3>6. Vue Router Deep Dive</h3>

            <h4>Router Setup</h4>

            <div class="code">// router/index.js
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

const routes = [
  {
    path: '/',
    name: 'home',
    component: Home
  },
  {
    path: '/about',
    name: 'about',
    component: About
  },
  {
    path: '/user/:id',
    name: 'user',
    component: () =&gt; import('@/views/User.vue'),  // Lazy loading
    props: true  // Pass route params as props
  },
  {
    path: '/dashboard',
    component: () =&gt; import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: '',
        name: 'dashboard-home',
        component: () =&gt; import('@/views/DashboardHome.vue')
      },
      {
        path: 'profile',
        name: 'profile',
        component: () =&gt; import('@/views/Profile.vue')
      }
    ]
  },
  {
    // Catch all 404
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () =&gt; import('@/views/NotFound.vue')
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;</div>

            <h4>Navigation Guards</h4>

            <div class="code">// Global navigation guard
router.beforeEach(async (to, from) =&gt; {
  const authStore = useAuthStore();
  
  // Check authentication
  if (to.meta.requiresAuth &amp;&amp; !authStore.isAuthenticated) {
    return { name: 'login' };
  }
  
  // Check admin access
  if (to.meta.requiresAdmin &amp;&amp; !authStore.isAdmin) {
    return { name: 'forbidden' };
  }
  
  // Allow navigation
  return true;
});

// Per-route guard
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from) =&gt; {
      if (!isAdmin()) {
        return { name: 'home' };
      }
    }
  }
];</div>

            <h4>Using Router in Components</h4>

            <div class="code">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- Declarative navigation --&gt;
    &lt;router-link to="/"&gt;Home&lt;/router-link&gt;
    &lt;router-link :to="{ name: 'user', params: { id: 123 } }"&gt;
      User 123
    &lt;/router-link&gt;
    
    &lt;!-- Router view --&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRouter, useRoute } from 'vue-router';

const router = useRouter();
const route = useRoute();

// Programmatic navigation
function goToUser(id) {
  router.push({ name: 'user', params: { id } });
}

function goBack() {
  router.go(-1);
}

// Access route params/query
const userId = computed(() =&gt; route.params.id);
const searchQuery = computed(() =&gt; route.query.search);

// Watch route changes
watch(() =&gt; route.params.id, (newId) =&gt; {
  console.log('User ID changed:', newId);
});
&lt;/script&gt;</div>

            <h3>7. Composables: Reusable Logic</h3>

            <p>Composables are the Vue equivalent of React hooks - reusable functions that encapsulate stateful logic.</p>

            <div class="code">// composables/useFetch.js
import { ref } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);
  const loading = ref(false);
  
  async function fetchData() {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  }
  
  fetchData();
  
  return { data, error, loading, refetch: fetchData };
}

// Usage in component
&lt;script setup&gt;
import { useFetch } from '@/composables/useFetch';

const { data: users, loading, error } = useFetch('/api/users');
&lt;/script&gt;

// composables/useLocalStorage.js
import { ref, watch } from 'vue';

export function useLocalStorage(key, defaultValue) {
  const storedValue = localStorage.getItem(key);
  const data = ref(storedValue ? JSON.parse(storedValue) : defaultValue);
  
  watch(data, (newValue) =&gt; {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return data;
}

// Usage
const user = useLocalStorage('user', { name: 'Guest' });

// composables/useMousePosition.js
export function useMousePosition() {
  const x = ref(0);
  const y = ref(0);
  
  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }
  
  onMounted(() =&gt; {
    window.addEventListener('mousemove', update);
  });
  
  onUnmounted(() =&gt; {
    window.removeEventListener('mousemove', update);
  });
  
  return { x, y };
}</div>

            <h3>8. Lifecycle Hooks</h3>

            <div class="code">&lt;script setup&gt;
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted
} from 'vue';

// Before component is mounted to DOM
onBeforeMount(() =&gt; {
  console.log('Before mount');
});

// After component is mounted (DOM available)
onMounted(() =&gt; {
  console.log('Mounted - DOM ready');
  // Perfect for:
  // - API calls
  // - DOM manipulation
  // - Setting up listeners
});

// Before reactive data changes trigger re-render
onBeforeUpdate(() =&gt; {
  console.log('Before update');
});

// After reactive data changes and DOM updates
onUpdated(() =&gt; {
  console.log('Updated - DOM has changed');
});

// Before component is unmounted
onBeforeUnmount(() =&gt; {
  console.log('Before unmount');
  // Cleanup here
});

// After component is unmounted
onUnmounted(() =&gt; {
  console.log('Unmounted');
  // Final cleanup
});
&lt;/script&gt;</div>

            <h3>9. Form Handling & Validation</h3>

            <h4>Advanced v-model</h4>

            <div class="code">&lt;!-- Custom component with v-model --&gt;
&lt;!-- CustomInput.vue --&gt;
&lt;template&gt;
  &lt;input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  &gt;
&lt;/template&gt;

&lt;script setup&gt;
defineProps(['modelValue']);
defineEmits(['update:modelValue']);
&lt;/script&gt;

&lt;!-- Usage --&gt;
&lt;CustomInput v-model="text" /&gt;

&lt;!-- Multiple v-models --&gt;
&lt;UserForm
  v-model:firstName="firstName"
  v-model:lastName="lastName"
/&gt;</div>

            <h4>Form Validation with Vuelidate</h4>

            <div class="code">&lt;script setup&gt;
import { useVuelidate } from '@vuelidate/core';
import { required, email, minLength } from '@vuelidate/validators';

const formData = reactive({
  email: '',
  password: '',
  confirmPassword: ''
});

const rules = {
  email: { required, email },
  password: { required, minLength: minLength(8) },
  confirmPassword: {
    required,
    sameAs: (value) =&gt; value === formData.password
  }
};

const v$ = useVuelidate(rules, formData);

async function submitForm() {
  const isValid = await v$.value.$validate();
  
  if (!isValid) {
    console.log('Validation errors:', v$.value.$errors);
    return;
  }
  
  // Submit form
  console.log('Form valid, submitting...');
}
&lt;/script&gt;

&lt;template&gt;
  &lt;form @submit.prevent="submitForm"&gt;
    &lt;div&gt;
      &lt;input v-model="formData.email" placeholder="Email"&gt;
      &lt;span v-if="v$.email.$error"&gt;
        {{ v$.email.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;input v-model="formData.password" type="password"&gt;
      &lt;span v-if="v$.password.$error"&gt;
        {{ v$.password.$errors[0].$message }}
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;</div>

            <h3>10. Performance Optimization</h3>

            <div class="code">&lt;template&gt;
  &lt;!-- v-once: Render once, never update --&gt;
  &lt;p v-once&gt;{{ staticContent }}&lt;/p&gt;
  
  &lt;!-- v-memo: Skip re-render if dependencies unchanged --&gt;
  &lt;div v-memo="[user.id, user.name]"&gt;
    &lt;UserCard :user="user" /&gt;
  &lt;/div&gt;
  
  &lt;!-- Lazy load components --&gt;
  &lt;component :is="AsyncComponent" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue';

// Lazy load heavy component
const AsyncComponent = defineAsyncComponent(() =&gt;
  import('./HeavyComponent.vue')
);

// Computed caching (automatically memoized)
const expensiveComputation = computed(() =&gt; {
  return items.value.reduce((sum, item) =&gt; sum + item.price, 0);
});

// Use shallowRef for large objects you rarely mutate
import { shallowRef } from 'vue';
const bigDataset = shallowRef({ /* thousands of items */ });
&lt;/script&gt;</div>

            <div class="info-box">
                <h4>Vue Performance Tips</h4>
                <p>
                ‚Ä¢ Use <span class="inline-code">v-show</span> for frequently toggled elements<br>
                ‚Ä¢ Use <span class="inline-code">v-if</span> for rarely changed conditions<br>
                ‚Ä¢ Always provide keys for v-for<br>
                ‚Ä¢ Lazy load route components<br>
                ‚Ä¢ Use computed for expensive calculations<br>
                ‚Ä¢ Use shallowRef/shallowReactive for large data structures<br>
                ‚Ä¢ Implement virtual scrolling for large lists (vue-virtual-scroller)<br>
                ‚Ä¢ Debounce expensive operations (user input, API calls)
                </p>
            </div>

            <div class="metaphor-box">
                <h4>Vue's Philosophy: Progressive Simplicity</h4>
                <p>Vue is designed to be incrementally adoptable - you start simple and add complexity only when needed. It's like learning to drive: you start with the basics (turning, braking), then gradually add advanced skills (parallel parking, highway merging). You don't need to know everything to be productive, but the advanced features are there when you're ready.</p>
            </div>

        <!-- SECTION 3: State Management (Redux, Zustand, Recoil, Context) -->
        <section id="state-management" class="section">
            <h2 class="section-title">State Management</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 4: API Integration -->
        <section id="api-integration" class="section">
            <h2 class="section-title">API Integration</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 5: Real-Time Features -->
        <section id="realtime-features" class="section">
            <h2 class="section-title">Real-Time Features</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 6: Authentication -->
        <section id="authentication" class="section">
            <h2 class="section-title">Authentication & Authorization</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 7: File Uploads -->
        <section id="file-uploads" class="section">
            <h2 class="section-title">File Uploads & Media</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 8: PWA Features -->
        <section id="pwa-features" class="section">
            <h2 class="section-title">Progressive Web Apps</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 9: Testing Integration -->
        <section id="testing-integration" class="section">
            <h2 class="section-title">Testing Full-Stack Apps</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

        <!-- SECTION 10: Deployment & Scaling -->
        <section id="deployment-scaling" class="section">
            <h2 class="section-title">Deployment & Scaling</h2>
            <p class="section-intro"><!-- EXPAND THIS SECTION --></p>
        </section>

    </main>

    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progress').style.width = scrolled + '%';
        });

        const sections = document.querySelectorAll('.section');
        const sidebarLinks = document.querySelectorAll('.sidebar-link');
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= (sectionTop - 150)) {
                    current = section.getAttribute('id');
                }
            });
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>

