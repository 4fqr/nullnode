<!-- CONTINUATION CONTENT FOR PROGRAMMING CH03 - INSERT AFTER TOPIC 1 -->

<!-- Topic 2: Time Complexity & Big O -->
<div style="background: linear-gradient(135deg, rgba(0,204,255,0.15) 0%, rgba(0,153,204,0.15) 100%); padding: 3rem; border-radius: 20px; margin: 3rem 0; border: 2px solid rgba(0,204,255,0.3);">
    <h2 style="color: #00ccff; font-size: 1.8rem; margin-bottom: 1.5rem;">‚è±Ô∏è Topic 2: Big O Notation ‚Äî Measuring Efficiency</h2>
    
    <h3 style="color: #33d4ff; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Why Efficiency Matters</h3>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Imagine two sorting algorithms:
    </p>
    <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0 0 1.5rem 2rem;">
        <li><strong>Algorithm A:</strong> Sorts 100 items in 0.01 seconds</li>
        <li><strong>Algorithm B:</strong> Sorts 100 items in 0.02 seconds</li>
    </ul>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Both seem fast. But scale to 1 million items:
    </p>
    <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0 0 1.5rem 2rem;">
        <li><strong>Algorithm A:</strong> 2 minutes</li>
        <li><strong>Algorithm B:</strong> 6 hours</li>
    </ul>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        <strong>Big O notation</strong> lets us predict this scaling behavior WITHOUT running the code on huge datasets.
    </p>

    <h3 style="color: #33d4ff; font-size: 1.4rem; margin: 2rem 0 1rem 0;">What IS Big O?</h3>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Big O describes <strong>how runtime grows</strong> as input size increases. It answers: "If I double my input, how much slower will my code be?"
    </p>

    <h3 style="color: #33d4ff; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Common Time Complexities</h3>
    
    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #00ff88;">
        <h4 style="color: #00ff88; margin-bottom: 1rem;">O(1) ‚Äî Constant Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Always takes the same time</strong>, no matter how big the input.
        </p>
        <div style="background: rgba(0,0,0,0.4); padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <pre style="margin: 0; color: #00ccff; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def get_first_element(arr):
    return arr[0]  # O(1) - just one operation
</code></pre>
        </div>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Array access, dictionary lookup, basic math operations
        </p>
    </div>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #ffc800;">
        <h4 style="color: #ffc800; margin-bottom: 1rem;">O(log n) ‚Äî Logarithmic Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Cuts problem in half</strong> each step. Very efficient.
        </p>
        <div style="background: rgba(0,0,0,0.4); padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <pre style="margin: 0; color: #00ccff; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
</code></pre>
        </div>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Binary search, balanced tree operations
        </p>
    </div>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #00ccff;">
        <h4 style="color: #00ccff; margin-bottom: 1rem;">O(n) ‚Äî Linear Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Loops through all elements once.</strong> Double input = double time.
        </p>
        <div style="background: rgba(0,0,0,0.4); padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <pre style="margin: 0; color: #00ccff; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def find_max(arr):
    max_val = arr[0]
    for num in arr:  # O(n) - one loop
        if num > max_val:
            max_val = num
    return max_val
</code></pre>
        </div>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Array traversal, linear search
        </p>
    </div>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #8a2be2;">
        <h4 style="color: #8a2be2; margin-bottom: 1rem;">O(n log n) ‚Äî Linearithmic Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Efficient sorting algorithms.</strong> Much better than O(n¬≤).
        </p>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Merge sort, quick sort, heap sort
        </p>
    </div>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #ff6b6b;">
        <h4 style="color: #ff6b6b; margin-bottom: 1rem;">O(n¬≤) ‚Äî Quadratic Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Nested loops.</strong> Gets slow FAST with large inputs.
        </p>
        <div style="background: rgba(0,0,0,0.4); padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <pre style="margin: 0; color: #00ccff; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def has_duplicates(arr):
    for i in range(len(arr)):      # O(n)
        for j in range(i+1, len(arr)):  # O(n)
            if arr[i] == arr[j]:
                return True
    return False
</code></pre>
        </div>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Bubble sort, selection sort, naive duplicate checking
        </p>
    </div>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0; border-left: 4px solid #ff1744;">
        <h4 style="color: #ff1744; margin-bottom: 1rem;">O(2‚Åø) ‚Äî Exponential Time</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>AVOID AT ALL COSTS.</strong> Doubles with each additional input.
        </p>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            <strong>Examples:</strong> Naive recursive Fibonacci, brute-force password cracking
        </p>
    </div>

    <h3 style="color: #33d4ff; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Comparing Complexities</h3>
    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0;">
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            For n = 1,000,000 elements:
        </p>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0;">
            <li><strong>O(1):</strong> 1 operation</li>
            <li><strong>O(log n):</strong> ~20 operations</li>
            <li><strong>O(n):</strong> 1,000,000 operations</li>
            <li><strong>O(n log n):</strong> ~20,000,000 operations</li>
            <li><strong>O(n¬≤):</strong> 1,000,000,000,000 operations üò±</li>
        </ul>
    </div>

    <div style="background: rgba(255,200,0,0.15); padding: 1.5rem; border-radius: 10px; margin: 2rem 0; border-left: 4px solid #ffc800;">
        <h4 style="color: #ffc800; margin-bottom: 0.5rem;">üí° Why This Matters</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin: 0;">
            Tech interviews ALWAYS ask about Big O. Employers want engineers who write scalable code. An O(n¬≤) algorithm might work for 100 users but crash at 10,000. Understanding complexity prevents production disasters and earns you respect as a developer.
        </p>
    </div>

    <div style="background: rgba(0,204,255,0.1); padding: 1.5rem; border-radius: 10px; margin: 2rem 0;">
        <h4 style="color: #00ccff; margin-bottom: 1rem;">üéØ Quick Check</h4>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0;">
            <li>What's the time complexity of accessing an element in an array?</li>
            <li>Why is O(log n) better than O(n)?</li>
            <li>What causes O(n¬≤) complexity?</li>
        </ul>
    </div>
</div>

<!-- Topic 3: Searching Algorithms -->
<div style="background: linear-gradient(135deg, rgba(255,107,107,0.15) 0%, rgba(255,50,50,0.15) 100%); padding: 3rem; border-radius: 20px; margin: 3rem 0; border: 2px solid rgba(255,107,107,0.3);">
    <h2 style="color: #ff6b6b; font-size: 1.8rem; margin-bottom: 1.5rem;">üîç Topic 3: Searching Algorithms ‚Äî Finding What You Need</h2>
    
    <h3 style="color: #ff8585; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Linear Search ‚Äî The Brute Force Approach</h3>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Check every element until you find what you're looking for. Simple but slow.
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Found at index i
    return -1  # Not found

# Example
numbers = [64, 34, 25, 12, 22, 11, 90]
index = linear_search(numbers, 22)
print(f"Found at index: {index}")  # Output: 4
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        <strong>Time Complexity:</strong> O(n) ‚Äî worst case checks all elements<br>
        <strong>Space Complexity:</strong> O(1) ‚Äî uses no extra memory<br>
        <strong>Use when:</strong> Array is unsorted or very small
    </p>

    <h3 style="color: #ff8585; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Binary Search ‚Äî The Smart Approach</h3>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Works ONLY on <strong>sorted arrays</strong>. Repeatedly divide search space in half.
    </p>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Think of guessing a number 1-100. Someone says "higher" or "lower." You don't guess randomly‚Äîyou start at 50, then 75 or 25, cutting possibilities in half each time.
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half
    
    return -1  # Not found

# Example (must be sorted!)
numbers = [11, 12, 22, 25, 34, 64, 90]
index = binary_search(numbers, 25)
print(f"Found at index: {index}")  # Output: 3
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        <strong>Time Complexity:</strong> O(log n) ‚Äî incredibly fast!<br>
        <strong>Space Complexity:</strong> O(1)<br>
        <strong>Requirement:</strong> Array MUST be sorted
    </p>

    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0;">
        <h4 style="color: #00ff88; margin-bottom: 1rem;">Binary Search Visualization</h4>
        <p style="font-size: 1.05rem; line-height: 1.8;">
            Searching for 22 in [11, 12, 22, 25, 34, 64, 90]:
        </p>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 1rem 0 0 2rem;">
            <li><strong>Step 1:</strong> Check middle (25) ‚Üí Too high, search left</li>
            <li><strong>Step 2:</strong> Check middle of left (12) ‚Üí Too low, search right</li>
            <li><strong>Step 3:</strong> Check 22 ‚Üí FOUND! (Only 3 comparisons)</li>
        </ul>
    </div>

    <div style="background: rgba(255,200,0,0.15); padding: 1.5rem; border-radius: 10px; margin: 2rem 0; border-left: 4px solid #ffc800;">
        <h4 style="color: #ffc800; margin-bottom: 0.5rem;">üí° Why This Matters</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin: 0;">
            Binary search powers databases, phone books, autocomplete, and more. Searching 1 billion sorted records? Binary search finds it in ~30 comparisons. Linear search? 1 billion comparisons. This difference transforms user experience from instant to unusable.
        </p>
    </div>
</div>

<!-- Topic 4: Sorting Algorithms -->
<div style="background: linear-gradient(135deg, rgba(255,200,0,0.15) 0%, rgba(255,150,0,0.15) 100%); padding: 3rem; border-radius: 20px; margin: 3rem 0; border: 2px solid rgba(255,200,0,0.3);">
    <h2 style="color: #ffc800; font-size: 1.8rem; margin-bottom: 1.5rem;">üìä Topic 4: Sorting Algorithms ‚Äî Organizing Data</h2>
    
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Sorting is one of the most fundamental operations in computer science. It enables binary search, improves data visualization, and optimizes countless algorithms.
    </p>

    <h3 style="color: #ffd54f; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Bubble Sort ‚Äî The Simple but Slow</h3>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order.
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break  # Already sorted
    return arr

numbers = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(numbers))
# [11, 12, 22, 25, 34, 64, 90]
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8;">
        <strong>Time Complexity:</strong> O(n¬≤)<br>
        <strong>Good for:</strong> Teaching, very small datasets
    </p>

    <h3 style="color: #ffd54f; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Merge Sort ‚Äî Divide and Conquer</h3>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Splits array in half recursively, sorts each half, then merges them back together.
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

numbers = [64, 34, 25, 12, 22, 11, 90]
print(merge_sort(numbers))
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8;">
        <strong>Time Complexity:</strong> O(n log n) ‚Äî very efficient!<br>
        <strong>Space Complexity:</strong> O(n) ‚Äî needs extra space<br>
        <strong>Good for:</strong> Large datasets, stable sorting needed
    </p>

    <h3 style="color: #ffd54f; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Quick Sort ‚Äî The Fast Favorite</h3>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Picks a "pivot," partitions array so elements less than pivot are left, greater are right, then recursively sorts each partition.
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

numbers = [64, 34, 25, 12, 22, 11, 90]
print(quick_sort(numbers))
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8;">
        <strong>Average Time Complexity:</strong> O(n log n)<br>
        <strong>Worst Case:</strong> O(n¬≤) (rare with good pivot selection)<br>
        <strong>Good for:</strong> General purpose, in-place sorting
    </p>

    <div style="background: rgba(255,200,0,0.15); padding: 1.5rem; border-radius: 10px; margin: 2rem 0; border-left: 4px solid #ffc800;">
        <h4 style="color: #ffc800; margin-bottom: 0.5rem;">üí° Why This Matters</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin: 0;">
            Databases sort millions of records. E-commerce sites sort products. Social media sorts feeds. Choosing O(n log n) over O(n¬≤) means the difference between instant results and users leaving your site. Python's built-in <code>sorted()</code> uses Timsort (O(n log n))‚Äîunderstand why it matters.
        </p>
    </div>
</div>

<!-- Topic 5: Recursion -->
<div style="background: linear-gradient(135deg, rgba(0,255,136,0.15) 0%, rgba(0,200,100,0.15) 100%); padding: 3rem; border-radius: 20px; margin: 3rem 0; border: 2px solid rgba(0,255,136,0.3);">
    <h2 style="color: #00ff88; font-size: 1.8rem; margin-bottom: 1.5rem;">üîÑ Topic 5: Recursion ‚Äî Functions Calling Themselves</h2>
    
    <h3 style="color: #33ffa5; font-size: 1.4rem; margin: 2rem 0 1rem 0;">What IS Recursion?</h3>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        A function that <strong>calls itself</strong> to solve a problem by breaking it into smaller instances of the same problem.
    </p>
    <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Think of Russian nesting dolls. To open the biggest doll, you open it and find a smaller doll. To open that one, you open it and find an even smaller doll. Eventually, you reach the smallest doll (base case) and stop.
    </p>

    <h3 style="color: #33ffa5; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Anatomy of Recursion</h3>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Every recursive function needs two things:
    </p>
    <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0 0 1.5rem 2rem;">
        <li><strong>Base case:</strong> Condition that stops recursion</li>
        <li><strong>Recursive case:</strong> Function calls itself with smaller input</li>
    </ul>

    <h3 style="color: #33ffa5; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Classic Example: Factorial</h3>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        <code>5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120</code>
    </p>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def factorial(n):
    # Base case
    if n == 0 or n == 1:
        return 1
    
    # Recursive case
    return n * factorial(n - 1)

print(factorial(5))  # 120
</code></pre>
    </div>
    <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1.5rem;">
        <strong>How it works:</strong>
    </p>
    <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0 0 1.5rem 2rem;">
        <li>factorial(5) calls factorial(4)</li>
        <li>factorial(4) calls factorial(3)</li>
        <li>factorial(3) calls factorial(2)</li>
        <li>factorial(2) calls factorial(1)</li>
        <li>factorial(1) returns 1 (base case)</li>
        <li>Then 2√ó1, 3√ó2, 4√ó6, 5√ó24 = 120</li>
    </ul>

    <h3 style="color: #33ffa5; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Fibonacci Sequence</h3>
    <div style="background: rgba(0,0,0,0.4); padding: 2rem; border-radius: 10px; margin: 1.5rem 0;">
        <pre style="margin: 0; color: #00ff88; font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.8;"><code>def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# First 10 Fibonacci numbers
for i in range(10):
    print(fibonacci(i), end=" ")
# 0 1 1 2 3 5 8 13 21 34
</code></pre>
    </div>

    <h3 style="color: #33ffa5; font-size: 1.4rem; margin: 2rem 0 1rem 0;">Recursion vs Iteration</h3>
    <div style="background: rgba(0,0,0,0.3); padding: 2rem; border-radius: 15px; margin: 1.5rem 0;">
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Recursion:</strong>
        </p>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0 0 1rem 2rem;">
            <li>‚úÖ Elegant, easier to understand for certain problems</li>
            <li>‚úÖ Natural for tree/graph traversal</li>
            <li>‚ùå Uses more memory (call stack)</li>
            <li>‚ùå Can cause stack overflow</li>
        </ul>
        <p style="font-size: 1.05rem; line-height: 1.8; margin-bottom: 1rem;">
            <strong>Iteration (loops):</strong>
        </p>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0;">
            <li>‚úÖ More memory efficient</li>
            <li>‚úÖ Faster execution</li>
            <li>‚ùå Can be harder to understand for complex problems</li>
        </ul>
    </div>

    <div style="background: rgba(255,200,0,0.15); padding: 1.5rem; border-radius: 10px; margin: 2rem 0; border-left: 4px solid #ffc800;">
        <h4 style="color: #ffc800; margin-bottom: 0.5rem;">üí° Why This Matters</h4>
        <p style="font-size: 1.05rem; line-height: 1.8; margin: 0;">
            Recursion is the foundation of divide-and-conquer algorithms (merge sort, quick sort, binary search trees). It's essential for parsing expressions, traversing file systems, and solving complex problems like the Tower of Hanoi. Master recursion, and you unlock a new level of problem-solving.
        </p>
    </div>
</div>

<!-- Conclusion -->
<div style="background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,204,255,0.1) 100%); padding: 3rem; border-radius: 20px; margin: 3rem 0; border-left: 5px solid var(--primary-color);">
    <h2 style="color: var(--primary-color); font-size: 1.8rem; margin-bottom: 1.5rem;">üéì You're Now Thinking Like a Computer Scientist</h2>
    <p style="font-size: 1.15rem; line-height: 1.8; margin-bottom: 1.5rem;">
        Congratulations! You've mastered the fundamental building blocks of algorithmic thinking. You can now analyze efficiency with Big O, implement search algorithms, understand sorting trade-offs, and harness the power of recursion.
    </p>
    <p style="font-size: 1.15rem; line-height: 1.8; margin-bottom: 1.5rem;">
        These aren't just academic concepts‚Äîthey're tools you'll use daily as a professional developer. Every time you write a loop, you're thinking about O(n). Every time you design an API, you're considering data structures. Every optimization starts with understanding complexity.
    </p>
    <p style="font-size: 1.15rem; line-height: 1.8;">
        In the next chapters, we'll build on this foundation to explore <strong>advanced data structures</strong> (trees, graphs, hash tables), <strong>dynamic programming</strong>, and <strong>real-world system design</strong>. Keep practicing‚Äîthe more problems you solve, the more patterns you'll recognize.
    </p>
    <div style="background: rgba(0,255,136,0.15); padding: 2rem; border-radius: 15px; margin: 2rem 0;">
        <h3 style="color: #00ff88; margin-bottom: 1rem;">üèÜ Practice Challenges</h3>
        <ul style="font-size: 1.05rem; line-height: 1.9; margin: 0;">
            <li>Implement binary search from scratch without looking at notes</li>
            <li>Write merge sort and test it on arrays of different sizes</li>
            <li>Solve 10 problems on LeetCode or HackerRank (Easy difficulty)</li>
            <li>Calculate the time complexity of your last project's key functions</li>
            <li>Rewrite a recursive function as an iterative one (and vice versa)</li>
            <li>Visualize how quick sort partitions arrays on paper</li>
        </ul>
    </div>
</div>
